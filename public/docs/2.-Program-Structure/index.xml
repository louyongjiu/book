<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程序结构 on Book</title>
    <link>https://book.ninescloud.com/docs/2.-Program-Structure/</link>
    <description>Recent content in 程序结构 on Book</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://book.ninescloud.com/docs/2.-Program-Structure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-01/</guid>
      <description>2.1. 命名 #  Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。
Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-02/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-02/</guid>
      <description>2.2. 声明 #  声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。这一章我们重点讨论变量和类型的声明，第三章将讨论常量的声明，第五章将讨论函数的声明。
一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。例如，下面的例子中声明了一个常量、一个函数和两个变量：
gopl.io/ch2/boiling
// Boiling prints the boiling point of water. package main import &amp;#34;fmt&amp;#34; const boilingF = 212.0 func main() { var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf(&amp;#34;boiling point = %g°F or %g°C\n&amp;#34;, f, c) // Output: 	// boiling point = 212°F or 100°C } 其中常量boilingF是在包一级范围声明语句声明的，然后f和c两个变量是在main函数内部声明的声明语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。
一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。
我们已经看到过很多函数声明和函数调用的例子了，在第五章将深入讨论函数的相关细节，这里只简单解释下。下面的fToC函数封装了温度转换的处理逻辑，这样它只需要被定义一次，就可以在多个地方多次被使用。在这个例子中，main函数就调用了两次fToC函数，分别使用在局部定义的两个常量作为调用函数的参数。
gopl.io/ch2/ftoc
// Ftoc prints two Fahrenheit-to-Celsius conversions. package main import &amp;#34;fmt&amp;#34; func main() { const freezingF, boilingF = 32.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-1/</guid>
      <description>2.3.1. 简短变量声明 #  在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。下面是lissajous函数中的三个简短变量声明语句（§1.4）：
anim := gif.GIF{LoopCount: nframes} freq := rand.Float64() * 3.0 t := 0.0 因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。
i := 100 // an int var boiling float64 = 100 // a float64 var names []string var err error var p Point 和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：
i, j := 0, 1 但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。
请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值（§2.4.1），后者是将右边各个表达式的值赋值给左边对应位置的各个变量：
i, j = j, i // 交换 i 和 j 的值 和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：
f, err := os.Open(name) if err != nil { return err } // .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-2/</guid>
      <description>2.3.2. 指针 #  一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋予一个新的值。
一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。
如果用“var x int”声明语句声明一个x变量，那么&amp;amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。
变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;amp;取地址操作。
任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
var x, y int fmt.Println(&amp;amp;x == &amp;amp;x, &amp;amp;x == &amp;amp;y, &amp;amp;x == nil) // &amp;#34;true false false&amp;#34; 在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。
var p = f() func f() *int { v := 1 return &amp;amp;v } 每次调用f函数都将返回不同的结果：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-3/</guid>
      <description>2.3.3. new函数 #  另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // &amp;#34;0&amp;#34; *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // &amp;#34;2&amp;#34; 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。
下面的两个newInt函数有着相同的行为：
func newInt() *int { return new(int) } func newInt() *int { var dummy int return &amp;amp;dummy } 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
p := new(int) q := new(int) fmt.Println(p == q) // &amp;#34;false&amp;#34; 当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）。
new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活（§4.4.1）。
由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：
func delta(old, new int) int { return new - old } 由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03-4/</guid>
      <description>2.3.4. 变量的生命周期 #  变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。
例如，下面是从1.4节的Lissajous程序摘录的代码片段：
for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) } 译注：函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。像下面这样：
for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex( size+int(x*size+0.5), size+int(y*size+0.5), blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性 	) // 小括弧另起一行缩进，和大括弧的风格保存一致 } 在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。
那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。
var global *int func f() { var x int x = 1 global = &amp;amp;x } func g() { y := new(int) *y = 1 } f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-03/</guid>
      <description>2.3. 变量 #  var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：
var 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。例如：
var s string fmt.Println(s) // &amp;#34;&amp;#34; 这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。
也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：
var i, j, k int // int, int, int var b, f, s = true, 2.3, &amp;#34;four&amp;#34; // bool, float64, string 初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。
一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：
var f, err = os.Open(name) // os.Open returns a file and an error {% include &amp;ldquo;./ch2-03-1.md&amp;rdquo; %}
{% include &amp;ldquo;./ch2-03-2.md&amp;rdquo; %}
{% include &amp;ldquo;./ch2-03-3.md&amp;rdquo; %}</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-04-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-04-1/</guid>
      <description>2.4.1. 元组赋值 #  元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：
x, y = y, x a[i], a[j] = a[j], a[i] 或者是计算两个整数值的的最大公约数（GCD）（译注：GCD不是那个敏感字，而是greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法）：
func gcd(x, y int) int { for y != 0 { x, y = y, x%y } return x } 或者是计算斐波纳契数列（Fibonacci）的第N个数：
func fib(n int) int { x, y := 0, 1 for i := 0; i &amp;lt; n; i++ { x, y = y, x+y } return x } 元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），
i, j, k = 2, 3, 5 但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-04-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-04-2/</guid>
      <description>2.4.2. 可赋值性 #  赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。例如下面的语句：
medals := []string{&amp;#34;gold&amp;#34;, &amp;#34;silver&amp;#34;, &amp;#34;bronze&amp;#34;} 隐式地对slice的每个元素进行赋值操作，类似这样写的行为：
medals[0] = &amp;#34;gold&amp;#34; medals[1] = &amp;#34;silver&amp;#34; medals[2] = &amp;#34;bronze&amp;#34; map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。
不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。
对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。和前面一样，我们会对每个新类型比较特殊的地方做专门的解释。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-04/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-04/</guid>
      <description>2.4. 赋值 #  使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。
x = 1 // 命名变量的赋值 *p = true // 通过指针间接赋值 person.name = &amp;#34;bob&amp;#34; // 结构体字段赋值 count[x] = count[x] * scale // 数组、slice或map的元素赋值 特定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：
count[x] *= scale 这样可以省去对变量表达式的重复计算。
数值变量也可以支持++递增和--递减语句（译注：自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的）：
v := 1 v++ // 等价方式 v = v + 1；v 变成 2 v-- // 等价方式 v = v - 1；v 变成 1 {% include &amp;ldquo;./ch2-04-1.md&amp;rdquo; %}
{% include &amp;ldquo;./ch2-04-2.md&amp;rdquo; %}</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-05/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-05/</guid>
      <description>2.5. 类型 #  变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。
在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个float64类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。
一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。
type 类型名字 底层类型 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。
译注：对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。下面是RobPik在 Issue763 的回复：
 A solution that&amp;rsquo;s been kicking around for a while:
For Go 2 (can&amp;rsquo;t do it before then): Change the definition to “lower case letters and _ are package-local; all else is exported”. Then with non-cased languages, such as Japanese, we can write 日本语 for an exported name and _日本语 for a local name. This rule has no effect, relative to the Go 1 rule, with cased languages.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-06-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-06-1/</guid>
      <description>2.6.1. 导入包 #  在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似&amp;quot;gopl.io/ch2/tempconv&amp;quot;的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。
除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。
要使用gopl.io/ch2/tempconv包，需要先导入：
gopl.io/ch2/cf
// Cf converts its numeric argument to Celsius and Fahrenheit. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;gopl.io/ch2/tempconv&amp;#34; ) func main() { for _, arg := range os.Args[1:] { t, err := strconv.ParseFloat(arg, 64) if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;cf: %v\n&amp;#34;, err) os.Exit(1) } f := tempconv.Fahrenheit(t) c := tempconv.Celsius(t) fmt.Printf(&amp;#34;%s = %s, %s = %s\n&amp;#34;, f, tempconv.FToC(f), c, tempconv.CToF(c)) } } 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。上面的导入声明将允许我们以tempconv.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-06-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-06-2/</guid>
      <description>2.6.2. 包的初始化 #  包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
var a = b + c // a 第三个初始化, 为 3 var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c) var c = 1 // c 第一个初始化, 为 1  func f() int { return c + 1 } 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。
对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数
func init() { /* ... */ } 这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。
下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。
gopl.io/ch2/popcount
package popcount // pc[i] is the population count of i. var pc [256]byte func init() { for i := range pc { pc[i] = pc[i/2] + byte(i&amp;amp;1) } } // PopCount returns the population count (number of set bits) of x.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-06/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-06/</guid>
      <description>2.6. 包和文件 #  Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。
每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。
包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。
为了演示包基本的用法，先假设我们的温度转换软件已经很流行，我们希望到Go语言社区也能使用这个包。我们该如何做呢？
让我们创建一个名为gopl.io/ch2/tempconv的包，这是前面例子的一个改进版本。（这里我们没有按照惯例按顺序对例子进行编号，因此包路径看起来更像一个真实的包）包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问；虽然在现实中，这样小的包一般只需要一个文件。
我们把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中：
gopl.io/ch2/tempconv
// Package tempconv performs Celsius and Fahrenheit conversions. package tempconv import &amp;#34;fmt&amp;#34; type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(&amp;#34;%g°C&amp;#34;, c) } func (f Fahrenheit) String() string { return fmt.Sprintf(&amp;#34;%g°F&amp;#34;, f) } 转换函数则放在另一个conv.go源文件中：
package tempconv // CToF converts a Celsius temperature to Fahrenheit.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-07/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/2.-Program-Structure/ch2-07/</guid>
      <description>2.7. 作用域 #  一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。
不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。
句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。
声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。
控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。
一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。
当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：
func f() {} var g = &amp;#34;g&amp;#34; func main() { f := &amp;#34;f&amp;#34; fmt.Println(f) // &amp;#34;f&amp;#34;; local var f shadows package-level func f 	fmt.Println(g) // &amp;#34;g&amp;#34;; package-level var 	fmt.Println(h) // compile error: undefined: h } 在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。
func main() { x := &amp;#34;hello!&amp;#34; for i := 0; i &amp;lt; len(x); i++ { x := x[i] if x != &amp;#39;!</description>
    </item>
    
  </channel>
</rss>