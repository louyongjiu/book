<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>8. Goroutines和Channels on Book</title>
    <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/</link>
    <description>Recent content in 8. Goroutines和Channels on Book</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-01/</guid>
      <description>8.1. Goroutines #  在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。
如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。
当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。
f() // call f(); wait for it to return go f() // create a new goroutine that calls f(); don&amp;#39;t wait 下面的例子，main goroutine将计算菲波那契数列的第45个元素值。由于计算函数使用低效的递归，所以会运行相当长时间，在此期间我们想让用户看到一个可见的标识来表明程序依然在正常运行，所以来做一个动画的小图标：
gopl.io/ch8/spinner
func main() { go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow 	fmt.Printf(&amp;#34;\rFibonacci(%d) = %d\n&amp;#34;, n, fibN) } func spinner(delay time.Duration) { for { for _, r := range `-\|/` { fmt.Printf(&amp;#34;\r%c&amp;#34;, r) time.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-02/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-02/</guid>
      <description>8.2. 示例: 并发的Clock服务 #  网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端。在本小节中，我们会讲解go语言的net包，这个包提供编写一个网络客户端或者服务器程序的基本组件，无论两者间通信是使用TCP、UDP或者Unix domain sockets。在第一章中我们使用过的net/http包里的方法，也算是net包的一部分。
我们的第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：
gopl.io/ch8/clock1
// Clock1 is a TCP server that periodically writes the time. package main import ( &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;time&amp;#34; ) func main() { listener, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:8000&amp;#34;) if err != nil { log.Fatal(err) } for { conn, err := listener.Accept() if err != nil { log.Print(err) // e.g., connection aborted 	continue } handleConn(conn) // handle one connection at a time 	} } func handleConn(c net.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-03/</guid>
      <description>8.3. 示例: 并发的Echo服务 #  clock服务器每一个连接都会起一个goroutine。在本节中我们会创建一个echo服务器，这个服务在每个连接中会有多个goroutine。大多数echo服务仅仅会返回他们读取到的内容，就像下面这个简单的handleConn函数所做的一样：
func handleConn(c net.Conn) { io.Copy(c, c) // NOTE: ignoring errors 	c.Close() } 一个更有意思的echo服务应该模拟一个实际的echo的“回响”，并且一开始要用大写HELLO来表示“声音很大”，之后经过一小段延迟返回一个有所缓和的Hello，然后一个全小写字母的hello表示声音渐渐变小直至消失，像下面这个版本的handleConn(译注：笑看作者脑洞大开)：
gopl.io/ch8/reverb1
func echo(c net.Conn, shout string, delay time.Duration) { fmt.Fprintln(c, &amp;#34;\t&amp;#34;, strings.ToUpper(shout)) time.Sleep(delay) fmt.Fprintln(c, &amp;#34;\t&amp;#34;, shout) time.Sleep(delay) fmt.Fprintln(c, &amp;#34;\t&amp;#34;, strings.ToLower(shout)) } func handleConn(c net.Conn) { input := bufio.NewScanner(c) for input.Scan() { echo(c, input.Text(), 1*time.Second) } // NOTE: ignoring potential errors from input.Err() 	c.Close() } 我们需要升级我们的客户端程序，这样它就可以发送终端的输入到服务器，并把服务端的返回输出到终端上，这使我们有了使用并发的另一个好机会：
gopl.io/ch8/netcat2
func main() { conn, err := net.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-1/</guid>
      <description>8.4.1. 不带缓存的Channels #  一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。
基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒唤醒发送者goroutine之前（译注：happens before，这是Go语言并发内存模型的一个关键术语！）。
在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。
当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。
在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：
gopl.io/ch8/netcat3
func main() { conn, err := net.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:8000&amp;#34;) if err != nil { log.Fatal(err) } done := make(chan struct{}) go func() { io.Copy(os.Stdout, conn) // NOTE: ignoring errors 	log.Println(&amp;#34;done&amp;#34;) done &amp;lt;- struct{}{} // signal the main goroutine 	}() mustCopy(conn, os.Stdin) conn.Close() &amp;lt;-done // wait for background goroutine to finish } 当用户关闭了标准输入，主goroutine中的mustCopy函数调用将返回，然后调用conn.Close()关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-file）结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这是Go语言中启动goroutine常用的形式。）
在后台goroutine返回之前，它先打印一个日志信息，然后向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。
基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为消息事件。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用struct{}空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，done &amp;lt;- 1语句也比done &amp;lt;- struct{}{}更短。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-2/</guid>
      <description>8.4.2. 串联的Channels（Pipeline） #  Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来，如图8.1所示。
 第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine。
gopl.io/ch8/pipeline1
func main() { naturals := make(chan int) squares := make(chan int) // Counter 	go func() { for x := 0; ; x++ { naturals &amp;lt;- x } }() // Squarer 	go func() { for { x := &amp;lt;-naturals squares &amp;lt;- x * x } }() // Printer (in main goroutine) 	for { fmt.Println(&amp;lt;-squares) } } 如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？
如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现：
close(naturals) 当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-3/</guid>
      <description>8.4.3. 单方向的Channel #  随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels来连接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法：
func counter(out chan int) func squarer(out, in chan int) func printer(in chan int) 其中计算平方的squarer函数在两个串联Channels的中间，因此拥有两个channel类型的参数，一个用于输入一个用于输出。两个channel都拥有相同的类型，但是它们的使用方式相反：一个只用于接收，另一个只用于发送。参数的名字in和out已经明确表示了这个意图，但是并无法保证squarer函数向一个in参数对应的channel发送数据或者从一个out参数对应的channel接收数据。
这种场景是典型的。当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。
为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan&amp;lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&amp;lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&amp;lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。
因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。
这是改进的版本，这一次参数使用了单方向channel类型：
gopl.io/ch8/pipeline3
func counter(out chan&amp;lt;- int) { for x := 0; x &amp;lt; 100; x++ { out &amp;lt;- x } close(out) } func squarer(out chan&amp;lt;- int, in &amp;lt;-chan int) { for v := range in { out &amp;lt;- v * v } close(out) } func printer(in &amp;lt;-chan int) { for v := range in { fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04-4/</guid>
      <description>8.4.4. 带缓存的Channels #  带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。图8.2是ch变量对应的channel的图形表示形式。
ch = make(chan string, 3)  向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。
我们可以在无阻塞的情况下连续向新创建的channel发送三个值：
ch &amp;lt;- &amp;#34;A&amp;#34; ch &amp;lt;- &amp;#34;B&amp;#34; ch &amp;lt;- &amp;#34;C&amp;#34; 此刻，channel的内部缓存队列将是满的（图8.3），如果有第四个发送操作将发生阻塞。
 如果我们接收一个值，
fmt.Println(&amp;lt;-ch) // &amp;#34;A&amp;#34; 那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发生阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。
 在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：
fmt.Println(cap(ch)) // &amp;#34;3&amp;#34; 同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。
fmt.Println(len(ch)) // &amp;#34;2&amp;#34; 在继续执行两次接收操作后channel内部的缓存队列将又成为空的，如果有第四个接收操作将发生阻塞：
fmt.Println(&amp;lt;-ch) // &amp;#34;B&amp;#34; fmt.Println(&amp;lt;-ch) // &amp;#34;C&amp;#34; 在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在真实的程序中它们一般由不同的goroutine执行。Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了。
下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。（顺便说一下，多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。）
func mirroredQuery() string { responses := make(chan string, 3) go func() { responses &amp;lt;- request(&amp;#34;asia.gopl.io&amp;#34;) }() go func() { responses &amp;lt;- request(&amp;#34;europe.gopl.io&amp;#34;) }() go func() { responses &amp;lt;- request(&amp;#34;americas.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-04/</guid>
      <description>8.4. Channels #  如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。
使用内置的make函数，我们可以创建一个channel：
ch := make(chan int) // ch has type &amp;#39;chan int&amp;#39; 和map类似，channel也对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。
两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。
一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用&amp;lt;-运算符。在发送语句中，&amp;lt;-运算符分割channel和要发送的值。在接收语句中，&amp;lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。
ch &amp;lt;- x // a send statement x = &amp;lt;-ch // a receive expression in an assignment statement &amp;lt;-ch // a receive statement; result is discarded Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。
使用内置的close函数就可以关闭一个channel：
close(ch) 以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。
ch = make(chan int) // unbuffered channel ch = make(chan int, 0) // unbuffered channel ch = make(chan int, 3) // buffered channel with capacity 3 我们将先讨论无缓存的channel，然后在8.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-05/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-05/</guid>
      <description>8.5. 并发的循环 #  本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io/ch8/thumbnail包提供了ImageFile函数来帮我们拉伸图片。我们不会说明这个函数的实现，只需要从gopl.io下载它。
gopl.io/ch8/thumbnail
package thumbnail // ImageFile reads an image from infile and writes // a thumbnail-size version of it in the same directory. // It returns the generated file name, e.g., &amp;#34;foo.thumb.jpg&amp;#34;. func ImageFile(infile string) (string, error) 下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：
gopl.io/ch8/thumbnail
// makeThumbnails makes thumbnails of the specified files. func makeThumbnails(filenames []string) { for _, f := range filenames { if _, err := thumbnail.ImageFile(f); err != nil { log.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-06/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-06/</guid>
      <description>8.6. 示例: 并发的Web爬虫 #  在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。
gopl.io/ch8/crawl1
func crawl(url string) []string { fmt.Println(url) list, err := links.Extract(url) if err != nil { log.Print(err) } return list } 主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。
func main() { worklist := make(chan []string) // Start with the command-line arguments. 	go func() { worklist &amp;lt;- os.Args[1:] }() // Crawl the web concurrently. 	seen := make(map[string]bool) for list := range worklist { for _, link := range list { if !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-07/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-07/</guid>
      <description>8.7. 基于select的多路复用 #  下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。
gopl.io/ch8/countdown1
func main() { fmt.Println(&amp;#34;Commencing countdown.&amp;#34;) tick := time.Tick(1 * time.Second) for countdown := 10; countdown &amp;gt; 0; countdown-- { fmt.Println(countdown) &amp;lt;-tick } launch() } 现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。
gopl.io/ch8/countdown2
abort := make(chan struct{}) go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte 	abort &amp;lt;- struct{}{} }() 现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：当一切正常时的ticker channel（就像NASA jorgon的&amp;quot;nominal&amp;rdquo;，译注：这梗估计我们是不懂了）或者异常时返回的abort事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用（multiplex）这些操作了，为了能够多路复用，我们使用了select语句。
select { case &amp;lt;-ch1: // ... case x := &amp;lt;-ch2: // ...use x... case ch3 &amp;lt;- y: // .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-08/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-08/</guid>
      <description>8.8. 示例: 并发的目录遍历 #  在本小节中，我们会创建一个程序来生成指定目录的硬盘使用情况报告，这个程序和Unix里的du工具比较相似。大多数工作用下面这个walkDir函数来完成，这个函数使用dirents函数来枚举一个目录下的所有入口。
gopl.io/ch8/du1
// walkDir recursively walks the file tree rooted at dir // and sends the size of each found file on fileSizes. func walkDir(dir string, fileSizes chan&amp;lt;- int64) { for _, entry := range dirents(dir) { if entry.IsDir() { subdir := filepath.Join(dir, entry.Name()) walkDir(subdir, fileSizes) } else { fileSizes &amp;lt;- entry.Size() } } } // dirents returns the entries of directory dir. func dirents(dir string) []os.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-09/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-09/</guid>
      <description>8.9. 并发的退出 #  有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。
Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？
一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。
回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。
只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，不需要向这个channel发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。
gopl.io/ch8/du4
var done = make(chan struct{}) func cancelled() bool { select { case &amp;lt;-done: return true default: return false } } 下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到（比如用户按了回车键），这个goroutine就会把取消消息通过关闭done的channel广播出去。
// Cancel traversal when input is detected. go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte 	close(done) }() 现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候即会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。
for { select { case &amp;lt;-done: // Drain fileSizes to allow existing goroutines to finish.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/8.-Goroutines-and-Channels/ch8-10/</guid>
      <description>8.10. 示例: 聊天服务 #  我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goroutine。main和broadcaster各自是一个goroutine实例，每一个客户端的连接都会有一个handleConn和clientWriter的goroutine。broadcaster是select用法的不错的样例，因为它需要处理三种不同类型的消息。
下面演示的main goroutine的工作，是listen和accept(译注：网络编程里的概念)从客户端过来的连接。对每一个连接，程序都会建立一个新的handleConn的goroutine，就像我们在本章开头的并发的echo服务器里所做的那样。
gopl.io/ch8/chat
func main() { listener, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:8000&amp;#34;) if err != nil { log.Fatal(err) } go broadcaster() for { conn, err := listener.Accept() if err != nil { log.Print(err) continue } go handleConn(conn) } } 然后是broadcaster的goroutine。他的内部变量clients会记录当前建立连接的客户端集合。其记录的内容是每一个客户端的消息发出channel的“资格”信息。
type client chan&amp;lt;- string // an outgoing message channel  var ( entering = make(chan client) leaving = make(chan client) messages = make(chan string) // all incoming client messages ) func broadcaster() { clients := make(map[client]bool) // all connected clients 	for { select { case msg := &amp;lt;-messages: // Broadcast incoming message to all 	// clients&amp;#39; outgoing message channels.</description>
    </item>
    
  </channel>
</rss>