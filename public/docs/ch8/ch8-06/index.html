<!DOCTYPE html>
<html lang="zh" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="8.6. 示例: 并发的Web爬虫 #  在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。
gopl.io/ch8/crawl1
func crawl(url string) []string { fmt.Println(url) list, err := links.Extract(url) if err != nil { log.Print(err) } return list } 主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。
func main() { worklist := make(chan []string) // Start with the command-line arguments. 	go func() { worklist &lt;- os.Args[1:] }() // Crawl the web concurrently. 	seen := make(map[string]bool) for list := range worklist { for _, link := range list { if !">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="8.6. 示例: 并发的Web爬虫 #  在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。
gopl.io/ch8/crawl1
func crawl(url string) []string { fmt.Println(url) list, err := links.Extract(url) if err != nil { log.Print(err) } return list } 主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。
func main() { worklist := make(chan []string) // Start with the command-line arguments. 	go func() { worklist &lt;- os.Args[1:] }() // Crawl the web concurrently. 	seen := make(map[string]bool) for list := range worklist { for _, link := range list { if !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/docs/ch8/ch8-06/" />

<title>Ch8 06 | Hugo Book</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css" integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY=">
<script defer src="/zh.search.min.7274e6413b1d4a32c98ed56250866993ea1b6e4e6df5b1983a42cd85991a6f9b.js" integrity="sha256-cnTmQTsdSjLJjtViUIZpk&#43;obbk5t9bGYOkLNhZkab5s="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/"><span>Hugo Book</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li><a href="/docs/ch0/"><strong>前言</strong></a>
<ul>
<li><a href="/docs/ch0/ch0-01/">Go语言起源</a></li>
<li><a href="/docs/ch0/ch0-02/">Go语言项目</a></li>
<li><a href="/docs/ch0/ch0-03/">本书的组织</a></li>
<li><a href="/docs/ch0/ch0-04/">更多的信息</a></li>
<li><a href="/docs/ch0/ch0-05/">致谢</a></li>
</ul>
</li>
<li><a href="/docs/ch1/ch1/"><strong>入门</strong></a>
<ul>
<li><a href="/docs/ch1/ch1-01/">Hello, World</a></li>
<li><a href="/docs/ch1/ch1-02/">命令行参数</a></li>
<li><a href="/docs/ch1/ch1-03/">查找重复的行</a></li>
<li><a href="/docs/ch1/ch1-04/">GIF动画</a></li>
<li><a href="/docs/ch1/ch1-05/">获取URL</a></li>
<li><a href="/docs/ch1/ch1-06/">并发获取多个URL</a></li>
<li><a href="/docs/ch1/ch1-07/">Web服务</a></li>
<li><a href="/docs/ch1/ch1-08/">本章要点</a></li>
</ul>
</li>
<li><a href="/docs/ch2/ch2/"><strong>程序结构</strong></a>
<ul>
<li><a href="/docs/ch2/ch2-01/">命名</a></li>
<li><a href="/docs/ch2/ch2-02/">声明</a></li>
<li><a href="/docs/ch2/ch2-03/">变量</a></li>
<li><a href="/docs/ch2/ch2-04/">赋值</a></li>
<li><a href="/docs/ch2/ch2-05/">类型</a></li>
<li><a href="/docs/ch2/ch2-06/">包和文件</a></li>
<li><a href="/docs/ch2/ch2-07/">作用域</a></li>
</ul>
</li>
<li><a href="/docs/ch3/ch3/"><strong>基础数据类型</strong></a>
<ul>
<li><a href="/docs/ch3/ch3-01/">整型</a></li>
<li><a href="/docs/ch3/ch3-02/">浮点数</a></li>
<li><a href="/docs/ch3/ch3-03/">复数</a></li>
<li><a href="/docs/ch3/ch3-04/">布尔型</a></li>
<li><a href="/docs/ch3/ch3-05/">字符串</a></li>
<li><a href="/docs/ch3/ch3-06/">常量</a></li>
</ul>
</li>
<li><a href="/docs/ch4/ch4/"><strong>复合数据类型</strong></a>
<ul>
<li><a href="/docs/ch4/ch4-01/">数组</a></li>
<li><a href="/docs/ch4/ch4-02/">Slice</a></li>
<li><a href="/docs/ch4/ch4-03/">Map</a></li>
<li><a href="/docs/ch4/ch4-04/">结构体</a></li>
<li><a href="/docs/ch4/ch4-05/">JSON</a></li>
<li><a href="/docs/ch4/ch4-06/">文本和HTML模板</a></li>
</ul>
</li>
<li><a href="/docs/ch5/ch5/"><strong>函数</strong></a>
<ul>
<li><a href="/docs/ch5/ch5-01/">函数声明</a></li>
<li><a href="/docs/ch5/ch5-02/">递归</a></li>
<li><a href="/docs/ch5/ch5-03/">多返回值</a></li>
<li><a href="/docs/ch5/ch5-04/">错误</a></li>
<li><a href="/docs/ch5/ch5-05/">函数值</a></li>
<li><a href="/docs/ch5/ch5-06/">匿名函数</a></li>
<li><a href="/docs/ch5/ch5-07/">可变参数</a></li>
<li><a href="/docs/ch5/ch5-08/">Deferred函数</a></li>
<li><a href="/docs/ch5/ch5-09/">Panic异常</a></li>
<li><a href="/docs/ch5/ch5-10/">Recover捕获异常</a></li>
</ul>
</li>
<li><a href="/docs/ch6/ch6/"><strong>方法</strong></a>
<ul>
<li><a href="/docs/ch6/ch6-01/">方法声明</a></li>
<li><a href="/docs/ch6/ch6-02/">基于指针对象的方法</a></li>
<li><a href="/docs/ch6/ch6-03/">通过嵌入结构体来扩展类型</a></li>
<li><a href="/docs/ch6/ch6-04/">方法值和方法表达式</a></li>
<li><a href="/docs/ch6/ch6-05/">示例: Bit数组</a></li>
<li><a href="/docs/ch6/ch6-06/">封装</a></li>
</ul>
</li>
<li><a href="/docs/ch7/ch7/"><strong>接口</strong></a>
<ul>
<li><a href="/docs/ch7/ch7-01/">接口是合约</a></li>
<li><a href="/docs/ch7/ch7-02/">接口类型</a></li>
<li><a href="/docs/ch7/ch7-03/">实现接口的条件</a></li>
<li><a href="/docs/ch7/ch7-04/">flag.Value接口</a></li>
<li><a href="/docs/ch7/ch7-05/">接口值</a></li>
<li><a href="/docs/ch7/ch7-06/">sort.Interface接口</a></li>
<li><a href="/docs/ch7/ch7-07/">http.Handler接口</a></li>
<li><a href="/docs/ch7/ch7-08/">error接口</a></li>
<li><a href="/docs/ch7/ch7-09/">示例: 表达式求值</a></li>
<li><a href="/docs/ch7/ch7-10/">类型断言</a></li>
<li><a href="/docs/ch7/ch7-11/">基于类型断言识别错误类型</a></li>
<li><a href="/docs/ch7/ch7-12/">通过类型断言查询接口</a></li>
<li><a href="/docs/ch7/ch7-13/">类型分支</a></li>
<li><a href="/docs/ch7/ch7-14/">示例: 基于标记的XML解码</a></li>
<li><a href="/docs/ch7/ch7-15/">补充几点</a></li>
</ul>
</li>
<li><a href="/docs/ch8/ch8/"><strong>Goroutines和Channels</strong></a>
<ul>
<li><a href="/docs/ch8/ch8-01/">Goroutines</a></li>
<li><a href="/docs/ch8/ch8-02/">示例: 并发的Clock服务</a></li>
<li><a href="/docs/ch8/ch8-03/">示例: 并发的Echo服务</a></li>
<li><a href="/docs/ch8/ch8-04/">Channels</a></li>
<li><a href="/docs/ch8/ch8-05/">并发的循环</a></li>
<li><a href="/docs/ch8/ch8-06/"class=active>示例: 并发的Web爬虫</a></li>
<li><a href="/docs/ch8/ch8-07/">基于select的多路复用</a>
 - <a href="/docs/ch8/ch8-08/">示例: 并发的目录遍历</a></li>
<li><a href="/docs/ch8/ch8-09/">并发的退出</a></li>
<li><a href="/docs/ch8/ch8-10/">示例: 聊天服务</a></li>
</ul>
</li>
<li><a href="/docs/ch9/ch9/"><strong>基于共享变量的并发</strong></a>
<ul>
<li><a href="/docs/ch9/ch9-01/">竞争条件</a></li>
<li><a href="/docs/ch9/ch9-02/">sync.Mutex互斥锁</a></li>
<li><a href="/docs/ch9/ch9-03/">sync.RWMutex读写锁</a></li>
<li><a href="/docs/ch9/ch9-04/">内存同步</a>
 - <a href="/docs/ch9/ch9-05/">sync.Once惰性初始化</a></li>
<li><a href="/docs/ch9/ch9-06/">竞争条件检测</a></li>
<li><a href="/docs/ch9/ch9-07/">示例: 并发的非阻塞缓存</a></li>
<li><a href="/docs/ch9/ch9-08/">Goroutines和线程</a></li>
</ul>
</li>
<li><a href="/docs/ch10/ch10/"><strong>包和工具</strong></a>
<ul>
<li><a href="/docs/ch10/ch10-01/">包简介</a></li>
<li><a href="/docs/ch10/ch10-02/">导入路径</a></li>
<li><a href="/docs/ch10/ch10-03/">包声明</a></li>
<li><a href="/docs/ch10/ch10-04/">导入声明</a></li>
<li><a href="/docs/ch10/ch10-05/">包的匿名导入</a></li>
<li><a href="/docs/ch10/ch10-06/">包和命名</a></li>
<li><a href="/docs/ch10/ch10-07/">工具</a></li>
</ul>
</li>
<li><a href="/docs/ch11/ch11/"><strong>测试</strong></a>
<ul>
<li><a href="/docs/ch11/ch11-01/">go test</a></li>
<li><a href="/docs/ch11/ch11-02/">测试函数</a></li>
<li><a href="/docs/ch11/ch11-03/">测试覆盖率</a></li>
<li><a href="/docs/ch11/ch11-04/">基准测试</a></li>
<li><a href="/docs/ch11/ch11-05/">剖析</a></li>
<li><a href="/docs/ch11/ch11-06/">示例函数</a></li>
</ul>
</li>
<li><a href="/docs/ch12/ch12/"><strong>反射</strong></a>
<ul>
<li><a href="/docs/ch12/ch12-01/">为何需要反射?</a></li>
<li><a href="/docs/ch12/ch12-02/">reflect.Type和reflect.Value</a></li>
<li><a href="/docs/ch12/ch12-03/">Display递归打印</a></li>
<li><a href="/docs/ch12/ch12-04/">示例: 编码S表达式</a></li>
<li><a href="/docs/ch12/ch12-05/">通过reflect.Value修改值</a></li>
<li><a href="/docs/ch12/ch12-06/">示例: 解码S表达式</a>
 - <a href="/docs/ch12/ch12-07/">获取结构体字段标签</a></li>
<li><a href="/docs/ch12/ch12-08/">显示一个类型的方法集</a></li>
<li><a href="/docs/ch12/ch12-09/">几点忠告</a></li>
</ul>
</li>
<li><a href="/docs/ch13/ch13/"><strong>底层编程</strong></a>
<ul>
<li><a href="/docs/ch13/ch13-01/">unsafe.Sizeof, Alignof 和 Offsetof</a></li>
<li><a href="/docs/ch13/ch13-02/">unsafe.Pointer</a></li>
<li><a href="/docs/ch13/ch13-03/">示例: 深度相等判断</a></li>
<li><a href="/docs/ch13/ch13-04/">通过cgo调用C代码</a></li>
<li><a href="/docs/ch13/ch13-05/">几点忠告</a></li>
</ul>
</li>
</ul>






  
<ul>
  
  <li>
    <a href="https://github.com/alex-shpak/hugo-book" target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
  <li>
    <a href="https://themes.gohugo.io/hugo-book/" target="_blank" rel="noopener">
        Hugo Themes
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Ch8 06</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#86-示例-并发的web爬虫">8.6. 示例: 并发的Web爬虫</a></li>
      </ul>
    </li>
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="86-示例-并发的web爬虫">
  8.6. 示例: 并发的Web爬虫
  <a class="anchor" href="#86-%e7%a4%ba%e4%be%8b-%e5%b9%b6%e5%8f%91%e7%9a%84web%e7%88%ac%e8%99%ab">#</a>
</h2>
<p>在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。</p>
<p><u><i>gopl.io/ch8/crawl1</i></u></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">crawl</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">url</span>)
	<span style="color:#a6e22e">list</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">links</span>.<span style="color:#a6e22e">Extract</span>(<span style="color:#a6e22e">url</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">err</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list</span>
}
</code></pre></div><p>主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">worklist</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>)

	<span style="color:#75715e">// Start with the command-line arguments.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">worklist</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">1</span>:] }()

	<span style="color:#75715e">// Crawl the web concurrently.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">list</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">worklist</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">link</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">list</span> {
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">link</span>] {
				<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">link</span>] = <span style="color:#66d9ef">true</span>
				<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">link</span> <span style="color:#66d9ef">string</span>) {
					<span style="color:#a6e22e">worklist</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">crawl</span>(<span style="color:#a6e22e">link</span>)
				}(<span style="color:#a6e22e">link</span>)
			}
		}
	}
}
</code></pre></div><p>注意这里的crawl所在的goroutine会将link作为一个显式的参数传入，来避免“循环变量快照”的问题（在5.6.1中有讲解）。另外注意这里将命令行参数传入worklist也是在一个另外的goroutine中进行的，这是为了避免channel两端的main goroutine与crawler goroutine都尝试向对方发送内容，却没有一端接收内容时发生死锁。当然，这里我们也可以用buffered channel来解决问题，这里不再赘述。</p>
<p>现在爬虫可以高并发地运行起来，并且可以产生一大坨的URL了，不过还是会有俩问题。一个问题是在运行一段时间后可能会出现在log的错误信息里的：</p>
<pre><code>$ go build gopl.io/ch8/crawl1
$ ./crawl1 http://gopl.io/
http://gopl.io/
https://golang.org/help/
https://golang.org/doc/
https://golang.org/blog/
...
2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host
2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files
...
</code></pre><p>最初的错误信息是一个让人莫名的DNS查找失败，即使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，既而导致了在调用net.Dial像DNS查找失败这样的问题。</p>
<p>这个程序实在是太他妈并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一些个限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对links.Extract在同一时间最多不会有超过n次调用，这里的n一般小于文件描述符的上限值，比如20。这和一个夜店里限制客人数目是一个道理，只有当有客人离开时，才会允许新的客人进入店内。</p>
<p>我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。从概念上讲，channel里的n个空槽代表n个可以处理内容的token（通行证），从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。（这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧。）由于channel里的元素类型并不重要，我们用一个零值的struct{}来作为其元素。</p>
<p>让我们重写crawl函数，将对links.Extract的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。</p>
<p><u><i>gopl.io/ch8/crawl2</i></u></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// tokens is a counting semaphore used to
</span><span style="color:#75715e">// enforce a limit of 20 concurrent requests.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">tokens</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}, <span style="color:#ae81ff">20</span>)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">crawl</span>(<span style="color:#a6e22e">url</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">string</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">url</span>)
	<span style="color:#a6e22e">tokens</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">struct</span>{}{} <span style="color:#75715e">// acquire a token
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">list</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">links</span>.<span style="color:#a6e22e">Extract</span>(<span style="color:#a6e22e">url</span>)
	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tokens</span> <span style="color:#75715e">// release the token
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">err</span>)
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list</span>
}
</code></pre></div><p>第二个问题是这个程序永远都不会终止，即使它已经爬到了所有初始链接衍生出的链接。（当然，除非你慎重地选择了合适的初始化URL或者已经实现了练习8.6中的深度限制，你应该还没有意识到这个问题。）为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">worklist</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>)
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// number of pending sends to worklist
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// Start with the command-line arguments.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">worklist</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">1</span>:] }()

	<span style="color:#75715e">// Crawl the web concurrently.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)

	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">n</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">list</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">worklist</span>
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">link</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">list</span> {
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">link</span>] {
				<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">link</span>] = <span style="color:#66d9ef">true</span>
				<span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
				<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">link</span> <span style="color:#66d9ef">string</span>) {
					<span style="color:#a6e22e">worklist</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">crawl</span>(<span style="color:#a6e22e">link</span>)
				}(<span style="color:#a6e22e">link</span>)
			}
		}
	}
}
</code></pre></div><p>这个版本中，计数器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会对n进行++操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次++操作。这里的操作++是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。</p>
<p>现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。</p>
<p>下面的程序是避免过度并发的另一种思路。这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个常驻的crawler goroutine，这样来保证最多20个HTTP请求在并发。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">worklist</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">string</span>)  <span style="color:#75715e">// lists of URLs, may have duplicates
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">unseenLinks</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>) <span style="color:#75715e">// de-duplicated URLs
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// Add command-line arguments to worklist.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">worklist</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">1</span>:] }()

	<span style="color:#75715e">// Create 20 crawler goroutines to fetch each unseen link.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">link</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">unseenLinks</span> {
				<span style="color:#a6e22e">foundLinks</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">crawl</span>(<span style="color:#a6e22e">link</span>)
				<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">worklist</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">foundLinks</span> }()
			}
		}()
	}

	<span style="color:#75715e">// The main goroutine de-duplicates worklist items
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// and sends the unseen ones to the crawlers.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">bool</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">list</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">worklist</span> {
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">link</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">list</span> {
			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">link</span>] {
				<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">link</span>] = <span style="color:#66d9ef">true</span>
				<span style="color:#a6e22e">unseenLinks</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">link</span>
			}
		}
	}
}
</code></pre></div><p>所有的爬虫goroutine现在都是被同一个channel - unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。</p>
<p>seen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。例如，内部变量不能够在函数外部被访问到；变量（§2.3.4）在没有发生变量逃逸（译注：局部变量被全局变量引用地址导致变量被分配在堆上）的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。</p>
<p>crawl函数爬到的链接在一个专有的goroutine中被发送到worklist中来避免死锁。为了节省篇幅，这个例子的终止问题我们先不进行详细阐述了。</p>
<p><strong>练习 8.6：</strong> 为并发爬虫增加深度限制。也就是说，如果用户设置了depth=3，那么只有从首页跳转三次以内能够跳到的页面才能被抓取到。</p>
<p><strong>练习 8.7：</strong> 完成一个并发程序来创建一个线上网站的本地镜像，把该站点的所有可达的页面都抓取到本地硬盘。为了省事，我们这里可以只取出现在该域下的所有页面（比如golang.org开头，译注：外链的应该就不算了。）当然了，出现在页面里的链接你也需要进行一些处理，使其能够在你的镜像站点上进行跳转，而不是指向原始的链接。</p>
<p><strong>译注：</strong>
拓展阅读 <a href="http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/">Handling 1 Million Requests per Minute with Go</a>。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





  <div>
    <a class="flex align-center" href="https://github.com/alex-shpak/hugo-book/edit/master//docs/ch8/ch8-06.md" target="_blank" rel="noopener">
      <img src="/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>

</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#86-示例-并发的web爬虫">8.6. 示例: 并发的Web爬虫</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












