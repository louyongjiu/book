<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go语言圣经 on Book</title>
    <link>https://book.ninescloud.com/</link>
    <description>Recent content in Go语言圣经 on Book</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="https://book.ninescloud.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1.1. Hello, World</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.1.-Hello-World/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.1.-Hello-World/</guid>
      <description>1.1. Hello, World #  我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于1978年出版的C语言圣经 《The C Programming Language》（译注：本书作者之一Brian W. Kernighan也是《The C Programming Language》一书的作者）。C语言是直接影响Go语言设计的语言之一。这个例子体现了Go语言一些核心理念。
gopl.io/ch1/helloworld
package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, 世界&amp;#34;) } Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。）
$ go run helloworld.go 毫无意外，这个命令会输出：
Hello, 世界 Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令：
$ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（译注：Windows系统下生成的可执行文件是helloworld.exe，增加了.exe后缀名），之后你可以随时运行它（译注：在Windows系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（译注：因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满）。
$ ./helloworld Hello, 世界 本书中所有示例代码上都有一行标记，利用这些标记可以从 gopl.io网站上本书源码仓库里获取代码：
gopl.io/ch1/helloworld 执行 go get gopl.io/ch1/helloworld 命令，就会从网上获取代码，并放到对应目录中（需要先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。序言已经提及，需要先设置好GOPATH环境变量，下载的代码会放在$GOPATH/src/gopl.io/ch1/helloworld目录）。2.6和10.7节有这方面更详细的介绍。
来讨论下程序本身。Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。
Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如fmt包，就含有格式化输出、接收输入的函数。Println是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。
main包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。main函数所做的事情就是程序做的。当然了，main函数一般调用其它包里的函数完成很多工作（如：fmt.Println）。
必须告诉编译器源文件需要哪些包，这就是跟随在package声明后面的import声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。
必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go语言编译过程没有警告信息，争议特性之一）。
import声明必须跟在文件的package声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）。这些内容的声明顺序并不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略package和import声明，但是，这些声明在源代码里有，并且必须得有才能编译。
一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。
Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个）。举个例子，函数的左括号{必须和func函数声明在同一行上，且位于末尾，不能独占一行，而在表达式x + y中，可在+后换行，不能在+前换行（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）。
Go语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且go工具中的fmt子命令会对指定包，否则默认为当前目录中所有.go源文件应用gofmt命令。本书中的所有代码都被gofmt过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了Go语言的TIOBE排名较低，因为缺少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。
很多文本编辑器都可以配置为保存文件时自动执行gofmt，这样你的源代码总会被恰当地格式化。还有个相关的工具，goimports，可以根据代码需要，自动地添加或删除import声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：</description>
    </item>
    
    <item>
      <title>10.1. 包简介</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.1.-Introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.1.-Introduction/</guid>
      <description>10.1. 包简介 #  任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。
每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时候减少和其它部分名字的冲突。
每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。
当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。</description>
    </item>
    
    <item>
      <title>10.7.1. 工作区结构</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.1-Workspace-Organization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.1-Workspace-Organization/</guid>
      <description>10.7.1. 工作区结构 #  对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写本书时将GOPATH设置为$HOME/gobook：
$ export GOPATH=$HOME/gobook $ go get gopl.io/... 当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的：
GOPATH/ src/ gopl.io/ .git/ ch1/ helloworld/ main.go dup/ main.go ... golang.org/x/net/ .git/ html/ parse.go node.go ... bin/ helloworld dup pkg/ darwin_amd64/ ... GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在与$GOPATH/src的相对路径为包导入路径的子目录中，例如gopl.io/ch1/helloworld相对应的路径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。
第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。
其中go env命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。
$ go env GOPATH=&amp;quot;/home/gopher/gobook&amp;quot; GOROOT=&amp;quot;/usr/local/go&amp;quot; GOARCH=&amp;quot;amd64&amp;quot; GOOS=&amp;quot;darwin&amp;quot; ... </description>
    </item>
    
    <item>
      <title>11.2.1. 随机测试</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.1-Randomized-Testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.1-Randomized-Testing/</guid>
      <description>11.2.1. 随机测试 #  表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。
那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。
下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。
import &amp;#34;math/rand&amp;#34; // randomPalindrome returns a palindrome whose length and contents // are derived from the pseudo-random number generator rng. func randomPalindrome(rng *rand.Rand) string { n := rng.Intn(25) // random length up to 24 	runes := make([]rune, n) for i := 0; i &amp;lt; (n+1)/2; i++ { r := rune(rng.Intn(0x1000)) // random rune up to &amp;#39;\u0999&amp;#39; 	runes[i] = r runes[n-1-i] = r } return string(runes) } func TestRandomPalindromes(t *testing.</description>
    </item>
    
    <item>
      <title>12.1. 为何需要反射?</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.1.-Why-Reflection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.1.-Why-Reflection/</guid>
      <description>12.1. 为何需要反射? #  有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在。
一个大家熟悉的例子是fmt.Fprintf函数提供的字符串格式化处理逻辑，它可以用来对任意类型的值格式化并打印，甚至支持用户自定义的类型。让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。
我们首先用switch类型分支来测试输入参数是否实现了String方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个值的动态类型是否是string、int、bool等基础类型，并在每种情况下执行相应的格式化操作。
func Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on... 	case bool: if x { return &amp;#34;true&amp;#34; } return &amp;#34;false&amp;#34; default: // array, chan, func, map, pointer, slice, struct 	return &amp;#34;???&amp;#34; } } 但是我们如何处理其它类似[]float64、map[string][]string等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理类似url.</description>
    </item>
    
    <item>
      <title>13.1. unsafe.Sizeof, Alignof 和 Offsetof</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.1.-unsafe.Sizeof-Alignof-and-Offsetof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.1.-unsafe.Sizeof-Alignof-and-Offsetof/</guid>
      <description>13.1. unsafe.Sizeof, Alignof 和 Offsetof #  unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。一个Sizeof函数调用是一个对应uintptr类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。
import &amp;#34;unsafe&amp;#34; fmt.Println(unsafe.Sizeof(float64(0))) // &amp;#34;8&amp;#34; Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。
计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。
由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
   类型 大小     bool 1个字节   intN, uintN, floatN, complexN N/8个字节（例如float64是8个字节）   int, uint, uintptr 1个机器字   *T 1个机器字   string 2个机器字（data、len）   []T 3个机器字（data、len、cap）   map 1个机器字   func 1个机器字   chan 1个机器字   interface 2个机器字（type、value）    Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编译器可以随意地重新排列每个字段的内存位置，虽然在写作本书的时候编译器还没有这么做。下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内存。</description>
    </item>
    
    <item>
      <title>2.1. 命名</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.1.-Names/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.1.-Names/</guid>
      <description>2.1. 命名 #  Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。
Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。
内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</description>
    </item>
    
    <item>
      <title>2.3.1. 简短变量声明</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.1-Short-Variable-Declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.1-Short-Variable-Declarations/</guid>
      <description>2.3.1. 简短变量声明 #  在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。下面是lissajous函数中的三个简短变量声明语句（§1.4）：
anim := gif.GIF{LoopCount: nframes} freq := rand.Float64() * 3.0 t := 0.0 因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。
i := 100 // an int var boiling float64 = 100 // a float64 var names []string var err error var p Point 和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：
i, j := 0, 1 但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。
请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值（§2.4.1），后者是将右边各个表达式的值赋值给左边对应位置的各个变量：
i, j = j, i // 交换 i 和 j 的值 和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：
f, err := os.Open(name) if err != nil { return err } // .</description>
    </item>
    
    <item>
      <title>2.4.1. 元组赋值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/2.4.1-Tuple-Assignment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/2.4.1-Tuple-Assignment/</guid>
      <description>2.4.1. 元组赋值 #  元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：
x, y = y, x a[i], a[j] = a[j], a[i] 或者是计算两个整数值的的最大公约数（GCD）（译注：GCD不是那个敏感字，而是greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法）：
func gcd(x, y int) int { for y != 0 { x, y = y, x%y } return x } 或者是计算斐波纳契数列（Fibonacci）的第N个数：
func fib(n int) int { x, y := 0, 1 for i := 0; i &amp;lt; n; i++ { x, y = y, x+y } return x } 元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），
i, j, k = 2, 3, 5 但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。</description>
    </item>
    
    <item>
      <title>2.6.1. 导入包</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/2.6.1-Imports/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/2.6.1-Imports/</guid>
      <description>2.6.1. 导入包 #  在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似&amp;quot;gopl.io/ch2/tempconv&amp;quot;的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。
除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。
要使用gopl.io/ch2/tempconv包，需要先导入：
gopl.io/ch2/cf
// Cf converts its numeric argument to Celsius and Fahrenheit. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;gopl.io/ch2/tempconv&amp;#34; ) func main() { for _, arg := range os.Args[1:] { t, err := strconv.ParseFloat(arg, 64) if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;cf: %v\n&amp;#34;, err) os.Exit(1) } f := tempconv.Fahrenheit(t) c := tempconv.Celsius(t) fmt.Printf(&amp;#34;%s = %s, %s = %s\n&amp;#34;, f, tempconv.FToC(f), c, tempconv.CToF(c)) } } 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。上面的导入声明将允许我们以tempconv.</description>
    </item>
    
    <item>
      <title>3.1. 整型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.1.-Integers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.1.-Integers/</guid>
      <description>3.1. 整型 #  Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。让我们先从整数类型开始介绍。
Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。
这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。
Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。我们将在第十三章的unsafe包相关部分看到类似的例子。
不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。
其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从$-2^{n-1}$到$2^{n-1}-1$。无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。
下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：
* / % &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;amp; &amp;amp;^ + - | ^ == != &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= &amp;amp;&amp;amp; || 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级，例如mask &amp;amp; (1 &amp;lt;&amp;lt; 28)。
对于上表中前两行的运算符，例如+运算符还有一个与赋值相结合的对应运算符+=，可以用于简化赋值语句。
算术运算符+、-、*和/可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符/的行为则依赖于操作数是否全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。
一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边的bit位是1的话，那么最终结果可能是负的，例如int8的例子：
var u uint8 = 255 fmt.Println(u, u+1, u*u) // &amp;#34;255 0 1&amp;#34;  var i int8 = 127 fmt.Println(i, i+1, i*i) // &amp;#34;127 -128 1&amp;#34; 两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。
== 等于 != 不等于 &amp;lt; 小于 &amp;lt;= 小于等于 &amp;gt; 大于 &amp;gt;= 大于等于 事实上，布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用==和!</description>
    </item>
    
    <item>
      <title>3.5.1. 字符串面值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.1-String-Literals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.1-String-Literals/</guid>
      <description>3.5.1. 字符串面值 #  字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可：
&amp;quot;Hello, 世界&amp;quot;  因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。
在一个双引号包含的字符串面值中，可以用以反斜杠\开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：
\a 响铃 \b 退格 \f 换页 \n 换行 \r 回车 \t 制表符 \v 垂直制表符 \&#39; 单引号（只用在 &#39;\&#39;&#39; 形式的rune符号面值中） \&amp;quot; 双引号（只用在 &amp;quot;...&amp;quot; 形式的字符串面值中） \\ 反斜杠 可以通过十六进制或八进制转义在字符串面值中包含任意的字节。一个十六进制的转义形式是\xhh，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是\ooo，包含三个八进制的o数字（0到7），但是不能超过\377（译注：对应一个字节的范围，十进制为255）。每一个单一的字节表达一个特定的值。稍后我们将看到如何将一个Unicode码点写到字符串面值中。
一个原生的字符串面值形式是`&amp;hellip;`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+&amp;rdquo;`&amp;quot;连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。
原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。
const GoUsage = `Go is a tool for managing Go source code. Usage: go command [arguments] ...` </description>
    </item>
    
    <item>
      <title>3.6.1. iota 常量生成器</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/3.6.1-The-Constant-Generator-iota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/3.6.1-The-Constant-Generator-iota/</guid>
      <description>3.6.1. iota 常量生成器 #  常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。
下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。
type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 周日将对应0，周一为1，如此等等。
我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：
type Flags uint const ( FlagUp Flags = 1 &amp;lt;&amp;lt; iota // is up 	FlagBroadcast // supports broadcast access capability 	FlagLoopback // is a loopback interface 	FlagPointToPoint // belongs to a point-to-point link 	FlagMulticast // supports multicast access capability ) 随着iota的递增，每个常量对应表达式1 &amp;laquo; iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值：</description>
    </item>
    
    <item>
      <title>4.1. 数组</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.1.-Arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.1.-Arrays/</guid>
      <description>4.1. 数组 #  数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。
数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。
var a [3]int // array of 3 integers fmt.Println(a[0]) // print the first element fmt.Println(a[len(a)-1]) // print the last element, a[2]  // Print the indices and elements. for i, v := range a { fmt.Printf(&amp;#34;%d %d\n&amp;#34;, i, v) } // Print the elements only. for _, v := range a { fmt.Printf(&amp;#34;%d\n&amp;#34;, v) } 默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：
var q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt.</description>
    </item>
    
    <item>
      <title>4.2.1. append函数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/4.2.1-The-append-Function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/4.2.1-The-append-Function/</guid>
      <description>4.2.1. append函数 #  内置的append函数用于向slice追加元素：
var runes []rune for _, r := range &amp;#34;Hello, 世界&amp;#34; { runes = append(runes, r) } fmt.Printf(&amp;#34;%q\n&amp;#34;, runes) // &amp;#34;[&amp;#39;H&amp;#39; &amp;#39;e&amp;#39; &amp;#39;l&amp;#39; &amp;#39;l&amp;#39; &amp;#39;o&amp;#39; &amp;#39;,&amp;#39; &amp;#39; &amp;#39; &amp;#39;世&amp;#39; &amp;#39;界&amp;#39;]&amp;#34; 在循环中使用append函数构建一个由九个rune字符构成的slice，当然对应这个特殊的问题我们可以通过Go语言内置的[]rune(&amp;ldquo;Hello, 世界&amp;rdquo;)转换操作完成。
append函数对于理解slice底层是如何工作的非常重要，所以让我们仔细查看究竟是发生了什么。下面是第一个版本的appendInt函数，专门用于处理[]int类型的slice：
gopl.io/ch4/append
func appendInt(x []int, y int) []int { var z []int zlen := len(x) + 1 if zlen &amp;lt;= cap(x) { // There is room to grow. Extend the slice. 	z = x[:zlen] } else { // There is insufficient space.</description>
    </item>
    
    <item>
      <title>4.4.1. 结构体字面值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.1-Struct-Literals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.1-Struct-Literals/</guid>
      <description>4.4.1. 结构体字面值 #  结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。
type Point struct{ X, Y int } p := Point{1, 2} 这里有两种形式的结构体字面值语法，上面的是第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如image.Point{x, y}或color.RGBA{red, green, blue, alpha}。
其实更常用的是第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员，如1.4节的Lissajous程序的写法：
anim := gif.GIF{LoopCount: nframes} 在这种形式的结构体字面值写法中，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。
两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。
package p type T struct{ a, b int } // a and b are not exported  package q import &amp;#34;p&amp;#34; var _ = p.T{a: 1, b: 2} // compile error: can&amp;#39;t reference a, b var _ = p.T{1, 2} // compile error: can&amp;#39;t reference a, b 虽然上面最后一行代码的编译错误信息中并没有显式提到未导出的成员，但是这样企图隐式使用未导出成员的行为也是不允许的。</description>
    </item>
    
    <item>
      <title>5.1. 函数声明</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.1.-Function-Declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.1.-Function-Declarations/</guid>
      <description>5.1. 函数声明 #  函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。
func name(parameter-list) (result-list) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。在hypot函数中：
func hypot(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(3,4)) // &amp;#34;5&amp;#34; x和y是形参名，3和4是调用时的传入的实参，函数返回了一个float64类型的值。 返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为该类型的零值。 如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。
正如hypot一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：
func f(i, j, k int, s, t string) { /* ... */ } func f(i int, j int, k int, s string, t string) { /* ... */ } 下面，我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：即下文的_符号)可以强调某个参数未被使用。
func add(x int, y int) int {return x + y} func sub(x, y int) (z int) { z = x - y; return} func first(x int, _ int) int { return x } func zero(int, int) int { return 0 } fmt.</description>
    </item>
    
    <item>
      <title>5.4.1. 错误处理策略</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/5.4.1-Error-Handling-Strategies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/5.4.1-Error-Handling-Strategies/</guid>
      <description>5.4.1. 错误处理策略 #  当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的五种方式。
首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。下面，我们以5.3节的findLinks函数作为例子。如果findLinks对http.Get的调用失败，findLinks会直接将这个HTTP错误返回给调用者：
resp, err := http.Get(url) if err != nil{ return nil, err } 当对html.Parse的调用失败时，findLinks不会直接返回html.Parse的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的url。因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。
doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return nil, fmt.Errorf(&amp;#34;parsing %s as HTML: %v&amp;#34;, url,err) } fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：
genesis: crashed: no parachute: G-switch failed: bad relay orientation 由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息（译者注：grep是一种文本搜索工具）。
编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。
以os包为例，os包确保文件操作（如os.Open、Read、Write、Close）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。
一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加url到html.Parse返回的错误中。
让我们来看看处理错误的第二种策略。如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。
gopl.io/ch5/wait
// WaitForServer attempts to contact the server of a URL. // It tries for one minute using exponential back-off.</description>
    </item>
    
    <item>
      <title>5.6.1. 警告：捕获迭代变量</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.6.-Anonymous-Functions/5.6.1-Caveat-Capturing-Iteration-Variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.6.-Anonymous-Functions/5.6.1-Caveat-Capturing-Iteration-Variables/</guid>
      <description>5.6.1. 警告：捕获迭代变量 #  本节，将介绍Go词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。
考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入os包。为了使代码简单，我们忽略了所有的异常处理。
var rmdirs []func() for _, d := range tempDirs() { dir := d // NOTE: necessary! 	os.MkdirAll(dir, 0755) // creates parent directories too 	rmdirs = append(rmdirs, func() { os.RemoveAll(dir) }) } // ...do some work… for _, rmdir := range rmdirs { rmdir() // clean up } 你可能会感到困惑，为什么要在循环体中用循环变量d赋值一个新的局部变量，而不是像下面的代码一样直接使用循环变量dir。需要注意，下面的代码是错误的。
var rmdirs []func() for _, dir := range tempDirs() { os.MkdirAll(dir, 0755) rmdirs = append(rmdirs, func() { os.</description>
    </item>
    
    <item>
      <title>6.1. 方法声明</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.1.-Method-Declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.1.-Method-Declarations/</guid>
      <description>6.1. 方法声明 #  在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
下面来写我们第一个方法的例子，这个例子在package geometry下：
gopl.io/ch6/geometry
package geometry import &amp;#34;math&amp;#34; type Point struct{ X, Y float64 } // traditional function func Distance(p, q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } 上面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。
在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。
在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：
p := Point{1, 2} q := Point{4, 6} fmt.Println(Distance(p, q)) // &amp;#34;5&amp;#34;, function call fmt.</description>
    </item>
    
    <item>
      <title>6.2.1. Nil也是一个合法的接收器类型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.2.-Methods-with-a-Pointer-Receiver/6.2.1-Nil-Is-a-Valid-Receiver-Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.2.-Methods-with-a-Pointer-Receiver/6.2.1-Nil-Is-a-Valid-Receiver-Value/</guid>
      <description>6.2.1. Nil也是一个合法的接收器类型 #  就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。在下面的简单int链表的例子里，nil代表的是空链表：
// An IntList is a linked list of integers. // A nil *IntList represents the empty list. type IntList struct { Value int Tail *IntList } // Sum returns the sum of the list elements. func (list *IntList) Sum() int { if list == nil { return 0 } return list.Value + list.Tail.Sum() } 当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们上面例子里做的这样。
下面是net/url包里Values类型定义的一部分。
net/url
package url // Values maps a string key to a list of values.</description>
    </item>
    
    <item>
      <title>7.1. 接口约定</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.1.-Interfaces-as-Contracts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.1.-Interfaces-as-Contracts/</guid>
      <description>7.1. 接口约定 #  目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。
在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。
在本书中，我们一直使用两个相似的函数来进行字符串的格式化：fmt.Printf，它会把结果写到标准输出，和fmt.Sprintf，它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数fmt.Fprintf来进行封装。fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。
package fmt func Fprintf(w io.Writer, format string, args ...interface{}) (int, error) func Printf(format string, args ...interface{}) (int, error) { return Fprintf(os.Stdout, format, args...) } func Sprintf(format string, args ...interface{}) string { var buf bytes.Buffer Fprintf(&amp;amp;buf, format, args...) return buf.String() } Fprintf的前缀F表示文件（File）也表明格式化输出结果应该被写入第一个参数提供的文件中。在Printf函数中的第一个参数os.Stdout是*os.File类型；在Sprintf函数中的第一个参数&amp;amp;buf是一个指向可以写入字节的内存缓冲区，然而它 并不是一个文件类型尽管它在某种意义上和文件类型相似。
即使Fprintf函数中的第一个参数也不是一个文件类型。它是io.Writer类型，这是一个接口类型定义如下：
package io // Writer is the interface that wraps the basic Write method. type Writer interface { // Write writes len(p) bytes from p to the underlying data stream.</description>
    </item>
    
    <item>
      <title>7.5.1. 警告：一个包含nil指针的接口不是nil接口</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.5.-Interface-Values/7.5.1-Caveat-An-Interface-Containing-a-Nil-Pointer-Is-Non-Nil/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.5.-Interface-Values/7.5.1-Caveat-An-Interface-Containing-a-Nil-Pointer-Is-Non-Nil/</guid>
      <description>7.5.1. 警告：一个包含nil指针的接口不是nil接口 #  一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。
思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。
const debug = true func main() { var buf *bytes.Buffer if debug { buf = new(bytes.Buffer) // enable collection of output 	} f(buf) // NOTE: subtly incorrect! 	if debug { // ...use buf... 	} } // If out is non-nil, output will be written to it. func f(out io.Writer) { // ...do something... 	if out != nil { out.Write([]byte(&amp;#34;done!\n&amp;#34;)) } } 我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.</description>
    </item>
    
    <item>
      <title>8.1. Goroutines</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.1.-Goroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.1.-Goroutines/</guid>
      <description>8.1. Goroutines #  在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。
如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。
当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。
f() // call f(); wait for it to return go f() // create a new goroutine that calls f(); don&amp;#39;t wait 下面的例子，main goroutine将计算菲波那契数列的第45个元素值。由于计算函数使用低效的递归，所以会运行相当长时间，在此期间我们想让用户看到一个可见的标识来表明程序依然在正常运行，所以来做一个动画的小图标：
gopl.io/ch8/spinner
func main() { go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow 	fmt.Printf(&amp;#34;\rFibonacci(%d) = %d\n&amp;#34;, n, fibN) } func spinner(delay time.Duration) { for { for _, r := range `-\|/` { fmt.Printf(&amp;#34;\r%c&amp;#34;, r) time.</description>
    </item>
    
    <item>
      <title>8.4.1. 不带缓存的Channels</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.1-Unbuffered-Channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.1-Unbuffered-Channels/</guid>
      <description>8.4.1. 不带缓存的Channels #  一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。
基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒唤醒发送者goroutine之前（译注：happens before，这是Go语言并发内存模型的一个关键术语！）。
在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。
当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。
在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：
gopl.io/ch8/netcat3
func main() { conn, err := net.Dial(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:8000&amp;#34;) if err != nil { log.Fatal(err) } done := make(chan struct{}) go func() { io.Copy(os.Stdout, conn) // NOTE: ignoring errors 	log.Println(&amp;#34;done&amp;#34;) done &amp;lt;- struct{}{} // signal the main goroutine 	}() mustCopy(conn, os.Stdin) conn.Close() &amp;lt;-done // wait for background goroutine to finish } 当用户关闭了标准输入，主goroutine中的mustCopy函数调用将返回，然后调用conn.Close()关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-file）结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这是Go语言中启动goroutine常用的形式。）
在后台goroutine返回之前，它先打印一个日志信息，然后向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。
基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为消息事件。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用struct{}空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，done &amp;lt;- 1语句也比done &amp;lt;- struct{}{}更短。</description>
    </item>
    
    <item>
      <title>9.1. 竞争条件</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.1.-Race-Conditions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.1.-Race-Conditions/</guid>
      <description>9.1. 竞争条件 #  在一个线性（就是说只有一个goroutine的）的程序中，程序的执行顺序只由程序的逻辑来决定。例如，我们有一段语句序列，第一个在第二个之前（废话），以此类推。在有两个或更多goroutine的程序中，每一个goroutine内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。
考虑一下，一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作。我们可以把这个概念概括为一个特定类型的一些方法和操作函数，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。
在一个程序中有非并发安全的类型的情况下，我们依然可以使这个程序并发安全。确实，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它。我们会避免并发访问大多数的类型，无论是将变量局限在单一的一个goroutine内，还是用互斥条件维持更高级别的不变性，都是为了这个目的。我们会在本章中说明这些术语。
相反，包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。
一个函数在并发调用时没法工作的原因太多了，比如死锁（deadlock）、活锁（livelock）和饿死（resource starvation）。我们没有空去讨论所有的问题，这里我们只聚焦在竞争条件上。
竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。
传统上经常用经济损失来为竞争条件做比喻，所以我们来看一个简单的银行账户程序。
// Package bank implements a bank with only one account. package bank var balance int func Deposit(amount int) { balance = balance + amount } func Balance() int { return balance } (当然我们也可以把Deposit存款函数写成balance += amount，这种形式也是等价的，不过长一些的形式解释起来更方便一些。)
对于这个简单的程序而言，我们一眼就能看出，以任意顺序调用函数Deposit和Balance都会得到正确的结果。也就是说，Balance函数会给出之前的所有存入的额度之和。然而，当我们并发地而不是顺序地调用这些函数的话，Balance就再也没办法保证结果正确了。考虑一下下面的两个goroutine，其代表了一个银行联合账户的两笔交易：
// Alice: go func() { bank.Deposit(200) // A1 	fmt.Println(&amp;#34;=&amp;#34;, bank.Balance()) // A2 }() // Bob: go bank.Deposit(100) // B Alice存了$200，然后检查她的余额，同时Bob存了$100。因为A1和A2是和B并发执行的，我们没法预测他们发生的先后顺序。直观地来看的话，我们会认为其执行顺序只有三种可能性：“Alice先”，“Bob先”以及“Alice/Bob/Alice”交错执行。下面的表格会展示经过每一步骤后balance变量的值。引号里的字符串表示余额单。
Alice first Bob first Alice/Bob/Alice 0 0 0 A1 200 B 100 A1 200 A2 &amp;quot;= 200&amp;quot; A1 300 B 300 B 300 A2 &amp;quot;= 300&amp;quot; A2 &amp;quot;= 300&amp;quot; 所有情况下最终的余额都是$300。唯一的变数是Alice的余额单是否包含了Bob交易，不过无论怎么着客户都不会在意。</description>
    </item>
    
    <item>
      <title>9.8.1. 动态栈















</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.1-Growable-Stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.1-Growable-Stacks/</guid>
      <description>9.8.1. 动态栈 #  每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。
相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。
** 练习 9.4:** 创建一个流水线程序，支持用channel连接任意数量的goroutine，在跑爆内存之前，可以创建多少流水线阶段？一个变量通过整个流水线需要用多久？（这个练习题翻译不是很确定）</description>
    </item>
    
    <item>
      <title>go test</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.1.-The-go-test-Tool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.1.-The-go-test-Tool/</guid>
      <description>11.1. go test #  go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。
在*_test.go文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。
go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。</description>
    </item>
    
    <item>
      <title>Go语言起源</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/The-Origins-of-Go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/The-Origins-of-Go/</guid>
      <description>Go语言起源 #  编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都会继承它们祖先的优点；当然有时多种语言杂合也可能会产生令人惊讶的特性；还有一些激进的新特性可能并没有先例。通过观察这些影响，我们可以学到为什么一门语言是这样子的，它已经适应了怎样的环境。
下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。
 Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。
但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自 Niklaus Wirth所设计的[Pascal][Pascal]语言。然后[Modula-2][Modula-2]语言激发了包的概念。然后[Oberon][Oberon]语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的[Oberon-2][Oberon-2]语言直接影响了包的导入和声明的语法，还有[Oberon][Oberon]语言的面向对象特性所提供的方法的声明语法等。
Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的 Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献 顺序通信进程 （ [communicating sequential processes][CSP] ，缩写为[CSP][CSP]。在[CSP][CSP]中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过 Tony Hoare的[CSP][CSP]只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。
接下来，Rob Pike和其他人开始不断尝试将 CSP引入实际的编程语言中。他们第一次尝试引入 CSP特性的编程语言叫 Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的 Newsqueak语言，提供了类似C语言语句和表达式的语法和类似[Pascal][Pascal]语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建的，属于第一类值，可以保存到变量中。
在Plan9操作系统中，这些优秀的想法被吸收到了一个叫[Alef][Alef]的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在Alef之后还有一个叫[Limbo][Limbo]的编程语言，Go语言从其中借鉴了很多特性。 具体请参考Pike的讲稿：http://talks.golang.org/2012/concurrency.slide#9 ）
Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从[APL][APL]语言借鉴，词法作用域与嵌套函数来自于[Scheme][Scheme]语言（和其他很多语言）。当然，我们也可以从Go中发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。</description>
    </item>
    
    <item>
      <title>1.2. 命令行参数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.2.-Command-Line-Arguments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.2.-Command-Line-Arguments/</guid>
      <description>1.2. 命令行参数 #  大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？一些程序生成自己的数据，但通常情况下，输入来自于程序外部：文件、网络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源。下面几个例子会讨论其中几个输入源，首先是命令行参数。
os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。
os.Args变量是一个字符串（string）的切片（slice）（译注：slice和Python语言中的切片类似，是一个简版的动态数组），切片是Go语言的基础概念，稍后详细介绍。现在先把切片s当作数组元素序列，序列的长度动态变化，用s[i]访问单个元素，用s[m:n]获取子序列（译注：和python里的语法差不多）。序列的元素数目为len(s)。和大多数编程语言类似，区间索引时，Go言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。（译注：比如a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3]，不包含最后一个元素）。比如s[m:n]这个切片，0 ≤ m ≤ n ≤ len(s)，包含n-m个元素。
os.Args的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数。s[m:n]形式的切片表达式，产生从第m个元素到第n-1个元素的切片，下个例子用到的元素包含在os.Args[1:len(os.Args)]切片中。如果省略切片表达式的m或n，会默认传入0或len(s)，因此前面的切片可以简写成os.Args[1:]。
下面是Unix里echo命令的一份实现，echo把它的命令行参数打印成一行。程序导入了两个包，用括号把它们括起来写成列表形式，而没有分开写成独立的import声明。两种形式都合法，列表形式习惯上用得多。包导入顺序并不重要；gofmt工具格式化时按照字母顺序对包名排序。（示例有多个版本时，我们会对示例编号，这样可以明确当前正在讨论的是哪个。）
gopl.io/ch1/echo1
// Echo1 prints its command-line arguments. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { var s, sep string for i := 1; i &amp;lt; len(os.Args); i++ { s += sep + os.Args[i] sep = &amp;#34; &amp;#34; } fmt.Println(s) } 注释语句以//开头。对于程序员来说，//之后到行末之间所有的内容都是注释，被编译器忽略。按照惯例，我们在每个包的包声明前添加注释；对于main package，注释包含一句或几句话，从整体角度对程序做个描述。</description>
    </item>
    
    <item>
      <title>10.2. 导入路径</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.2.-Import-Paths/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.2.-Import-Paths/</guid>
      <description>10.2. 导入路径 #  每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。
import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;encoding/json&amp;#34; &amp;#34;golang.org/x/net/html&amp;#34; &amp;#34;github.com/go-sql-driver/mysql&amp;#34; ) 就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类似 Bazel的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境），用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。
如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。</description>
    </item>
    
    <item>
      <title>10.7.2. 下载包</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.2-Downloading-Packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.2-Downloading-Packages/</guid>
      <description>10.7.2. 下载包 #  使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。
使用命令go get可以下载一个单一的包或者用...下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org/x/net/html自动出现在本地工作区目录的原因。
一旦go get命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的gopl.io/ch2/popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档：
$ go get github.com/golang/lint/golint $ $GOPATH/bin/golint gopl.io/ch2/popcount src/gopl.io/ch2/popcount/main.go:1:1: package comment should be of the form &amp;quot;Package popcount ...&amp;quot; go get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行go help importpath获取相关的信息。
go get命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org/x/net包目录对应一个Git仓库：
$ cd $GOPATH/src/golang.org/x/net $ git remote -v origin https://go.googlesource.com/net (fetch) origin https://go.googlesource.com/net (push) 需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 https://golang.org/x/net/html 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：
$ go build gopl.io/ch1/fetch $ ./fetch https://golang.org/x/net/html | grep go-import &amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;golang.org/x/net git https://go.googlesource.com/net&amp;quot;&amp;gt; 如果指定-u命令行标志参数，go get命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。
go get -u命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org/x/net/html导入路径可能会变为gopl.io/vendor/golang.org/x/net/html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过go help gopath命令查看Vendor的帮助文档。</description>
    </item>
    
    <item>
      <title>11.2.2. 测试一个命令</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.2-Testing-a-Commandvvvvvvvv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.2-Testing-a-Commandvvvvvvvv/</guid>
      <description>11.2.2. 测试一个命令 #  对于测试包go test是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。
让我们为2.3.2节的echo程序编写一个测试。我们先将程序拆分为两个函数：echo函数完成真正的工作，main函数用于处理命令行输入参数和echo可能返回的错误。
gopl.io/ch11/echo
// Echo prints its command-line arguments. package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;os&amp;#34; &amp;#34;strings&amp;#34; ) var ( n = flag.Bool(&amp;#34;n&amp;#34;, false, &amp;#34;omit trailing newline&amp;#34;) s = flag.String(&amp;#34;s&amp;#34;, &amp;#34; &amp;#34;, &amp;#34;separator&amp;#34;) ) var out io.Writer = os.Stdout // modified during testing  func main() { flag.Parse() if err := echo(!*n, *s, flag.Args()); err != nil { fmt.Fprintf(os.Stderr, &amp;#34;echo: %v\n&amp;#34;, err) os.Exit(1) } } func echo(newline bool, sep string, args []string) error { fmt.</description>
    </item>
    
    <item>
      <title>12.2. reflect.Type 和 reflect.Value</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.2.-reflect.Type-and-reflect.Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.2.-reflect.Type-and-reflect.Value/</guid>
      <description>12.2. reflect.Type 和 reflect.Value #  反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 reflect.Type 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。
函数 reflect.TypeOf 接受任意的 interface{} 类型，并以 reflect.Type 形式返回其动态类型：
t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; 其中 TypeOf(3) 调用将值 3 传给 interface{} 参数。回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是 int）和它的动态的值（这里是 3）。
因为 reflect.TypeOf 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 &amp;ldquo;*os.File&amp;rdquo; 而不是 &amp;ldquo;io.Writer&amp;rdquo;。稍后，我们将看到能够表达接口类型的 reflect.Type。
var w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // &amp;#34;*os.File&amp;#34; 要注意的是 reflect.Type 接口是满足 fmt.Stringer 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， fmt.Printf 提供了一个缩写 %T 参数，内部使用 reflect.TypeOf 来输出：</description>
    </item>
    
    <item>
      <title>13.2. unsafe.Pointer</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.2.-unsafe.Pointer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.2.-unsafe.Pointer/</guid>
      <description>13.2. unsafe.Pointer #  大多数指针类型会写成*T，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的void*类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。
一个普通的*T类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的*T类型相同。通过将*float64类型指针转化为*uint64类型指针，我们可以查看一个浮点数变量的位模式。
package math func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&amp;amp;f)) } fmt.Printf(&amp;#34;%#016x\n&amp;#34;, Float64bits(1.0)) // &amp;#34;0x3ff0000000000000&amp;#34; 通过转为新类型指针，我们可以更新浮点数的位模式。通过位模式操作浮点数是可以的，但是更重要的意义是指针转换语法让我们可以在不破坏类型系统的前提下向内存写入任意的值。
一个unsafe.Pointer指针也可以被转化为uintptr类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。（第三章内容，uintptr是一个无符号的整型数，足以保存一个地址）这种转换虽然也是可逆的，但是将uintptr转为unsafe.Pointer指针可能会破坏类型系统，因为并不是所有的数字都是有效的内存地址。
许多将unsafe.Pointer指针转为原生数字，然后再转回为unsafe.Pointer类型指针的操作也是不安全的。比如下面的例子需要将变量x的地址加上b字段地址偏移量转化为*int16类型指针，然后通过该指针更新x.b：
gopl.io/ch13/unsafeptr
var x struct { a bool b int16 c []int } // 和 pb := &amp;amp;x.b 等价 pb := (*int16)(unsafe.Pointer( uintptr(unsafe.Pointer(&amp;amp;x)) + unsafe.Offsetof(x.b))) *pb = 42 fmt.Println(x.b) // &amp;#34;42&amp;#34; 上面的写法尽管很繁琐，但在这里并不是一件坏事，因为这些功能应该很谨慎地使用。不要试图引入一个uintptr类型的临时变量，因为它可能会破坏代码的安全性（译注：这是真正可以体会unsafe包为何不安全的例子）。下面段代码是错误的：
// NOTE: subtly incorrect! tmp := uintptr(unsafe.Pointer(&amp;amp;x)) + unsafe.Offsetof(x.b) pb := (*int16)(unsafe.Pointer(tmp)) *pb = 42 产生错误的原因很微妙。有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC。当一个变量被移动，所有的保存该变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动时对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的&amp;amp;x.b地址。第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！</description>
    </item>
    
    <item>
      <title>2.2. 声明</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.2.-Declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.2.-Declarations/</guid>
      <description>2.2. 声明 #  声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。这一章我们重点讨论变量和类型的声明，第三章将讨论常量的声明，第五章将讨论函数的声明。
一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。例如，下面的例子中声明了一个常量、一个函数和两个变量：
gopl.io/ch2/boiling
// Boiling prints the boiling point of water. package main import &amp;#34;fmt&amp;#34; const boilingF = 212.0 func main() { var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf(&amp;#34;boiling point = %g°F or %g°C\n&amp;#34;, f, c) // Output: 	// boiling point = 212°F or 100°C } 其中常量boilingF是在包一级范围声明语句声明的，然后f和c两个变量是在main函数内部声明的声明语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。
一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。
我们已经看到过很多函数声明和函数调用的例子了，在第五章将深入讨论函数的相关细节，这里只简单解释下。下面的fToC函数封装了温度转换的处理逻辑，这样它只需要被定义一次，就可以在多个地方多次被使用。在这个例子中，main函数就调用了两次fToC函数，分别使用在局部定义的两个常量作为调用函数的参数。
gopl.io/ch2/ftoc
// Ftoc prints two Fahrenheit-to-Celsius conversions. package main import &amp;#34;fmt&amp;#34; func main() { const freezingF, boilingF = 32.</description>
    </item>
    
    <item>
      <title>2.3.2. 指针</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.2-Pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.2-Pointers/</guid>
      <description>2.3.2. 指针 #  一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋予一个新的值。
一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。
如果用“var x int”声明语句声明一个x变量，那么&amp;amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。
x := 1 p := &amp;amp;x // p, of type *int, points to x fmt.Println(*p) // &amp;#34;1&amp;#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // &amp;#34;2&amp;#34; 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。
变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;amp;取地址操作。
任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
var x, y int fmt.Println(&amp;amp;x == &amp;amp;x, &amp;amp;x == &amp;amp;y, &amp;amp;x == nil) // &amp;#34;true false false&amp;#34; 在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。
var p = f() func f() *int { v := 1 return &amp;amp;v } 每次调用f函数都将返回不同的结果：</description>
    </item>
    
    <item>
      <title>2.4.2. 可赋值性</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/2.4.2-Assignability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/2.4.2-Assignability/</guid>
      <description>2.4.2. 可赋值性 #  赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。例如下面的语句：
medals := []string{&amp;#34;gold&amp;#34;, &amp;#34;silver&amp;#34;, &amp;#34;bronze&amp;#34;} 隐式地对slice的每个元素进行赋值操作，类似这样写的行为：
medals[0] = &amp;#34;gold&amp;#34; medals[1] = &amp;#34;silver&amp;#34; medals[2] = &amp;#34;bronze&amp;#34; map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。
不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。
对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。和前面一样，我们会对每个新类型比较特殊的地方做专门的解释。</description>
    </item>
    
    <item>
      <title>2.6.2. 包的初始化</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/2.6.2-Package-Initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/2.6.2-Package-Initialization/</guid>
      <description>2.6.2. 包的初始化 #  包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
var a = b + c // a 第三个初始化, 为 3 var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c) var c = 1 // c 第一个初始化, 为 1  func f() int { return c + 1 } 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。
对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数
func init() { /* ... */ } 这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。
下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。
gopl.io/ch2/popcount
package popcount // pc[i] is the population count of i. var pc [256]byte func init() { for i := range pc { pc[i] = pc[i/2] + byte(i&amp;amp;1) } } // PopCount returns the population count (number of set bits) of x.</description>
    </item>
    
    <item>
      <title>3.2. 浮点数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.2.-Floating-Point-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.2.-Floating-Point-Numbers/</guid>
      <description>3.2. 浮点数 #  Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。
这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。
一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：
var f float32 = 16777216 // 1 &amp;lt;&amp;lt; 24 fmt.Println(f == f+1) // &amp;#34;true&amp;#34;! 浮点数的字面值可以直接写小数部分，像这样：
const e = 2.71828 // (approximately) 小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分：
const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。
for x := 0; x &amp;lt; 8; x++ { fmt.Printf(&amp;#34;x = %d e^x = %8.3f\n&amp;#34;, x, math.Exp(float64(x))) } 上面代码打印e的幂，打印精度是小数点后三个小数精度和8个字符宽度：
x = 0 e^x = 1.000 x = 1 e^x = 2.</description>
    </item>
    
    <item>
      <title>3.5.2. Unicode</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.2-Unicode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.2-Unicode/</guid>
      <description>3.5.2. Unicode #  在很久以前，世界还是比较简单的，起码计算机世界就只有一个ASCII字符集：美国信息交换标准代码。ASCII，更准确地说是美国的ASCII，使用7bit来表示128个字符：包含英文字母的大小写、数字、各种标点符号和设备控制符。对于早期的计算机程序来说，这些就足够了，但是这也导致了世界上很多其他地区的用户无法直接使用自己的符号系统。随着互联网的发展，混合多种语言的数据变得很常见（译注：比如本身的英文原文或中文翻译都包含了ASCII、中文、日文等多种语言字符）。如何有效处理这些包含了各种语言的丰富多样的文本数据呢？
答案就是使用Unicode（ http://unicode.org ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。
在第八版本的Unicode标准里收集了超过120,000个字符，涵盖超过100多种语言。这些在计算机程序和数据中是如何体现的呢？通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思。
我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样大小的32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间，因为大多数计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节就能表示。而且即使是常用的字符也远少于65,536个，也就是说用16bit编码方式就能表达常用字符。但是，还有其它更好的编码方法吗？</description>
    </item>
    
    <item>
      <title>3.6.2. 无类型常量</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/3.6.2-Untyped-Constants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/3.6.2-Untyped-Constants/</guid>
      <description>3.6.2. 无类型常量 #  Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB/ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：
fmt.Println(YiB/ZiB) // &amp;#34;1024&amp;#34; 另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：
var x float32 = math.Pi var y float64 = math.Pi var z complex128 = math.Pi 如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：
const Pi64 float64 = math.Pi var x float32 = float32(Pi64) var y float64 = Pi64 var z complex128 = complex128(Pi64) 对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。
前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：
var f float64 = 212 fmt.Println((f - 32) * 5 / 9) // &amp;#34;100&amp;#34;; (f - 32) * 5 is a float64 fmt.</description>
    </item>
    
    <item>
      <title>4.2.2. Slice内存技巧</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/4.2.2-In-Place-Slice-Techniques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/4.2.2-In-Place-Slice-Techniques/</guid>
      <description>4.2.2. Slice内存技巧 #  让我们看看更多的例子，比如旋转slice、反转slice或在slice原有内存空间修改元素。给定一个字符串列表，下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表：
gopl.io/ch4/nonempty
// Nonempty is an example of an in-place slice algorithm. package main import &amp;#34;fmt&amp;#34; // nonempty returns a slice holding only the non-empty strings. // The underlying array is modified during the call. func nonempty(strings []string) []string { i := 0 for _, s := range strings { if s != &amp;#34;&amp;#34; { strings[i] = s i++ } } return strings[:i] } 比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样：
data := []string{&amp;#34;one&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;three&amp;#34;} fmt.</description>
    </item>
    
    <item>
      <title>4.4.2. 结构体比较</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.2-Comparing-Structs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.2-Comparing-Structs/</guid>
      <description>4.4.2. 结构体比较 #  如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：
type Point struct{ X, Y int } p := Point{1, 2} q := Point{2, 1} fmt.Println(p.X == q.X &amp;amp;&amp;amp; p.Y == q.Y) // &amp;#34;false&amp;#34; fmt.Println(p == q) // &amp;#34;false&amp;#34; 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。
type address struct { hostname string port int } hits := make(map[address]int) hits[address{&amp;#34;golang.org&amp;#34;, 443}]++ </description>
    </item>
    
    <item>
      <title>5.2. 递归</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.2.-Recursion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.2.-Recursion/</guid>
      <description>5.2. 递归 #  函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我们通过遍历二叉树来实现简单的插入排序，在本章节，我们再次使用它来处理HTML文件。
下文的示例代码使用了非标准包 golang.org/x/net/html ，解析HTML。golang.org/x/&amp;hellip; 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。
例子中调用golang.org/x/net/html的部分api如下所示。html.Parse函数读入一组bytes解析后，返回html.Node类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）、commnets（注释）类型，在下面的例子中，我们 只关注&amp;lt; name key=&#39;value&amp;rsquo; &amp;gt;形式的结点。
golang.org/x/net/html
package html type Node struct { Type NodeType Data string Attr []Attribute FirstChild, NextSibling *Node } type NodeType int32 const ( ErrorNode NodeType = iota TextNode DocumentNode ElementNode CommentNode DoctypeNode ) type Attribute struct { Key, Val string } func Parse(r io.Reader) (*Node, error) main函数解析HTML标准输入，通过递归函数visit获得links（链接），并打印出这些links：
gopl.io/ch5/findlinks1
// Findlinks1 prints the links in an HTML document read from standard input.</description>
    </item>
    
    <item>
      <title>5.4.2. 文件结尾错误（EOF）</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/5.4.2-End-of-File-EOF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/5.4.2-End-of-File-EOF/</guid>
      <description>5.4.2. 文件结尾错误（EOF） #  函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义：
package io import &amp;#34;errors&amp;#34; // EOF is the error returned by Read when no more input is available. var EOF = errors.New(&amp;#34;EOF&amp;#34;) 调用者只需通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。（4.3的chartcount程序展示了更加复杂的代码）
in := bufio.NewReader(os.Stdin) for { r, _, err := in.ReadRune() if err == io.EOF { break // finished reading 	} if err != nil { return fmt.Errorf(&amp;#34;read failed:%v&amp;#34;, err) } // ...use r… } 因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的错误信息。在7.11节中，我们会提出更系统的方法区分某些固定的错误值。</description>
    </item>
    
    <item>
      <title>7.2. 接口类型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.2.-Interface-Types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.2.-Interface-Types/</guid>
      <description>7.2. 接口类型 #  接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。
io.Writer类型是用得最广泛的接口之一，因为它提供了所有类型的写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。io包中定义了很多其它有用的接口类型。Reader可以代表任意可以读取bytes的类型，Closer可以是任意可以关闭的值，例如一个文件或是网络链接。（到现在你可能注意到了很多Go语言中单方法接口的命名习惯）
package io type Reader interface { Read(p []byte) (n int, err error) } type Closer interface { Close() error } 再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：
type ReadWriter interface { Reader Writer } type ReadWriteCloser interface { Reader Writer Closer } 上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。尽管略失简洁，我们可以像下面这样，不使用内嵌来声明io.ReadWriter接口。
type ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } 或者甚至使用一种混合的风格：
type ReadWriter interface { Read(p []byte) (n int, err error) Writer } 上面3种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。</description>
    </item>
    
    <item>
      <title>8.2. 示例: 并发的Clock服务</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.2.-Example-Concurrent-Clock-Server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.2.-Example-Concurrent-Clock-Server/</guid>
      <description>8.2. 示例: 并发的Clock服务 #  网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端。在本小节中，我们会讲解go语言的net包，这个包提供编写一个网络客户端或者服务器程序的基本组件，无论两者间通信是使用TCP、UDP或者Unix domain sockets。在第一章中我们使用过的net/http包里的方法，也算是net包的一部分。
我们的第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：
gopl.io/ch8/clock1
// Clock1 is a TCP server that periodically writes the time. package main import ( &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;time&amp;#34; ) func main() { listener, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:8000&amp;#34;) if err != nil { log.Fatal(err) } for { conn, err := listener.Accept() if err != nil { log.Print(err) // e.g., connection aborted 	continue } handleConn(conn) // handle one connection at a time 	} } func handleConn(c net.</description>
    </item>
    
    <item>
      <title>8.4.2. 串联的Channels（Pipeline）</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.2-Pipelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.2-Pipelines/</guid>
      <description>8.4.2. 串联的Channels（Pipeline） #  Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来，如图8.1所示。
 第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine。
gopl.io/ch8/pipeline1
func main() { naturals := make(chan int) squares := make(chan int) // Counter 	go func() { for x := 0; ; x++ { naturals &amp;lt;- x } }() // Squarer 	go func() { for { x := &amp;lt;-naturals squares &amp;lt;- x * x } }() // Printer (in main goroutine) 	for { fmt.Println(&amp;lt;-squares) } } 如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？
如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现：
close(naturals) 当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</description>
    </item>
    
    <item>
      <title>9.2. sync.Mutex互斥锁</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.2.-Mutual-Exclusion-sync.Mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.2.-Mutual-Exclusion-sync.Mutex/</guid>
      <description>9.2. sync.Mutex互斥锁 #  在8.6节中，我们使用了一个buffered channel作为一个计数信号量，来保证最多只有20个goroutine会同时执行HTTP请求。同理，我们可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量（binary semaphore）。
gopl.io/ch9/bank2
var ( sema = make(chan struct{}, 1) // a binary semaphore guarding balance 	balance int ) func Deposit(amount int) { sema &amp;lt;- struct{}{} // acquire token 	balance = balance + amount &amp;lt;-sema // release token } func Balance() int { sema &amp;lt;- struct{}{} // acquire token 	b := balance &amp;lt;-sema // release token 	return b } 这种互斥很实用，而且被sync包里的Mutex类型直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token：
gopl.io/ch9/bank3</description>
    </item>
    
    <item>
      <title>9.8.2. Goroutine调度</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.2-Goroutine-Scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.2-Goroutine-Scheduling/</guid>
      <description>9.8.2. Goroutine调度 #  OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。
Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工（调度）m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（译注：按程序独立）。
和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。
** 练习 9.5: ** 写一个有两个goroutine的程序，两个goroutine会向两个无buffer channel反复地发送ping-pong消息。这样的程序每秒可以支持多少次通信？</description>
    </item>
    
    <item>
      <title>Go语言项目</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/The-Go-Project/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/The-Go-Project/</guid>
      <description>Go语言项目 #  所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。
正如 Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。
简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如 Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。
Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。
Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。
Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。
Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。</description>
    </item>
    
    <item>
      <title>1.3. 查找重复的行</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.3.-Finding-Duplicate-Lines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.3.-Finding-Duplicate-Lines/</guid>
      <description>1.3. 查找重复的行 #  对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为dup的程序的三个版本；灵感来自于Unix的uniq命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。
dup的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入if语句，map数据类型以及bufio包。
gopl.io/ch1/dup1
// Dup1 prints the text of each line that appears more than // once in the standard input, preceded by its count. package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { counts[input.Text()]++ } // NOTE: ignoring potential errors from input.Err() 	for line, n := range counts { if n &amp;gt; 1 { fmt.</description>
    </item>
    
    <item>
      <title>10.3. 包声明</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.3.-The-Package-Declaration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.3.-The-Package-Declaration/</guid>
      <description>10.3. 包声明 #  在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。
例如，math/rand包的每个源文件的开头都包含package rand包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) func main() { fmt.Println(rand.Int()) } 通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。
关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。
第二个例外，包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件（译注：前面必须有其它的字符，因为以_或.开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。
第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。</description>
    </item>
    
    <item>
      <title>10.7.3. 构建包</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.3-Building-Packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.3-Building-Packages/</guid>
      <description>10.7.3. 构建包 #  go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main，go build将调用链接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。
由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org/x/tools/cmd/godoc命令就是放在cmd子目录（§10.7.4）。
每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指定，相对路径必须以.或..开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包，虽然它们的写法各不相同：
$ cd $GOPATH/src/gopl.io/ch1/helloworld $ go build 或者：
$ cd anywhere $ go build gopl.io/ch1/helloworld 或者：
$ cd $GOPATH $ go build ./src/gopl.io/ch1/helloworld 但不能这样：
$ cd $GOPATH $ go build src/gopl.io/ch1/helloworld Error: cannot find package &amp;quot;src/gopl.io/ch1/helloworld&amp;quot;. 也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。
$ cat quoteargs.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;os&amp;quot; ) func main() { fmt.Printf(&amp;quot;%q\n&amp;quot;, os.Args[1:]) } $ go build quoteargs.go $ ./quoteargs one &amp;quot;two three&amp;quot; four\ five [&amp;quot;one&amp;quot; &amp;quot;two three&amp;quot; &amp;quot;four five&amp;quot;] 特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。go run命令实际上是结合了构建和运行的两个步骤：</description>
    </item>
    
    <item>
      <title>11.2.3. 白盒测试</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.3-White-Box-Testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.3-White-Box-Testing/</guid>
      <description>11.2.3. 白盒测试 #  一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（白盒测试只是一个传统的名称，其实称为clear box测试会更准确。）
黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。
我们已经看到两种测试的例子。TestIsPalindrome测试仅仅使用导出的IsPalindrome函数，因此这是一个黑盒测试。TestEcho测试则调用了内部的echo函数，并且更新了内部的out包级变量，这两个都是未导出的，因此这是白盒测试。
当我们准备TestEcho测试的时候，我们修改了echo函数使用包级的out变量作为输出对象，因此测试代码可以用另一个实现代替标准输出，这样可以方便对比echo输出的数据。使用类似的技术，我们可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。
下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。（译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值=&amp;gt;触发报警的逻辑，所以是很实用的案例。）
gopl.io/ch11/storage1
package storage import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/smtp&amp;#34; ) func bytesInUse(username string) int64 { return 0 /* ... */ } // Email sender configuration. // NOTE: never put passwords in source code! const sender = &amp;#34;notifications@example.com&amp;#34; const password = &amp;#34;correcthorsebatterystaple&amp;#34; const hostname = &amp;#34;smtp.example.com&amp;#34; const template = `Warning: you are using %d bytes of storage, %d%% of your quota.` func CheckQuota(username string) { used := bytesInUse(username) const quota = 1000000000 // 1GB 	percent := 100 * used / quota if percent &amp;lt; 90 { return // OK 	} msg := fmt.</description>
    </item>
    
    <item>
      <title>11.3. 测试覆盖率</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.3.-Coverage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.3.-Coverage/</guid>
      <description>11.3. 测试覆盖率 #  就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再多的测试也不能证明一个程序没有BUG。在最好的情况下，测试可以增强我们的信心：代码在很多重要场景下是可以正常工作的。
对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化——即使最简单的程序的动态也是难以精确测量的——但是有启发式方法来帮助我们编写有效的测试代码。
这些启发式方法中，语句的覆盖率是最简单和最广泛使用的。语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。在本节中，我们使用go test命令中集成的测试覆盖率工具，来度量下面代码的测试覆盖率，帮助我们识别测试和我们期望间的差距。
下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：
gopl.io/ch7/eval
func TestCoverage(t *testing.T) { var tests = []struct { input string env Env want string // expected error from Parse/Check or result from Eval 	}{ {&amp;#34;x % 2&amp;#34;, nil, &amp;#34;unexpected &amp;#39;%&amp;#39;&amp;#34;}, {&amp;#34;!true&amp;#34;, nil, &amp;#34;unexpected &amp;#39;!&amp;#39;&amp;#34;}, {&amp;#34;log(10)&amp;#34;, nil, `unknown function &amp;#34;log&amp;#34;`}, {&amp;#34;sqrt(1, 2)&amp;#34;, nil, &amp;#34;call to sqrt has 2 args, want 1&amp;#34;}, {&amp;#34;sqrt(A / pi)&amp;#34;, Env{&amp;#34;A&amp;#34;: 87616, &amp;#34;pi&amp;#34;: math.Pi}, &amp;#34;167&amp;#34;}, {&amp;#34;pow(x, 3) + pow(y, 3)&amp;#34;, Env{&amp;#34;x&amp;#34;: 9, &amp;#34;y&amp;#34;: 10}, &amp;#34;1729&amp;#34;}, {&amp;#34;5 / 9 * (F - 32)&amp;#34;, Env{&amp;#34;F&amp;#34;: -40}, &amp;#34;-40&amp;#34;}, } for _, test := range tests { expr, err := Parse(test.</description>
    </item>
    
    <item>
      <title>12.2. reflect.Type 和 reflect.Value</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.3.-Display-a-Recursive-Value-Printer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.3.-Display-a-Recursive-Value-Printer/</guid>
      <description>12.3. Display，一个递归的值打印器 #  接下来，让我们看看如何改善聚合数据类型的显示。我们并不想完全克隆一个fmt.Sprint函数，我们只是构建一个用于调试用的Display函数：给定任意一个复杂类型 x，打印这个值对应的完整结构，同时标记每个元素的发现路径。让我们从一个例子开始。
e, _ := eval.Parse(&amp;#34;sqrt(A / pi)&amp;#34;) Display(&amp;#34;e&amp;#34;, e) 在上面的调用中，传入Display函数的参数是在7.9节一个表达式求值函数返回的语法树。Display函数的输出如下：
Display e (eval.call): e.fn = &amp;#34;sqrt&amp;#34; e.args[0].type = eval.binary e.args[0].value.op = 47 e.args[0].value.x.type = eval.Var e.args[0].value.x.value = &amp;#34;A&amp;#34; e.args[0].value.y.type = eval.Var e.args[0].value.y.value = &amp;#34;pi&amp;#34; 你应该尽量避免在一个包的API中暴露涉及反射的接口。我们将定义一个未导出的display函数用于递归处理工作，导出的是Display函数，它只是display函数简单的包装以接受interface{}类型的参数：
gopl.io/ch12/display
func Display(name string, x interface{}) { fmt.Printf(&amp;#34;Display %s (%T):\n&amp;#34;, name, x) display(name, reflect.ValueOf(x)) } 在display函数中，我们使用了前面定义的打印基础类型——基本类型、函数和chan等——元素值的formatAtom函数，但是我们会使用reflect.Value的方法来递归显示复杂类型的每一个成员。在递归下降过程中，path字符串，从最开始传入的起始值（这里是“e”），将逐步增长来表示是如何达到当前值（例如“e.args[0].value”）的。
因为我们不再模拟fmt.Sprint函数，我们将直接使用fmt包来简化我们的例子实现。
func display(path string, v reflect.Value) { switch v.Kind() { case reflect.Invalid: fmt.Printf(&amp;#34;%s = invalid\n&amp;#34;, path) case reflect.</description>
    </item>
    
    <item>
      <title>13.3. 示例: 深度相等判断</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.3.-Example-Deep-Equivalence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.3.-Example-Deep-Equivalence/</guid>
      <description>13.3. 示例: 深度相等判断 #  来自reflect包的DeepEqual函数可以对两个值进行深度相等判断。DeepEqual函数使用内建的==比较操作符对基础类型进行相等判断，对于复合类型则递归该变量的每个基础类型然后做类似的比较判断。因为它可以工作在任意的类型上，甚至对于一些不支持==操作运算符的类型也可以工作，因此在一些测试代码中广泛地使用该函数。比如下面的代码是用DeepEqual函数比较两个字符串slice是否相等。
func TestSplit(t *testing.T) { got := strings.Split(&amp;#34;a:b:c&amp;#34;, &amp;#34;:&amp;#34;) want := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}; if !reflect.DeepEqual(got, want) { /* ... */ } } 尽管DeepEqual函数很方便，而且可以支持任意的数据类型，但是它也有不足之处。例如，它将一个nil值的map和非nil值但是空的map视作不相等，同样nil值的slice 和非nil但是空的slice也视作不相等。
var a, b []string = nil, []string{} fmt.Println(reflect.DeepEqual(a, b)) // &amp;#34;false&amp;#34;  var c, d map[string]int = nil, make(map[string]int) fmt.Println(reflect.DeepEqual(c, d)) // &amp;#34;false&amp;#34; 我们希望在这里实现一个自己的Equal函数，用于比较类型的值。和DeepEqual函数类似的地方是它也是基于slice和map的每个元素进行递归比较，不同之处是它将nil值的slice（map类似）和非nil值但是空的slice视作相等的值。基础部分的比较可以基于reflect包完成，和12.3章的Display函数的实现方法类似。同样，我们也定义了一个内部函数equal，用于内部的递归比较。读者目前不用关心seen参数的具体含义。对于每一对需要比较的x和y，equal函数首先检测它们是否都有效（或都无效），然后检测它们是否是相同的类型。剩下的部分是一个巨大的switch分支，用于相同基础类型的元素比较。因为页面空间的限制，我们省略了一些相似的分支。
gopl.io/ch13/equal
func equal(x, y reflect.Value, seen map[comparison]bool) bool { if !x.IsValid() || !y.IsValid() { return x.IsValid() == y.</description>
    </item>
    
    <item>
      <title>2.3.3. new函数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.3-The-new-Function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.3-The-new-Function/</guid>
      <description>2.3.3. new函数 #  另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // &amp;#34;0&amp;#34; *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // &amp;#34;2&amp;#34; 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。
下面的两个newInt函数有着相同的行为：
func newInt() *int { return new(int) } func newInt() *int { var dummy int return &amp;amp;dummy } 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
p := new(int) q := new(int) fmt.Println(p == q) // &amp;#34;false&amp;#34; 当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）。
new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活（§4.4.1）。
由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：
func delta(old, new int) int { return new - old } 由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。</description>
    </item>
    
    <item>
      <title>3.3. 复数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.3.-Complex-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.3.-Complex-Numbers/</guid>
      <description>3.3. 复数 #  Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：
var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // &amp;#34;(-5+10i)&amp;#34; fmt.Println(real(x*y)) // &amp;#34;-5&amp;#34; fmt.Println(imag(x*y)) // &amp;#34;10&amp;#34; 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：
fmt.Println(1i * 1i) // &amp;#34;(-1+0i)&amp;#34;, i^2 = -1 在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：
x := 1 + 2i y := 3 + 4i 复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。
math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。
fmt.Println(cmplx.Sqrt(-1)) // &amp;#34;(0+1i)&amp;#34; 下面的程序使用complex128复数算法来生成一个Mandelbrot图像。
gopl.io/ch3/mandelbrot
// Mandelbrot emits a PNG image of the Mandelbrot fractal. package main import ( &amp;#34;image&amp;#34; &amp;#34;image/color&amp;#34; &amp;#34;image/png&amp;#34; &amp;#34;math/cmplx&amp;#34; &amp;#34;os&amp;#34; ) func main() { const ( xmin, ymin, xmax, ymax = -2, -2, +2, +2 width, height = 1024, 1024 ) img := image.</description>
    </item>
    
    <item>
      <title>3.5.3. UTF-8</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.3-UTF-8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.3-UTF-8/</guid>
      <description>3.5.3. UTF-8 #  UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。更大的Unicode码点也是采用类似的策略处理。
0xxxxxxx runes 0-127 (ASCII) 110xxxxx 10xxxxxx 128-2047 (values &amp;lt;128 unused) 1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values &amp;lt;2048 unused) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused) 变长的编码无法直接通过索引来访问第n个字符，但是UTF8编码获得了很多额外的优点。首先UTF8编码比较紧凑，完全兼容ASCII码，并且可以自动同步：它可以通过向前回朔最多3个字节就能确定当前字符编码的开始字节的位置。它也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看（译注：像GBK之类的编码，如果不知道起点位置则可能会出现歧义）。没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。同时UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列。同时因为没有嵌入的NUL(0)字节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言。
Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能。
有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符（译注：中文和日文就有很多相似但不同的字）。Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：\uhhhh对应16bit的码点值，\Uhhhhhhhh对应32bit的码点值，其中h是一个十六进制数字；一般很少需要使用32bit的形式。每一个对应码点的UTF8编码。例如：下面的字母串面值都表示相同的值：
&amp;quot;世界&amp;quot; &amp;quot;\xe4\xb8\x96\xe7\x95\x8c&amp;quot; &amp;quot;\u4e16\u754c&amp;quot; &amp;quot;\U00004e16\U0000754c&amp;quot; 上面三个转义序列都为第一个字符串提供替代写法，但是它们的值都是相同的。
Unicode转义也可以使用在rune字符中。下面三个字符是等价的：
&#39;世&#39; &#39;\u4e16&#39; &#39;\U00004e16&#39; 对于小于256的码点值可以写在一个十六进制转义字节中，例如\x41对应字符&amp;rsquo;A&amp;rsquo;，但是对于更大的码点则必须使用\u或\U转义形式。因此，\xe4\xb8\x96并不是一个合法的rune字符，虽然这三个字节对应一个有效的UTF8编码的码点。
得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀：
func HasPrefix(s, prefix string) bool { return len(s) &amp;gt;= len(prefix) &amp;amp;&amp;amp; s[:len(prefix)] == prefix } 或者是后缀测试：
func HasSuffix(s, suffix string) bool { return len(s) &amp;gt;= len(suffix) &amp;amp;&amp;amp; s[len(s)-len(suffix):] == suffix } 或者是包含子串测试：</description>
    </item>
    
    <item>
      <title>4.3. Map</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.3.-Maps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.3.-Maps/</guid>
      <description>4.3. Map #  哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。
在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。
内置的make函数可以创建一个map：
ages := make(map[string]int) // mapping from strings to ints 我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：
ages := map[string]int{ &amp;#34;alice&amp;#34;: 31, &amp;#34;charlie&amp;#34;: 34, } 这相当于
ages := make(map[string]int) ages[&amp;#34;alice&amp;#34;] = 31 ages[&amp;#34;charlie&amp;#34;] = 34 因此，另一种创建空的map的表达式是map[string]int{}。
Map中的元素通过key对应的下标语法访问：
ages[&amp;#34;alice&amp;#34;] = 32 fmt.Println(ages[&amp;#34;alice&amp;#34;]) // &amp;#34;32&amp;#34; 使用内置的delete函数可以删除元素：
delete(ages, &amp;#34;alice&amp;#34;) // remove element ages[&amp;#34;alice&amp;#34;] 所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[&amp;ldquo;bob&amp;rdquo;]失败时将返回0。
ages[&amp;#34;bob&amp;#34;] = ages[&amp;#34;bob&amp;#34;] + 1 // happy birthday! 而且x += y和x++等简短赋值语法也可以用在map上，所以上面的代码可以改写成
ages[&amp;#34;bob&amp;#34;] += 1 更简单的写法
ages[&amp;#34;bob&amp;#34;]++ 但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：
_ = &amp;amp;ages[&amp;#34;bob&amp;#34;] // compile error: cannot take address of map element 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</description>
    </item>
    
    <item>
      <title>4.4.3. 结构体嵌入和匿名成员</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.3-Struct-Embedding-and-Anonymous-Fields/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.3-Struct-Embedding-and-Anonymous-Fields/</guid>
      <description>4.4.3. 结构体嵌入和匿名成员 #  在本节中，我们将看到如何使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。
考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义：
type Circle struct { X, Y, Radius int } type Wheel struct { X, Y, Radius, Spokes int } 一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量：
var w Wheel w.X = 8 w.Y = 8 w.Radius = 5 w.Spokes = 20 随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来：
type Point struct { X, Y int } type Circle struct { Center Point Radius int } type Wheel struct { Circle Circle Spokes int } 这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐：
var w Wheel w.</description>
    </item>
    
    <item>
      <title>5.3. 多返回值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.3.-Multiple-Return-Values/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.3.-Multiple-Return-Values/</guid>
      <description>5.3. 多返回值 #  在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。下面的例子会展示如何编写多返回值的函数。
下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。这意味着如果findlinks函数失败了，很可能是由于I/O的错误导致的。
gopl.io/ch5/findlinks2
func main() { for _, url := range os.Args[1:] { links, err := findLinks(url) if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;findlinks2: %v\n&amp;#34;, err) continue } for _, link := range links { fmt.Println(link) } } } // findLinks performs an HTTP GET request for url, parses the // response as HTML, and extracts and returns the links. func findLinks(url string) ([]string, error) { resp, err := http.</description>
    </item>
    
    <item>
      <title>6.3. 通过嵌入结构体来扩展类型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.3.-Composing-Types-by-Struct-Embedding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.3.-Composing-Types-by-Struct-Embedding/</guid>
      <description>6.3. 通过嵌入结构体来扩展类型 #  来看看ColoredPoint这个类型：
gopl.io/ch6/coloredpoint
import &amp;#34;image/color&amp;#34; type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } 我们完全可以将ColoredPoint定义为一个有三个字段的struct，但是我们却将Point这个类型嵌入到ColoredPoint来提供X和Y这两个字段。像我们在4.4节中看到的那样，内嵌可以使我们在定义ColoredPoint时得到一种句法上的简写形式，并使其包含Point类型所具有的一切字段，然后再定义一些自己的。如果我们想要的话，我们可以直接认为通过嵌入的字段就是ColoredPoint自身的字段，而完全不需要在调用时指出Point，比如下面这样。
var cp ColoredPoint cp.X = 1 fmt.Println(cp.Point.X) // &amp;#34;1&amp;#34; cp.Point.Y = 2 fmt.Println(cp.Y) // &amp;#34;2&amp;#34; 对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法：
red := color.RGBA{255, 0, 0, 255} blue := color.RGBA{0, 0, 255, 255} var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} fmt.Println(p.Distance(q.Point)) // &amp;#34;5&amp;#34; p.ScaleBy(2) q.ScaleBy(2) fmt.Println(p.Distance(q.Point)) // &amp;#34;10&amp;#34; Point类的方法也被引入了ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。</description>
    </item>
    
    <item>
      <title>7.3. 实现接口的条件</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.3.-Interface-Satisfaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.3.-Interface-Satisfaction/</guid>
      <description>7.3. 实现接口的条件 #  一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。例如，*os.File类型实现了io.Reader，Writer，Closer，和ReadWriter接口。*bytes.Buffer实现了Reader，Writer，和ReadWriter这些接口，但是它没有实现Closer接口因为它不具有Close方法。Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，*bytes.Buffer是io.Writer；*os.Files是io.ReadWriter。
接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：
var w io.Writer w = os.Stdout // OK: *os.File has Write method w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method w = time.Second // compile error: time.Duration lacks Write method  var rwc io.ReadWriteCloser rwc = os.Stdout // OK: *os.File has Read, Write, Close methods rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method 这个规则甚至适用于等式右边本身也是一个接口类型
w = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.</description>
    </item>
    
    <item>
      <title>8.3. 示例: 并发的Echo服务</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.3.-Example-Concurrent-Echo-Server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.3.-Example-Concurrent-Echo-Server/</guid>
      <description>8.3. 示例: 并发的Echo服务 #  clock服务器每一个连接都会起一个goroutine。在本节中我们会创建一个echo服务器，这个服务在每个连接中会有多个goroutine。大多数echo服务仅仅会返回他们读取到的内容，就像下面这个简单的handleConn函数所做的一样：
func handleConn(c net.Conn) { io.Copy(c, c) // NOTE: ignoring errors 	c.Close() } 一个更有意思的echo服务应该模拟一个实际的echo的“回响”，并且一开始要用大写HELLO来表示“声音很大”，之后经过一小段延迟返回一个有所缓和的Hello，然后一个全小写字母的hello表示声音渐渐变小直至消失，像下面这个版本的handleConn(译注：笑看作者脑洞大开)：
gopl.io/ch8/reverb1
func echo(c net.Conn, shout string, delay time.Duration) { fmt.Fprintln(c, &amp;#34;\t&amp;#34;, strings.ToUpper(shout)) time.Sleep(delay) fmt.Fprintln(c, &amp;#34;\t&amp;#34;, shout) time.Sleep(delay) fmt.Fprintln(c, &amp;#34;\t&amp;#34;, strings.ToLower(shout)) } func handleConn(c net.Conn) { input := bufio.NewScanner(c) for input.Scan() { echo(c, input.Text(), 1*time.Second) } // NOTE: ignoring potential errors from input.Err() 	c.Close() } 我们需要升级我们的客户端程序，这样它就可以发送终端的输入到服务器，并把服务端的返回输出到终端上，这使我们有了使用并发的另一个好机会：
gopl.io/ch8/netcat2
func main() { conn, err := net.</description>
    </item>
    
    <item>
      <title>8.4.3. 单方向的Channel</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.3-Unidirectional-Channel-Types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.3-Unidirectional-Channel-Types/</guid>
      <description>8.4.3. 单方向的Channel #  随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels来连接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法：
func counter(out chan int) func squarer(out, in chan int) func printer(in chan int) 其中计算平方的squarer函数在两个串联Channels的中间，因此拥有两个channel类型的参数，一个用于输入一个用于输出。两个channel都拥有相同的类型，但是它们的使用方式相反：一个只用于接收，另一个只用于发送。参数的名字in和out已经明确表示了这个意图，但是并无法保证squarer函数向一个in参数对应的channel发送数据或者从一个out参数对应的channel接收数据。
这种场景是典型的。当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。
为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan&amp;lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&amp;lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&amp;lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。
因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。
这是改进的版本，这一次参数使用了单方向channel类型：
gopl.io/ch8/pipeline3
func counter(out chan&amp;lt;- int) { for x := 0; x &amp;lt; 100; x++ { out &amp;lt;- x } close(out) } func squarer(out chan&amp;lt;- int, in &amp;lt;-chan int) { for v := range in { out &amp;lt;- v * v } close(out) } func printer(in &amp;lt;-chan int) { for v := range in { fmt.</description>
    </item>
    
    <item>
      <title>9.3. sync.RWMutex读写锁</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.3.-Read-Write-Mutexes-sync.RWMutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.3.-Read-Write-Mutexes-sync.RWMutex/</guid>
      <description>9.3. sync.RWMutex读写锁 #  在100刀的存款消失时不做记录多少还是会让我们有一些恐慌，Bob写了一个程序，每秒运行几百次来检查他的银行余额。他会在家，在工作中，甚至会在他的手机上来运行这个程序。银行注意到这些陡增的流量使得存款和取款有了延时，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。
由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁（multiple readers, single writer lock），Go语言提供的这样的锁是sync.RWMutex：
var mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers lock 	defer mu.RUnlock() return balance } Balance函数现在调用了RLock和RUnlock方法来获取和释放一个读取或者共享锁。Deposit函数没有变化，会调用mu.Lock和mu.Unlock方法来获取和释放一个写或互斥锁。
在这次修改后，Bob的余额查询请求就可以彼此并行地执行并且会很快地完成了。锁在更多的时间范围可用，并且存款请求也能够及时地被响应了。
RLock只能在临界区共享变量没有任何写入操作时可用。一般来说，我们不应该假设逻辑上的只读函数/方法也不会去更新某一些变量。比如一个方法功能是访问一个变量，但它也有可能会同时去给一个内部的计数器+1（译注：可能是记录这个方法的访问次数啥的），或者去更新缓存——使即时的调用能够更快。如果有疑惑的话，请使用互斥锁。
RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。</description>
    </item>
    
    <item>
      <title>9.8.3. GOMAXPROCS</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.3-GOMAXPROCS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.3-GOMAXPROCS/</guid>
      <description>9.8.3. GOMAXPROCS #  Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。（GOMAXPROCS是前面说的m:n调度中的n）。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。
你可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。我们在下面的小程序中会看到GOMAXPROCS的效果，这个程序会无限打印0和1。
for { go fmt.Print(0) fmt.Print(1) } $ GOMAXPROCS=1 go run hacker-cliché.go 111111111111111111110000000000000000000011111... $ GOMAXPROCS=2 go run hacker-cliché.go 010101010101010101011001100101011010010100110... 在第一次执行时，最多同时只能有一个goroutine被执行。初始情况下只有main goroutine被执行，所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。我们必须强调的是goroutine的调度是受很多因子影响的，而runtime也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。
** 练习9.6:** 测试一下计算密集型的并发程序（练习8.5那样的）会被GOMAXPROCS怎样影响到。在你的电脑上最佳的值是多少？你的电脑CPU有多少个核心？</description>
    </item>
    
    <item>
      <title>本书的组织</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/Organization-of-the-Book/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/Organization-of-the-Book/</guid>
      <description>本书的组织 #  我们假设你已经有一种或多种其他编程语言的使用经历，不管是类似C、C++或Java的编译型语言，还是类似Python、Ruby、JavaScript的脚本语言，因此我们不会像对完全的编程语言初学者那样解释所有的细节。因为，Go语言的变量、常量、表达式、控制流和函数等基本语法也是类似的。
第一章包含了本教程的基本结构，通过十几个程序介绍了用Go语言如何实现类似读写文件、文本格式化、创建图像、网络客户端和服务器通讯等日常工作。
第二章描述了Go语言程序的基本元素结构、变量、新类型定义、包和文件、以及作用域等概念。第三章讨论了数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符。第四章描述了复合类型，从简单的数组、字典、切片到动态列表。第五章涵盖了函数，并讨论了错误处理、panic和recover，还有defer语句。
第一章到第五章是基础部分，主流命令式编程语言这部分都类似。个别之处，Go语言有自己特色的语法和风格，但是大多数程序员能很快适应。其余章节是Go语言特有的：方法、接口、并发、包、测试和反射等语言特性。
Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。方法不仅可以定义在结构体上，而且，可以定义在任何用户自定义的类型上；并且，具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。方法在第六章讨论，接口在第七章讨论。
第八章讨论了基于顺序通信进程（CSP）概念的并发编程，使用goroutines和channels处理并发编程。第九章则讨论了传统的基于共享变量的并发编程。
第十章描述了包机制和包的组织结构。这一章还展示了如何有效地利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。
第十一章讨论了单元测试，Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大但复杂的测试框架。测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件。
第十二章讨论了反射，一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，不过要谨慎地使用；这一章利用反射机制实现一些重要的Go语言库函数，展示了反射的强大用法。第十三章解释了底层编程的细节，在必要时，可以使用unsafe包绕过Go语言安全的类型系统。
每一章都有一些练习题，你可以用来测试你对Go的理解，你也可以探讨书中这些例子的扩展和替代。
书中所有的代码都可以从 http://gopl.io 上的Git仓库下载。go get命令根据每个例子的导入路径智能地获取、构建并安装。只需要选择一个目录作为工作空间，然后将GOPATH环境变量设置为该路径。
必要时，Go语言工具会创建目录。例如：
$ export GOPATH=$HOME/gobook # 选择工作目录$ go get gopl.io/ch1/helloworld # 获取/编译/安装$ $GOPATH/bin/helloworld # 运行程序Hello, 世界 # 这是中文运行这些例子需要安装Go1.5以上的版本。
$ go versiongo version go1.5 linux/amd64如果使用其他的操作系统，请参考 https://golang.org/doc/install 提供的说明安装。</description>
    </item>
    
    <item>
      <title>1.4. GIF动画</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.4.-Animated-GIFs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.4.-Animated-GIFs/</guid>
      <description>1.4. GIF动画 #  下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形（Lissajous figures），这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。图1.1是这样的一个例子：
 译注：要看这个程序的结果，需要将标准输出重定向到一个GIF图像文件（使用 ./lissajous &amp;gt; output.gif 命令）。下面是GIF图像动画效果：
 这段代码里我们用了一些新的结构，包括const声明，struct结构体类型，复合声明。和我们举的其它的例子不太一样，这一个例子包含了浮点数运算。这些概念我们只在这里简单地说明一下，之后的章节会更详细地讲解。
gopl.io/ch1/lissajous
// Lissajous generates GIF animations of random Lissajous figures. package main import ( &amp;#34;image&amp;#34; &amp;#34;image/color&amp;#34; &amp;#34;image/gif&amp;#34; &amp;#34;io&amp;#34; &amp;#34;math&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; ) var palette = []color.Color{color.White, color.Black} const ( whiteIndex = 0 // first color in palette 	blackIndex = 1 // next color in palette ) func main() { // The sequence of images is deterministic unless we seed 	// the pseudo-random number generator using the current time.</description>
    </item>
    
    <item>
      <title>10.4. 导入声明</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.4.-Import-Declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.4.-Import-Declarations/</guid>
      <description>10.4. 导入声明 #  可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。
import &amp;#34;fmt&amp;#34; import &amp;#34;os&amp;#34; import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) 导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将不同分组导入的包独立排序。）
import ( &amp;#34;fmt&amp;#34; &amp;#34;html/template&amp;#34; &amp;#34;os&amp;#34; &amp;#34;golang.org/x/net/html&amp;#34; &amp;#34;golang.org/x/net/ipv4&amp;#34; ) 如果我们想同时导入两个有着名字相同的包，例如math/rand包和crypto/rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。
import ( &amp;#34;crypto/rand&amp;#34; mrand &amp;#34;math/rand&amp;#34; // alternative name mrand avoids conflict ) 导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。
导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将“path”标准包重命名为pathpkg。
每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。</description>
    </item>
    
    <item>
      <title>10.7.4. 包文档</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.4-Documenting-Packagesvvvvvvvvvvvvvv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.4-Documenting-Packagesvvvvvvvvvvvvvv/</guid>
      <description>10.7.4. 包文档 #  Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。
Go语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。
// Fprintf formats according to a format specifier and writes to w. // It returns the number of bytes written and any write error encountered. func Fprintf(w io.Writer, format string, a ...interface{}) (int, error) Fprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。
好的文档并不需要面面俱到，文档本身应该是简洁但不可忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。
在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。
首先是go doc命令，该命令打印其后所指定的实体的声明与文档注释，该实体可能是一个包：
$ go doc time package time // import &amp;quot;time&amp;quot; Package time provides functionality for measuring and displaying time. const Nanosecond Duration = 1 ... func After(d Duration) &amp;lt;-chan Time func Sleep(d Duration) func Since(t Time) Duration func Now() Time type Duration int64 type Time struct { .</description>
    </item>
    
    <item>
      <title>11.2.4. 外部测试包</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.4-External-Test-Packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.4-External-Test-Packages/</guid>
      <description>11.2.4. 外部测试包 #  考虑下这两个包：net/url包，提供了URL解析的功能；net/http包，提供了web服务和HTTP客户端的功能。如我们所料，上层的net/http包依赖下层的net/url包。然后，net/url包中的一个测试是演示不同URL和HTTP客户端的交互行为。也就是说，一个下层包的测试代码导入了上层的包。
 这样的行为在net/url包的测试代码中会导致包的循环依赖，正如图11.1中向上箭头所示，同时正如我们在10.1节所讲的，Go语言规范是禁止包的循环依赖的。
不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net/url包所在的目录声明一个独立的url_test测试包。其中包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net/url_test会更容易理解，但实际上它并不能被其他任何包导入。
因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。
 通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。
我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。
{% raw %}
$ go list -f={{.GoFiles}} fmt [doc.go format.go print.go scan.go] {% endraw %}
TestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：
{% raw %}
$ go list -f={{.TestGoFiles}} fmt [export_test.go] {% endraw %}
包的测试代码通常都在这些文件中，不过fmt包并非如此；稍后我们再解释export_test.go文件的作用。
XTestGoFiles表示的是属于外部测试包的测试代码，也就是fmt_test包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：
{% raw %}
$ go list -f={{.XTestGoFiles}} fmt [fmt_test.go scan_test.go stringer_test.go] {% endraw %}
有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在export_test.go文件中。
例如，fmt包的fmt.Scanf函数需要unicode.IsSpace函数提供的功能。但是为了避免太多的依赖，fmt包并没有导入包含巨大表格数据的unicode包；相反fmt包有一个叫isSpace内部的简易实现。
为了确保fmt.isSpace和unicode.IsSpace函数的行为保持一致，fmt包谨慎地包含了一个测试。一个在外部测试包内的白盒测试，是无法直接访问到isSpace内部函数的，因此fmt通过一个后门导出了isSpace函数。export_test.go文件就是专门用于外部测试包的后门。
package fmt var IsSpace = isSpace 这个测试文件并没有定义测试代码；它只是通过fmt.IsSpace简单导出了内部的isSpace函数，提供给外部测试包使用。这个技巧可以广泛用于位于外部测试包的白盒测试。</description>
    </item>
    
    <item>
      <title>11.4. 基准测试</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.4.-Benchmark-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.4.-Benchmark-Functions/</guid>
      <description>11.4. 基准测试 #  基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个*testing.B类型的参数；*testing.B参数除了提供和*testing.T类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。
下面是IsPalindrome函数的基准测试，其中循环将执行N次。
import &amp;#34;testing&amp;#34; func BenchmarkIsPalindrome(b *testing.B) { for i := 0; i &amp;lt; b.N; i++ { IsPalindrome(&amp;#34;A man, a plan, a canal: Panama&amp;#34;) } } 我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过-bench命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和-bench=IsPalindrome参数是等价的效果。
$ cd $GOPATH/src/gopl.io/ch11/word2 $ go test -bench=. PASS BenchmarkIsPalindrome-8 1000000 1035 ns/op ok gopl.io/ch11/word2 2.179s 结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。
报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。
循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。
现在我们有了一个基准测试和普通测试，我们可以很容易测试改进程序运行速度的想法。也许最明显的优化是在IsPalindrome函数中第二个循环的停止检查，这样可以避免每个比较都做两次：
n := len(letters)/2 for i := 0; i &amp;lt; n; i++ { if letters[i] != letters[len(letters)-1-i] { return false } } return true 不过很多情况下，一个显而易见的优化未必能带来预期的效果。这个改进在基准测试中只带来了4%的性能提升。</description>
    </item>
    
    <item>
      <title>12.4. 示例: 编码为S表达式</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.4.-Example-Encoding-S-Expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.4.-Example-Encoding-S-Expressions/</guid>
      <description>12.4. 示例: 编码为S表达式 #  Display是一个用于显示结构化数据的调试工具，但是它并不能将任意的Go语言对象编码为通用消息然后用于进程间通信。
正如我们在4.5节中中看到的，Go语言的标准库支持了包括JSON、XML和ASN.1等多种编码格式。还有另一种依然被广泛使用的格式是S表达式格式，采用Lisp语言的语法。但是和其他编码格式不同的是，Go语言自带的标准库并不支持S表达式，主要是因为它没有一个公认的标准规范。
在本节中，我们将定义一个包用于将任意的Go语言对象编码为S表达式格式，它支持以下结构：
42 integer &amp;quot;hello&amp;quot; string（带有Go风格的引号） foo symbol（未用引号括起来的名字） (1 2 3) list （括号包起来的0个或多个元素） 布尔型习惯上使用t符号表示true，空列表或nil符号表示false，但是为了简单起见，我们暂时忽略布尔类型。同时忽略的还有chan管道和函数，因为通过反射并无法知道它们的确切状态。我们忽略的还有浮点数、复数和interface。支持它们是练习12.3的任务。
我们将Go语言的类型编码为S表达式的方法如下。整数和字符串以显而易见的方式编码。空值编码为nil符号。数组和slice被编码为列表。
结构体被编码为成员对象的列表，每个成员对象对应一个有两个元素的子列表，子列表的第一个元素是成员的名字，第二个元素是成员的值。Map被编码为键值对的列表。传统上，S表达式使用点状符号列表(key . value)结构来表示key/value对，而不是用一个含双元素的列表，不过为了简单我们忽略了点状符号列表。
编码是由一个encode递归函数完成，如下所示。它的结构本质上和前面的Display函数类似：
gopl.io/ch12/sexpr
func encode(buf *bytes.Buffer, v reflect.Value) error { switch v.Kind() { case reflect.Invalid: buf.WriteString(&amp;#34;nil&amp;#34;) case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: fmt.Fprintf(buf, &amp;#34;%d&amp;#34;, v.Int()) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: fmt.Fprintf(buf, &amp;#34;%d&amp;#34;, v.Uint()) case reflect.String: fmt.Fprintf(buf, &amp;#34;%q&amp;#34;, v.String()) case reflect.Ptr: return encode(buf, v.Elem()) case reflect.Array, reflect.</description>
    </item>
    
    <item>
      <title>13.4. 通过cgo调用C代码</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.4.-Calling-C-Code-with-cgo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.4.-Calling-C-Code-with-cgo/</guid>
      <description>13.4. 通过cgo调用C代码 #  Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景，或者是从一个C++语言实现的嵌入式数据库查询记录的场景，或者是使用Fortran语言实现的一些线性代数库的场景。C语言作为一个通用语言，很多库会选择提供一个C兼容的API，然后用其他不同的编程语言实现（译者：Go语言需要也应该拥抱这些巨大的代码遗产）。
在本节中，我们将构建一个简易的数据压缩程序，使用了一个Go语言自带的叫cgo的用于支援C语言函数调用的工具。这类工具一般被称为 foreign-function interfaces （简称ffi），并且在类似工具中cgo也不是唯一的。SWIG（http://swig.org）是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支援C++的特性，但SWIG并不是我们要讨论的主题。
在标准库的compress/...子包有很多流行的压缩算法的编码和解码实现，包括流行的LZW压缩算法（Unix的compress命令用的算法）和DEFLATE压缩算法（GNU gzip命令用的算法）。这些包的API的细节虽然有些差异，但是它们都提供了针对 io.Writer类型输出的压缩接口和提供了针对io.Reader类型输入的解压缩接口。例如：
package gzip // compress/gzip func NewWriter(w io.Writer) io.WriteCloser func NewReader(r io.Reader) (io.ReadCloser, error) bzip2压缩算法，是基于优雅的Burrows-Wheeler变换算法，运行速度比gzip要慢，但是可以提供更高的压缩比。标准库的compress/bzip2包目前还没有提供bzip2压缩算法的实现。完全从头开始实现一个压缩算法是一件繁琐的工作，而且 http://bzip.org 已经有现成的libbzip2的开源实现，不仅文档齐全而且性能又好。
如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了（译注：用os/exec包调用子进程的方法会导致程序运行时依赖那个应用程序）。下面我们将通过一个例子讲述cgo的具体用法。
译注：本章采用的代码都是最新的。因为之前已经出版的书中包含的代码只能在Go1.5之前使用。从Go1.6开始，Go语言已经明确规定了哪些Go语言指针可以直接传入C语言函数。新代码重点是增加了bz2alloc和bz2free的两个函数，用于bz_stream对象空间的申请和释放操作。下面是新代码中增加的注释，说明这个问题：
// The version of this program that appeared in the first and second // printings did not comply with the proposed rules for passing // pointers between Go and C, described here: // https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md // // The rules forbid a C function like bz2compress from storing &amp;#39;in&amp;#39; // and &amp;#39;out&amp;#39; (pointers to variables allocated by Go) into the Go // variable &amp;#39;s&amp;#39;, even temporarily.</description>
    </item>
    
    <item>
      <title>2.3.4. 变量的生命周期</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.4-Lifetime-of-Variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.4-Lifetime-of-Variables/</guid>
      <description>2.3.4. 变量的生命周期 #  变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。
例如，下面是从1.4节的Lissajous程序摘录的代码片段：
for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) } 译注：函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。像下面这样：
for t := 0.0; t &amp;lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex( size+int(x*size+0.5), size+int(y*size+0.5), blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性 	) // 小括弧另起一行缩进，和大括弧的风格保存一致 } 在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。
那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。
var global *int func f() { var x int x = 1 global = &amp;amp;x } func g() { y := new(int) *y = 1 } f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</description>
    </item>
    
    <item>
      <title>3.4. 布尔型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.4.-Booleans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.4.-Booleans/</guid>
      <description>3.4. 布尔型 #  一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和&amp;lt;等比较操作也会产生布尔型的值。一元操作符!对应逻辑非操作，因此!true的值为false，更罗嗦的说法是(!true==false)==true，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用x来表示x==true。
布尔值可以和&amp;amp;&amp;amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：
s != &amp;#34;&amp;#34; &amp;amp;&amp;amp; s[0] == &amp;#39;x&amp;#39; 其中s[0]操作如果应用于空字符串将会导致panic异常。
因为&amp;amp;&amp;amp;的优先级比||高（助记：&amp;amp;&amp;amp;对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：
if &amp;#39;a&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39; || &amp;#39;A&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39; || &amp;#39;0&amp;#39; &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;9&amp;#39; { // ...ASCII letter or digit... } 布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换：
i := 0 if b { i = 1 } 如果需要经常做类似的转换，包装成一个函数会更方便：
// btoi returns 1 if b is true and 0 if false. func btoi(b bool) int { if b { return 1 } return 0 } 数字到布尔型的逆转换则非常简单，不过为了保持对称，我们也可以包装一个函数：</description>
    </item>
    
    <item>
      <title>3.5.4. 字符串和Byte切片</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.4-Strings-and-Byte-Slices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.4-Strings-and-Byte-Slices/</guid>
      <description>3.5.4. 字符串和Byte切片 #  标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。
strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。
下面例子的basename函数灵感源于Unix shell的同名工具。在我们实现的版本中，basename(s)将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除：
fmt.Println(basename(&amp;#34;a/b/c.go&amp;#34;)) // &amp;#34;c&amp;#34; fmt.Println(basename(&amp;#34;c.d.go&amp;#34;)) // &amp;#34;c.d&amp;#34; fmt.Println(basename(&amp;#34;abc&amp;#34;)) // &amp;#34;abc&amp;#34; 第一个版本并没有使用任何库，全部手工硬编码实现：
gopl.io/ch3/basename1
// basename removes directory components and a .suffix. // e.g., a =&amp;gt; a, a.go =&amp;gt; a, a/b/c.go =&amp;gt; c, a/b.c.go =&amp;gt; b.c func basename(s string) string { // Discard last &amp;#39;/&amp;#39; and everything before. 	for i := len(s) - 1; i &amp;gt;= 0; i-- { if s[i] == &amp;#39;/&amp;#39; { s = s[i+1:] break } } // Preserve everything before last &amp;#39;.</description>
    </item>
    
    <item>
      <title>6.4. 方法值和方法表达式</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.4.-Method-Values-and-Expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.4.-Method-Values-and-Expressions/</guid>
      <description>6.4. 方法值和方法表达式 #  我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法“值”-&amp;gt;一个将方法（Point.Distance）绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器（译注：因为已经在前文中指定过了），只要传入函数的参数即可：
p := Point{1, 2} q := Point{4, 6} distanceFromP := p.Distance // method value fmt.Println(distanceFromP(q)) // &amp;#34;5&amp;#34; var origin Point // {0, 0} fmt.Println(distanceFromP(origin)) // &amp;#34;2.23606797749979&amp;#34;, sqrt(5)  scaleP := p.ScaleBy // method value scaleP(2) // p becomes (2, 4) scaleP(3) // then (6, 12) scaleP(10) // then (60, 120) 在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法“值”会非常实用（``=_=`真是绕）。举例来说，下面例子中的time.AfterFunc这个函数的功能是在指定的延迟时间之后来执行一个（译注：另外的）函数。且这个函数操作的是一个Rocket对象r
type Rocket struct { /* ... */ } func (r *Rocket) Launch() { /* .</description>
    </item>
    
    <item>
      <title>7.4. flag.Value接口</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.4.-Parsing-Flags-with-flag.Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.4.-Parsing-Flags-with-flag.Value/</guid>
      <description>7.4. flag.Value接口 #  在本章，我们会学到另一个标准的接口类型flag.Value是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特定时间的程序：
gopl.io/ch7/sleep
var period = flag.Duration(&amp;#34;period&amp;#34;, 1*time.Second, &amp;#34;sleep period&amp;#34;) func main() { flag.Parse() fmt.Printf(&amp;#34;Sleeping for %v...&amp;#34;, *period) time.Sleep(*period) fmt.Println() } 在它休眠前它会打印出休眠的时间周期。fmt包调用time.Duration的String方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字：
$ go build gopl.io/ch7/sleep $ ./sleep Sleeping for 1s... 默认情况下，休眠周期是一秒，但是可以通过 -period 这个命令行标记来控制。flag.Duration函数创建一个time.Duration类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和String方法相同的符号排版形式。这种对称设计使得用户交互良好。
$ ./sleep -period 50ms Sleeping for 50ms... $ ./sleep -period 2m30s Sleeping for 2m30s... $ ./sleep -period 1.5h Sleeping for 1h30m0s... $ ./sleep -period &amp;quot;1 day&amp;quot; invalid value &amp;quot;1 day&amp;quot; for flag -period: time: invalid duration 1 day 因为时间周期标记值非常的有用，所以这个特性被构建到了flag包中；但是我们为我们自己的数据类型定义新的标记符号是简单容易的。我们只需要定义一个实现flag.</description>
    </item>
    
    <item>
      <title>8.4.4. 带缓存的Channels</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.4-Buffered-Channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.4-Buffered-Channels/</guid>
      <description>8.4.4. 带缓存的Channels #  带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。图8.2是ch变量对应的channel的图形表示形式。
ch = make(chan string, 3)  向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。
我们可以在无阻塞的情况下连续向新创建的channel发送三个值：
ch &amp;lt;- &amp;#34;A&amp;#34; ch &amp;lt;- &amp;#34;B&amp;#34; ch &amp;lt;- &amp;#34;C&amp;#34; 此刻，channel的内部缓存队列将是满的（图8.3），如果有第四个发送操作将发生阻塞。
 如果我们接收一个值，
fmt.Println(&amp;lt;-ch) // &amp;#34;A&amp;#34; 那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发生阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。
 在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：
fmt.Println(cap(ch)) // &amp;#34;3&amp;#34; 同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。
fmt.Println(len(ch)) // &amp;#34;2&amp;#34; 在继续执行两次接收操作后channel内部的缓存队列将又成为空的，如果有第四个接收操作将发生阻塞：
fmt.Println(&amp;lt;-ch) // &amp;#34;B&amp;#34; fmt.Println(&amp;lt;-ch) // &amp;#34;C&amp;#34; 在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在真实的程序中它们一般由不同的goroutine执行。Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了。
下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。（顺便说一下，多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。）
func mirroredQuery() string { responses := make(chan string, 3) go func() { responses &amp;lt;- request(&amp;#34;asia.gopl.io&amp;#34;) }() go func() { responses &amp;lt;- request(&amp;#34;europe.gopl.io&amp;#34;) }() go func() { responses &amp;lt;- request(&amp;#34;americas.</description>
    </item>
    
    <item>
      <title>9.4. 内存同步</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.4.-Memory-Synchronization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.4.-Memory-Synchronization/</guid>
      <description>9.4. 内存同步 #  你可能比较纠结为什么Balance方法需要用到互斥条件，无论是基于channel还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它goroutine在其执行“期间”执行其它逻辑的风险。这里使用mutex有两方面考虑。第一Balance不会在其它操作比如Withdraw“中间”执行。第二（更重要的）是“同步”不仅仅是一堆goroutine执行顺序的问题，同样也会涉及到内存的问题。
在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存（local cache）。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。
考虑一下下面代码片段的可能输出：
var x, y int go func() { x = 1 // A1 	fmt.Print(&amp;#34;y:&amp;#34;, y, &amp;#34; &amp;#34;) // A2 }() go func() { y = 1 // B1 	fmt.Print(&amp;#34;x:&amp;#34;, x, &amp;#34; &amp;#34;) // B2 }() 因为两个goroutine是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：
y:0 x:1 x:0 y:1 x:1 y:1 y:1 x:1 第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。然而实际运行时还是有些情况让我们有点惊讶：
x:0 y:0 y:0 x:0 根据所使用的编译器，CPU，或者其它很多影响因子，这两种情况也是有可能发生的。那么这两种情况要怎么解释呢？
在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。
尽管去理解并发的一种尝试是去将其运行理解为不同goroutine语句的交错执行，但看看上面的例子，这已经不是现代的编译器和cpu的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。
所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。</description>
    </item>
    
    <item>
      <title>9.8.4. Goroutine没有ID号</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.4-Goroutines-Have-No-Identity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.4-Goroutines-Have-No-Identity/</guid>
      <description>9.8.4. Goroutine没有ID号 #  在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份（id），并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个integer或者指针值。这种情况下我们做一个抽象化的thread-local storage（线程本地存储，多线程编程中不希望其它线程访问的内容）就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。
goroutine没有可以被程序员获取到的身份（id）的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层（这个存储层有可能是tls）查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变——比如一些worker线程之类的——那么函数的行为就会变得神秘莫测。
Go鼓励更为简单的模式，这种模式下参数（译注：外部显式参数和内部显式参数。tls 中的内容算是&amp;quot;外部&amp;quot;隐式参数）对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。
你现在应该已经明白了写一个Go程序所需要的所有语言特性信息。在后面两章节中，我们会回顾一些之前的实例和工具，支持我们写出更大规模的程序：如何将一个工程组织成一系列的包，如何获取，构建，测试，性能测试，剖析，写文档，并且将这些包分享出去。</description>
    </item>
    
    <item>
      <title>更多的信息</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/Where-to-Find-More-Information/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/Where-to-Find-More-Information/</guid>
      <description>更多的信息 #  最佳的帮助信息来自Go语言的官方网站，https://golang.org ，它提供了完善的参考文档，包括编程语言规范和标准库等诸多权威的帮助信息。同时也包含了如何编写更地道的Go程序的基本教程，还有各种各样的在线文本资源和视频资源，它们是本书最有价值的补充。Go语言的官方博客 https://blog.golang.org 会不定期发布一些Go语言最好的实践文章，包括当前语言的发展状态、未来的计划、会议报告和Go语言相关的各种会议的主题等信息（译注： http://talks.golang.org/ 包含了官方收录的各种报告的讲稿）。
在线访问的一个有价值的地方是可以从web页面运行Go语言的程序（而纸质书则没有这么便利了）。这个功能由来自 https://play.golang.org 的 Go Playground 提供，并且可以方便地嵌入到其他页面中，例如 https://golang.org 的主页，或 godoc 提供的文档页面中。
Playground可以简单的通过执行一个小程序来测试对语法、语义和对程序库的理解，类似其他很多语言提供的REPL即时运行的工具。同时它可以生成对应的url，非常适合共享Go语言代码片段，汇报bug或提供反馈意见等。
基于 Playground 构建的 Go Tour，https://tour.golang.org ，是一个系列的Go语言入门教程，它包含了诸多基本概念和结构相关的并可在线运行的互动小程序。
当然，Playground 和 Tour 也有一些限制，它们只能导入标准库，而且因为安全的原因对一些网络库做了限制。如果要在编译和运行时需要访问互联网，对于一些更复杂的实验，你可能需要在自己的电脑上构建并运行程序。幸运的是下载Go语言的过程很简单，从 https://golang.org 下载安装包应该不超过几分钟（译注：感谢伟大的长城，让大陆的Gopher们都学会了自己打洞的基本生活技能，下载时间可能会因为洞的大小等因素从几分钟到几天或更久），然后就可以在自己电脑上编写和运行Go程序了。
Go语言是一个开源项目，你可以在 https://golang.org/pkg 阅读标准库中任意函数和类型的实现代码，和下载安装包的代码完全一致。这样，你可以知道很多函数是如何工作的， 通过挖掘找出一些答案的细节，或者仅仅是出于欣赏专业级Go代码。</description>
    </item>
    
    <item>
      <title>1.5. 获取URL</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.5.-Fetching-a-URL/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.5.-Fetching-a-URL/</guid>
      <description>1.5. 获取URL #  对于很多现代应用来说，访问互联网上的信息和访问本地文件系统一样重要。Go语言在net这个强大package的帮助下提供了一系列的package来做这件事情，使用这些包可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。在这些情景下，Go语言原生的并发特性（在第八章中会介绍）显得尤其好用。
为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具（译注：unix下的一个用来发http请求的工具，具体可以man curl）。当然，curl提供的功能更为复杂丰富，这里只编写最简单的样例。这个样例之后还会多次被用到。
gopl.io/ch1/fetch
// Fetch prints the content found at a URL. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; ) func main() { for _, url := range os.Args[1:] { resp, err := http.Get(url) if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;fetch: %v\n&amp;#34;, err) os.Exit(1) } b, err := ioutil.ReadAll(resp.Body) resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;fetch: reading %s: %v\n&amp;#34;, url, err) os.Exit(1) } fmt.</description>
    </item>
    
    <item>
      <title>10.5. 包的匿名导入</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.5.-Blank-Imports/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.5.-Blank-Imports/</guid>
      <description>10.5. 包的匿名导入 #  如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线_来重命名导入的包。像往常一样，下划线_为空白标识符，并不能被访问。
import _ &amp;#34;image/png&amp;#34; // register PNG decoder 这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。首先，让我们看看如何使用该特性，然后再看看它是如何工作的。
标准库的image图像包包含了一个Decode函数，用于从io.Reader接口读取数据并解码图像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使用image.Decode很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另一种图像格式：
gopl.io/ch10/jpeg
// The jpeg command reads a PNG image from the standard input // and writes it as a JPEG image to the standard output. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;image&amp;#34; &amp;#34;image/jpeg&amp;#34; _ &amp;#34;image/png&amp;#34; // register PNG decoder 	&amp;#34;io&amp;#34; &amp;#34;os&amp;#34; ) func main() { if err := toJPEG(os.Stdin, os.Stdout); err != nil { fmt.Fprintf(os.Stderr, &amp;#34;jpeg: %v\n&amp;#34;, err) os.</description>
    </item>
    
    <item>
      <title>10.7.5. 内部包</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.5-Internal-Packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.5-Internal-Packages/</guid>
      <description>10.7.5. 内部包 #  在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。
有时候，一个中间的状态可能也是有用的，标识符对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。
为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。
net/http net/http/internal/chunked net/http/httputil net/url </description>
    </item>
    
    <item>
      <title>11.2.5. 编写有效的测试</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.5-Writing-Effective-Tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.5-Writing-Effective-Tests/</guid>
      <description>11.2.5. 编写有效的测试 #  许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 == 1”或成页的海量跟踪日志。
Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。
下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。
import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;testing&amp;#34; ) // A poor assertion function. func assertEqual(x, y int) { if x != y { panic(fmt.Sprintf(&amp;#34;%d != %d&amp;#34;, x, y)) } } func TestSplit(t *testing.T) { words := strings.Split(&amp;#34;a:b:c&amp;#34;, &amp;#34;:&amp;#34;) assertEqual(len(words), 3) // ... } 从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。
func TestSplit(t *testing.T) { s, sep := &amp;#34;a:b:c&amp;#34;, &amp;#34;:&amp;#34; words := strings.Split(s, sep) if got, want := len(words), 3; got !</description>
    </item>
    
    <item>
      <title>11.5. 剖析</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.5.-Profiling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.5.-Profiling/</guid>
      <description>11.5. 剖析 #  基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每个码农都应该知道Donald Knuth在1974年的“Structured Programming with go to Statements”上所说的格言。虽然经常被解读为不重视性能的意思，但是从原文我们可以看到不同的含义：
 毫无疑问，对效率的片面追求会导致各种滥用。程序员会浪费大量的时间在非关键程序的速度上，实际上这些尝试提升效率的行为反倒可能产生很大的负面影响，特别是当调试和维护的时候。我们不应该过度纠结于细节的优化，应该说约97%的场景：过早的优化是万恶之源。
当然我们也不应该放弃对那关键3%的优化。一个好的程序员不会因为这个比例小就裹足不前，他们会明智地观察和识别哪些是关键的代码；但是仅当关键代码已经被确认的前提下才会进行优化。对于很多程序员来说，判断哪部分是关键的性能瓶颈，是很容易犯经验上的错误的，因此一般应该借助测量工具来证明。
 当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。
Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的go test工具对几种分析方式都提供了支持。
CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。
堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。
阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。
只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。
$ go test -cpuprofile=cpu.out $ go test -blockprofile=block.out $ go test -memprofile=mem.out 对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。
一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应go tool pprof命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。
为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然go test通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。
下面的命令演示了如何收集并展示一个CPU分析文件。我们选择net/http包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run=NONE参数禁止那些简单测试。
$ go test -run=NONE -bench=ClientServerParallelTLS64 \ -cpuprofile=cpu.log net/http PASS BenchmarkClientServerParallelTLS64-8 1000 3141325 ns/op 143010 B/op 1747 allocs/op ok net/http 3.395s $ go tool pprof -text -nodecount=10 ./http.test cpu.log 2570ms of 3590ms total (71.</description>
    </item>
    
    <item>
      <title>12.5. 通过reflect.Value修改值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.5.-Setting-Variables-with-reflect.Value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.5.-Setting-Variables-with-reflect.Value/</guid>
      <description>12.5. 通过reflect.Value修改值 #  到目前为止，反射还只是程序中变量的另一种读取方式。然而，在本节中我们将重点讨论如何通过反射机制来修改变量。
回想一下，Go语言中类似x、x.f[1]和*p形式的表达式都可以表示变量，但是其它如x + 1和f(2)则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。
对于reflect.Values也有类似的区别。有一些reflect.Values是可取地址的；其它一些则不可以。考虑以下的声明语句：
x := 2 // value type variable? a := reflect.ValueOf(2) // 2 int no b := reflect.ValueOf(x) // 2 int no c := reflect.ValueOf(&amp;amp;x) // &amp;amp;x *int no d := c.Elem() // 2 int yes (x) 其中a对应的变量不可取地址。因为a中的值仅仅是整数2的拷贝副本。b中的值也同样不可取地址。c中的值还是不可取地址，它只是一个指针&amp;amp;x的拷贝。实际上，所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的。但是对于d，它是c的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用reflect.ValueOf(&amp;amp;x).Elem()，来获取任意变量x对应的可取地址的Value。
我们可以通过调用reflect.Value的CanAddr方法来判断其是否可以被取地址：
fmt.Println(a.CanAddr()) // &amp;#34;false&amp;#34; fmt.Println(b.CanAddr()) // &amp;#34;false&amp;#34; fmt.Println(c.CanAddr()) // &amp;#34;false&amp;#34; fmt.Println(d.CanAddr()) // &amp;#34;true&amp;#34; 每当我们通过指针间接地获取的reflect.Value都是可取地址的，即使开始的是一个不可取地址的Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice的索引表达式e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。以此类推，reflect.ValueOf(e).Index(i)对应的值也是可取地址的，即使原始的reflect.ValueOf(e)不支持也没有关系。
要从变量对应的可取地址的reflect.Value来访问变量需要三个步骤。第一步是调用Addr()方法，它返回一个Value，里面保存了指向变量的指针。然后是在Value上调用Interface()方法，也就是返回一个interface{}，里面包含指向变量的指针。最后，如果我们知道变量的类型，我们可以使用类型的断言机制将得到的interface{}类型的接口强制转为普通的类型指针。这样我们就可以通过这个普通指针来更新变量了：
x := 2 d := reflect.ValueOf(&amp;amp;x).Elem() // d refers to the variable x px := d.</description>
    </item>
    
    <item>
      <title>13.5. 几点忠告</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.5.-Another-Word-of-Caution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.5.-Another-Word-of-Caution/</guid>
      <description>13.5. 几点忠告 #  我们在前一章结尾的时候，我们警告要谨慎使用reflect包。那些警告同样适用于本章的unsafe包。
高级语言使得程序员不用再关心真正运行程序的指令细节，同时也不再需要关注许多如内存布局之类的实现细节。因为高级语言这个绝缘的抽象层，我们可以编写安全健壮的，并且可以运行在不同操作系统上的具有高度可移植性的程序。
但是unsafe包，它让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，虽然可能是为了获得更好的性能。但是代价就是牺牲了可移植性和程序安全，因此使用unsafe包是一个危险的行为。我们对何时以及如何使用unsafe包的建议和我们在11.5节提到的Knuth对过早优化的建议类似。大多数Go程序员可能永远不会需要直接使用unsafe包。当然，也永远都会有一些需要使用unsafe包实现会更简单的场景。如果确实认为使用unsafe包是最理想的方式，那么应该尽可能将它限制在较小的范围，这样其它代码就可以忽略unsafe的影响。
现在，赶紧将最后两章抛入脑后吧。编写一些实实在在的应用是真理。请远离reflect和unsafe包，除非你确实需要它们。
最后，用Go快乐地编程。我们希望你能像我们一样喜欢Go语言。</description>
    </item>
    
    <item>
      <title>2.5. 类型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.5.-Type-Declarations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.5.-Type-Declarations/</guid>
      <description>2.5. 类型 #  变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。
在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个float64类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。
一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。
type 类型名字 底层类型 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。
译注：对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。下面是RobPik在 Issue763 的回复：
 A solution that&amp;rsquo;s been kicking around for a while:
For Go 2 (can&amp;rsquo;t do it before then): Change the definition to “lower case letters and _ are package-local; all else is exported”. Then with non-cased languages, such as Japanese, we can write 日本语 for an exported name and _日本语 for a local name. This rule has no effect, relative to the Go 1 rule, with cased languages.</description>
    </item>
    
    <item>
      <title>3.5.5. 字符串和数字的转换</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.5-Conversions-between-Strings-and-Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.5-Conversions-between-Strings-and-Numbers/</guid>
      <description>3.5.5. 字符串和数字的转换 #  除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。
将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)：
x := 123 y := fmt.Sprintf(&amp;#34;%d&amp;#34;, x) fmt.Println(y, strconv.Itoa(x)) // &amp;#34;123 123&amp;#34; FormatInt和FormatUint函数可以用不同的进制来格式化数字：
fmt.Println(strconv.FormatInt(int64(x), 2)) // &amp;#34;1111011&amp;#34; fmt.Printf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含有附加额外信息的时候：
s := fmt.Sprintf(&amp;#34;x=%b&amp;#34;, x) // &amp;#34;x=1111011&amp;#34; 如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：
x, err := strconv.Atoi(&amp;#34;123&amp;#34;) // x is an int y, err := strconv.ParseInt(&amp;#34;123&amp;#34;, 10, 64) // base 10, up to 64 bits ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。
有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。</description>
    </item>
    
    <item>
      <title>4.5. JSON</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.5.-JSON/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.5.-JSON/</guid>
      <description>4.5. JSON #  JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。
Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持（译注：Protocol Buffers的支持由 github.com/golang/protobuf 包提供），并且这类包都有着相似的API接口。本节，我们将对重要的encoding/json包的用法做个概述。
JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它可以用有效可读的方式表示第三章的基础数据类型和本章的数组、slice、结构体和map等聚合数据类型。
基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是\Uhhhh转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。
这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：
boolean true number -273.15 string &amp;quot;She said \&amp;quot;Hello, BF\&amp;quot;&amp;quot; array [&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, &amp;quot;bronze&amp;quot;] object {&amp;quot;year&amp;quot;: 1980, &amp;quot;event&amp;quot;: &amp;quot;archery&amp;quot;, &amp;quot;medals&amp;quot;: [&amp;quot;gold&amp;quot;, &amp;quot;silver&amp;quot;, &amp;quot;bronze&amp;quot;]} 考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。）
gopl.io/ch4/movie
type Movie struct { Title string Year int `json:&amp;#34;released&amp;#34;` Color bool `json:&amp;#34;color,omitempty&amp;#34;` Actors []string } var movies = []Movie{ {Title: &amp;#34;Casablanca&amp;#34;, Year: 1942, Color: false, Actors: []string{&amp;#34;Humphrey Bogart&amp;#34;, &amp;#34;Ingrid Bergman&amp;#34;}}, {Title: &amp;#34;Cool Hand Luke&amp;#34;, Year: 1967, Color: true, Actors: []string{&amp;#34;Paul Newman&amp;#34;}}, {Title: &amp;#34;Bullitt&amp;#34;, Year: 1968, Color: true, Actors: []string{&amp;#34;Steve McQueen&amp;#34;, &amp;#34;Jacqueline Bisset&amp;#34;}}, // .</description>
    </item>
    
    <item>
      <title>5.5. 函数值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.5.-Function-Values/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.5.-Function-Values/</guid>
      <description>5.5. 函数值 #  在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。例子如下：
func square(n int) int { return n * n } func negative(n int) int { return -n } func product(m, n int) int { return m * n } f := square fmt.Println(f(3)) // &amp;#34;9&amp;#34;  f = negative fmt.Println(f(3)) // &amp;#34;-3&amp;#34; 	fmt.Printf(&amp;#34;%T\n&amp;#34;, f) // &amp;#34;func(int) int&amp;#34;  f = product // compile error: can&amp;#39;t assign func(int, int) int to func(int) int 函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</description>
    </item>
    
    <item>
      <title>6.5. 示例: Bit数组</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.5.-Example-Bit-Vector-Type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.5.-Example-Bit-Vector-Type/</guid>
      <description>6.5. 示例: Bit数组 #  Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。（译注：这里再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组。）
一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i。下面的这个程序展示了一个简单的bit数组类型，并且实现了三个函数来对这个bit数组来进行操作：
gopl.io/ch6/intset
// An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint64 } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/64, uint(x%64) return word &amp;lt; len(s.words) &amp;amp;&amp;amp; s.words[word]&amp;amp;(1&amp;lt;&amp;lt;bit) != 0 } // Add adds the non-negative value x to the set.</description>
    </item>
    
    <item>
      <title>8.5. 并发的循环</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.5.-Looping-in-Parallel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.5.-Looping-in-Parallel/</guid>
      <description>8.5. 并发的循环 #  本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io/ch8/thumbnail包提供了ImageFile函数来帮我们拉伸图片。我们不会说明这个函数的实现，只需要从gopl.io下载它。
gopl.io/ch8/thumbnail
package thumbnail // ImageFile reads an image from infile and writes // a thumbnail-size version of it in the same directory. // It returns the generated file name, e.g., &amp;#34;foo.thumb.jpg&amp;#34;. func ImageFile(infile string) (string, error) 下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：
gopl.io/ch8/thumbnail
// makeThumbnails makes thumbnails of the specified files. func makeThumbnails(filenames []string) { for _, f := range filenames { if _, err := thumbnail.ImageFile(f); err != nil { log.</description>
    </item>
    
    <item>
      <title>9.5. sync.Once惰性初始化</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.5.-Lazy-Initialization-sync.Once/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.5.-Lazy-Initialization-sync.Once/</guid>
      <description>9.5. sync.Once惰性初始化 #  如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。让我们来看在本章早一些时候的icons变量：
var icons map[string]image.Image 这个版本的Icon用到了懒初始化（lazy initialization）。
func loadIcons() { icons = map[string]image.Image{ &amp;#34;spades.png&amp;#34;: loadIcon(&amp;#34;spades.png&amp;#34;), &amp;#34;hearts.png&amp;#34;: loadIcon(&amp;#34;hearts.png&amp;#34;), &amp;#34;diamonds.png&amp;#34;: loadIcon(&amp;#34;diamonds.png&amp;#34;), &amp;#34;clubs.png&amp;#34;:	loadIcon(&amp;#34;clubs.png&amp;#34;), } } // NOTE: not concurrency-safe! func Icon(name string) image.Image { if icons == nil { loadIcons() // one-time initialization 	} return icons[name] } 如果一个变量只被一个单独的goroutine所访问的话，我们可以使用上面的这种模板，但这种模板在Icon被并发调用时并不安全。就像前面银行的那个Deposit(存款)函数一样，Icon函数也是由多个步骤组成的：首先测试icons是否为空，然后load这些icons，之后将icons更新为一个非空的值。直觉会告诉我们最差的情况是loadIcons函数被多次访问会带来数据竞争。当第一个goroutine在忙着loading这些icons的时候，另一个goroutine进入了Icon函数，发现变量是nil，然后也会调用loadIcons函数。
不过这种直觉是错误的。（我们希望你从现在开始能够构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的！），回忆一下9.4节。因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。其中一种可能loadIcons的语句重排是下面这样。它会在填写icons变量的值之前先用一个空map来初始化icons变量。
func loadIcons() { icons = make(map[string]image.Image) icons[&amp;#34;spades.png&amp;#34;] = loadIcon(&amp;#34;spades.png&amp;#34;) icons[&amp;#34;hearts.png&amp;#34;] = loadIcon(&amp;#34;hearts.png&amp;#34;) icons[&amp;#34;diamonds.png&amp;#34;] = loadIcon(&amp;#34;diamonds.png&amp;#34;) icons[&amp;#34;clubs.png&amp;#34;] = loadIcon(&amp;#34;clubs.png&amp;#34;) } 因此，一个goroutine在检查icons是非空时，也并不能就假设这个变量的初始化流程已经走完了（译注：可能只是塞了个空map，里面的值还没填完，也就是说填值的语句都没执行完呢）。</description>
    </item>
    
    <item>
      <title>致谢</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/Acknowledgments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/Preface/Acknowledgments/</guid>
      <description>致谢 #   Rob Pike和 Russ Cox，以及很多其他Go团队的核心成员多次仔细阅读了本书的手稿，他们对本书的组织结构和表述用词等给出了很多宝贵的建议。在准备日文版翻译的时候，Yoshiki Shibata更是仔细地审阅了本书的每个部分，及时发现了诸多英文和代码的错误。我们非常感谢本书的每一位审阅者，并感谢对本书给出了重要的建议的Brian Goetz、Corey Kosak、Arnold Robbins、Josh Bleecher Snyder和Peter Weinberger等人。
我们还感谢Sameer Ajmani、Ittai Balaban、David Crawshaw、Billy Donohue、Jonathan Feinberg、Andrew Gerrand、Robert Griesemer、John Linderman、Minux Ma（译注：中国人，Go团队成员。）、Bryan Mills、Bala Natarajan、Cosmos Nicolaou、Paul Staniforth、Nigel Tao（译注：好像是陶哲轩的兄弟）以及Howard Trickey给出的许多有价值的建议。我们还要感谢David Brailsford和Raph Levien关于类型设置的建议。
我们从来自Addison-Wesley的编辑Greg Doench收到了很多帮助，从最开始就得到了越来越多的帮助。来自AW生产团队的John Fuller、Dayna Isley、Julie Nahil、Chuti Prasertsith到Barbara Wood，感谢你们的热心帮助。
 Alan Donovan特别感谢：Sameer Ajmani、Chris Demetriou、Walt Drummond和Google公司的Reid Tatge允许他有充裕的时间去写本书；感谢Stephen Donovan的建议和始终如一的鼓励，以及他的妻子Leila Kazemi并没有让他为了家庭琐事而分心，并热情坚定地支持这个项目。
 Brian Kernighan特别感谢：朋友和同事对他的耐心和宽容，让他慢慢地梳理本书的写作思路。同时感谢他的妻子Meg和其他很多朋友对他写作事业的支持。
2015年 10月 于 纽约</description>
    </item>
    
    <item>
      <title>1.6. 并发获取多个URL</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.6.-Fetching-URLs-Concurrently/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.6.-Fetching-URLs-Concurrently/</guid>
      <description>1.6. 并发获取多个URL #  Go语言最有意思并且最新奇的特性就是对并发编程的支持。并发编程是一个大话题，在第八章和第九章中会专门讲到。这里我们只浅尝辄止地来体验一下Go语言里的goroutine和channel。
下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。
gopl.io/ch1/fetchall
// Fetchall fetches URLs in parallel and reports their times and sizes. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; ) func main() { start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] { go fetch(url, ch) // start a goroutine 	} for range os.Args[1:] { fmt.Println(&amp;lt;-ch) // receive from channel ch 	} fmt.Printf(&amp;#34;%.2fs elapsed\n&amp;#34;, time.</description>
    </item>
    
    <item>
      <title>10.6. 包和命名</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.6.-Packages-and-Naming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.6.-Packages-and-Naming/</guid>
      <description>10.6. 包和命名 #  在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。
当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。
尽可能让命名有描述性且无歧义。例如，类似imageutil或ioutilis的工具包命名已经足够简洁了，就无须再命名为util了。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的path包。
包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。
要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段时间使用了temperature作为包名，显然名字并没有表达包的真实用途。最后我们改成了和strconv标准包类似的tempconv包名，这个名字比之前的就好多了。
现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子：
bytes.Equal flag.Int http.Get json.Marshal 我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作：
package strings func Index(needle, haystack string) int type Replacer struct{ /* ... */ } func NewReplacer(oldnew ...string) *Replacer type Reader struct{ /* ... */ } func NewReader(s string) *Reader 包名strings并没有出现在任何成员名字中。因为用户会这样引用这些成员strings.Index、strings.Replacer等。
其它一些包，可能只描述了单一的数据类型，例如html/template和math/rand等，只暴露一个主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。
package rand // &amp;#34;math/rand&amp;#34;  type Rand struct{ /* ... */ } func New(source Source) *Rand 这可能导致一些名字重复，例如template.Template或rand.Rand，这就是这些种类的包名往往特别短的原因之一。
在另一个极端，还有像net/http包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。</description>
    </item>
    
    <item>
      <title>10.7.6. 查询包</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.6-Querying-Packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.6-Querying-Packages/</guid>
      <description>10.7.6. 查询包 #  go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径：
$ go list github.com/go-sql-driver/mysql github.com/go-sql-driver/mysql go list命令的参数还可以用&amp;quot;...&amp;quot;表示匹配任意的包的导入路径。我们可以用它来列出工作区中的所有包：
$ go list ... archive/tar archive/zip bufio bytes cmd/addr2line cmd/api ...many more... 或者是特定子目录下的所有包：
$ go list gopl.io/ch3/... gopl.io/ch3/basename1 gopl.io/ch3/basename2 gopl.io/ch3/comma gopl.io/ch3/mandelbrot gopl.io/ch3/netflag gopl.io/ch3/printints gopl.io/ch3/surface 或者是和某个主题相关的所有包:
$ go list ...xml... encoding/xml gopl.io/ch7/xmlselect go list命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中-json命令行参数表示用JSON格式打印每个包的元信息。
$ go list -json hash { &amp;quot;Dir&amp;quot;: &amp;quot;/home/gopher/go/src/hash&amp;quot;, &amp;quot;ImportPath&amp;quot;: &amp;quot;hash&amp;quot;, &amp;quot;Name&amp;quot;: &amp;quot;hash&amp;quot;, &amp;quot;Doc&amp;quot;: &amp;quot;Package hash provides interfaces for hash functions.&amp;quot;, &amp;quot;Target&amp;quot;: &amp;quot;/home/gopher/go/pkg/darwin_amd64/hash.a&amp;quot;, &amp;quot;Goroot&amp;quot;: true, &amp;quot;Standard&amp;quot;: true, &amp;quot;Root&amp;quot;: &amp;quot;/home/gopher/go&amp;quot;, &amp;quot;GoFiles&amp;quot;: [ &amp;quot;hash.</description>
    </item>
    
    <item>
      <title>11.2.6. 避免脆弱的测试</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.6-Avoiding-Brittle-Tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.6-Avoiding-Brittle-Tests/</guid>
      <description>11.2.6. 避免脆弱的测试 #  如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就失败则称为脆弱。就像一个不够稳健的程序会挫败它的用户一样，一个脆弱的测试同样会激怒它的维护者。最脆弱的测试代码会在程序没有任何变化的时候产生不同的结果，时好时坏，处理它们会耗费大量的时间但是并不会得到任何好处。
当一个测试函数会产生一个复杂的输出如一个很长的字符串、一个精心设计的数据结构或一个文件时，人们很容易想预先写下一系列固定的用于对比的标杆数据。但是随着项目的发展，有些输出可能会发生变化，尽管很可能是一个改进的实现导致的。而且不仅仅是输出部分，函数复杂的输入部分可能也跟着变化了，因此测试使用的输入也就不再有效了。
避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。</description>
    </item>
    
    <item>
      <title>11.6. 示例函数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.6.-Example-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/11.-Testing/11.6.-Example-Functions/</guid>
      <description>11.6. 示例函数 #  第三种被go test特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是IsPalindrome函数对应的示例函数：
func ExampleIsPalindrome() { fmt.Println(IsPalindrome(&amp;#34;A man, a plan, a canal: Panama&amp;#34;)) fmt.Println(IsPalindrome(&amp;#34;palindrome&amp;#34;)) // Output: 	// true 	// false } 示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。
根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。
示例函数的第二个用处是，在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的// Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。
示例函数的第三个目的提供一个真实的演练场。 http://golang.org 就是由godoc提供的文档服务，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式。
 本书最后的两章是讨论reflect和unsafe包，一般的Go程序员很少使用它们，事实上也很少需要用到。因此，如果你还没有写过任何真实的Go程序的话，现在可以先去写些代码了。</description>
    </item>
    
    <item>
      <title>12.6. 示例: 解码S表达式</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.6.-Example-Decoding-S-Expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.6.-Example-Decoding-S-Expressions/</guid>
      <description>12.6. 示例: 解码S表达式 #  标准库中encoding/&amp;hellip;下每个包中提供的Marshal编码函数都有一个对应的Unmarshal函数用于解码。例如，我们在4.5节中看到的，要将包含JSON编码格式的字节slice数据解码为我们自己的Movie类型（§12.3），我们可以这样做：
data := []byte{/* ... */} var movie Movie err := json.Unmarshal(data, &amp;amp;movie) Unmarshal函数使用了反射机制类修改movie变量的每个成员，根据输入的内容为Movie成员创建对应的map、结构体和slice。
现在让我们为S表达式编码实现一个简易的Unmarshal，类似于前面的json.Unmarshal标准库函数，对应我们之前实现的sexpr.Marshal函数的逆操作。我们必须提醒一下，一个健壮的和通用的实现通常需要比例子更多的代码，为了便于演示我们采用了精简的实现。我们只支持S表达式有限的子集，同时处理错误的方式也比较粗暴，代码的目的是为了演示反射的用法，而不是构造一个实用的S表达式的解码器。
词法分析器lexer使用了标准库中的text/scanner包将输入流的字节数据解析为一个个类似注释、标识符、字符串面值和数字面值之类的标记。输入扫描器scanner的Scan方法将提前扫描和返回下一个记号，对于rune类型。大多数记号，比如“(”，对应一个单一rune可表示的Unicode字符，但是text/scanner也可以用小的负数表示记号标识符、字符串等由多个字符组成的记号。调用Scan方法将返回这些记号的类型，接着调用TokenText方法将返回记号对应的文本内容。
因为每个解析器可能需要多次使用当前的记号，但是Scan会一直向前扫描，所以我们包装了一个lexer扫描器辅助类型，用于跟踪最近由Scan方法返回的记号。
gopl.io/ch12/sexpr
type lexer struct { scan scanner.Scanner token rune // the current token } func (lex *lexer) next() { lex.token = lex.scan.Scan() } func (lex *lexer) text() string { return lex.scan.TokenText() } func (lex *lexer) consume(want rune) { if lex.token != want { // NOTE: Not an example of good error handling.</description>
    </item>
    
    <item>
      <title>4.6. 文本和HTML模板</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.6.-Text-and-HTML-Templates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/4.-Composite-Types/4.6.-Text-and-HTML-Templates/</guid>
      <description>4.6. 文本和HTML模板 #  前面的例子，只是最简单的格式化，使用Printf是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由text/template和html/template等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。
一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的{{action}}对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：
{% raw %}
gopl.io/ch4/issuesreport
const templ = `{{.TotalCount}}issues: {{range .Items}}---------------------------------------- Number: {{.Number}}User: {{.User.Login}}Title: {{.Title | printf &amp;#34;%.64s&amp;#34;}}Age: {{.CreatedAt | daysAgo}}days {{end}}` {% endraw %}
{% raw %}
这个模板先打印匹配到的issue总数，然后打印每个issue的编号、创建用户、标题还有存在的时间。对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。当前值“.”最初被初始化为调用模板时的参数，在当前例子中对应github.IssuesSearchResult类型的变量。模板中{{.TotalCount}}对应action将展开为结构体中TotalCount成员以默认的方式打印的值。模板中{{range .Items}}和{{end}}对应一个循环action，因此它们之间的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。
{% endraw %}
在一个action中，|操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。对于Age部分，第二个动作是一个叫daysAgo的函数，通过time.Since函数将CreatedAt成员转换为过去的时间长度：
func daysAgo(t time.Time) int { return int(time.Since(t).Hours() / 24) } 需要注意的是CreatedAt的参数类型是time.Time，并不是字符串。以同样的方式，我们可以通过定义一些方法来控制字符串的格式化（§2.5），一个类型同样可以定制自己的JSON编码和解码行为。time.Time类型对应的JSON值是一个标准时间格式的字符串。
生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。下面的代码创建并分析上面定义的模板templ。注意方法调用链的顺序：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。
report, err := template.New(&amp;#34;report&amp;#34;). Funcs(template.FuncMap{&amp;#34;daysAgo&amp;#34;: daysAgo}). Parse(templ) if err != nil { log.Fatal(err) } 因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。template.Must辅助函数可以简化这个致命错误的处理：它接受一个模板和一个error类型的参数，检测error是否为nil（如果不是nil则发出panic异常），然后返回传入的模板。我们将在5.9节再讨论这个话题。
一旦模板已经创建、注册了daysAgo函数、并通过分析和检测，我们就可以使用github.IssuesSearchResult作为输入源、os.Stdout作为输出源来执行模板：
var report = template.</description>
    </item>
    
    <item>
      <title>6.6. 封装</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.6.-Encapsulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/6.-Methods/6.6.-Encapsulation/</guid>
      <description>6.6. 封装 #  一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。
Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。
这也就是前面的小节中IntSet被定义为struct类型的原因，尽管它只有一个字段：
type IntSet struct { words []uint64 } 当然，我们也可以把IntSet定义为一个slice类型，但这样我们就需要把代码中所有方法里用到的s.words用*s替换掉了：
type IntSet []uint64 尽管这个版本的IntSet在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个slice。换句话说，相对于*s这个表达式会出现在所有的包中，s.words只需要在定义IntSet的包中出现（译注：所以还是推荐后者吧的意思）。
这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。
封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。
第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。
把bytes.Buffer这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为Buffer是一个struct类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer和其增长算法我们列在这里，为了简洁性稍微做了一些精简：
type Buffer struct { buf []byte initial [64]byte /* ... */ } // Grow expands the buffer&amp;#39;s capacity, if necessary, // to guarantee space for another n bytes. [...] func (b *Buffer) Grow(n int) { if b.buf == nil { b.buf = b.initial[:0] // use preallocated space initially  } if len(b.</description>
    </item>
    
    <item>
      <title>7.6. sort.Interface接口</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.6.-Sorting-with-sort.Interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.6.-Sorting-with-sort.Interface/</guid>
      <description>7.6. sort.Interface接口 #  排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要15行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。
幸运的是，sort包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。相比之下，Go语言的sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。
一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是sort.Interface的三个方法：
package sort type Interface interface { Len() int Less(i, j int) bool // i, j are indices of sequence elements 	Swap(i, j int) } 为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型StringSlice和它的Len，Less和Swap方法
type StringSlice []string func (p StringSlice) Len() int { return len(p) } func (p StringSlice) Less(i, j int) bool { return p[i] &amp;lt; p[j] } func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } 现在我们可以通过像下面这样将一个切片转换为一个StringSlice类型来进行排序：</description>
    </item>
    
    <item>
      <title>8.6. 示例: 并发的Web爬虫</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.6.-Example-Concurrent-Web-Crawler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.6.-Example-Concurrent-Web-Crawler/</guid>
      <description>8.6. 示例: 并发的Web爬虫 #  在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。
gopl.io/ch8/crawl1
func crawl(url string) []string { fmt.Println(url) list, err := links.Extract(url) if err != nil { log.Print(err) } return list } 主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。
func main() { worklist := make(chan []string) // Start with the command-line arguments. 	go func() { worklist &amp;lt;- os.Args[1:] }() // Crawl the web concurrently. 	seen := make(map[string]bool) for list := range worklist { for _, link := range list { if !</description>
    </item>
    
    <item>
      <title>9.6. 竞争条件检测</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.6.-The-Race-Detector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.6.-The-Race-Detector/</guid>
      <description>9.6. 竞争条件检测 #  即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器（the race detector）。
只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。（完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：https://golang.org/ref/mem ）
竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。
竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。
由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的程序（工作）来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。（译注：多少服务端C和C++程序员为此竞折腰。）</description>
    </item>
    
    <item>
      <title>1.7. Web服务</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.7.-A-Web-Server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.7.-A-Web-Server/</guid>
      <description>1.7. Web服务 #  Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 http://localhost:8000/hello ，那么响应是URL.Path = &amp;ldquo;hello&amp;rdquo;。
gopl.io/ch1/server1
// Server1 is a minimal &amp;#34;echo&amp;#34; server. package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/&amp;#34;, handler) // each request calls handler 	log.Fatal(http.ListenAndServe(&amp;#34;localhost:8000&amp;#34;, nil)) } // handler echoes the Path component of the request URL r. func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;URL.Path = %q\n&amp;#34;, r.URL.Path) } 我们只用了八九行代码就实现了一个Web服务程序，这都是多亏了标准库里的方法已经帮我们完成了大量工作。main函数将所有发送到/路径下的请求和handler函数关联起来，/开头的请求其实就是所有发送到当前站点上的请求，服务监听8000端口。发送到这个服务的“请求”是一个http.Request类型的对象，这个对象中包含了请求中的一系列相关字段，其中就包括我们需要的URL。当请求到达服务器时，这个请求会被传给handler函数来处理，这个函数会将/hello这个路径从请求的URL中解析出来，然后把其发送到响应中，这里我们用的是标准输出流的fmt.Fprintf。Web服务会在第7.7节中做更详细的阐述。
让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&amp;amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。
$ go run src/gopl.io/ch1/server1/main.go &amp;amp; 现在可以通过命令行来发送客户端请求了：</description>
    </item>
    
    <item>
      <title>12.7. 获取结构体字段标签</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.7.-Accessing-Struct-Field-Tags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.7.-Accessing-Struct-Field-Tags/</guid>
      <description>12.7. 获取结构体字段标签 #  在4.5节我们使用构体成员标签用于设置对应JSON对应的名字。其中json成员标签让我们可以选择成员的名字和抑制零值成员的输出。在本节，我们将看到如何通过反射机制类获取成员标签。
对于一个web服务，大部分HTTP处理函数要做的第一件事情就是展开请求中的参数到本地变量中。我们定义了一个工具函数，叫params.Unpack，通过使用结构体成员标签机制来让HTTP处理函数解析请求参数更方便。
首先，我们看看如何使用它。下面的search函数是一个HTTP请求处理函数。它定义了一个匿名结构体类型的变量，用结构体的每个成员表示HTTP请求的参数。其中结构体成员标签指明了对于请求参数的名字，为了减少URL的长度这些参数名通常都是神秘的缩略词。Unpack将请求参数填充到合适的结构体成员中，这样我们可以方便地通过合适的类型类来访问这些参数。
gopl.io/ch12/search
import &amp;#34;gopl.io/ch12/params&amp;#34; // search implements the /search URL endpoint. func search(resp http.ResponseWriter, req *http.Request) { var data struct { Labels []string `http:&amp;#34;l&amp;#34;` MaxResults int `http:&amp;#34;max&amp;#34;` Exact bool `http:&amp;#34;x&amp;#34;` } data.MaxResults = 10 // set default 	if err := params.Unpack(req, &amp;amp;data); err != nil { http.Error(resp, err.Error(), http.StatusBadRequest) // 400 	return } // ...rest of handler... 	fmt.Fprintf(resp, &amp;#34;Search: %+v\n&amp;#34;, data) } 下面的Unpack函数主要完成三件事情。第一，它调用req.</description>
    </item>
    
    <item>
      <title>2.7. 作用域</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.7.-Scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/2.-Program-Structure/2.7.-Scope/</guid>
      <description>2.7. 作用域 #  一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。
不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。
句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。
声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。
控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。
一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。
当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：
func f() {} var g = &amp;#34;g&amp;#34; func main() { f := &amp;#34;f&amp;#34; fmt.Println(f) // &amp;#34;f&amp;#34;; local var f shadows package-level func f 	fmt.Println(g) // &amp;#34;g&amp;#34;; package-level var 	fmt.Println(h) // compile error: undefined: h } 在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。
func main() { x := &amp;#34;hello!&amp;#34; for i := 0; i &amp;lt; len(x); i++ { x := x[i] if x != &amp;#39;!</description>
    </item>
    
    <item>
      <title>5.7. 可变参数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.7.-Variadic-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.7.-Variadic-Functions/</guid>
      <description>5.7. 可变参数 #  参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。
在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“&amp;hellip;”，这表示该函数会接收任意数量的该类型参数。
gopl.io/ch5/sum
func sum(vals ...int) int { total := 0 for _, val := range vals { total += val } return total } sum函数返回任意个int型参数的和。在函数体中，vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数：
fmt.Println(sum()) // &amp;#34;0&amp;#34; fmt.Println(sum(3)) // &amp;#34;3&amp;#34; fmt.Println(sum(1, 2, 3, 4)) // &amp;#34;10&amp;#34; 在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。
values := []int{1, 2, 3, 4} fmt.Println(sum(values...)) // &amp;#34;10&amp;#34; 虽然在可变参数函数内部，&amp;hellip;int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。
func f(...int) {} func g([]int) {} fmt.Printf(&amp;#34;%T\n&amp;#34;, f) // &amp;#34;func(...int)&amp;#34; fmt.Printf(&amp;#34;%T\n&amp;#34;, g) // &amp;#34;func([]int)&amp;#34; 可变参数函数经常被用于格式化字符串。下面的errorf函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。</description>
    </item>
    
    <item>
      <title>7.7. http.Handler接口</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.7.-The-http.Handler-Interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.7.-The-http.Handler-Interface/</guid>
      <description>7.7. http.Handler接口 #  在第一章中，我们粗略的了解了怎么用net/http包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于http.Handler接口的服务器API做更进一步的学习：
net/http
package http type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } func ListenAndServe(address string, h Handler) error ListenAndServe函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。
想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个ServeHttp方法，这样它可以满足http.Handler接口。这个handler会遍历整个map并输出物品信息。
gopl.io/ch7/http1
func main() { db := database{&amp;#34;shoes&amp;#34;: 50, &amp;#34;socks&amp;#34;: 5} log.Fatal(http.ListenAndServe(&amp;#34;localhost:8000&amp;#34;, db)) } type dollars float32 func (d dollars) String() string { return fmt.Sprintf(&amp;#34;$%.2f&amp;#34;, d) } type database map[string]dollars func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) { for item, price := range db { fmt.Fprintf(w, &amp;#34;%s: %s\n&amp;#34;, item, price) } } 如果我们启动这个服务，</description>
    </item>
    
    <item>
      <title>8.7. 基于select的多路复用</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.7.-Multiplexing-with-select/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.7.-Multiplexing-with-select/</guid>
      <description>8.7. 基于select的多路复用 #  下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。
gopl.io/ch8/countdown1
func main() { fmt.Println(&amp;#34;Commencing countdown.&amp;#34;) tick := time.Tick(1 * time.Second) for countdown := 10; countdown &amp;gt; 0; countdown-- { fmt.Println(countdown) &amp;lt;-tick } launch() } 现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。
gopl.io/ch8/countdown2
abort := make(chan struct{}) go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte 	abort &amp;lt;- struct{}{} }() 现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：当一切正常时的ticker channel（就像NASA jorgon的&amp;quot;nominal&amp;rdquo;，译注：这梗估计我们是不懂了）或者异常时返回的abort事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用（multiplex）这些操作了，为了能够多路复用，我们使用了select语句。
select { case &amp;lt;-ch1: // ... case x := &amp;lt;-ch2: // ...use x... case ch3 &amp;lt;- y: // .</description>
    </item>
    
    <item>
      <title>9.7. 示例: 并发的非阻塞缓存</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.7.-Example-Concurrent-Non-Blocking-Cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.7.-Example-Concurrent-Non-Blocking-Cache/</guid>
      <description>9.7. 示例: 并发的非阻塞缓存 #  本节中我们会做一个无阻塞的缓存，这种工具可以帮助我们来解决现实世界中并发程序出现但没有现成的库可以解决的问题。这个问题叫作缓存（memoizing）函数（译注：Memoization的定义： memoization 一词是Donald Michie 根据拉丁语memorandum杜撰的一个词。相应的动词、过去分词、ing形式有memoiz、memoized、memoizing），也就是说，我们需要缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。我们的解决方案会是并发安全且会避免对整个缓存加锁而导致所有操作都去争一个锁的设计。
我们将使用下面的httpGetBody函数作为我们需要缓存的函数的一个样例。这个函数会去进行HTTP GET请求并且获取http响应body。对这个函数的调用本身开销是比较大的，所以我们尽量避免在不必要的时候反复调用。
func httpGetBody(url string) (interface{}, error) { resp, err := http.Get(url) if err != nil { return nil, err } defer resp.Body.Close() return ioutil.ReadAll(resp.Body) } 最后一行稍微隐藏了一些细节。ReadAll会返回两个结果，一个[]byte数组和一个错误，不过这两个对象可以被赋值给httpGetBody的返回声明里的interface{}和error类型，所以我们也就可以这样返回结果并且不需要额外的工作了。我们在httpGetBody中选用这种返回类型是为了使其可以与缓存匹配。
下面是我们要设计的cache的第一个“草稿”：
gopl.io/ch9/memo1
// Package memo provides a concurrency-unsafe // memoization of a function of type Func. package memo // A Memo caches the results of calling a Func. type Memo struct { f Func cache map[string]result } // Func is the type of the function to memoize.</description>
    </item>
    
    <item>
      <title>1.8. 本章要点</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.8.-Loose-Ends/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/1.-Tutorial/1.8.-Loose-Ends/</guid>
      <description>1.8. 本章要点 #  本章对Go语言做了一些介绍，Go语言很多方面在有限的篇幅中无法覆盖到。本节会把没有讲到的内容也做一些简单的介绍，这样读者在读到完整的内容之前，可以有个简单的印象。
控制流： 在本章我们只介绍了if控制和for，但是没有提到switch多路选择。这里是一个简单的switch的例子：
switch coinflip() { case &amp;#34;heads&amp;#34;: heads++ case &amp;#34;tails&amp;#34;: tails++ default: fmt.Println(&amp;#34;landed on edge!&amp;#34;) } 在翻转硬币的时候，例子里的coinflip函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。
Go语言里的switch还可以不带操作对象（译注：switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较）；可以直接罗列多种条件，像其它语言里面的多个if else一样，下面是一个例子：
func Signum(x int) int { switch { case x &amp;gt; 0: return +1 default: return 0 case x &amp;lt; 0: return -1 } } 这种形式叫做无tag switch(tagless switch)；这和switch true是等价的。
像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用（译注：比其它语言丰富）。
break和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句（之后会讲到），在1.3节中我们看到，continue会跳过内层的循环，如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。
命名类型： 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：
type Point struct { X, Y int } var p Point 类型声明和命名类型会在第二章中介绍。
指针： Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，&amp;amp;操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。我们会在2.3.2中进行详细介绍。</description>
    </item>
    
    <item>
      <title>12.8. 显示一个类型的方法集</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.8.-Displaying-the-Methods-of-a-Type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.8.-Displaying-the-Methods-of-a-Type/</guid>
      <description>12.8. 显示一个类型的方法集 #  我们的最后一个例子是使用reflect.Type来打印任意值的类型和枚举它的方法：
gopl.io/ch12/methods
// Print prints the method set of the value x. func Print(x interface{}) { v := reflect.ValueOf(x) t := v.Type() fmt.Printf(&amp;#34;type %s\n&amp;#34;, t) for i := 0; i &amp;lt; v.NumMethod(); i++ { methType := v.Method(i).Type() fmt.Printf(&amp;#34;func (%s) %s%s\n&amp;#34;, t, t.Method(i).Name, strings.TrimPrefix(methType.String(), &amp;#34;func&amp;#34;)) } } reflect.Type和reflect.Value都提供了一个Method方法。每次t.Method(i)调用将一个reflect.Method的实例，对应一个用于描述一个方法的名称和类型的结构体。每次v.Method(i)方法调用都返回一个reflect.Value以表示对应的值（§6.4），也就是一个方法是帮到它的接收者的。使用reflect.Value.Call方法（我们这里没有演示），将可以调用一个Func类型的Value，但是这个例子中只用到了它的类型。
这是属于time.Duration和*strings.Replacer两个类型的方法：
methods.Print(time.Hour) // Output: // type time.Duration // func (time.Duration) Hours() float64 // func (time.Duration) Minutes() float64 // func (time.</description>
    </item>
    
    <item>
      <title>5.8. Deferred函数</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.8.-Deferred-Function-Calls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.8.-Deferred-Function-Calls/</guid>
      <description>5.8. Deferred函数 #  在findLinks的例子中，我们用http.Get的输出作为html.Parse的输入。只有url的内容的确是HTML格式的，html.Parse才可以正常工作，但实际上，url指向的内容很丰富，可能是图片，纯文本或是其他。将这些格式的内容传递给html.parse，会产生不良后果。
下面的例子获取HTML页面并输出页面的标题。title函数会检查服务器返回的Content-Type字段，如果发现页面不是HTML，将终止函数运行，返回错误。
gopl.io/ch5/title1
func title(url string) error { resp, err := http.Get(url) if err != nil { return err } // Check Content-Type is HTML (e.g., &amp;#34;text/html;charset=utf-8&amp;#34;). 	ct := resp.Header.Get(&amp;#34;Content-Type&amp;#34;) if ct != &amp;#34;text/html&amp;#34; &amp;amp;&amp;amp; !strings.HasPrefix(ct,&amp;#34;text/html;&amp;#34;) { resp.Body.Close() return fmt.Errorf(&amp;#34;%s has type %s, not text/html&amp;#34;,url, ct) } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return fmt.Errorf(&amp;#34;parsing %s as HTML: %v&amp;#34;, url,err) } visitNode := func(n *html.</description>
    </item>
    
    <item>
      <title>7.8. error接口</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.8.-The-error-Interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.8.-The-error-Interface/</guid>
      <description>7.8. error接口 #  从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：
type error interface { Error() string } 创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。整个errors包仅只有4行：
package errors func New(text string) error { return &amp;amp;errorString{text} } type errorString struct { text string } func (e *errorString) Error() string { return e.text } 承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。并且因为是指针类型*errorString满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。
fmt.Println(errors.New(&amp;#34;EOF&amp;#34;) == errors.New(&amp;#34;EOF&amp;#34;)) // &amp;#34;false&amp;#34; 调用errors.New函数是非常稀少的，因为有一个方便的封装函数fmt.Errorf，它还会处理字符串格式化。我们曾多次在第5章中用到它。
package fmt import &amp;#34;errors&amp;#34; func Errorf(format string, args ...interface{}) error { return errors.New(Sprintf(format, args...)) } 虽然*errorString可能是最简单的错误类型，但远非只有它一个。例如，syscall包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：
package syscall type Errno uintptr // operating system error code  var errors = [.</description>
    </item>
    
    <item>
      <title>8.8. 示例: 并发的目录遍历</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.8.-Example-Concurrent-Directory-Traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.8.-Example-Concurrent-Directory-Traversal/</guid>
      <description>8.8. 示例: 并发的目录遍历 #  在本小节中，我们会创建一个程序来生成指定目录的硬盘使用情况报告，这个程序和Unix里的du工具比较相似。大多数工作用下面这个walkDir函数来完成，这个函数使用dirents函数来枚举一个目录下的所有入口。
gopl.io/ch8/du1
// walkDir recursively walks the file tree rooted at dir // and sends the size of each found file on fileSizes. func walkDir(dir string, fileSizes chan&amp;lt;- int64) { for _, entry := range dirents(dir) { if entry.IsDir() { subdir := filepath.Join(dir, entry.Name()) walkDir(subdir, fileSizes) } else { fileSizes &amp;lt;- entry.Size() } } } // dirents returns the entries of directory dir. func dirents(dir string) []os.</description>
    </item>
    
    <item>
      <title>12.9. 几点忠告</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.9.-A-Word-of-Caution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/12.-Reflection/12.9.-A-Word-of-Caution/</guid>
      <description>12.9. 几点忠告 #  虽然反射提供的API远多于我们讲到的，我们前面的例子主要是给出了一个方向，通过反射可以实现哪些功能。反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三。
第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。
以前面的readList函数（§12.6）为例，为了从输入读取字符串并填充int类型的变量而调用的reflect.Value.SetString方法可能导致panic异常。绝大多数使用反射的程序都有类似的风险，需要非常小心地检查每个reflect.Value的对应值的类型、是否可取地址，还有是否可以被修改等。
避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码为例，当fmt.Printf收到一个非法的操作数时，它并不会抛出panic异常，而是打印相关的错误信息。程序虽然还有BUG，但是会更加容易诊断。
fmt.Printf(&amp;#34;%d %s\n&amp;#34;, &amp;#34;hello&amp;#34;, 42) // &amp;#34;%!d(string=hello) %!s(int=42)&amp;#34; 反射同样降低了程序的安全性，还影响了自动化重构和分析工具的准确性，因为它们无法识别运行时才能确认的类型信息。
避免使用反射的第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受interface{}或reflect.Value类型参数的函数维护说明文档。
第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。</description>
    </item>
    
    <item>
      <title>5.9. Panic异常</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.9.-Panic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.9.-Panic/</guid>
      <description>5.9. Panic异常 #  Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。
一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。
不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：
switch s := suit(drawCard()); s { case &amp;#34;Spades&amp;#34;: // ... case &amp;#34;Hearts&amp;#34;: // ... case &amp;#34;Diamonds&amp;#34;: // ... case &amp;#34;Clubs&amp;#34;: // ... default: panic(fmt.Sprintf(&amp;#34;invalid suit %q&amp;#34;, s)) // Joker? } 断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码。
func Reset(x *Buffer) { if x == nil { panic(&amp;#34;x is nil&amp;#34;) // unnecessary! 	} x.elements = nil } 虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。
考虑regexp.Compile函数，该函数将正则表达式编译成有效的可匹配格式。当输入的正则表达式不合法时，该函数会返回一个错误。当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，就如前面的断言一样：当调用者输入了不应该出现的输入时，触发panic异常。
在程序源码中，大多数正则表达式是字符串字面值（string literals），因此regexp包提供了包装函数regexp.MustCompile检查输入的合法性。
package regexp func Compile(expr string) (*Regexp, error) { /* .</description>
    </item>
    
    <item>
      <title>7.9. 示例: 表达式求值</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.9.-Example-Expression-Evaluator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.9.-Example-Expression-Evaluator/</guid>
      <description>7.9. 示例: 表达式求值 #  在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口Expr来表示Go语言中任意的表达式。现在这个接口不需要有方法，但是我们后面会为它增加一些。
// An Expr is an arithmetic expression. type Expr interface{} 我们的表达式语言由浮点数符号（小数点）；二元操作符+，-，*， 和/；一元操作符-x和+x；调用pow(x,y)，sin(x)，和sqrt(x)的函数；例如x和pi的变量；当然也有括号和标准的优先级运算符。所有的值都是float64类型。这下面是一些表达式的例子：
sqrt(A / pi) pow(x, 3) + pow(y, 3) (F - 32) * 5 / 9 下面的五个具体类型表示了具体的表达式类型。Var类型表示对一个变量的引用。（我们很快会知道为什么它可以被输出。）literal类型表示一个浮点型常量。unary和binary类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。call类型表示对一个函数的调用；我们限制它的fn字段只能是pow，sin或者sqrt。
gopl.io/ch7/eval
// A Var identifies a variable, e.g., x. type Var string // A literal is a numeric constant, e.g., 3.141. type literal float64 // A unary represents a unary operator expression, e.g., -x. type unary struct { op rune // one of &amp;#39;+&amp;#39;, &amp;#39;-&amp;#39; 	x Expr } // A binary represents a binary operator expression, e.</description>
    </item>
    
    <item>
      <title>8.9. 并发的退出</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.9.-Cancellation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.9.-Cancellation/</guid>
      <description>8.9. 并发的退出 #  有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。
Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？
一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。
回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。
只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，不需要向这个channel发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。
gopl.io/ch8/du4
var done = make(chan struct{}) func cancelled() bool { select { case &amp;lt;-done: return true default: return false } } 下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到（比如用户按了回车键），这个goroutine就会把取消消息通过关闭done的channel广播出去。
// Cancel traversal when input is detected. go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte 	close(done) }() 现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候即会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。
for { select { case &amp;lt;-done: // Drain fileSizes to allow existing goroutines to finish.</description>
    </item>
    
    <item>
      <title>5.10. Recover捕获异常</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.10.-Recover/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/5.-Functions/5.10.-Recover/</guid>
      <description>5.10. Recover捕获异常 #  通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。
如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。
让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。
func Parse(input string) (s *Syntax, err error) { defer func() { if p := recover(); p != nil { err = fmt.Errorf(&amp;#34;internal error: %v&amp;#34;, p) } }() // ...parser... } deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。
不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。
虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。
有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。
基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。
下面的例子是title函数的变形，如果HTML页面包含多个&amp;lt;title&amp;gt;，该函数会给调用者返回一个错误（error）。在soleTitle内部处理时，如果检测到有多个&amp;lt;title&amp;gt;，会调用panic，阻止函数继续递归，并将特殊类型bailout作为panic的参数。
// soleTitle returns the text of the first non-empty title element // in doc, and an error if there was not exactly one.</description>
    </item>
    
    <item>
      <title>7.10. 类型断言</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.10.-Type-Assertions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.10.-Type-Assertions/</guid>
      <description>7.10. 类型断言 #  类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。
这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：
var w io.Writer w = os.Stdout f := w.(*os.File) // success: f == os.Stdout c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer 第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。
在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型*os.File，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。
var w io.Writer w = os.Stdout rw := w.(io.ReadWriter) // success: *os.File has both Read and Write w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method 如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。
w = rw // io.ReadWriter is assignable to io.</description>
    </item>
    
    <item>
      <title>8.10. 示例: 聊天服务</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.10.-Example-Chat-Server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.10.-Example-Chat-Server/</guid>
      <description>8.10. 示例: 聊天服务 #  我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goroutine。main和broadcaster各自是一个goroutine实例，每一个客户端的连接都会有一个handleConn和clientWriter的goroutine。broadcaster是select用法的不错的样例，因为它需要处理三种不同类型的消息。
下面演示的main goroutine的工作，是listen和accept(译注：网络编程里的概念)从客户端过来的连接。对每一个连接，程序都会建立一个新的handleConn的goroutine，就像我们在本章开头的并发的echo服务器里所做的那样。
gopl.io/ch8/chat
func main() { listener, err := net.Listen(&amp;#34;tcp&amp;#34;, &amp;#34;localhost:8000&amp;#34;) if err != nil { log.Fatal(err) } go broadcaster() for { conn, err := listener.Accept() if err != nil { log.Print(err) continue } go handleConn(conn) } } 然后是broadcaster的goroutine。他的内部变量clients会记录当前建立连接的客户端集合。其记录的内容是每一个客户端的消息发出channel的“资格”信息。
type client chan&amp;lt;- string // an outgoing message channel  var ( entering = make(chan client) leaving = make(chan client) messages = make(chan string) // all incoming client messages ) func broadcaster() { clients := make(map[client]bool) // all connected clients 	for { select { case msg := &amp;lt;-messages: // Broadcast incoming message to all 	// clients&amp;#39; outgoing message channels.</description>
    </item>
    
    <item>
      <title>7.11. 基于类型断言区别错误类型</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.11.-Discriminating-Errors-with-Type-Assertions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.11.-Discriminating-Errors-with-Type-Assertions/</guid>
      <description>7.11. 基于类型断言区别错误类型 #  思考在os包中文件操作返回的错误集合。I/O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。os包中提供了三个帮助函数来对给定的错误值表示的失败进行分类：
package os func IsExist(err error) bool func IsNotExist(err error) bool func IsPermission(err error) bool 对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，
func IsNotExist(err error) bool { // NOTE: not robust! 	return strings.Contains(err.Error(), &amp;#34;file does not exist&amp;#34;) } 但是处理I/O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。
一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：
package os // PathError records an error and the operation and file path that caused it. type PathError struct { Op string Path string Err error } func (e *PathError) Error() string { return e.</description>
    </item>
    
    <item>
      <title>7.12. 通过类型断言询问行为</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.12.-Querying-Behaviors-with-Interface-Type-Assertions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.12.-Querying-Behaviors-with-Interface-Type-Assertions/</guid>
      <description>7.12. 通过类型断言询问行为 #  下面这段逻辑和net/http包中web服务器负责写入HTTP头字段（例如：&amp;ldquo;Content-type:text/html&amp;rdquo;）的部分相似。io.Writer接口类型的变量w代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。
func writeHeader(w io.Writer, contentType string) error { if _, err := w.Write([]byte(&amp;#34;Content-Type: &amp;#34;)); err != nil { return err } if _, err := w.Write([]byte(contentType)); err != nil { return err } // ... } 因为Write方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用[]byte(&amp;hellip;)进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？
这个io.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。如果我们回顾net/http包中的内幕，我们知道在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法；这个方法会避免去分配一个临时的拷贝。（这可能像在黑夜中射击一样，但是许多满足io.Writer接口的重要类型同时也有WriteString方法，包括*bytes.Buffer，*os.File和*bufio.Writer。）
我们不能对任意io.Writer类型的变量w，假设它也拥有WriteString方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否w的动态类型满足这个新接口。
// writeString writes s to w. // If w has a WriteString method, it is invoked instead of w.Write. func writeString(w io.Writer, s string) (n int, err error) { type stringWriter interface { WriteString(string) (n int, err error) } if sw, ok := w.</description>
    </item>
    
    <item>
      <title>7.13. 类型分支</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.13.-Type-Switches/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.13.-Type-Switches/</guid>
      <description>7.13. 类型分支 #  接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。
第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。
如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。
和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：
import &amp;#34;database/sql&amp;#34; func listTracks(db sql.DB, artist string, minYear, maxYear int) { result, err := db.Exec( &amp;#34;SELECT * FROM tracks WHERE artist = ? AND ? &amp;lt;= year AND year &amp;lt;= ?&amp;#34;, artist, minYear, maxYear) // ... } Exec方法使用SQL字面量替换在查询字符串中的每个&amp;rsquo;?&#39;；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。
func sqlQuote(x interface{}) string { if x == nil { return &amp;#34;NULL&amp;#34; } else if _, ok := x.(int); ok { return fmt.</description>
    </item>
    
    <item>
      <title>7.14. 示例: 基于标记的XML解码</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.14.-Example-Token-Based-XML-Decoding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.14.-Example-Token-Based-XML-Decoding/</guid>
      <description>7.14. 示例: 基于标记的XML解码 #  第4.5章节展示了如何使用encoding/json包中的Marshal和Unmarshal函数来将JSON文档转换成Go语言的数据结构。encoding/xml包提供了一个相似的API。当我们想构造一个文档树的表示时使用encoding/xml包会很方便，但是对于很多程序并不是必须的。encoding/xml包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－StartElement，EndElement，CharData，和Comment－每一个都是encoding/xml包中的具体类型。每一个对(*xml.Decoder).Token的调用都返回一个标记。
这里显示的是和这个API相关的部分：
encoding/xml
package xml type Name struct { Local string // e.g., &amp;#34;Title&amp;#34; or &amp;#34;id&amp;#34; } type Attr struct { // e.g., name=&amp;#34;value&amp;#34; 	Name Name Value string } // A Token includes StartElement, EndElement, CharData, // and Comment, plus a few esoteric types (not shown). type Token interface{} type StartElement struct { // e.g., &amp;lt;name&amp;gt;  Name Name Attr []Attr } type EndElement struct { Name Name } // e.</description>
    </item>
    
    <item>
      <title>7.15. 一些建议</title>
      <link>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.15.-A-Few-Words-of-Advicevvvv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/The-Go-Programming-Language/7.-Interfaces/7.15.-A-Few-Words-of-Advicevvvv/</guid>
      <description>7.15. 一些建议 #  当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制（§6.6）来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。
当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。
因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）
我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像input.Scan这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如fmt.Printf。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/apA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/apA/</guid>
      <description>附录 A 并发编程 II #  by Brett L. Schuchert
This appendix supports and amplifies the Concurrency chapter on page 177. It is written as a series of independent topics and you can generally read them in any order. There is some duplication between sections to allow for such reading.
 本附录扩充了“并发编程”一章的内容，由一组相互独立的主题组成，你可以按随意顺序阅读。为了实现这样的阅读方式，节与节之间存在一些重复内容。
 A.1 CLIENT/SERVER EXAMPLE 客户端/服务器的例子 #  Imagine a simple client/server application. A server sits and waits listening on a socket for a client to connect.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch1/</guid>
      <description>第 1 章 Clean Code 整洁代码 #   You are reading this book for two reasons. First, you are a programmer. Second, you want to be a better programmer. Good. We need better programmers.
 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。很好。我们需要更好的程序员。
 This is a book about good programming. It is filled with code. We are going to look at code from every different direction. We’ll look down at it from the top, up at it from the bottom, and through it from the inside out.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch10/</guid>
      <description>第 10 章 Classes 类 #  with Jeff Langr
 So far in this book we have focused on how to write lines and blocks of code well. We have delved into proper composition of functions and how they interrelate. But for all the attention to the expressiveness of code statements and the functions they comprise, we still don’t have clean code until we’ve paid attention to higher levels of code organization.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch11/</guid>
      <description>第 11 章 Systems 系统 #  by Dr. Kevin Dean Wampler
 “Complexity kills. It sucks the life out of developers, it makes products difficult to plan, build, and test.”
—Ray Ozzie, CTO, Microsoft Corporation
 “复杂要人命。它消磨开发者的生命，让产品难以规划、构建和测试。”
——Ray Ozzie，微软公司首席技术官
 11.1 HOW WOULD YOU BUILD A CITY? 如何建造一个城市 #  Could you manage all the details yourself? Probably not. Even managing an existing city is too much for one person.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch12/</guid>
      <description>第 12 章 Emergence 迭进 #  by Jeff Langr
 12.1 GETTING CLEAN VIA EMERGENT DESIGN 通过迭进设计达到整洁目的 #  What if there were four simple rules that you could follow that would help you create good designs as you worked? What if by following these rules you gained insights into the structure and design of your code, making it easier to apply principles such as SRP and DIP? What if these four rules facilitated the emergence of good designs?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch13/</guid>
      <description>第 13 章 Concurrency 并发编程 #  by Brett L. Schuchert
 “Objects are abstractions of processing. Threads are abstractions of schedule.”
—James O. Coplien1
 “对象是过程的抽象。线程是调度的抽象。”
——James O
 Writing clean concurrent programs is hard—very hard. It is much easier to write code that executes in a single thread. It is also easy to write multithreaded code that looks fine on the surface but is broken at a deeper level.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch14/</guid>
      <description>第 14 章 Successive Refinement 逐步改进 #  Case Study of a Command-Line Argument Parser
 This chapter is a case study in successive refinement. You will see a module that started well but did not scale. Then you will see how the module was refactored and cleaned.
 本章研究一个逐步改进的案例。你将看到一个开始还不错，规模扩大后即出问题的模块。你还将看到这个模块是如何被重构得整洁起来的。
 Most of us have had to parse command-line arguments from time to time. If we don’t have a convenient utility, then we simply walk the array of strings that is passed into the main function.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch15/</guid>
      <description>第 15 章 JUnit Internals JUnit 内幕 #   JUnit is one of the most famous of all Java frameworks. As frameworks go, it is simple in conception, precise in definition, and elegant in implementation. But what does the code look like? In this chapter we’ll critique an example drawn from the JUnit framework.
 JUnit 是最有名的 Java 框架之一。就像别的框架一样，它概念简单，定义精确，实现优雅。但它的代码是怎样的呢？本章将研判来自 JUnit 框架的一个代码例子。
 15.1THE JUNIT FRAMEWORK JUnit 框架 #  JUnit has had many authors, but it began with Kent Beck and Eric Gamma together on a plane to Atlanta.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch16/</guid>
      <description>第 16 章 Refactoring SerialDate 重构 SerialDate #   If you go to http://www.jfree.org/jcommon/index.php, you will find the JCommon library. Deep within that library there is a package named org.jfree.date. Within that package there is a class named SerialDate. We are going to explore that class.
 如果你访问 http://www.jfree.org/jcommon/index.php，就能找到 JCommon 类库。深入该类库，其中有个名为 org.jfree.date 的程序包。在该程序包中，有个名为 SerialDate 的类。我们即将剖析这个类。
 The author of SerialDate is David Gilbert. David is clearly an experienced and competent programmer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch17/</guid>
      <description>第 17 章 Smells and Heuristics 味道与启发 #   In his wonderful book Refactoring,1 Martin Fowler identified many different “Code Smells.” The list that follows includes many of Martin’s smells and adds many more of my own. It also includes other pearls and heuristics that I use to practice my trade.
 Martin Fowler 在其妙书 Refectoring:Improving the Design of Existing Code[1]中指出了许多不同的“代码味道”。下面的清单包括很多 Martin 提出的味道，还添加了更多我自己提出的，也包括我借以历练本业的其他珍宝与启发。
 I compiled this list by walking through several different programs and refactoring them.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch2/</guid>
      <description>第 2 章 Meaningful Names 有意义的命名 #   by Tim Ottinger
2.1 INTRODUCTION 介绍 #  Names are everywhere in software. We name our variables, our functions, our arguments, classes, and packages. We name our source files and the directories that contain them. We name our jar files and war files and ear files. We name and name and name. Because we do so much of it, we’d better do it well.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch3/</guid>
      <description>第 3 章 Functions 函数 #   In the early days of programming we composed our systems of routines and subroutines. Then, in the era of Fortran and PL/1 we composed our systems of programs, subprograms, and functions. Nowadays only the function survives from those early days. Functions are the first line of organization in any program. Writing them well is the topic of this chapter.
 在编程的早年岁月，系统由程序和子程序组成。后来，在 Fortran 和 PL/1 的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。本章将讨论如何写好函数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch4/</guid>
      <description>第 4 章 Comments 注释 #   “Don’t comment bad code—rewrite it.”—Brian W. Kernighan and P. J. Plaugher1
 “别给糟糕的代码加注释——重新写吧。”——Brian W. Kernighan 与 P. J.
 Nothing can be quite so helpful as a well-placed comment. Nothing can clutter up a module more than frivolous dogmatic comments. Nothing can be quite so damaging as an old crufty comment that propagates lies and misinformation.
 什么也比不上放置良好的注释来得有用。什么也不会比乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。
 Comments are not like Schindler’s List.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch5/</guid>
      <description>第 5 章 Formatting 格式 #   When people look under the hood, we want them to be impressed with the neatness, consistency, and attention to detail that they perceive. We want them to be struck by the orderliness. We want their eyebrows to rise as they scroll through the modules. We want them to perceive that professionals have been at work. If instead they see a scrambled mass of code that looks like it was written by a bevy of drunken sailors, then they are likely to conclude that the same inattention to detail pervades every other aspect of the project.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch6/</guid>
      <description>第 6 章 Objects and Data Structures 对象和数据结构 #   There is a reason that we keep our variables private. We don’t want anyone else to depend on them. We want to keep the freedom to change their type or implementation on a whim or an impulse. Why, then, do so many programmers automatically add getters and setters to their objects, exposing their private variables as if they were public?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch7/</guid>
      <description>第 7 章 Error Handling 错误处理 #  by Michael Feathers
 It might seem odd to have a section about error handling in a book about clean code. Error handling is just one of those things that we all have to do when we program. Input can be abnormal and devices can fail. In short, things can go wrong, and when they do, we as programmers are responsible for making sure that our code does what it needs to do.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch8/</guid>
      <description>第 8 章 Boundaries 边界 #  by James Grenning
 We seldom control all the software in our systems. Sometimes we buy third-party packages or use open source. Other times we depend on teams in our own company to produce components or subsystems for us. Somehow we must cleanly integrate this foreign code with our own. In this chapter we look at practices and techniques to keep the boundaries of our software clean.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/ch9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/ch9/</guid>
      <description>第 9 章 Unit Tests 单元测试 #   Our profession has come a long way in the last ten years. In 1997 no one had heard of Test Driven Development. For the vast majority of us, unit tests were short bits of throw-away code that we wrote to make sure our programs “worked.” We would painstakingly write our classes and methods, and then we would concoct some ad hoc code to test them.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://book.ninescloud.com/docs/Clean-Code/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://book.ninescloud.com/docs/Clean-Code/README/</guid>
      <description>目录 #    第 1 章 整洁代码  第 2 章 有意义的命名  第 3 章 函数  第 4 章 注释  第 5 章 格式  第 6 章 对象和数据结构  第 7 章 错误处理  第 8 章 边界  第 9 章 单元测试  第 10 章 类  第 11 章 系统  第 12 章 迭进  第 13 章 并发编程  第 14 章 逐步改进  第 15 章 JUnit 内幕  第 16 章 重构 SerialDate  第 17 章 味道与启发  附录 A 并发编程 II  </description>
    </item>
    
  </channel>
</rss>