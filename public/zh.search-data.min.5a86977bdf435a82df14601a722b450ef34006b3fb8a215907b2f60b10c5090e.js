'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/Clean-Code/1.-Clean-Code/','title':"1. 整洁代码",'section':"Go语言圣经",'content':"第 1 章 整洁代码 #   You are reading this book for two reasons. First, you are a programmer. Second, you want to be a better programmer. Good. We need better programmers.\n 阅读本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。很好。我们需要更好的程序员。\n This is a book about good programming. It is filled with code. We are going to look at code from every different direction. We’ll look down at it from the top, up at it from the bottom, and through it from the inside out. By the time we are done, we’re going to know a lot about code. What’s more, we’ll be able to tell the difference between good code and bad code. We’ll know how to write good code. And we’ll know how to transform bad code into good code.\n 这是本有关编写好程序的书。它充斥着代码。我们要从各个方向来考察这些代码。从顶向下，从底往上，从里而外。读完后，就能知道许多关于代码的事了。而且，我们还能说出好代码和糟糕的代码之间的差异。我们将了解到如何写出好代码。我们也会知道，如何将糟糕的代码改成好代码。\n "});index.add({'id':1,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.1.-Hello-World/','title':"1.1. Hello, World",'section':"1. 入门",'content':"1.1. Hello, World #  我们以现已成为传统的“hello world”案例来开始吧，这个例子首次出现于1978年出版的C语言圣经 《The C Programming Language》（译注：本书作者之一Brian W. Kernighan也是《The C Programming Language》一书的作者）。C语言是直接影响Go语言设计的语言之一。这个例子体现了Go语言一些核心理念。\ngopl.io/ch1/helloworld\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) } Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令（译注：静态编译）。Go语言提供的工具都通过一个单独的命令go调用，go命令有一系列子命令。最简单的一个子命令就是run。这个命令编译一个或多个以.go结尾的源文件，链接库文件，并运行最终生成的可执行文件。（本书使用$表示命令行提示符。）\n$ go run helloworld.go 毫无意外，这个命令会输出：\nHello, 世界 Go语言原生支持Unicode，它可以处理全世界任何语言的文本。\n如果不只是一次性实验，你肯定希望能够编译这个程序，保存编译结果以备将来之用。可以用build子命令：\n$ go build helloworld.go 这个命令生成一个名为helloworld的可执行的二进制文件（译注：Windows系统下生成的可执行文件是helloworld.exe，增加了.exe后缀名），之后你可以随时运行它（译注：在Windows系统下在命令行直接输入helloworld.exe命令运行），不需任何处理（译注：因为静态编译，所以不用担心在系统库更新的时候冲突，幸福感满满）。\n$ ./helloworld Hello, 世界 本书中所有示例代码上都有一行标记，利用这些标记可以从 gopl.io网站上本书源码仓库里获取代码：\ngopl.io/ch1/helloworld 执行 go get gopl.io/ch1/helloworld 命令，就会从网上获取代码，并放到对应目录中（需要先安装Git或Hg之类的版本管理工具，并将对应的命令添加到PATH环境变量中。序言已经提及，需要先设置好GOPATH环境变量，下载的代码会放在$GOPATH/src/gopl.io/ch1/helloworld目录）。2.6和10.7节有这方面更详细的介绍。\n来讨论下程序本身。Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成，目录定义包的作用。每个源文件都以一条package声明语句开始，这个例子里就是package main，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。\nGo的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。比如fmt包，就含有格式化输出、接收输入的函数。Println是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。\nmain包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在main里的main 函数 也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。main函数所做的事情就是程序做的。当然了，main函数一般调用其它包里的函数完成很多工作（如：fmt.Println）。\n必须告诉编译器源文件需要哪些包，这就是跟随在package声明后面的import声明扮演的角色。hello world例子只用到了一个包，大多数程序需要导入多个包。\n必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。这项严格要求避免了程序开发过程中引入未使用的包（译注：Go语言编译过程没有警告信息，争议特性之一）。\nimport声明必须跟在文件的package声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）。这些内容的声明顺序并不重要（译注：最好还是定一下规范）。这个例子的程序已经尽可能短了，只声明了一个函数，其中只调用了一个其他函数。为了节省篇幅，有些时候示例程序会省略package和import声明，但是，这些声明在源代码里有，并且必须得有才能编译。\n一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。第五章进一步考察函数。\nGo语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个）。举个例子，函数的左括号{必须和func函数声明在同一行上，且位于末尾，不能独占一行，而在表达式x + y中，可在+后换行，不能在+前换行（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）。\nGo语言在代码格式上采取了很强硬的态度。gofmt工具把代码格式化为标准格式（译注：这个格式化工具没有任何可以调整代码格式的参数，Go语言就是这么任性），并且go工具中的fmt子命令会对指定包，否则默认为当前目录中所有.go源文件应用gofmt命令。本书中的所有代码都被gofmt过。你也应该养成格式化自己的代码的习惯。以法令方式规定标准的代码格式可以避免无尽的无意义的琐碎争执（译注：也导致了Go语言的TIOBE排名较低，因为缺少撕逼的话题）。更重要的是，这样可以做多种自动源码转换，如果放任Go语言代码格式，这些转换就不大可能了。\n很多文本编辑器都可以配置为保存文件时自动执行gofmt，这样你的源代码总会被恰当地格式化。还有个相关的工具，goimports，可以根据代码需要，自动地添加或删除import声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：\n$ go get golang.org/x/tools/cmd/goimports 对于大多数用户来说，下载、编译包、运行测试用例、察看Go语言的文档等等常用功能都可以用go的工具完成。10.7节详细介绍这些知识。\n"});index.add({'id':2,'href':'/docs/Clean-Code/1.-Clean-Code/1.1.-There-Will-Be-Code/','title':"1.1. 要有代码",'section':"1. 整洁代码",'content':"1.1 要有代码 #  One might argue that a book about code is somehow behind the times—that code is no longer the issue; that we should be concerned about models and requirements instead. Indeed some have suggested that we are close to the end of code. That soon all code will be generated instead of written. That programmers simply won’t be needed because business people will generate programs from specifications.\n 有人也许会以为，关于代码的书有点儿落后于时代——代码不再是问题；我们应当关注模型和需求。确实，有人说过我们正在临近代码的终结点。很快，代码就会自动产生出来，不需要再人工编写。程序员完全没用了，因为商务人士可以从规约直接生成程序。\n Nonsense! We will never be rid of code, because code represents the details of the requirements. At some level those details cannot be ignored or abstracted; they have to be specified. And specifying requirements in such detail that a machine can execute them is programming. Such a specification is code.\n 扯淡！我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是代码。\n I expect that the level of abstraction of our languages will continue to increase. I also expect that the number of domain-specific languages will continue to grow. This will be a good thing. But it will not eliminate code. Indeed, all the specifications written in these higher level and domain-specific language will be code! It will still need to be rigorous, accurate, and so formal and detailed that a machine can understand and execute it.\n 我期望语言的抽象程度继续提升。我也期望领域特定语言的数量继续增加。那会是好事一桩。但那终结不了代码。实际上，在较高层次上用领域特定语言撰写的规约也将是代码！它也得严谨、精确、规范和详细，好让机器理解和执行。\n The folks who think that code will one day disappear are like mathematicians who hope one day to discover a mathematics that does not have to be formal. They are hoping that one day we will discover a way to create machines that can do what we want rather than what we say. These machines will have to be able to understand us so well that they can translate vaguely specified needs into perfectly executing programs that precisely meet those needs.\n 那帮以为代码终将消失的伙计，就像是巴望着发现一种无规范数学的数学家们一般。他们巴望着，总有一天能创造出某种机器，我们只要想想、嘴都不用张就能叫它依计行事。那机器要能透彻理解我们，只有这样，它才能把含糊不清的需求翻译为可完美执行的程序，精确满足需求。\n This will never happen. Not even humans, with all their intuition and creativity, have been able to create successful systems from the vague feelings of their customers. Indeed, if the discipline of requirements specification has taught us anything, it is that well-specified requirements are as formal as code and can act as executable tests of that code!\n 这种事永远不会发生。即便是人类，倾其全部的直觉和创造力，也造不出满足客户模糊感觉的成功系统来。如果说需求规约原则教给了我们什么，那就是归置良好的需求就像代码一样正式，也能作为代码的可执行测试来使用。\n Remember that code is really the language in which we ultimately express the requirements. We may create languages that are closer to the requirements. We may create tools that help us parse and assemble those requirements into formal structures. But we will never eliminate necessary precision—so there will always be code.\n 记住，代码确然是我们最终用来表达需求的那种语言。我们可以创造各种与需求接近的语言。我们可以创造帮助把需求解析和汇整为正式结构的各种工具。然而，我们永远无法抛弃必要的精确性——所以代码永存。\n "});index.add({'id':3,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.1.-Introduction/','title':"10.1. 包简介",'section':"10. 包和工具",'content':"10.1. 包简介 #  任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。\n每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时候减少和其它部分名字的冲突。\n每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。\n当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。\n"});index.add({'id':4,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.1.-Workspace-Organization/','title':"10.7.1. 工作区结构",'section':"10.7. 工具",'content':"10.7.1. 工作区结构 #  对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写本书时将GOPATH设置为$HOME/gobook：\n$ export GOPATH=$HOME/gobook $ go get gopl.io/... 当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的：\nGOPATH/ src/ gopl.io/ .git/ ch1/ helloworld/ main.go dup/ main.go ... golang.org/x/net/ .git/ html/ parse.go node.go ... bin/ helloworld dup pkg/ darwin_amd64/ ... GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在与$GOPATH/src的相对路径为包导入路径的子目录中，例如gopl.io/ch1/helloworld相对应的路径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。\n第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。\n其中go env命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。\n$ go env GOPATH=\u0026quot;/home/gopher/gobook\u0026quot; GOROOT=\u0026quot;/usr/local/go\u0026quot; GOARCH=\u0026quot;amd64\u0026quot; GOOS=\u0026quot;darwin\u0026quot; ... "});index.add({'id':5,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.1.-Randomized-Testing/','title':"11.2.1. 随机测试",'section':"11.2. 测试函数",'content':"11.2.1. 随机测试 #  表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。\n那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。\n下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。\nimport \u0026#34;math/rand\u0026#34; // randomPalindrome returns a palindrome whose length and contents // are derived from the pseudo-random number generator rng. func randomPalindrome(rng *rand.Rand) string { n := rng.Intn(25) // random length up to 24 \trunes := make([]rune, n) for i := 0; i \u0026lt; (n+1)/2; i++ { r := rune(rng.Intn(0x1000)) // random rune up to \u0026#39;\\u0999\u0026#39; \trunes[i] = r runes[n-1-i] = r } return string(runes) } func TestRandomPalindromes(t *testing.T) { // Initialize a pseudo-random number generator. \tseed := time.Now().UTC().UnixNano() t.Logf(\u0026#34;Random seed: %d\u0026#34;, seed) rng := rand.New(rand.NewSource(seed)) for i := 0; i \u0026lt; 1000; i++ { p := randomPalindrome(rng) if !IsPalindrome(p) { t.Errorf(\u0026#34;IsPalindrome(%q) = false\u0026#34;, p) } } } 虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入IsPalindrome的p参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。\n通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。\n练习 11.3: TestRandomPalindromes测试函数只测试了回文字符串。编写新的随机测试生成器，用于测试随机生成的非回文字符串。\n练习 11.4: 修改randomPalindrome函数，以探索IsPalindrome是否对标点和空格做了正确处理。\n译者注：拓展阅读感兴趣的读者可以再了解一下go-fuzz\n"});index.add({'id':6,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.1.-Why-Reflection/','title':"12.1. 为何需要反射?",'section':"12. 反射",'content':"12.1. 为何需要反射? #  有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在。\n一个大家熟悉的例子是fmt.Fprintf函数提供的字符串格式化处理逻辑，它可以用来对任意类型的值格式化并打印，甚至支持用户自定义的类型。让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。\n我们首先用switch类型分支来测试输入参数是否实现了String方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个值的动态类型是否是string、int、bool等基础类型，并在每种情况下执行相应的格式化操作。\nfunc Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) // ...similar cases for int16, uint32, and so on... \tcase bool: if x { return \u0026#34;true\u0026#34; } return \u0026#34;false\u0026#34; default: // array, chan, func, map, pointer, slice, struct \treturn \u0026#34;???\u0026#34; } } 但是我们如何处理其它类似[]float64、map[string][]string等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理类似url.Values这样的具名类型呢？即使类型分支可以识别出底层的基础类型是map[string][]string，但是它并不匹配url.Values类型，因为它们是两种不同的类型，而且switch类型分支也不可能包含每个类似url.Values的类型，这会导致对这些库的依赖。\n没有办法来检查未知类型的表示方式，我们被卡住了。这就是我们需要反射的原因。\n"});index.add({'id':7,'href':'/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.1.-unsafe.Sizeof-Alignof-and-Offsetof/','title':"13.1. unsafe.Sizeof, Alignof 和 Offsetof",'section':"13. 底层编程",'content':"13.1. unsafe.Sizeof, Alignof 和 Offsetof #  unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。一个Sizeof函数调用是一个对应uintptr类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。\nimport \u0026#34;unsafe\u0026#34; fmt.Println(unsafe.Sizeof(float64(0))) // \u0026#34;8\u0026#34; Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。\n计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。\n由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。\n   类型 大小     bool 1个字节   intN, uintN, floatN, complexN N/8个字节（例如float64是8个字节）   int, uint, uintptr 1个机器字   *T 1个机器字   string 2个机器字（data、len）   []T 3个机器字（data、len、cap）   map 1个机器字   func 1个机器字   chan 1个机器字   interface 2个机器字（type、value）    Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编译器可以随意地重新排列每个字段的内存位置，虽然在写作本书的时候编译器还没有这么做。下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内存。\n// 64-bit 32-bit struct{ bool; float64; int16 } // 3 words 4words struct{ float64; int16; bool } // 2 words 3words struct{ bool; int16; float64 } // 2 words 3words 关于内存地址对齐算法的细节超出了本书的范围，也不是每一个结构体都需要担心这个问题，不过有效的包装可以使数据结构更加紧凑（译注：未来的Go语言编译器应该会默认优化结构体的顺序，当然应该也能够指定具体的内存布局，相同讨论请参考 Issue10014 ），内存使用率和性能都可能会受益。\nunsafe.Alignof 函数返回对应参数的类型需要对齐的倍数。和 Sizeof 类似， Alignof 也是返回一个常量表达式，对应一个常量。通常情况下布尔和数字类型需要对齐到它们本身的大小（最多8个字节），其它的类型对齐到机器字大小。\nunsafe.Offsetof 函数的参数必须是一个字段 x.f，然后返回 f 字段相对于 x 起始地址的偏移量，包括可能的空洞。\n图 13.1 显示了一个结构体变量 x 以及其在32位和64位机器上的典型的内存。灰色区域是空洞。\nvar x struct { a bool b int16 c []int } 下面显示了对x和它的三个字段调用unsafe包相关函数的计算结果：\n 32位系统：\nSizeof(x) = 16 Alignof(x) = 4 Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0 Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2 Sizeof(x.c) = 12 Alignof(x.c) = 4 Offsetof(x.c) = 4 64位系统：\nSizeof(x) = 32 Alignof(x) = 8 Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0 Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2 Sizeof(x.c) = 24 Alignof(x.c) = 8 Offsetof(x.c) = 8 虽然这几个函数在不安全的unsafe包，但是这几个函数调用并不是真的不安全，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。\n"});index.add({'id':8,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.1.-Introduction/','title':"2.1. 介绍",'section':"2. 有意义的命名",'content':"2.1 介绍 #  Names are everywhere in software. We name our variables, our functions, our arguments, classes, and packages. We name our source files and the directories that contain them. We name our jar files and war files and ear files. We name and name and name. Because we do so much of it, we’d better do it well. What follows are some simple rules for creating good names.\n 软件中随处可见命名。我们给变量、函数、参数、类和封包命名。我们给源代码及源代码所在目录命名。我们给 jar 文件、war 文件和 ear 文件命名。我们命名、命名，不断命名。既然有这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则。\n "});index.add({'id':9,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.1.-Names/','title':"2.1. 命名",'section':"2. 程序结构",'content':"2.1. 命名 #  Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。\nGo语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。\n内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。\n如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。\n名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。\n在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。\n"});index.add({'id':10,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.1.-Short-Variable-Declarations/','title':"2.3.1. 简短变量声明",'section':"2.3. 变量",'content':"2.3.1. 简短变量声明 #  在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。下面是lissajous函数中的三个简短变量声明语句（§1.4）：\nanim := gif.GIF{LoopCount: nframes} freq := rand.Float64() * 3.0 t := 0.0 因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。\ni := 100 // an int var boiling float64 = 100 // a float64 var names []string var err error var p Point 和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：\ni, j := 0, 1 但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。\n请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值（§2.4.1），后者是将右边各个表达式的值赋值给左边对应位置的各个变量：\ni, j = j, i // 交换 i 和 j 的值 和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：\nf, err := os.Open(name) if err != nil { return err } // ...use f... f.Close() 这里有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在相同的词法域声明过了（§2.7），那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。\n在下面的代码中，第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。\nin, err := os.Open(infile) // ... out, err := os.Create(outfile) 简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：\nf, err := os.Open(infile) // ... f, err := os.Create(outfile) // compile error: no new variables 解决的方法是第二个简短变量声明语句改用普通的多重赋值语句。\n简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。我们在本章后面将会看到类似的例子。\n"});index.add({'id':11,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/2.4.1.-Tuple-Assignment/','title':"2.4.1. 元组赋值",'section':"2.4. 赋值",'content':"2.4.1. 元组赋值 #  元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：\nx, y = y, x a[i], a[j] = a[j], a[i] 或者是计算两个整数值的的最大公约数（GCD）（译注：GCD不是那个敏感字，而是greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法）：\nfunc gcd(x, y int) int { for y != 0 { x, y = y, x%y } return x } 或者是计算斐波纳契数列（Fibonacci）的第N个数：\nfunc fib(n int) int { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { x, y = y, x+y } return x } 元组赋值也可以使一系列琐碎赋值更加紧凑（译注: 特别是在for循环的初始化部分），\ni, j, k = 2, 3, 5 但如果表达式太复杂的话，应该尽量避免过度使用元组赋值；因为每个变量单独赋值语句的写法可读性会更好。\n有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。\nf, err = os.Open(\u0026#34;foo.txt\u0026#34;) // function call returns two values 通常，这类函数会用额外的返回值来表达某种错误类型，例如os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok。在稍后我们将看到的三个操作都是类似的用法。如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：\nv, ok = m[key] // map lookup v, ok = x.(T) // type assertion v, ok = \u0026lt;-ch // channel receive 译注：map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：\nv = m[key] // map查找，失败时返回零值 v = x.(T) // type断言，失败时panic异常 v = \u0026lt;-ch // 管道接收，失败时返回零值（阻塞不算是失败）  _, ok = m[key] // map返回2个值 _, ok = mm[\u0026#34;\u0026#34;], false // map返回1个值 _ = mm[\u0026#34;\u0026#34;] // map返回1个值 和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值。\n_, err = io.Copy(dst, src) // 丢弃字节数 _, ok = x.(T) // 只检测类型，忽略具体值 "});index.add({'id':12,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/2.6.1.-Imports/','title':"2.6.1. 导入包",'section':"2.6. 包和文件",'content':"2.6.1. 导入包 #  在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似\u0026quot;gopl.io/ch2/tempconv\u0026quot;的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。\n除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。\n要使用gopl.io/ch2/tempconv包，需要先导入：\ngopl.io/ch2/cf\n// Cf converts its numeric argument to Celsius and Fahrenheit. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;gopl.io/ch2/tempconv\u0026#34; ) func main() { for _, arg := range os.Args[1:] { t, err := strconv.ParseFloat(arg, 64) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;cf: %v\\n\u0026#34;, err) os.Exit(1) } f := tempconv.Fahrenheit(t) c := tempconv.Celsius(t) fmt.Printf(\u0026#34;%s = %s, %s = %s\\n\u0026#34;, f, tempconv.FToC(f), c, tempconv.CToF(c)) } } 导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。上面的导入声明将允许我们以tempconv.CToF的形式来访问gopl.io/ch2/tempconv包中的内容。在默认情况下，导入的包绑定到tempconv名字（译注：指包声明语句指定的名字），但是我们也可以绑定到另一个名称，以避免名字冲突（§10.4）。\ncf程序将命令行输入的一个温度在Celsius和Fahrenheit温度单位之间转换：\n$ go build gopl.io/ch2/cf $ ./cf 32 32°F = 0°C, 32°C = 89.6°F $ ./cf 212 212°F = 100°C, 212°C = 413.6°F $ ./cf -40 -40°F = -40°C, -40°C = -40°F 如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。这种强制规则可以有效减少不必要的依赖，虽然在调试期间可能会让人讨厌，因为删除一个类似log.Print(\u0026ldquo;got here!\u0026quot;)的打印语句可能导致需要同时删除log包导入声明，否则，编译器将会发出一个错误。在这种情况下，我们需要将不必要的导入删除或注释掉。\n不过有更好的解决方案，我们可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以用来格式化Go源文件。\n练习 2.2： 写一个通用的单位转换程序，用类似cf程序的方式从命令行读取参数，如果缺省的话则是从标准输入读取参数，然后做类似Celsius和Fahrenheit的单位转换，长度单位可以对应英尺和米，重量单位可以对应磅和公斤等。\n"});index.add({'id':13,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.1.-Integers/','title':"3.1. 整型",'section':"3. 基础数据类型",'content':"3.1. 整型 #  Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。让我们先从整数类型开始介绍。\nGo语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。\n这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。\nUnicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。\n最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。我们将在第十三章的unsafe包相关部分看到类似的例子。\n不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。\n其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从$-2^{n-1}$到$2^{n-1}-1$。无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。\n下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：\n* / % \u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; \u0026amp;^ + - | ^ == != \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= \u0026amp;\u0026amp; || 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级，例如mask \u0026amp; (1 \u0026lt;\u0026lt; 28)。\n对于上表中前两行的运算符，例如+运算符还有一个与赋值相结合的对应运算符+=，可以用于简化赋值语句。\n算术运算符+、-、*和/可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符/的行为则依赖于操作数是否全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。\n一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边的bit位是1的话，那么最终结果可能是负的，例如int8的例子：\nvar u uint8 = 255 fmt.Println(u, u+1, u*u) // \u0026#34;255 0 1\u0026#34;  var i int8 = 127 fmt.Println(i, i+1, i*i) // \u0026#34;127 -128 1\u0026#34; 两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。\n== 等于 != 不等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026gt; 大于 \u0026gt;= 大于等于 事实上，布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用==和!=进行比较。此外，整数、浮点数和字符串可以根据比较结果排序。许多其它类型的值可能是不可比较的，因此也就可能是不可排序的。对于我们遇到的每种类型，我们需要保证规则的一致性。\n这里是一元的加法和减法运算符：\n+ 一元加法（无效果） - 负数 对于整数，+x是0+x的简写，-x则是0-x的简写；对于浮点数和复数，+x就是x，-x则是x 的负数。\nGo语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：\n\u0026amp; 位运算 AND | 位运算 OR ^ 位运算 XOR \u0026amp;^ 位清空（AND NOT） \u0026lt;\u0026lt; 左移 \u0026gt;\u0026gt; 右移 位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。位操作运算符\u0026amp;^用于按位置零（AND NOT）：如果对应y中bit位为1的话，表达式z = x \u0026amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。\n下面的代码演示了如何使用位操作解释uint8类型值的8个独立的bit位。它使用了Printf函数的%b参数打印二进制格式的数字；其中%08b中08表示打印至少8个字符宽度，不足的前缀部分用0填充。\nvar x uint8 = 1\u0026lt;\u0026lt;1 | 1\u0026lt;\u0026lt;5 var y uint8 = 1\u0026lt;\u0026lt;1 | 1\u0026lt;\u0026lt;2 fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x) // \u0026#34;00100010\u0026#34;, the set {1, 5} fmt.Printf(\u0026#34;%08b\\n\u0026#34;, y) // \u0026#34;00000110\u0026#34;, the set {1, 2}  fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x\u0026amp;y) // \u0026#34;00000010\u0026#34;, the intersection {1} fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x|y) // \u0026#34;00100110\u0026#34;, the union {1, 2, 5} fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x^y) // \u0026#34;00100100\u0026#34;, the symmetric difference {2, 5} fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x\u0026amp;^y) // \u0026#34;00100000\u0026#34;, the difference {5}  for i := uint(0); i \u0026lt; 8; i++ { if x\u0026amp;(1\u0026lt;\u0026lt;i) != 0 { // membership test \tfmt.Println(i) // \u0026#34;1\u0026#34;, \u0026#34;5\u0026#34; \t} } fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x\u0026lt;\u0026lt;1) // \u0026#34;01000100\u0026#34;, the set {2, 6} fmt.Printf(\u0026#34;%08b\\n\u0026#34;, x\u0026gt;\u0026gt;1) // \u0026#34;00010001\u0026#34;, the set {0, 4} （6.5节给出了一个可以远大于一个字节的整数集的实现。）\n在x\u0026lt;\u0026lt;n和x\u0026gt;\u0026gt;n移位运算中，决定了移位操作的bit数部分必须是无符号数；被操作的x可以是有符号数或无符号数。算术上，一个x\u0026lt;\u0026lt;n左移运算等价于乘以$2^n$，一个x\u0026gt;\u0026gt;n右移运算等价于除以$2^n$。\n左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。\n尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的int类型，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。事实上，内置的len函数返回一个有符号的int，我们可以像下面例子那样处理逆序循环。\nmedals := []string{\u0026#34;gold\u0026#34;, \u0026#34;silver\u0026#34;, \u0026#34;bronze\u0026#34;} for i := len(medals) - 1; i \u0026gt;= 0; i-- { fmt.Println(medals[i]) // \u0026#34;bronze\u0026#34;, \u0026#34;silver\u0026#34;, \u0026#34;gold\u0026#34; } 另一个选择对于上面的例子来说将是灾难性的。如果len函数返回一个无符号数，那么i也将是无符号的uint类型，然后条件i \u0026gt;= 0则永远为真。在三次迭代之后，也就是i == 0时，i\u0026ndash;语句将不会产生-1，而是变成一个uint类型的最大值（可能是$2^64-1$），然后medals[i]表达式运行时将发生panic异常（§5.9），也就是试图访问一个slice范围以外的元素。\n出于这个原因，无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。\n一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关的问题，而且也使得程序容易理解。\n在很多场景，会遇到类似下面代码的常见的错误：\nvar apples int32 = 1 var oranges int16 = 2 var compote int = apples + oranges // compile error 当尝试编译这三个语句时，将产生一个错误信息：\ninvalid operation: apples + oranges (mismatched types int32 and int16) 这种类型不匹配的问题可以有几种不同的方法修复，最常见方法是将它们都显式转型为一个常见类型：\nvar compote = int(apples) + int(oranges) 如2.5节所述，对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型。许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度：\nf := 3.141 // a float64 i := int(f) fmt.Println(f, i) // \u0026#34;3.141 3\u0026#34; f = 1.99 fmt.Println(int(f)) // \u0026#34;1\u0026#34; 浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。你应该避免对可能会超出目标类型表示范围的数值做类型转换，因为截断的行为可能依赖于具体的实现：\nf := 1e100 // a float64 i := int(f) // 结果依赖于具体实现 任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。\n当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式，就像下面的例子：\no := 0666 fmt.Printf(\u0026#34;%d %[1]o %#[1]o\\n\u0026#34;, o) // \u0026#34;438 666 0666\u0026#34; x := int64(0xdeadbeef) fmt.Printf(\u0026#34;%d %[1]x %#[1]x %#[1]X\\n\u0026#34;, x) // Output: // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 请注意fmt的两个使用技巧。通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。\n字符面值通过一对单引号直接包含对应字符。最简单的例子是ASCII中类似\u0026rsquo;a\u0026rsquo;写法的字符面值，但是我们也可以通过转义的数值来表示任意的Unicode码点对应的字符，马上将会看到这样的例子。\n字符使用%c参数打印，或者是用%q参数打印带单引号的字符：\nascii := \u0026#39;a\u0026#39; unicode := \u0026#39;国\u0026#39; newline := \u0026#39;\\n\u0026#39; fmt.Printf(\u0026#34;%d %[1]c %[1]q\\n\u0026#34;, ascii) // \u0026#34;97 a \u0026#39;a\u0026#39;\u0026#34; fmt.Printf(\u0026#34;%d %[1]c %[1]q\\n\u0026#34;, unicode) // \u0026#34;22269 国 \u0026#39;国\u0026#39;\u0026#34; fmt.Printf(\u0026#34;%d %[1]q\\n\u0026#34;, newline) // \u0026#34;10 \u0026#39;\\n\u0026#39;\u0026#34; "});index.add({'id':14,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.1.-String-Literals/','title':"3.5.1. 字符串面值",'section':"3.5. 字符串",'content':"3.5.1. 字符串面值 #  字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可：\n\u0026quot;Hello, 世界\u0026quot;  因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。\n在一个双引号包含的字符串面值中，可以用以反斜杠\\开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：\n\\a 响铃 \\b 退格 \\f 换页 \\n 换行 \\r 回车 \\t 制表符 \\v 垂直制表符 \\' 单引号（只用在 '\\'' 形式的rune符号面值中） \\\u0026quot; 双引号（只用在 \u0026quot;...\u0026quot; 形式的字符串面值中） \\\\ 反斜杠 可以通过十六进制或八进制转义在字符串面值中包含任意的字节。一个十六进制的转义形式是\\xhh，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是\\ooo，包含三个八进制的o数字（0到7），但是不能超过\\377（译注：对应一个字节的范围，十进制为255）。每一个单一的字节表达一个特定的值。稍后我们将看到如何将一个Unicode码点写到字符串面值中。\n一个原生的字符串面值形式是`\u0026hellip;`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+\u0026rdquo;`\u0026quot;连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。\n原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。\nconst GoUsage = `Go is a tool for managing Go source code. Usage: go command [arguments] ...` "});index.add({'id':15,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/3.6.1.-The-Constant-Generator-iota/','title':"3.6.1. iota 常量生成器",'section':"3.6. 常量",'content':"3.6.1. iota 常量生成器 #  常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。\n下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。\ntype Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 周日将对应0，周一为1，如此等等。\n我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：\ntype Flags uint const ( FlagUp Flags = 1 \u0026lt;\u0026lt; iota // is up \tFlagBroadcast // supports broadcast access capability \tFlagLoopback // is a loopback interface \tFlagPointToPoint // belongs to a point-to-point link \tFlagMulticast // supports multicast access capability ) 随着iota的递增，每个常量对应表达式1 \u0026laquo; iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值：\ngopl.io/ch3/netflag\nfunc IsUp(v Flags) bool { return v\u0026amp;FlagUp == FlagUp } func TurnDown(v *Flags) { *v \u0026amp;^= FlagUp } func SetBroadcast(v *Flags) { *v |= FlagBroadcast } func IsCast(v Flags) bool { return v\u0026amp;(FlagBroadcast|FlagMulticast) != 0 } func main() { var v Flags = FlagMulticast | FlagUp fmt.Printf(\u0026#34;%b %t\\n\u0026#34;, v, IsUp(v)) // \u0026#34;10001 true\u0026#34; \tTurnDown(\u0026amp;v) fmt.Printf(\u0026#34;%b %t\\n\u0026#34;, v, IsUp(v)) // \u0026#34;10000 false\u0026#34; \tSetBroadcast(\u0026amp;v) fmt.Printf(\u0026#34;%b %t\\n\u0026#34;, v, IsUp(v)) // \u0026#34;10010 false\u0026#34; \tfmt.Printf(\u0026#34;%b %t\\n\u0026#34;, v, IsCast(v)) // \u0026#34;10010 true\u0026#34; } 下面是一个更复杂的例子，每个常量都是1024的幂：\nconst ( _ = 1 \u0026lt;\u0026lt; (10 * iota) KiB // 1024 \tMiB // 1048576 \tGiB // 1073741824 \tTiB // 1099511627776 (exceeds 1 \u0026lt;\u0026lt; 32) \tPiB // 1125899906842624 \tEiB // 1152921504606846976 \tZiB // 1180591620717411303424 (exceeds 1 \u0026lt;\u0026lt; 64) \tYiB // 1208925819614629174706176 ) 不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。\n练习 3.13： 编写KB、MB的常量声明，然后扩展到YB。\n"});index.add({'id':16,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.1.-Arrays/','title':"4.1. 数组",'section':"4. 复合数据类型",'content':"4.1. 数组 #  数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。\n数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。\nvar a [3]int // array of 3 integers fmt.Println(a[0]) // print the first element fmt.Println(a[len(a)-1]) // print the last element, a[2]  // Print the indices and elements. for i, v := range a { fmt.Printf(\u0026#34;%d %d\\n\u0026#34;, i, v) } // Print the elements only. for _, v := range a { fmt.Printf(\u0026#34;%d\\n\u0026#34;, v) } 默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：\nvar q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt.Println(r[2]) // \u0026#34;0\u0026#34; 在数组字面值中，如果在数组的长度位置出现的是“\u0026hellip;”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为\nq := [...]int{1, 2, 3} fmt.Printf(\u0026#34;%T\\n\u0026#34;, q) // \u0026#34;[3]int\u0026#34; 数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。\nq := [3]int{1, 2, 3} q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int 我们将会发现，数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样：\ntype Currency int const ( USD Currency = iota // 美元 \tEUR // 欧元 \tGBP // 英镑 \tRMB // 人民币 ) symbol := [...]string{USD: \u0026#34;$\u0026#34;, EUR: \u0026#34;€\u0026#34;, GBP: \u0026#34;￡\u0026#34;, RMB: \u0026#34;￥\u0026#34;} fmt.Println(RMB, symbol[RMB]) // \u0026#34;3 ￥\u0026#34; 在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。例如，\nr := [...]int{99: -1} 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。\n如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。\na := [2]int{1, 2} b := [...]int{1, 2} c := [2]int{1, 3} fmt.Println(a == b, a == c, b == c) // \u0026#34;true false false\u0026#34; d := [3]int{1, 2} fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int 作为一个真实的例子，crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成“x”和“X”两个信息的摘要：\ngopl.io/ch4/sha256\nimport \u0026#34;crypto/sha256\u0026#34; func main() { c1 := sha256.Sum256([]byte(\u0026#34;x\u0026#34;)) c2 := sha256.Sum256([]byte(\u0026#34;X\u0026#34;)) fmt.Printf(\u0026#34;%x\\n%x\\n%t\\n%T\\n\u0026#34;, c1, c2, c1 == c2, c1) // Output: \t// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881 \t// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015 \t// false \t// [32]uint8 } 上面例子中，两个消息虽然只有一个字符的差异，但是生成的消息摘要则几乎有一半的bit位是不相同的。需要注意Printf函数的%x副词参数，它用于指定以十六进制的格式打印数组或slice全部的元素，%t副词参数是用于打印布尔型数据，%T副词参数是用于显示一个值对应的数据类型。\n当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。\n当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。下面的函数用于给[32]byte类型的数组清零：\nfunc zero(ptr *[32]byte) { for i := range ptr { ptr[i] = 0 } } 其实数组字面值[32]byte{}就可以生成一个32字节的数组。而且每个数组的元素都是零值初始化，也就是0。因此，我们可以将上面的zero函数写的更简洁一点：\nfunc zero(ptr *[32]byte) { *ptr = [32]byte{} } 虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的zero函数并不能接收指向[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。\n练习 4.1： 编写一个函数，计算两个SHA256哈希码中不同bit的数目。（参考2.6.2节的PopCount函数。)\n练习 4.2： 编写一个程序，默认情况下打印标准输入的SHA256编码，并支持通过命令行flag定制，输出SHA384或SHA512哈希算法。\n"});index.add({'id':17,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/4.2.1.-The-append-Function/','title':"4.2.1. append函数",'section':"4.2. Slice",'content':"4.2.1. append函数 #  内置的append函数用于向slice追加元素：\nvar runes []rune for _, r := range \u0026#34;Hello, 世界\u0026#34; { runes = append(runes, r) } fmt.Printf(\u0026#34;%q\\n\u0026#34;, runes) // \u0026#34;[\u0026#39;H\u0026#39; \u0026#39;e\u0026#39; \u0026#39;l\u0026#39; \u0026#39;l\u0026#39; \u0026#39;o\u0026#39; \u0026#39;,\u0026#39; \u0026#39; \u0026#39; \u0026#39;世\u0026#39; \u0026#39;界\u0026#39;]\u0026#34; 在循环中使用append函数构建一个由九个rune字符构成的slice，当然对应这个特殊的问题我们可以通过Go语言内置的[]rune(\u0026ldquo;Hello, 世界\u0026rdquo;)转换操作完成。\nappend函数对于理解slice底层是如何工作的非常重要，所以让我们仔细查看究竟是发生了什么。下面是第一个版本的appendInt函数，专门用于处理[]int类型的slice：\ngopl.io/ch4/append\nfunc appendInt(x []int, y int) []int { var z []int zlen := len(x) + 1 if zlen \u0026lt;= cap(x) { // There is room to grow. Extend the slice. \tz = x[:zlen] } else { // There is insufficient space. Allocate a new array. \t// Grow by doubling, for amortized linear complexity. \tzcap := zlen if zcap \u0026lt; 2*len(x) { zcap = 2 * len(x) } z = make([]int, zlen, zcap) copy(z, x) // a built-in function; see text \t} z[len(x)] = y return z } 每次调用appendInt函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice。因此，输入的x和输出的z共享相同的底层数组。\n如果没有足够的增长空间的话，appendInt函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素。结果z和输入的x引用的将是不同的底层数组。\n虽然通过循环复制元素更直接，不过内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice，目标和源的位置顺序和dst = src赋值语句是一致的。两个slice可以共享同一个底层数组，甚至有重叠也没有问题。copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。\n为了提高内存使用效率，新分配的数组一般略大于保存x和y所需要的最低大小。通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间。这个程序演示了效果：\nfunc main() { var x, y []int for i := 0; i \u0026lt; 10; i++ { y = appendInt(x, i) fmt.Printf(\u0026#34;%d cap=%d\\t%v\\n\u0026#34;, i, cap(y), y) x = y } } 每一次容量的变化都会导致重新分配内存和copy操作：\n0 cap=1 [0] 1 cap=2 [0 1] 2 cap=4 [0 1 2] 3 cap=4 [0 1 2 3] 4 cap=8 [0 1 2 3 4] 5 cap=8 [0 1 2 3 4 5] 6 cap=8 [0 1 2 3 4 5 6] 7 cap=8 [0 1 2 3 4 5 6 7] 8 cap=16 [0 1 2 3 4 5 6 7 8] 9 cap=16 [0 1 2 3 4 5 6 7 8 9] 让我们仔细查看i=3次的迭代。当时x包含了[0 1 2]三个元素，但是容量是4，因此可以简单将新的元素添加到末尾，不需要新的内存分配。然后新的y的长度和容量都是4，并且和x引用着相同的底层数组，如图4.2所示。\n 在下一次迭代时i=4，现在没有新的空余的空间了，因此appendInt函数分配一个容量为8的底层数组，将x的4个元素[0 1 2 3]复制到新空间的开头，然后添加新的元素i，新元素的值是4。新的y的长度是5，容量是8；后面有3个空闲的位置，三次迭代都不需要分配新的空间。当前迭代中，y和x是对应不同底层数组的view。这次操作如图4.3所示。\n 内置的append函数可能使用比appendInt更复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量：\nrunes = append(runes, r) 更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：\ntype IntSlice struct { ptr *int len, cap int } 我们的appendInt函数每次只能向slice追加一个元素，但是内置的append函数则可以追加多个元素，甚至追加一个slice。\nvar x []int x = append(x, 1) x = append(x, 2, 3) x = append(x, 4, 5, 6) x = append(x, x...) // append the slice x fmt.Println(x) // \u0026#34;[1 2 3 4 5 6 1 2 3 4 5 6]\u0026#34; 通过下面的小修改，我们可以达到append函数类似的功能。其中在appendInt函数参数中的最后的“\u0026hellip;”省略号表示接收变长的参数为slice。我们将在5.7节详细解释这个特性。\nfunc appendInt(x []int, y ...int) []int { var z []int zlen := len(x) + len(y) // ...expand z to at least zlen... \tcopy(z[len(x):], y) return z } 为了避免重复，和前面相同的代码并没有显示。\n"});index.add({'id':18,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.1.-Struct-Literals/','title':"4.4.1. 结构体字面值",'section':"4.4. 结构体",'content':"4.4.1. 结构体字面值 #  结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。\ntype Point struct{ X, Y int } p := Point{1, 2} 这里有两种形式的结构体字面值语法，上面的是第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如image.Point{x, y}或color.RGBA{red, green, blue, alpha}。\n其实更常用的是第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员，如1.4节的Lissajous程序的写法：\nanim := gif.GIF{LoopCount: nframes} 在这种形式的结构体字面值写法中，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。\n两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。\npackage p type T struct{ a, b int } // a and b are not exported  package q import \u0026#34;p\u0026#34; var _ = p.T{a: 1, b: 2} // compile error: can\u0026#39;t reference a, b var _ = p.T{1, 2} // compile error: can\u0026#39;t reference a, b 虽然上面最后一行代码的编译错误信息中并没有显式提到未导出的成员，但是这样企图隐式使用未导出成员的行为也是不允许的。\n结构体可以作为函数的参数和返回值。例如，这个Scale函数将Point类型的值缩放后返回：\nfunc Scale(p Point, factor int) Point { return Point{p.X * factor, p.Y * factor} } fmt.Println(Scale(Point{1, 2}, 5)) // \u0026#34;{5 10}\u0026#34; 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回，\nfunc Bonus(e *Employee, percent int) int { return e.Salary * percent / 100 } 如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。\nfunc AwardAnnualRaise(e *Employee) { e.Salary = e.Salary * 105 / 100 } 因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：\npp := \u0026amp;Point{1, 2} 它和下面的语句是等价的\npp := new(Point) *pp = Point{1, 2} 不过\u0026amp;Point{1, 2}写法可以直接在表达式中使用，比如一个函数调用。\n"});index.add({'id':19,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.1.-Function-Declarations/','title':"5.1. 函数声明",'section':"5. 函数",'content':"5.1. 函数声明 #  函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。\nfunc name(parameter-list) (result-list) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。在hypot函数中：\nfunc hypot(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(3,4)) // \u0026#34;5\u0026#34; x和y是形参名，3和4是调用时的传入的实参，函数返回了一个float64类型的值。 返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为该类型的零值。 如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。\n正如hypot一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：\nfunc f(i, j, k int, s, t string) { /* ... */ } func f(i int, j int, k int, s string, t string) { /* ... */ } 下面，我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：即下文的_符号)可以强调某个参数未被使用。\nfunc add(x int, y int) int {return x + y} func sub(x, y int) (z int) { z = x - y; return} func first(x int, _ int) int { return x } func zero(int, int) int { return 0 } fmt.Printf(\u0026#34;%T\\n\u0026#34;, add) // \u0026#34;func(int, int) int\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, sub) // \u0026#34;func(int, int) int\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, first) // \u0026#34;func(int, int) int\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, zero) // \u0026#34;func(int, int) int\u0026#34; 函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。\n每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。\n在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。\n实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。\n你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。\npackage math func Sin(x float64) float //implemented in assembly language "});index.add({'id':20,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/5.4.1.-Error-Handling-Strategies/','title':"5.4.1. 错误处理策略",'section':"5.4. 错误",'content':"5.4.1. 错误处理策略 #  当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的五种方式。\n首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。下面，我们以5.3节的findLinks函数作为例子。如果findLinks对http.Get的调用失败，findLinks会直接将这个HTTP错误返回给调用者：\nresp, err := http.Get(url) if err != nil{ return nil, err } 当对html.Parse的调用失败时，findLinks不会直接返回html.Parse的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的url。因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。\ndoc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return nil, fmt.Errorf(\u0026#34;parsing %s as HTML: %v\u0026#34;, url,err) } fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样：\ngenesis: crashed: no parachute: G-switch failed: bad relay orientation 由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息（译者注：grep是一种文本搜索工具）。\n编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。\n以os包为例，os包确保文件操作（如os.Open、Read、Write、Close）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。\n一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加url到html.Parse返回的错误中。\n让我们来看看处理错误的第二种策略。如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。\ngopl.io/ch5/wait\n// WaitForServer attempts to contact the server of a URL. // It tries for one minute using exponential back-off. // It reports an error if all attempts fail. func WaitForServer(url string) error { const timeout = 1 * time.Minute deadline := time.Now().Add(timeout) for tries := 0; time.Now().Before(deadline); tries++ { _, err := http.Head(url) if err == nil { return nil // success \t} log.Printf(\u0026#34;server not responding (%s);retrying…\u0026#34;, err) time.Sleep(time.Second \u0026lt;\u0026lt; uint(tries)) // exponential back-off \t} return fmt.Errorf(\u0026#34;server %s failed to respond after %s\u0026#34;, url, timeout) } 如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。\n// (In function main.) if err := WaitForServer(url); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Site is down: %v\\n\u0026#34;, err) os.Exit(1) } 调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。\nif err := WaitForServer(url); err != nil { log.Fatalf(\u0026#34;Site is down: %v\\n\u0026#34;, err) } 长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。\n2006/01/02 15:04:05 Site is down: no such domain: bad.gopl.io 我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。\nlog.SetPrefix(\u0026#34;wait: \u0026#34;) log.SetFlags(0) 第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数\nif err := Ping(); err != nil { log.Printf(\u0026#34;ping failed: %v; networking disabled\u0026#34;,err) } 或者标准错误流输出错误信息。\nif err := Ping(); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;ping failed: %v; networking disabled\\n\u0026#34;, err) } log包中的所有函数会为没有换行符的字符串增加换行符。\n第五种，也是最后一种策略：我们可以直接忽略掉错误。\ndir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;scratch\u0026#34;) if err != nil { return fmt.Errorf(\u0026#34;failed to create temp dir: %v\u0026#34;,err) } // ...use temp dir… os.RemoveAll(dir) // ignore errors; $TMPDIR is cleaned periodically 尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响。我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。\n在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。\n"});index.add({'id':21,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.6.-Anonymous-Functions/5.6.1.-Caveat-Capturing-Iteration-Variables/','title':"5.6.1. 警告：捕获迭代变量",'section':"5.6. 匿名函数",'content':"5.6.1. 警告：捕获迭代变量 #  本节，将介绍Go词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。\n考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入os包。为了使代码简单，我们忽略了所有的异常处理。\nvar rmdirs []func() for _, d := range tempDirs() { dir := d // NOTE: necessary! \tos.MkdirAll(dir, 0755) // creates parent directories too \trmdirs = append(rmdirs, func() { os.RemoveAll(dir) }) } // ...do some work… for _, rmdir := range rmdirs { rmdir() // clean up } 你可能会感到困惑，为什么要在循环体中用循环变量d赋值一个新的局部变量，而不是像下面的代码一样直接使用循环变量dir。需要注意，下面的代码是错误的。\nvar rmdirs []func() for _, dir := range tempDirs() { os.MkdirAll(dir, 0755) rmdirs = append(rmdirs, func() { os.RemoveAll(dir) // NOTE: incorrect! \t}) } 问题的原因在于循环变量的作用域。在上面的程序中，for循环语句引入了新的词法块，循环变量dir在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。这意味着，每次对os.RemoveAll的调用删除的都是相同的目录。\n通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。比如下面的变量dir，虽然这看起来很奇怪，但却很有用。\nfor _, dir := range tempDirs() { dir := dir // declares inner dir, initialized to outer dir \t// ... } 这个问题不仅存在基于range的循环，在下面的例子中，对循环变量i的使用也存在同样的问题：\nvar rmdirs []func() dirs := tempDirs() for i := 0; i \u0026lt; len(dirs); i++ { os.MkdirAll(dirs[i], 0755) // OK \trmdirs = append(rmdirs, func() { os.RemoveAll(dirs[i]) // NOTE: incorrect! \t}) } 如果你使用go语句（第八章）或者defer语句（5.8节）会经常遇到此类问题。这不是go或defer本身导致的，而是因为它们都会等待循环结束后，再执行函数值。\n"});index.add({'id':22,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.1.-Method-Declarations/','title':"6.1. 方法声明",'section':"6. 方法",'content':"6.1. 方法声明 #  在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。\n下面来写我们第一个方法的例子，这个例子在package geometry下：\ngopl.io/ch6/geometry\npackage geometry import \u0026#34;math\u0026#34; type Point struct{ X, Y float64 } // traditional function func Distance(p, q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } // same thing, but as a method of the Point type func (p Point) Distance(q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) } 上面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。\n在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。\n在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：\np := Point{1, 2} q := Point{4, 6} fmt.Println(Distance(p, q)) // \u0026#34;5\u0026#34;, function call fmt.Println(p.Distance(q)) // \u0026#34;5\u0026#34;, method call 可以看到，上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数geometry.Distance，而第二个则是使用刚刚声明的Point，调用的是Point类下声明的Point.Distance方法。\n这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义（译注：这里确实挺奇怪的）。\n因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。让我们来定义一个Path类型，这个Path代表一个线段的集合，并且也给这个Path定义一个叫Distance的方法。\n// A Path is a journey connecting the points with straight lines. type Path []Point // Distance returns the distance traveled along the path. func (path Path) Distance() float64 { sum := 0.0 for i := range path { if i \u0026gt; 0 { sum += path[i-1].Distance(path[i]) } } return sum } Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型（译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型）不是指针或者interface。\n两个Distance方法有不同的类型。他们两个方法之间没有任何关系，尽管Path的Distance方法会在内部调用Point.Distance方法来计算每个连接邻接点的线段的长度。\n让我们来调用一个新方法，计算三角形的周长：\nperim := Path{ {1, 1}, {5, 1}, {5, 4}, {1, 1}, } fmt.Println(perim.Distance()) // \u0026#34;12\u0026#34; 在上面两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。第一个例子中path[i-1]数组中的类型是Point，因此Point.Distance这个方法被调用；在第二个例子中perim的类型是Path，因此Distance调用的是Path.Distance。\n对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：\nimport \u0026#34;gopl.io/ch6/geometry\u0026#34; perim := geometry.Path{{1, 1}, {5, 1}, {5, 4}, {1, 1}} fmt.Println(geometry.PathDistance(perim)) // \u0026#34;12\u0026#34;, standalone function fmt.Println(perim.Distance()) // \u0026#34;12\u0026#34;, method of geometry.Path 译注： 如果我们要用方法去计算perim的distance，还需要去写全geometry的包名，和其函数名，但是因为Path这个类型定义了一个可以直接用的Distance方法，所以我们可以直接写perim.Distance()。相当于可以少打很多字，作者应该是这个意思。因为在Go里包外调用函数需要带上包名，还是挺麻烦的。\n"});index.add({'id':23,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.2.-Methods-with-a-Pointer-Receiver/6.2.1.-Nil-Is-a-Valid-Receiver-Value/','title':"6.2.1. Nil也是一个合法的接收器类型",'section':"6.2. 基于指针对象的方法",'content':"6.2.1. Nil也是一个合法的接收器类型 #  就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。在下面的简单int链表的例子里，nil代表的是空链表：\n// An IntList is a linked list of integers. // A nil *IntList represents the empty list. type IntList struct { Value int Tail *IntList } // Sum returns the sum of the list elements. func (list *IntList) Sum() int { if list == nil { return 0 } return list.Value + list.Tail.Sum() } 当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们上面例子里做的这样。\n下面是net/url包里Values类型定义的一部分。\nnet/url\npackage url // Values maps a string key to a list of values. type Values map[string][]string // Get returns the first value associated with the given key, // or \u0026#34;\u0026#34; if there are none. func (v Values) Get(key string) string { if vs := v[key]; len(vs) \u0026gt; 0 { return vs[0] } return \u0026#34;\u0026#34; } // Add adds the value to key. // It appends to any existing values associated with key. func (v Values) Add(key, value string) { v[key] = append(v[key], value) } 这个定义向外部暴露了一个map的命名类型，并且提供了一些能够简单操作这个map的方法。这个map的value字段是一个string的slice，所以这个Values是一个多维map。客户端使用这个变量的时候可以使用map固有的一些操作（make，切片，m[key]等等），也可以使用这里提供的操作方法，或者两者并用，都是可以的：\ngopl.io/ch6/urlvalues\nm := url.Values{\u0026#34;lang\u0026#34;: {\u0026#34;en\u0026#34;}} // direct construction m.Add(\u0026#34;item\u0026#34;, \u0026#34;1\u0026#34;) m.Add(\u0026#34;item\u0026#34;, \u0026#34;2\u0026#34;) fmt.Println(m.Get(\u0026#34;lang\u0026#34;)) // \u0026#34;en\u0026#34; fmt.Println(m.Get(\u0026#34;q\u0026#34;)) // \u0026#34;\u0026#34; fmt.Println(m.Get(\u0026#34;item\u0026#34;)) // \u0026#34;1\u0026#34; (first value) fmt.Println(m[\u0026#34;item\u0026#34;]) // \u0026#34;[1 2]\u0026#34; (direct map access)  m = nil fmt.Println(m.Get(\u0026#34;item\u0026#34;)) // \u0026#34;\u0026#34; m.Add(\u0026#34;item\u0026#34;, \u0026#34;3\u0026#34;) // panic: assignment to entry in nil map 对Get的最后一次调用中，nil接收器的行为即是一个空map的行为。我们可以等价地将这个操作写成Value(nil).Get(\u0026ldquo;item\u0026rdquo;)，但是如果你直接写nil.Get(\u0026ldquo;item\u0026rdquo;)的话是无法通过编译的，因为nil的字面量编译器无法判断其准确类型。所以相比之下，最后的那行m.Add的调用就会产生一个panic，因为他尝试更新一个空map。\n由于url.Values是一个map类型，并且间接引用了其key/value对，因此url.Values.Add对这个map里的元素做任何的更新、删除操作对调用方都是可见的。实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为nil，或者让这个引用指向了其它的对象，调用方都不会受影响。（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的）\n"});index.add({'id':24,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.1.-Interfaces-as-Contracts/','title':"7.1. 接口约定",'section':"7. 接口",'content':"7.1. 接口约定 #  目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。\n在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。\n在本书中，我们一直使用两个相似的函数来进行字符串的格式化：fmt.Printf，它会把结果写到标准输出，和fmt.Sprintf，它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数fmt.Fprintf来进行封装。fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。\npackage fmt func Fprintf(w io.Writer, format string, args ...interface{}) (int, error) func Printf(format string, args ...interface{}) (int, error) { return Fprintf(os.Stdout, format, args...) } func Sprintf(format string, args ...interface{}) string { var buf bytes.Buffer Fprintf(\u0026amp;buf, format, args...) return buf.String() } Fprintf的前缀F表示文件（File）也表明格式化输出结果应该被写入第一个参数提供的文件中。在Printf函数中的第一个参数os.Stdout是*os.File类型；在Sprintf函数中的第一个参数\u0026amp;buf是一个指向可以写入字节的内存缓冲区，然而它 并不是一个文件类型尽管它在某种意义上和文件类型相似。\n即使Fprintf函数中的第一个参数也不是一个文件类型。它是io.Writer类型，这是一个接口类型定义如下：\npackage io // Writer is the interface that wraps the basic Write method. type Writer interface { // Write writes len(p) bytes from p to the underlying data stream. \t// It returns the number of bytes written from p (0 \u0026lt;= n \u0026lt;= len(p)) \t// and any error encountered that caused the write to stop early. \t// Write must return a non-nil error if it returns n \u0026lt; len(p). \t// Write must not modify the slice data, even temporarily. \t// \t// Implementations must not retain p. \tWrite(p []byte) (n int, err error) } io.Writer类型定义了函数Fprintf和这个函数调用者之间的约定。一方面这个约定需要调用者提供具体类型的值就像*os.File和*bytes.Buffer，这些类型都有一个特定签名和行为的Write的函数。另一方面这个约定保证了Fprintf接受任何满足io.Writer接口的值都可以工作。Fprintf函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用Write函数的值。\n因为fmt.Fprintf函数没有对具体操作的值做任何假设，而是仅仅通过io.Writer接口的约定来保证行为，所以第一个参数可以安全地传入一个只需要满足io.Writer接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）。这是一个面向对象的特征。\n让我们通过一个新的类型来进行校验，下面*ByteCounter类型里的Write方法，仅仅在丢弃写向它的字节前统计它们的长度。（在这个+=赋值语句中，让len(p)的类型和*c的类型匹配的转换是必须的。）\ngopl.io/ch7/bytecounter\ntype ByteCounter int func (c *ByteCounter) Write(p []byte) (int, error) { *c += ByteCounter(len(p)) // convert int to ByteCounter \treturn len(p), nil } 因为*ByteCounter满足io.Writer的约定，我们可以把它传入Fprintf函数中；Fprintf函数执行字符串格式化的过程不会去关注ByteCounter正确的累加结果的长度。\nvar c ByteCounter c.Write([]byte(\u0026#34;hello\u0026#34;)) fmt.Println(c) // \u0026#34;5\u0026#34;, = len(\u0026#34;hello\u0026#34;) c = 0 // reset the counter var name = \u0026#34;Dolly\u0026#34; fmt.Fprintf(\u0026amp;c, \u0026#34;hello, %s\u0026#34;, name) fmt.Println(c) // \u0026#34;12\u0026#34;, = len(\u0026#34;hello, Dolly\u0026#34;) 除了io.Writer这个接口类型，还有另一个对fmt包很重要的接口类型。Fprintf和Fprintln函数向类型提供了一种控制它们值输出的途径。在2.5节中，我们为Celsius类型提供了一个String方法以便于可以打印成这样\u0026quot;100°C\u0026rdquo; ，在6.5节中我们给*IntSet添加一个String方法，这样集合可以用传统的符号来进行表示就像\u0026rdquo;{1 2 3}\u0026quot;。给一个类型定义String方法，可以让它满足最广泛使用之一的接口类型fmt.Stringer：\npackage fmt // The String method is used to print values passed // as an operand to any format that accepts a string // or to an unformatted printer such as Print. type Stringer interface { String() string } 我们会在7.10节解释fmt包怎么发现哪些值是满足这个接口类型的。\n练习 7.1： 使用来自ByteCounter的思路，实现一个针对单词和行数的计数器。你会发现bufio.ScanWords非常的有用。\n练习 7.2： 写一个带有如下函数签名的函数CountingWriter，传入一个io.Writer接口类型，返回一个把原来的Writer封装在里面的新的Writer类型和一个表示新的写入字节数的int64类型指针。\nfunc CountingWriter(w io.Writer) (io.Writer, *int64) 练习 7.3： 为在gopl.io/ch4/treesort（§4.4）中的*tree类型实现一个String方法去展示tree类型的值序列。\n"});index.add({'id':25,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.5.-Interface-Values/7.5.1.-Caveat-An-Interface-Containing-a-Nil-Pointer-Is-Non-Nil/','title':"7.5.1. 警告：一个包含nil指针的接口不是nil接口",'section':"7.5. 接口值",'content':"7.5.1. 警告：一个包含nil指针的接口不是nil接口 #  一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。\n思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。\nconst debug = true func main() { var buf *bytes.Buffer if debug { buf = new(bytes.Buffer) // enable collection of output \t} f(buf) // NOTE: subtly incorrect! \tif debug { // ...use buf... \t} } // If out is non-nil, output will be written to it. func f(out io.Writer) { // ...do something... \tif out != nil { out.Write([]byte(\u0026#34;done!\\n\u0026#34;)) } } 我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：\nif out != nil { out.Write([]byte(\u0026#34;done!\\n\u0026#34;)) // panic: nil pointer dereference } 当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!=nil的结果依然是true。\n 动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。\n问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：\nvar buf io.Writer if debug { buf = new(bytes.Buffer) // enable collection of output } f(buf) // OK 现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。\n"});index.add({'id':26,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.1.-Goroutines/','title':"8.1. Goroutines",'section':"8. Goroutines和Channels",'content':"8.1. Goroutines #  在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。\n如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。\n当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。\nf() // call f(); wait for it to return go f() // create a new goroutine that calls f(); don\u0026#39;t wait 下面的例子，main goroutine将计算菲波那契数列的第45个元素值。由于计算函数使用低效的递归，所以会运行相当长时间，在此期间我们想让用户看到一个可见的标识来表明程序依然在正常运行，所以来做一个动画的小图标：\ngopl.io/ch8/spinner\nfunc main() { go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow \tfmt.Printf(\u0026#34;\\rFibonacci(%d) = %d\\n\u0026#34;, n, fibN) } func spinner(delay time.Duration) { for { for _, r := range `-\\|/` { fmt.Printf(\u0026#34;\\r%c\u0026#34;, r) time.Sleep(delay) } } } func fib(x int) int { if x \u0026lt; 2 { return x } return fib(x-1) + fib(x-2) } 动画显示了几秒之后，fib(45)的调用成功地返回，并且打印结果：\nFibonacci(45) = 1134903170 然后主函数返回。主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。\n留意一下这里的两个独立的单元是如何进行组合的，spinning和菲波那契的计算。分别在独立的函数中，但两个函数会同时执行。\n"});index.add({'id':27,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.1.-Unbuffered-Channels/','title':"8.4.1. 不带缓存的Channels",'section':"8.4. Channels",'content':"8.4.1. 不带缓存的Channels #  一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。\n基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒唤醒发送者goroutine之前（译注：happens before，这是Go语言并发内存模型的一个关键术语！）。\n在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。\n当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。\n在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：\ngopl.io/ch8/netcat3\nfunc main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) if err != nil { log.Fatal(err) } done := make(chan struct{}) go func() { io.Copy(os.Stdout, conn) // NOTE: ignoring errors \tlog.Println(\u0026#34;done\u0026#34;) done \u0026lt;- struct{}{} // signal the main goroutine \t}() mustCopy(conn, os.Stdin) conn.Close() \u0026lt;-done // wait for background goroutine to finish } 当用户关闭了标准输入，主goroutine中的mustCopy函数调用将返回，然后调用conn.Close()关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-file）结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这是Go语言中启动goroutine常用的形式。）\n在后台goroutine返回之前，它先打印一个日志信息，然后向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。\n基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为消息事件。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用struct{}空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，done \u0026lt;- 1语句也比done \u0026lt;- struct{}{}更短。\n练习 8.3： 在netcat3例子中，conn虽然是一个interface类型的值，但是其底层真实类型是*net.TCPConn，代表一个TCP连接。一个TCP连接有读和写两个部分，可以使用CloseRead和CloseWrite方法分别关闭它们。修改netcat3的主goroutine代码，只关闭网络连接中写的部分，这样的话后台goroutine可以在标准输入被关闭后继续打印从reverb1服务器传回的数据。（要在reverb2服务器也完成同样的功能是比较困难的；参考练习 8.4。）\n"});index.add({'id':28,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.1.-Race-Conditions/','title':"9.1. 竞争条件",'section':"9. 基于共享变量的并发",'content':"9.1. 竞争条件 #  在一个线性（就是说只有一个goroutine的）的程序中，程序的执行顺序只由程序的逻辑来决定。例如，我们有一段语句序列，第一个在第二个之前（废话），以此类推。在有两个或更多goroutine的程序中，每一个goroutine内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。\n考虑一下，一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作。我们可以把这个概念概括为一个特定类型的一些方法和操作函数，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。\n在一个程序中有非并发安全的类型的情况下，我们依然可以使这个程序并发安全。确实，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它。我们会避免并发访问大多数的类型，无论是将变量局限在单一的一个goroutine内，还是用互斥条件维持更高级别的不变性，都是为了这个目的。我们会在本章中说明这些术语。\n相反，包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。\n一个函数在并发调用时没法工作的原因太多了，比如死锁（deadlock）、活锁（livelock）和饿死（resource starvation）。我们没有空去讨论所有的问题，这里我们只聚焦在竞争条件上。\n竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。\n传统上经常用经济损失来为竞争条件做比喻，所以我们来看一个简单的银行账户程序。\n// Package bank implements a bank with only one account. package bank var balance int func Deposit(amount int) { balance = balance + amount } func Balance() int { return balance } (当然我们也可以把Deposit存款函数写成balance += amount，这种形式也是等价的，不过长一些的形式解释起来更方便一些。)\n对于这个简单的程序而言，我们一眼就能看出，以任意顺序调用函数Deposit和Balance都会得到正确的结果。也就是说，Balance函数会给出之前的所有存入的额度之和。然而，当我们并发地而不是顺序地调用这些函数的话，Balance就再也没办法保证结果正确了。考虑一下下面的两个goroutine，其代表了一个银行联合账户的两笔交易：\n// Alice: go func() { bank.Deposit(200) // A1 \tfmt.Println(\u0026#34;=\u0026#34;, bank.Balance()) // A2 }() // Bob: go bank.Deposit(100) // B Alice存了$200，然后检查她的余额，同时Bob存了$100。因为A1和A2是和B并发执行的，我们没法预测他们发生的先后顺序。直观地来看的话，我们会认为其执行顺序只有三种可能性：“Alice先”，“Bob先”以及“Alice/Bob/Alice”交错执行。下面的表格会展示经过每一步骤后balance变量的值。引号里的字符串表示余额单。\nAlice first Bob first Alice/Bob/Alice 0 0 0 A1 200 B 100 A1 200 A2 \u0026quot;= 200\u0026quot; A1 300 B 300 B 300 A2 \u0026quot;= 300\u0026quot; A2 \u0026quot;= 300\u0026quot; 所有情况下最终的余额都是$300。唯一的变数是Alice的余额单是否包含了Bob交易，不过无论怎么着客户都不会在意。\n但是事实是上面的直觉推断是错误的。第四种可能的结果是事实存在的，这种情况下Bob的存款会在Alice存款操作中间，在余额被读到（balance + amount）之后，在余额被更新之前（balance = \u0026hellip;），这样会导致Bob的交易丢失。而这是因为Alice的存款操作A1实际上是两个操作的一个序列，读取然后写；可以称之为A1r和A1w。下面是交叉时产生的问题：\nData race 0 A1r 0 ... = balance + amount B 100 A1w 200 balance = ... A2 \u0026quot;= 200\u0026quot; 在A1r之后，balance + amount会被计算为200，所以这是A1w会写入的值，并不受其它存款操作的干预。最终的余额是$200。银行的账户上的资产比Bob实际的资产多了$100。（译注：因为丢失了Bob的存款操作，所以其实是说Bob的钱丢了。）\n这个程序包含了一个特定的竞争条件，叫作数据竞争。无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。\n如果数据竞争的对象是一个比一个机器字（译注：32位机器上一个字=4个字节）更大的类型时，事情就变得更麻烦了，比如interface，string或者slice类型都是如此。下面的代码会并发地更新两个不同长度的slice：\nvar x []int go func() { x = make([]int, 10) }() go func() { x = make([]int, 1000000) }() x[999999] = 1 // NOTE: undefined behavior; memory corruption possible! 最后一个语句中的x的值是未定义的；其可能是nil，或者也可能是一个长度为10的slice，也可能是一个长度为1,000,000的slice。但是回忆一下slice的三个组成部分：指针（pointer）、长度（length）和容量（capacity）。如果指针是从第一个make调用来，而长度从第二个make来，x就变成了一个混合体，一个自称长度为1,000,000但实际上内部只有10个元素的slice。这样导致的结果是存储999,999元素的位置会碰撞一个遥远的内存位置，这种情况下难以对值进行预测，而且debug也会变成噩梦。这种语义雷区被称为未定义行为，对C程序员来说应该很熟悉；幸运的是在Go语言里造成的麻烦要比C里小得多。\n尽管并发程序的概念让我们知道并发并不是简单的语句交叉执行。我们将会在9.4节中看到，数据竞争可能会有奇怪的结果。许多程序员，甚至一些非常聪明的人也还是会偶尔提出一些理由来允许数据竞争，比如：“互斥条件代价太高”，“这个逻辑只是用来做logging”，“我不介意丢失一些消息”等等。因为在他们的编译器或者平台上很少遇到问题，可能给了他们错误的信心。一个好的经验法则是根本就没有什么所谓的良性数据竞争。所以我们一定要避免数据竞争，那么在我们的程序中要如何做到呢？\n我们来重复一下数据竞争的定义，因为实在太重要了：数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。根据上述定义，有三种方式可以避免数据竞争：\n第一种方法是不要去写变量。考虑一下下面的map，会被“懒”填充，也就是说在每个key被第一次请求到的时候才会去填值。如果Icon是被顺序调用的话，这个程序会工作很正常，但如果Icon被并发调用，那么对于这个map来说就会存在数据竞争。\nvar icons = make(map[string]image.Image) func loadIcon(name string) image.Image // NOTE: not concurrency-safe! func Icon(name string) image.Image { icon, ok := icons[name] if !ok { icon = loadIcon(name) icons[name] = icon } return icon } 反之，如果我们在创建goroutine之前的初始化阶段，就初始化了map中的所有条目并且再也不去修改它们，那么任意数量的goroutine并发访问Icon都是安全的，因为每一个goroutine都只是去读取而已。\nvar icons = map[string]image.Image{ \u0026#34;spades.png\u0026#34;: loadIcon(\u0026#34;spades.png\u0026#34;), \u0026#34;hearts.png\u0026#34;: loadIcon(\u0026#34;hearts.png\u0026#34;), \u0026#34;diamonds.png\u0026#34;: loadIcon(\u0026#34;diamonds.png\u0026#34;), \u0026#34;clubs.png\u0026#34;: loadIcon(\u0026#34;clubs.png\u0026#34;), } // Concurrency-safe. func Icon(name string) image.Image { return icons[name] } 上面的例子里icons变量在包初始化阶段就已经被赋值了，包的初始化是在程序main函数开始执行之前就完成了的。只要初始化完成了，icons就再也不会被修改。数据结构如果从不被修改或是不变量则是并发安全的，无需进行同步。不过显然，如果update操作是必要的，我们就没法用这种方法，比如说银行账户。\n第二种避免数据竞争的方法是，避免从多个goroutine访问变量。这也是前一章中大多数程序所采用的方法。例如前面的并发web爬虫（§8.6）的main goroutine是唯一一个能够访问seen map的goroutine，而聊天服务器（§8.10）中的broadcaster goroutine是唯一一个能够访问clients map的goroutine。这些变量都被限定在了一个单独的goroutine中。\n由于其它的goroutine不能够直接访问变量，它们只能使用一个channel来发送请求给指定的goroutine来查询更新变量。这也就是Go的口头禅“不要使用共享数据来通信；使用通信来共享数据”。一个提供对一个指定的变量通过channel来请求的goroutine叫做这个变量的monitor（监控）goroutine。例如broadcaster goroutine会监控clients map的全部访问。\n下面是一个重写了的银行的例子，这个例子中balance变量被限制在了monitor goroutine中，名为teller：\ngopl.io/ch9/bank1\n// Package bank provides a concurrency-safe bank with one account. package bank var deposits = make(chan int) // send amount to deposit var balances = make(chan int) // receive balance  func Deposit(amount int) { deposits \u0026lt;- amount } func Balance() int { return \u0026lt;-balances } func teller() { var balance int // balance is confined to teller goroutine \tfor { select { case amount := \u0026lt;-deposits: balance += amount case balances \u0026lt;- balance: } } } func init() { go teller() // start the monitor goroutine } 即使当一个变量无法在其整个生命周期内被绑定到一个独立的goroutine，绑定依然是并发问题的一个解决方案。例如在一条流水线上的goroutine之间共享变量是很普遍的行为，在这两者间会通过channel来传输地址信息。如果流水线的每一个阶段都能够避免在将变量传送到下一阶段后再去访问它，那么对这个变量的所有访问就是线性的。其效果是变量会被绑定到流水线的一个阶段，传送完之后被绑定到下一个，以此类推。这种规则有时被称为串行绑定。\n下面的例子中，Cakes会被严格地顺序访问，先是baker gorouine，然后是icer gorouine：\ntype Cake struct{ state string } func baker(cooked chan\u0026lt;- *Cake) { for { cake := new(Cake) cake.state = \u0026#34;cooked\u0026#34; cooked \u0026lt;- cake // baker never touches this cake again \t} } func icer(iced chan\u0026lt;- *Cake, cooked \u0026lt;-chan *Cake) { for cake := range cooked { cake.state = \u0026#34;iced\u0026#34; iced \u0026lt;- cake // icer never touches this cake again \t} } 第三种避免数据竞争的方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“互斥”，在下一节来讨论这个主题。\n练习 9.1： 给gopl.io/ch9/bank1程序添加一个Withdraw(amount int)取款函数。其返回结果应该要表明事务是成功了还是因为没有足够资金失败了。这条消息会被发送给monitor的goroutine，且消息需要包含取款的额度和一个新的channel，这个新channel会被monitor goroutine来把boolean结果发回给Withdraw。\n"});index.add({'id':29,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.1.-Growable-Stacks/','title':"9.8.1. 动态栈\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",'section':"9.8. Goroutines和线程",'content':"9.8.1. 动态栈 #  每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。\n相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。\n** 练习 9.4:** 创建一个流水线程序，支持用channel连接任意数量的goroutine，在跑爆内存之前，可以创建多少流水线阶段？一个变量通过整个流水线需要用多久？（这个练习题翻译不是很确定）\n"});index.add({'id':30,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.1.-The-go-test-Tool/','title':"go test",'section':"11. 测试",'content':"11.1. go test #  go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。\n在*_test.go文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。\ngo test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。\n"});index.add({'id':31,'href':'/docs/Clean-Code/','title':"Go语言圣经",'section':"Docs",'content':"代码整洁之道 #  《代码整洁之道》中文翻译\n在线阅读： http://gdut_yy.gitee.io/doc-cleancode/\n前言 #  Index #    第 1 章 整洁代码  第 2 章 有意义的命名  第 3 章 函数  第 4 章 注释  第 5 章 格式  第 6 章 对象和数据结构  第 7 章 错误处理  第 8 章 边界  第 9 章 单元测试  第 10 章 类  第 11 章 系统  第 12 章 迭进  第 13 章 并发编程  第 14 章 逐步改进  第 15 章 JUnit 内幕  第 16 章 重构 SerialDate  第 17 章 味道与启发  附录 A 并发编程 II  "});index.add({'id':32,'href':'/docs/The-Go-Programming-Language/Preface/The-Origins-of-Go/','title':"Go语言起源",'section':"前言",'content':"Go语言起源 #  编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都会继承它们祖先的优点；当然有时多种语言杂合也可能会产生令人惊讶的特性；还有一些激进的新特性可能并没有先例。通过观察这些影响，我们可以学到为什么一门语言是这样子的，它已经适应了怎样的环境。\n下图展示了有哪些早期的编程语言对Go语言的设计产生了重要影响。\n Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。\n但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自 Niklaus Wirth所设计的[Pascal][Pascal]语言。然后[Modula-2][Modula-2]语言激发了包的概念。然后[Oberon][Oberon]语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的[Oberon-2][Oberon-2]语言直接影响了包的导入和声明的语法，还有[Oberon][Oberon]语言的面向对象特性所提供的方法的声明语法等。\nGo语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的 Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献 顺序通信进程 （ [communicating sequential processes][CSP] ，缩写为[CSP][CSP]。在[CSP][CSP]中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过 Tony Hoare的[CSP][CSP]只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。\n接下来，Rob Pike和其他人开始不断尝试将 CSP引入实际的编程语言中。他们第一次尝试引入 CSP特性的编程语言叫 Squeak（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的 Newsqueak语言，提供了类似C语言语句和表达式的语法和类似[Pascal][Pascal]语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建的，属于第一类值，可以保存到变量中。\n在Plan9操作系统中，这些优秀的想法被吸收到了一个叫[Alef][Alef]的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在Alef之后还有一个叫[Limbo][Limbo]的编程语言，Go语言从其中借鉴了很多特性。 具体请参考Pike的讲稿：http://talks.golang.org/2012/concurrency.slide#9 ）\nGo语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从[APL][APL]语言借鉴，词法作用域与嵌套函数来自于[Scheme][Scheme]语言（和其他很多语言）。当然，我们也可以从Go中发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。\n"});index.add({'id':33,'href':'/docs/The-Go-Programming-Language/Preface/','title':"前言",'section':"Go语言圣经",'content':"前言 #  “Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。”（摘自Go语言官方网站：http://golang.org ）\nGo语言由来自Google公司的 Robert Griesemer， Rob Pike和 Ken Thompson三位大牛于2007年9月开始设计和实现，然后于2009年的11月对外正式发布（译注：关于Go语言的创世纪过程请参考 http://talks.golang.org/2015/how-go-was-made.slide ）。语言及其配套工具的设计目标是具有表达力，高效的编译和执行效率，有效地编写高效和健壮的程序。\nGo语言有着和C语言类似的语法外表，和C语言一样是专业程序员的必备工具，可以用最小的代价获得最大的战果。 但是它不仅仅是一个更新的C语言。它还从其他语言借鉴了很多好的想法，同时避免引入过度的复杂性。 Go语言中和并发编程相关的特性是全新的也是有效的，同时对数据抽象和面向对象编程的支持也很灵活。 Go语言同时还集成了自动垃圾收集技术用于更好地管理内存。\nGo语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。 但是Go语言确实是一个通用的编程语言，它也可以用在图形图像驱动编程、移动应用程序开发 和机器学习等诸多领域。目前Go语言已经成为受欢迎的作为无类型的脚本语言的替代者： 因为Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。\nGo语言还是一个开源的项目，可以免费获取编译器、库、配套工具的源代码。 Go语言的贡献者来自一个活跃的全球社区。Go语言可以运行在类 UNIX系统—— 比如 Linux、 FreeBSD、 OpenBSD、 Mac OSX——和 Plan9系统和 Microsoft Windows操作系统之上。 Go语言编写的程序无需修改就可以运行在上面这些环境。\n本书是为了帮助你开始以有效的方式使用Go语言，充分利用语言本身的特性和自带的标准库去编写清晰地道的Go程序。\n"});index.add({'id':34,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/','title':"1. 入门",'section':"Go语言圣经",'content':"第一章　入门 #  本章介绍Go语言的基础组件。本章提供了足够的信息和示例程序，希望可以帮你尽快入门，写出有用的程序。本章和之后章节的示例程序都针对你可能遇到的现实案例。先了解几个Go程序，涉及的主题从简单的文件处理、图像处理到互联网客户端和服务端并发。当然，第一章不会解释细枝末节，但用这些程序来学习一门新语言还是很有效的。\n学习一门新语言时，会有一种自然的倾向，按照自己熟悉的语言的套路写新语言程序。学习Go语言的过程中，请警惕这种想法，尽量别这么做。我们会演示怎么写好Go语言程序，所以，请使用本书的代码作为你自己写程序时的指南。\n"});index.add({'id':35,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.2.-Command-Line-Arguments/','title':"1.2. 命令行参数",'section':"1. 入门",'content':"1.2. 命令行参数 #  大多数的程序都是处理输入，产生输出；这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？一些程序生成自己的数据，但通常情况下，输入来自于程序外部：文件、网络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源。下面几个例子会讨论其中几个输入源，首先是命令行参数。\nos包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。\nos.Args变量是一个字符串（string）的切片（slice）（译注：slice和Python语言中的切片类似，是一个简版的动态数组），切片是Go语言的基础概念，稍后详细介绍。现在先把切片s当作数组元素序列，序列的长度动态变化，用s[i]访问单个元素，用s[m:n]获取子序列（译注：和python里的语法差不多）。序列的元素数目为len(s)。和大多数编程语言类似，区间索引时，Go言里也采用左闭右开形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。（译注：比如a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3]，不包含最后一个元素）。比如s[m:n]这个切片，0 ≤ m ≤ n ≤ len(s)，包含n-m个元素。\nos.Args的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数。s[m:n]形式的切片表达式，产生从第m个元素到第n-1个元素的切片，下个例子用到的元素包含在os.Args[1:len(os.Args)]切片中。如果省略切片表达式的m或n，会默认传入0或len(s)，因此前面的切片可以简写成os.Args[1:]。\n下面是Unix里echo命令的一份实现，echo把它的命令行参数打印成一行。程序导入了两个包，用括号把它们括起来写成列表形式，而没有分开写成独立的import声明。两种形式都合法，列表形式习惯上用得多。包导入顺序并不重要；gofmt工具格式化时按照字母顺序对包名排序。（示例有多个版本时，我们会对示例编号，这样可以明确当前正在讨论的是哪个。）\ngopl.io/ch1/echo1\n// Echo1 prints its command-line arguments. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { var s, sep string for i := 1; i \u0026lt; len(os.Args); i++ { s += sep + os.Args[i] sep = \u0026#34; \u0026#34; } fmt.Println(s) } 注释语句以//开头。对于程序员来说，//之后到行末之间所有的内容都是注释，被编译器忽略。按照惯例，我们在每个包的包声明前添加注释；对于main package，注释包含一句或几句话，从整体角度对程序做个描述。\nvar声明定义了两个string类型的变量s和sep。变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的零值（zero value），数值类型是0，字符串类型是空字符串\u0026rdquo;\u0026quot;。这个例子里，声明把s和sep隐式地初始化成空字符串。第2章再来详细地讲解变量和声明。\n对数值类型，Go语言提供了常规的数值和逻辑运算符。而对string类型，+运算符连接字符串（译注：和C++或者js是一样的）。所以表达式：\nsep + os.Args[i] 表示连接字符串sep和os.Args。程序中使用的语句：\ns += sep + os.Args[i] 是一条赋值语句，将s的旧值跟sep与os.Args[i]连接后赋值回s，等价于：\ns = s + sep + os.Args[i] 运算符+=是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，如+或*，都有对应的赋值运算符。\necho程序可以每循环一次输出一个参数，这个版本却是不断地把新文本追加到末尾来构造字符串。字符串s开始为空，即值为\u0026rdquo;\u0026quot;，每次循环会添加一些文本；第一次迭代之后，还会再插入一个空格，因此循环结束时每个参数中间都有一个空格。这是一种二次加工（quadratic process），当参数数量庞大时，开销很大，但是对于echo，这种情形不大可能出现。本章会介绍echo的若干改进版，下一章解决低效问题。\n循环索引变量i在for循环的第一部分中定义。符号:=是短变量声明（short variable declaration）的一部分，这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句。下一章有这方面更多说明。\n自增语句i++给i加1；这和i += 1以及i = i + 1都是等价的。对应的还有i--给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i++非法，而且++和\u0026ndash;都只能放在变量名后面，因此--i也非法。\nGo语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：\nfor initialization; condition; post { // zero or more statements } for循环三个部分不需括号包围。大括号强制要求，左大括号必须和post语句在同一行。\ninitialization语句是可选的，在循环开始前执行。initalization如果存在，必须是一条简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。condition是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。post语句在循环体执行结束后执行，之后再次对condition求值。condition值为false时，循环结束。\nfor循环的这三个部分每个都可以省略，如果省略initialization和post，分号也可以省略：\n// a traditional \u0026#34;while\u0026#34; loop for condition { // ... } 如果连condition也省略了，像下面这样：\n// a traditional infinite loop for { // ... } 这就变成一个无限循环，尽管如此，还可以用其他方式终止循环，如一条break或return语句。\nfor循环的另一种形式，在某种数据类型的区间（range）上遍历，如字符串或切片。echo的第二版本展示了这种形式：\ngopl.io/ch1/echo2\n// Echo2 prints its command-line arguments. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { s, sep := \u0026#34;\u0026#34;, \u0026#34;\u0026#34; for _, arg := range os.Args[1:] { s += sep + arg sep = \u0026#34; \u0026#34; } fmt.Println(s) } 每次循环迭代，range产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但range的语法要求，要处理元素，必须处理索引。一种思路是把索引赋值给一个临时变量（如temp）然后忽略它的值，但Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。\nGo语言中这种情况的解决方法是用空标识符（blank identifier），即_（也就是下划线）。空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候（如：在循环里）丢弃不需要的循环索引，并保留元素值。大多数的Go程序员都会像上面这样使用range和_写echo程序，因为隐式地而非显式地索引os.Args，容易写对。\necho的这个版本使用一条短变量声明来声明并初始化s和seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：\ns := \u0026#34;\u0026#34; var s string var s = \u0026#34;\u0026#34; var s string = \u0026#34;\u0026#34; 用哪种不用哪种，为什么呢？第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。第二种形式依赖于字符串的默认初始化零值机制，被初始化为\u0026rdquo;\u0026quot;。第三种形式用得很少，除非同时声明多个变量。第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。\n如前文所述，每次循环迭代字符串s的内容都会更新。+=连接原字符串、空格和下个参数，产生新字符串，并把它赋值给s。s原来的内容已经不再使用，将在适当时机对它进行垃圾回收。\n如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用strings包的Join函数：\ngopl.io/ch1/echo3\nfunc main() { fmt.Println(strings.Join(os.Args[1:], \u0026#34; \u0026#34;)) } 最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用Println为我们格式化输出。\nfmt.Println(os.Args[1:]) 这条语句的输出结果跟strings.Join得到的结果很像，只是被放到了一对方括号里。切片都会被打印成这种格式。\n练习 1.1： 修改echo程序，使其能够打印os.Args[0]，即被执行命令本身的名字。\n练习 1.2： 修改echo程序，使其打印每个参数的索引和值，每个一行。\n练习 1.3： 做实验测量潜在低效的版本和使用了strings.Join的版本的运行时间差异。（1.6节讲解了部分time包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）\n"});index.add({'id':36,'href':'/docs/Clean-Code/1.-Clean-Code/1.2.-Bad-Code/','title':"1.2. 糟糕的代码",'section':"1. 整洁代码",'content':"1.2 糟糕的代码 #  I was recently reading the preface to Kent Beck’s book Implementation Patterns.1 He says, “… this book is based on a rather fragile premise: that good code matters….” A fragile premise? I disagree! I think that premise is one of the most robust, supported, and overloaded of all the premises in our craft (and I think Kent knows it). We know good code matters because we’ve had to deal for so long with its lack.\n 最近我在读 Kent Beck 著 Implementation Patterns（中译版《实现模式》）[1]一书的序言。他这样写道：“……本书基于一种不太牢靠的前提：好代码的确重要……”这前提不牢靠？我反对！我认为这是该领域最强固、最受支持、最被强调的前提了（我想 Kent 也知道）。我们知道好代码重要，是因为其短缺实在困扰了我们太久。\n I know of one company that, in the late 80s, wrote a killer app. It was very popular, and lots of professionals bought and used it. But then the release cycles began to stretch. Bugs were not repaired from one release to the next. Load times grew and crashes increased. I remember the day I shut the product down in frustration and never used it again. The company went out of business a short time after that.\n 20 世纪 80 年代末，有家公司写了个很流行的杀手应用，许多专业人士都买来用。然后，发布周期开始拉长。缺陷总是不能修复。装载时间越来越久，崩溃的几率也越来越大。至今我还记得自己在某天沮丧地关掉那个程序，从此再不用它。在那之后不久，该公司就关门大吉了。\n  Two decades later I met one of the early employees of that company and asked him what had happened. The answer confirmed my fears. They had rushed the product to market and had made a huge mess in the code. As they added more and more features, the code got worse and worse until they simply could not manage it any longer. It was the bad code that brought the company down.\n 20 年后，我见到那家公司的一位早期雇员，问他当年发生了什么事。他的回答叫我愈发恐惧起来。原来，当时他们赶着推出产品，代码写得乱七八糟。特性越加越多，代码也越来越烂，最后再也没法管理这些代码了。是糟糕的代码毁了这家公司。\n Have you ever been significantly impeded by bad code? If you are a programmer of any experience then you’ve felt this impediment many times. Indeed, we have a name for it. We call it wading. We wade through bad code. We slog through a morass of tangled brambles and hidden pitfalls. We struggle to find our way, hoping for some hint, some clue, of what is going on; but all we see is more and more senseless code.\n 你是否曾为糟糕的代码所深深困扰？如果你是位有点儿经验的程序员，定然多次遇到过这类困境。我们有专用来形容这事的词：沼泽（wading）。我们趟过代码的水域。我们穿过灌木密布、瀑布暗藏的沼泽地。我们拼命想找到出路，期望有点什么线索能启发我们到底发生了什么事；但目光所及，只是越来越多死气沉沉的代码。\n Of course you have been impeded by bad code. So then—why did you write it?\n 你当然曾为糟糕的代码所困扰过。那么——为什么要写糟糕的代码呢？\n Were you trying to go fast? Were you in a rush? Probably so. Perhaps you felt that you didn’t have time to do a good job; that your boss would be angry with you if you took the time to clean up your code. Perhaps you were just tired of working on this program and wanted it to be over. Or maybe you looked at the backlog of other stuff that you had promised to get done and realized that you needed to slam this module together so you could move on to the next. We’ve all done it.\n 是想快点完成吗？是要赶时间吗？有可能。或许你觉得自己要干好所需的时间不够；假使花时间清理代码，老板就会大发雷霆。或许你只是不耐烦再搞这套程序，期望早点结束。或许你看了看自己承诺要做的其他事，意识到得赶紧弄完手上的东西，好接着做下一件工作。这种事我们都干过。\n We’ve all looked at the mess we’ve just made and then have chosen to leave it for another day. We’ve all felt the relief of seeing our messy program work and deciding that a working mess is better than nothing. We’ve all said we’d go back and clean it up later. Of course, in those days we didn’t know LeBlanc’s law: Later equals never.\n 我们都曾经瞟一眼自己亲手造成的混乱，决定弃之而不顾，走向新一天。我们都曾经看到自己的烂程序居然能运行，然后断言能运行的烂程序总比什么都没有强。我们都曾经说过有朝一日再回头清理。当然，在那些日子里，我们都没听过勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）。\n "});index.add({'id':37,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.2.-Import-Paths/','title':"10.2. 导入路径",'section':"10. 包和工具",'content':"10.2. 导入路径 #  每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;golang.org/x/net/html\u0026#34; \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) 就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类似 Bazel的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境），用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。\n如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。\n"});index.add({'id':38,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.2.-Downloading-Packages/','title':"10.7.2. 下载包",'section':"10.7. 工具",'content':"10.7.2. 下载包 #  使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。\n使用命令go get可以下载一个单一的包或者用...下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org/x/net/html自动出现在本地工作区目录的原因。\n一旦go get命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的gopl.io/ch2/popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档：\n$ go get github.com/golang/lint/golint $ $GOPATH/bin/golint gopl.io/ch2/popcount src/gopl.io/ch2/popcount/main.go:1:1: package comment should be of the form \u0026quot;Package popcount ...\u0026quot; go get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行go help importpath获取相关的信息。\ngo get命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org/x/net包目录对应一个Git仓库：\n$ cd $GOPATH/src/golang.org/x/net $ git remote -v origin https://go.googlesource.com/net (fetch) origin https://go.googlesource.com/net (push) 需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 https://golang.org/x/net/html 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：\n$ go build gopl.io/ch1/fetch $ ./fetch https://golang.org/x/net/html | grep go-import \u0026lt;meta name=\u0026quot;go-import\u0026quot; content=\u0026quot;golang.org/x/net git https://go.googlesource.com/net\u0026quot;\u0026gt; 如果指定-u命令行标志参数，go get命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。\ngo get -u命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org/x/net/html导入路径可能会变为gopl.io/vendor/golang.org/x/net/html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过go help gopath命令查看Vendor的帮助文档。\n(译注：墙内用户在上面这些命令的基础上，还需要学习用翻墙来go get。)\n练习 10.3: 从 http://gopl.io/ch1/helloworld?go-get=1 获取内容，查看本书的代码的真实托管的网址（go get请求HTML页面时包含了go-get参数，以区别普通的浏览器请求）。\n"});index.add({'id':39,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/','title':"11.2. 测试函数",'section':"11. 测试",'content':"11.2. 测试函数 #  每个测试函数必须导入testing包。测试函数有如下的签名：\nfunc TestName(t *testing.T) { // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：\nfunc TestSin(t *testing.T) { /* ... */ } func TestCos(t *testing.T) { /* ... */ } func TestLog(t *testing.T) { /* ... */ } 其中t参数用于报告测试失败和附加的日志信息。让我们定义一个实例包gopl.io/ch11/word1，其中只有一个函数IsPalindrome用于检查一个字符串是否从前向后和从后向前读都是一样的。（下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。）\ngopl.io/ch11/word1\n// Package word provides utilities for word games. package word // IsPalindrome reports whether s reads the same forward and backward. // (Our first attempt.) func IsPalindrome(s string) bool { for i := range s { if s[i] != s[len(s)-1-i] { return false } } return true } 在相同的目录下，word_test.go测试文件中包含了TestPalindrome和TestNonPalindrome两个测试函数。每一个都是测试IsPalindrome是否给出正确的结果，并使用t.Error报告失败信息：\npackage word import \u0026#34;testing\u0026#34; func TestPalindrome(t *testing.T) { if !IsPalindrome(\u0026#34;detartrated\u0026#34;) { t.Error(`IsPalindrome(\u0026#34;detartrated\u0026#34;) = false`) } if !IsPalindrome(\u0026#34;kayak\u0026#34;) { t.Error(`IsPalindrome(\u0026#34;kayak\u0026#34;) = false`) } } func TestNonPalindrome(t *testing.T) { if IsPalindrome(\u0026#34;palindrome\u0026#34;) { t.Error(`IsPalindrome(\u0026#34;palindrome\u0026#34;) = true`) } } go test命令如果没有参数指定包那么将默认采用当前目录对应的包（和go build命令一样）。我们可以用下面的命令构建和运行测试。\n$ cd $GOPATH/src/gopl.io/ch11/word1 $ go test ok gopl.io/ch11/word1 0.008s 结果还比较满意，我们运行了这个程序， 不过没有提前退出是因为还没有遇到BUG报告。不过一个法国名为“Noelle Eve Elleon”的用户会抱怨IsPalindrome函数不能识别“été”。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”。执行特殊和小的BUG报告为我们提供了新的更自然的测试用例。\nfunc TestFrenchPalindrome(t *testing.T) { if !IsPalindrome(\u0026#34;été\u0026#34;) { t.Error(`IsPalindrome(\u0026#34;été\u0026#34;) = false`) } } func TestCanalPalindrome(t *testing.T) { input := \u0026#34;A man, a plan, a canal: Panama\u0026#34; if !IsPalindrome(input) { t.Errorf(`IsPalindrome(%q) = false`, input) } } 为了避免两次输入较长的字符串，我们使用了提供了有类似Printf格式化功能的 Errorf函数来汇报错误结果。\n当添加了这两个测试用例之后，go test返回了测试失败的信息。\n$ go test --- FAIL: TestFrenchPalindrome (0.00s) word_test.go:28: IsPalindrome(\u0026quot;été\u0026quot;) = false --- FAIL: TestCanalPalindrome (0.00s) word_test.go:35: IsPalindrome(\u0026quot;A man, a plan, a canal: Panama\u0026quot;) = false FAIL FAIL gopl.io/ch11/word1 0.014s 先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。\n先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。\n参数-v可用于打印每个测试函数的名字和运行时间：\n$ go test -v === RUN TestPalindrome --- PASS: TestPalindrome (0.00s) === RUN TestNonPalindrome --- PASS: TestNonPalindrome (0.00s) === RUN TestFrenchPalindrome --- FAIL: TestFrenchPalindrome (0.00s) word_test.go:28: IsPalindrome(\u0026quot;été\u0026quot;) = false === RUN TestCanalPalindrome --- FAIL: TestCanalPalindrome (0.00s) word_test.go:35: IsPalindrome(\u0026quot;A man, a plan, a canal: Panama\u0026quot;) = false FAIL exit status 1 FAIL gopl.io/ch11/word1 0.017s 参数-run对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行：\n$ go test -v -run=\u0026quot;French|Canal\u0026quot; === RUN TestFrenchPalindrome --- FAIL: TestFrenchPalindrome (0.00s) word_test.go:28: IsPalindrome(\u0026quot;été\u0026quot;) = false === RUN TestCanalPalindrome --- FAIL: TestCanalPalindrome (0.00s) word_test.go:35: IsPalindrome(\u0026quot;A man, a plan, a canal: Panama\u0026quot;) = false FAIL exit status 1 FAIL gopl.io/ch11/word1 0.014s 当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的go test命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。\n我们现在的任务就是修复这些错误。简要分析后发现第一个BUG的原因是我们采用了 byte而不是rune序列，所以像“été”中的é等非ASCII字符不能正确处理。第二个BUG是因为没有忽略空格和字母的大小写导致的。\n针对上述两个BUG，我们仔细重写了函数：\ngopl.io/ch11/word2\n// Package word provides utilities for word games. package word import \u0026#34;unicode\u0026#34; // IsPalindrome reports whether s reads the same forward and backward. // Letter case is ignored, as are non-letters. func IsPalindrome(s string) bool { var letters []rune for _, r := range s { if unicode.IsLetter(r) { letters = append(letters, unicode.ToLower(r)) } } for i := range letters { if letters[i] != letters[len(letters)-1-i] { return false } } return true } 同时我们也将之前的所有测试数据合并到了一个测试中的表格中。\nfunc TestIsPalindrome(t *testing.T) { var tests = []struct { input string want bool }{ {\u0026#34;\u0026#34;, true}, {\u0026#34;a\u0026#34;, true}, {\u0026#34;aa\u0026#34;, true}, {\u0026#34;ab\u0026#34;, false}, {\u0026#34;kayak\u0026#34;, true}, {\u0026#34;detartrated\u0026#34;, true}, {\u0026#34;A man, a plan, a canal: Panama\u0026#34;, true}, {\u0026#34;Evil I did dwell; lewd did I live.\u0026#34;, true}, {\u0026#34;Able was I ere I saw Elba\u0026#34;, true}, {\u0026#34;été\u0026#34;, true}, {\u0026#34;Et se resservir, ivresse reste.\u0026#34;, true}, {\u0026#34;palindrome\u0026#34;, false}, // non-palindrome \t{\u0026#34;desserts\u0026#34;, false}, // semi-palindrome \t} for _, test := range tests { if got := IsPalindrome(test.input); got != test.want { t.Errorf(\u0026#34;IsPalindrome(%q) = %v\u0026#34;, test.input, got) } } } 现在我们的新测试都通过了：\n$ go test gopl.io/ch11/word2 ok gopl.io/ch11/word2 0.015s 这种表格驱动的测试在Go语言中很常见。我们可以很容易地向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力去完善错误信息。\n失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。\n如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。\n测试失败的信息一般的形式是“f(x) = y, want z”，其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。就像前面检查回文字符串的例子，实际的函数用于f(x)部分。显示x是表格驱动型测试中比较重要的部分，因为同一个断言可能对应不同的表格项执行多次。要避免无用和冗余的信息。在测试类似IsPalindrome返回布尔类型的函数时，可以忽略并没有额外信息的z部分。如果x、y或z是y的长度，输出一个相关部分的简明总结即可。测试的作者应该要努力帮助程序员诊断测试失败的原因。\n练习 11.1: 为4.3节中的charcount程序编写测试。\n练习 11.2: 为（§6.5）的IntSet编写一组测试，用于检查每个操作后的行为和基于内置map的集合等价，后面练习11.7将会用到。\n"});index.add({'id':40,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.2.-Testing-a-Command/','title':"11.2.2. 测试一个命令",'section':"11.2. 测试函数",'content':"11.2.2. 测试一个命令 #  对于测试包go test是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。\n让我们为2.3.2节的echo程序编写一个测试。我们先将程序拆分为两个函数：echo函数完成真正的工作，main函数用于处理命令行输入参数和echo可能返回的错误。\ngopl.io/ch11/echo\n// Echo prints its command-line arguments. package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) var ( n = flag.Bool(\u0026#34;n\u0026#34;, false, \u0026#34;omit trailing newline\u0026#34;) s = flag.String(\u0026#34;s\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;separator\u0026#34;) ) var out io.Writer = os.Stdout // modified during testing  func main() { flag.Parse() if err := echo(!*n, *s, flag.Args()); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;echo: %v\\n\u0026#34;, err) os.Exit(1) } } func echo(newline bool, sep string, args []string) error { fmt.Fprint(out, strings.Join(args, sep)) if newline { fmt.Fprintln(out) } return nil } 在测试中我们可以用各种参数和标志调用echo函数，然后检测它的输出是否正确，我们通过增加参数来减少echo函数对全局变量的依赖。我们还增加了一个全局名为out的变量来替代直接使用os.Stdout，这样测试代码可以根据需要将out修改为不同的对象以便于检查。下面就是echo_test.go文件中的测试代码：\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;testing\u0026#34; ) func TestEcho(t *testing.T) { var tests = []struct { newline bool sep string args []string want string }{ {true, \u0026#34;\u0026#34;, []string{}, \u0026#34;\\n\u0026#34;}, {false, \u0026#34;\u0026#34;, []string{}, \u0026#34;\u0026#34;}, {true, \u0026#34;\\t\u0026#34;, []string{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;}, \u0026#34;one\\ttwo\\tthree\\n\u0026#34;}, {true, \u0026#34;,\u0026#34;, []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}, \u0026#34;a,b,c\\n\u0026#34;}, {false, \u0026#34;:\u0026#34;, []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;}, \u0026#34;1:2:3\u0026#34;}, } for _, test := range tests { descr := fmt.Sprintf(\u0026#34;echo(%v, %q, %q)\u0026#34;, test.newline, test.sep, test.args) out = new(bytes.Buffer) // captured output \tif err := echo(test.newline, test.sep, test.args); err != nil { t.Errorf(\u0026#34;%s failed: %v\u0026#34;, descr, err) continue } got := out.(*bytes.Buffer).String() if got != test.want { t.Errorf(\u0026#34;%s = %q, want %q\u0026#34;, descr, got, test.want) } } } 要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。\n通过将测试放到表格中，我们很容易添加新的测试用例。让我通过增加下面的测试用例来看看失败的情况是怎么样的：\n{true, \u0026#34;,\u0026#34;, []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}, \u0026#34;a b c\\n\u0026#34;}, // NOTE: wrong expectation! go test输出如下：\n$ go test gopl.io/ch11/echo --- FAIL: TestEcho (0.00s) echo_test.go:31: echo(true, \u0026quot;,\u0026quot;, [\u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot;]) = \u0026quot;a,b,c\u0026quot;, want \u0026quot;a b c\\n\u0026quot; FAIL FAIL gopl.io/ch11/echo 0.006s 错误信息描述了尝试的操作（使用Go类似语法），实际的结果和期望的结果。通过这样的错误信息，你可以在检视代码之前就很容易定位错误的原因。\n要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。幸运的是（上面的意外只是一个插曲），我们的echo示例是比较简单的也没有需要返回非空error的情况。\n"});index.add({'id':41,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.2.-reflect.Type-and-reflect.Value/','title':"12.2. reflect.Type 和 reflect.Value",'section':"12. 反射",'content':"12.2. reflect.Type 和 reflect.Value #  反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 reflect.Type 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。\n函数 reflect.TypeOf 接受任意的 interface{} 类型，并以 reflect.Type 形式返回其动态类型：\nt := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // \u0026#34;int\u0026#34; fmt.Println(t) // \u0026#34;int\u0026#34; 其中 TypeOf(3) 调用将值 3 传给 interface{} 参数。回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是 int）和它的动态的值（这里是 3）。\n因为 reflect.TypeOf 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 \u0026ldquo;*os.File\u0026rdquo; 而不是 \u0026ldquo;io.Writer\u0026rdquo;。稍后，我们将看到能够表达接口类型的 reflect.Type。\nvar w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // \u0026#34;*os.File\u0026#34; 要注意的是 reflect.Type 接口是满足 fmt.Stringer 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， fmt.Printf 提供了一个缩写 %T 参数，内部使用 reflect.TypeOf 来输出：\nfmt.Printf(\u0026#34;%T\\n\u0026#34;, 3) // \u0026#34;int\u0026#34; reflect 包中另一个重要的类型是 Value。一个 reflect.Value 可以装载任意类型的值。函数 reflect.ValueOf 接受任意的 interface{} 类型，并返回一个装载着其动态值的 reflect.Value。和 reflect.TypeOf 类似，reflect.ValueOf 返回的结果也是具体的类型，但是 reflect.Value 也可以持有一个接口值。\nv := reflect.ValueOf(3) // a reflect.Value fmt.Println(v) // \u0026#34;3\u0026#34; fmt.Printf(\u0026#34;%v\\n\u0026#34;, v) // \u0026#34;3\u0026#34; fmt.Println(v.String()) // NOTE: \u0026#34;\u0026lt;int Value\u0026gt;\u0026#34; 和 reflect.Type 类似，reflect.Value 也满足 fmt.Stringer 接口，但是除非 Value 持有的是字符串，否则 String 方法只返回其类型。而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理。\n对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type：\nt := v.Type() // a reflect.Type fmt.Println(t.String()) // \u0026#34;int\u0026#34; reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法。它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值：\nv := reflect.ValueOf(3) // a reflect.Value x := v.Interface() // an interface{} i := x.(int) // an int fmt.Printf(\u0026#34;%d\\n\u0026#34;, i) // \u0026#34;3\u0026#34; reflect.Value 和 interface{} 都能装载任意的值。所不同的是，一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值（就像上面那样），内部值我们没法访问。相比之下，一个 Value 则有很多方法来检查其内容，无论它的具体类型是什么。让我们再次尝试实现我们的格式化函数 format.Any。\n我们使用 reflect.Value 的 Kind 方法来替代之前的类型 switch。虽然还是有无穷多的类型，但是它们的 kinds 类型却是有限的：Bool、String 和 所有数字类型的基础类型；Array 和 Struct 对应的聚合类型；Chan、Func、Ptr、Slice 和 Map 对应的引用类型；interface 类型；还有表示空值的 Invalid 类型。（空的 reflect.Value 的 kind 即为 Invalid。）\ngopl.io/ch12/format\npackage format import ( \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; ) // Any formats any value as a string. func Any(value interface{}) string { return formatAtom(reflect.ValueOf(value)) } // formatAtom formats a value without inspecting its internal structure. func formatAtom(v reflect.Value) string { switch v.Kind() { case reflect.Invalid: return \u0026#34;invalid\u0026#34; case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return strconv.FormatInt(v.Int(), 10) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: return strconv.FormatUint(v.Uint(), 10) // ...floating-point and complex cases omitted for brevity... \tcase reflect.Bool: return strconv.FormatBool(v.Bool()) case reflect.String: return strconv.Quote(v.String()) case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map: return v.Type().String() + \u0026#34; 0x\u0026#34; + strconv.FormatUint(uint64(v.Pointer()), 16) default: // reflect.Array, reflect.Struct, reflect.Interface \treturn v.Type().String() + \u0026#34; value\u0026#34; } } 到目前为止，我们的函数将每个值视作一个不可分割没有内部结构的物品，因此它叫 formatAtom。对于聚合类型（结构体和数组）和接口，只是打印值的类型，对于引用类型（channels、functions、pointers、slices 和 maps），打印类型和十六进制的引用地址。虽然还不够理想，但是依然是一个重大的进步，并且 Kind 只关心底层表示，format.Any 也支持具名类型。例如：\nvar x int64 = 1 var d time.Duration = 1 * time.Nanosecond fmt.Println(format.Any(x)) // \u0026#34;1\u0026#34; fmt.Println(format.Any(d)) // \u0026#34;1\u0026#34; fmt.Println(format.Any([]int64{x})) // \u0026#34;[]int64 0x8202b87b0\u0026#34; fmt.Println(format.Any([]time.Duration{d})) // \u0026#34;[]time.Duration 0x8202b87e0\u0026#34; "});index.add({'id':42,'href':'/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.2.-unsafe.Pointer/','title':"13.2. unsafe.Pointer",'section':"13. 底层编程",'content':"13.2. unsafe.Pointer #  大多数指针类型会写成*T，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的void*类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过*p来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。\n一个普通的*T类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的*T类型相同。通过将*float64类型指针转化为*uint64类型指针，我们可以查看一个浮点数变量的位模式。\npackage math func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(\u0026amp;f)) } fmt.Printf(\u0026#34;%#016x\\n\u0026#34;, Float64bits(1.0)) // \u0026#34;0x3ff0000000000000\u0026#34; 通过转为新类型指针，我们可以更新浮点数的位模式。通过位模式操作浮点数是可以的，但是更重要的意义是指针转换语法让我们可以在不破坏类型系统的前提下向内存写入任意的值。\n一个unsafe.Pointer指针也可以被转化为uintptr类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。（第三章内容，uintptr是一个无符号的整型数，足以保存一个地址）这种转换虽然也是可逆的，但是将uintptr转为unsafe.Pointer指针可能会破坏类型系统，因为并不是所有的数字都是有效的内存地址。\n许多将unsafe.Pointer指针转为原生数字，然后再转回为unsafe.Pointer类型指针的操作也是不安全的。比如下面的例子需要将变量x的地址加上b字段地址偏移量转化为*int16类型指针，然后通过该指针更新x.b：\ngopl.io/ch13/unsafeptr\nvar x struct { a bool b int16 c []int } // 和 pb := \u0026amp;x.b 等价 pb := (*int16)(unsafe.Pointer( uintptr(unsafe.Pointer(\u0026amp;x)) + unsafe.Offsetof(x.b))) *pb = 42 fmt.Println(x.b) // \u0026#34;42\u0026#34; 上面的写法尽管很繁琐，但在这里并不是一件坏事，因为这些功能应该很谨慎地使用。不要试图引入一个uintptr类型的临时变量，因为它可能会破坏代码的安全性（译注：这是真正可以体会unsafe包为何不安全的例子）。下面段代码是错误的：\n// NOTE: subtly incorrect! tmp := uintptr(unsafe.Pointer(\u0026amp;x)) + unsafe.Offsetof(x.b) pb := (*int16)(unsafe.Pointer(tmp)) *pb = 42 产生错误的原因很微妙。有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC。当一个变量被移动，所有的保存该变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动时对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的\u0026amp;x.b地址。第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！\n还有很多类似原因导致的错误。例如这条语句：\npT := uintptr(unsafe.Pointer(new(T))) // 提示: 错误! 这里并没有指针引用new新创建的变量，因此该语句执行完成之后，垃圾收集器有权马上回收其内存空间，所以返回的pT将是无效的地址。\n虽然目前的Go语言实现还没有使用移动GC（译注：未来可能实现），但这不该是编写错误代码侥幸的理由：当前的Go语言实现已经有移动变量的场景。在5.2节我们提到goroutine的栈是根据需要动态增长的。当发生栈动态增长的时候，原来栈中的所有变量可能需要被移动到新的更大的栈中，所以我们并不能确保变量的地址在整个使用周期内是不变的。\n在编写本文时，还没有清晰的原则来指引Go程序员，什么样的unsafe.Pointer和uintptr的转换是不安全的（参考 Issue7192 ）. 译注: 该问题已经关闭），因此我们强烈建议按照最坏的方式处理。将所有包含变量地址的uintptr类型变量当作BUG处理，同时减少不必要的unsafe.Pointer类型到uintptr类型的转换。在第一个例子中，有三个转换——字段偏移量到uintptr的转换和转回unsafe.Pointer类型的操作——所有的转换全在一个表达式完成。\n当调用一个库函数，并且返回的是uintptr类型地址时（译注：普通方法实现的函数尽量不要返回该类型。下面例子是reflect包的函数，reflect包和unsafe包一样都是采用特殊技术实现的，编译器可能给它们开了后门），比如下面反射包中的相关函数，返回的结果应该立即转换为unsafe.Pointer以确保指针指向的是相同的变量。\npackage reflect func (Value) Pointer() uintptr func (Value) UnsafeAddr() uintptr func (Value) InterfaceData() [2]uintptr // (index 1) "});index.add({'id':43,'href':'/docs/Clean-Code/2.-Meaningful-Names/','title':"2. 有意义的命名",'section':"Go语言圣经",'content':"第 2 章 有意义的命名 #   by Tim Ottinger\n"});index.add({'id':44,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.2.-Use-Intention-Revealing-Names/','title':"2.2. 名副其实",'section':"2. 有意义的命名",'content':"2.2 名副其实 #  It is easy to say that names should reveal intent. What we want to impress upon you is that we are serious about this. Choosing good names takes time but saves more than it takes. So take care with your names and change them when you find better ones. Everyone who reads your code (including you) will be happier if you do.\n 名副其实说起来简单。我们想要强调，这事很严肃。选个好名字要花时间，但省下来的时间比花掉的多。注意命名，而且一旦发现有更好的名称，就换掉旧的。这么做，读你代码的人（包括你自己）都会更开心。\n The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent.\n 变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。如果名称需要注释来补充，那就不算是名副其实。\n int d; // elapsed time in days The name d reveals nothing. It does not evoke a sense of elapsed time, nor of days. We should choose a name that specifies what is being measured and the unit of that measurement:\n 名称 d 什么也没说明。它没有引起对时间消逝的感觉，更别说以日计了。我们应该选择指明了计量对象和计量单位的名称：\n int elapsedTimeInDays; int daysSinceCreation; int daysSinceModification; int fileAgeInDays; Choosing names that reveal intent can make it much easier to understand and change code. What is the purpose of this code?\n 选择体现本意的名称能让人更容易理解和修改代码。下列代码的目的何在？\n public List\u0026lt;int[]\u0026gt; getThem() { List\u0026lt;int[]\u0026gt; list1 = new ArrayList\u0026lt;int[]\u0026gt;(); for (int[] x : theList) if (x[0] == 4) list1.add(x); return list1; } Why is it hard to tell what this code is doing? There are no complex expressions. Spacing and indentation are reasonable. There are only three variables and two constants mentioned. There aren’t even any fancy classes or polymorphic methods, just a list of arrays (or so it seems).\n 为什么难以说明上列代码要做什么事？里面并没有复杂的表达式。空格和缩进中规中矩。只用到三个变量和两个常量。甚至没有涉及任何其他类或多态方法，只是（或者看起来是）一个数组的列表而已。\n The problem isn’t the simplicity of the code but the implicity of the code (to coin a phrase): the degree to which the context is not explicit in the code itself. The code implicitly requires that we know the answers to questions such as:\n 问题不在于代码的简洁度，而是在于代码的模糊度：即上下文在代码中未被明确体现的程度。上列代码要求我们了解类似以下问题的答案：\n  What kinds of things are in theList? What is the significance of the zeroth subscript of an item in theList? What is the significance of the value 4? How would I use the list being returned?     theList 中是什么类型的东西？ theList 零下标条目的意义是什么？ 值 4 的意义是什么？ 我怎么使用返回的列表？   The answers to these questions are not present in the code sample, but they could have been. Say that we’re working in a mine sweeper game. We find that the board is a list of cells called theList. Let’s rename that to gameBoard.\n 问题的答案没体现在代码段中，可那就是它们该在的地方。比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其名称改为 gameBoard。\n Each cell on the board is represented by a simple array. We further find that the zeroth subscript is the location of a status value and that a status value of 4 means “flagged.” Just by giving these concepts names we can improve the code considerably:\n 盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而该种状态值为 4 表示“已标记”。只要改为有意义的名称，代码就会得到相当程度的改进：\n public List\u0026lt;int[]\u0026gt; getFlaggedCells() { List\u0026lt;int[]\u0026gt; flaggedCells = new ArrayList\u0026lt;int[]\u0026gt;(); for (int[] cell : gameBoard) if (cell[STATUS_VALUE] == FLAGGED) flaggedCells.add(cell); return flaggedCells; } Notice that the simplicity of the code has not changed. It still has exactly the same number of operators and constants, with exactly the same number of nesting levels. But the code has become much more explicit.\n 注意，代码的简洁性并未被触及。运算符和常量的数量全然保持不变，嵌套数量也全然保持不变。但代码变得明确多了。\n We can go further and write a simple class for cells instead of using an array of ints. It can include an intention-revealing function (call it isFlagged) to hide the magic numbers. It results in a new version of the function:\n 还可以更进一步，不用 int 数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。于是得到函数的新版本：\n public List\u0026lt;Cell\u0026gt; getFlaggedCells() { List\u0026lt;Cell\u0026gt; flaggedCells = new ArrayList\u0026lt;Cell\u0026gt;(); for (Cell cell : gameBoard) if (cell.isFlagged()) flaggedCells.add(cell); return flaggedCells; } With these simple name changes, it’s not difficult to understand what’s going on. This is the power of choosing good names.\n 只要简单改一下名称，就能轻易知道发生了什么。这就是选用好名称的力量。\n "});index.add({'id':45,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.2.-Declarations/','title':"2.2. 声明",'section':"2. 程序结构",'content':"2.2. 声明 #  声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。这一章我们重点讨论变量和类型的声明，第三章将讨论常量的声明，第五章将讨论函数的声明。\n一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。例如，下面的例子中声明了一个常量、一个函数和两个变量：\ngopl.io/ch2/boiling\n// Boiling prints the boiling point of water. package main import \u0026#34;fmt\u0026#34; const boilingF = 212.0 func main() { var f = boilingF var c = (f - 32) * 5 / 9 fmt.Printf(\u0026#34;boiling point = %g°F or %g°C\\n\u0026#34;, f, c) // Output: \t// boiling point = 212°F or 100°C } 其中常量boilingF是在包一级范围声明语句声明的，然后f和c两个变量是在main函数内部声明的声明语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。\n一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。\n我们已经看到过很多函数声明和函数调用的例子了，在第五章将深入讨论函数的相关细节，这里只简单解释下。下面的fToC函数封装了温度转换的处理逻辑，这样它只需要被定义一次，就可以在多个地方多次被使用。在这个例子中，main函数就调用了两次fToC函数，分别使用在局部定义的两个常量作为调用函数的参数。\ngopl.io/ch2/ftoc\n// Ftoc prints two Fahrenheit-to-Celsius conversions. package main import \u0026#34;fmt\u0026#34; func main() { const freezingF, boilingF = 32.0, 212.0 fmt.Printf(\u0026#34;%g°F = %g°C\\n\u0026#34;, freezingF, fToC(freezingF)) // \u0026#34;32°F = 0°C\u0026#34; \tfmt.Printf(\u0026#34;%g°F = %g°C\\n\u0026#34;, boilingF, fToC(boilingF)) // \u0026#34;212°F = 100°C\u0026#34; } func fToC(f float64) float64 { return (f - 32) * 5 / 9 } "});index.add({'id':46,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.2.-Pointers/','title':"2.3.2. 指针",'section':"2.3. 变量",'content':"2.3.2. 指针 #  一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但是还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是给对应变量赋予一个新的值。\n一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。\n如果用“var x int”声明语句声明一个x变量，那么\u0026amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。\nx := 1 p := \u0026amp;x // p, of type *int, points to x fmt.Println(*p) // \u0026#34;1\u0026#34; *p = 2 // equivalent to x = 2 fmt.Println(x) // \u0026#34;2\u0026#34; 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。\n变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受\u0026amp;取地址操作。\n任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。\nvar x, y int fmt.Println(\u0026amp;x == \u0026amp;x, \u0026amp;x == \u0026amp;y, \u0026amp;x == nil) // \u0026#34;true false false\u0026#34; 在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。\nvar p = f() func f() *int { v := 1 return \u0026amp;v } 每次调用f函数都将返回不同的结果：\nfmt.Println(f() == f()) // \u0026#34;false\u0026#34; 因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。例如下面这个例子就是通过指针来更新变量的值，然后返回更新后的值，可用在一个表达式中（译注：这是对C语言中++v操作的模拟，这里只是为了说明指针的用法，incr函数模拟的做法并不推荐）：\nfunc incr(p *int) int { *p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！ \treturn *p } v := 1 incr(\u0026amp;v) // side effect: v is now 2 fmt.Println(incr(\u0026amp;v)) // \u0026#34;3\u0026#34; (and v is 3) 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例如，*p就是变量v的别名。指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（译注：这是Go语言的垃圾回收器所做的工作）。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。\n指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。为了说明这一点，在早些的echo版本中，就包含了两个可选的命令行参数：-n用于忽略行尾的换行符，-s sep用于指定分隔字符（默认是空格）。下面这是第四个版本，对应包路径为gopl.io/ch2/echo4。\ngopl.io/ch2/echo4\n// Echo4 prints its command-line arguments. package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) var n = flag.Bool(\u0026#34;n\u0026#34;, false, \u0026#34;omit trailing newline\u0026#34;) var sep = flag.String(\u0026#34;s\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;separator\u0026#34;) func main() { flag.Parse() fmt.Print(strings.Join(flag.Args(), *sep)) if !*n { fmt.Println() } } 调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是命令行标志参数的名字“n”，然后是该标志参数的默认值（这里是false），最后是该标志参数对应的描述信息。如果用户在命令行输入了一个无效的标志参数，或者输入-h或-help参数，那么将打印所有标志参数的名字、默认值和描述信息。类似的，调用flag.String函数将创建一个对应字符串类型的标志参数变量，同样包含命令行标志参数对应的参数名、默认值、和描述信息。程序中的sep和n变量分别是指向对应命令行标志参数变量的指针，因此必须用*sep和*n形式的指针语法间接引用它们。\n当程序运行时，必须在使用标志参数对应的变量之前先调用flag.Parse函数，用于更新每个标志参数对应变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过调用flag.Args()函数来访问，返回值对应一个字符串类型的slice。如果在flag.Parse函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用os.Exit(2)终止程序。\n让我们运行一些echo测试用例：\n$ go build gopl.io/ch2/echo4 $ ./echo4 a bc def a bc def $ ./echo4 -s / a bc def a/bc/def $ ./echo4 -n a bc def a bc def$ $ ./echo4 -help Usage of ./echo4: -n omit trailing newline -s string separator (default \u0026quot; \u0026quot;) "});index.add({'id':47,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/2.4.2.-Assignability/','title':"2.4.2. 可赋值性",'section':"2.4. 赋值",'content':"2.4.2. 可赋值性 #  赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。例如下面的语句：\nmedals := []string{\u0026#34;gold\u0026#34;, \u0026#34;silver\u0026#34;, \u0026#34;bronze\u0026#34;} 隐式地对slice的每个元素进行赋值操作，类似这样写的行为：\nmedals[0] = \u0026#34;gold\u0026#34; medals[1] = \u0026#34;silver\u0026#34; medals[2] = \u0026#34;bronze\u0026#34; map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。\n不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。\n可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。\n对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。和前面一样，我们会对每个新类型比较特殊的地方做专门的解释。\n"});index.add({'id':48,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/2.6.2.-Package-Initialization/','title':"2.6.2. 包的初始化",'section':"2.6. 包和文件",'content':"2.6.2. 包的初始化 #  包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：\nvar a = b + c // a 第三个初始化, 为 3 var b = f() // b 第二个初始化, 为 2, 通过调用 f (依赖c) var c = 1 // c 第一个初始化, 为 1  func f() int { return c + 1 } 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。\n对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数\nfunc init() { /* ... */ } 这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。\n每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。\n下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。\ngopl.io/ch2/popcount\npackage popcount // pc[i] is the population count of i. var pc [256]byte func init() { for i := range pc { pc[i] = pc[i/2] + byte(i\u0026amp;1) } } // PopCount returns the population count (number of set bits) of x. func PopCount(x uint64) int { return int(pc[byte(x\u0026gt;\u0026gt;(0*8))] + pc[byte(x\u0026gt;\u0026gt;(1*8))] + pc[byte(x\u0026gt;\u0026gt;(2*8))] + pc[byte(x\u0026gt;\u0026gt;(3*8))] + pc[byte(x\u0026gt;\u0026gt;(4*8))] + pc[byte(x\u0026gt;\u0026gt;(5*8))] + pc[byte(x\u0026gt;\u0026gt;(6*8))] + pc[byte(x\u0026gt;\u0026gt;(7*8))]) } 译注：对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理，像下面这样：\n// pc[i] is the population count of i. var pc [256]byte = func() (pc [256]byte) { for i := range pc { pc[i] = pc[i/2] + byte(i\u0026amp;1) } return }() 要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：\nfor i, _ := range pc { 我们在下一节和10.5节还将看到其它使用init函数的地方。\n练习 2.3： 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。（11.4节将展示如何系统地比较两个不同实现的性能。）\n练习 2.4： 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和查表算法的性能差异。\n练习 2.5： 表达式x\u0026amp;(x-1)用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数，然后比较性能。\n"});index.add({'id':49,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.2.-Floating-Point-Numbers/','title':"3.2. 浮点数",'section':"3. 基础数据类型",'content':"3.2. 浮点数 #  Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。\n这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。\n一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：\nvar f float32 = 16777216 // 1 \u0026lt;\u0026lt; 24 fmt.Println(f == f+1) // \u0026#34;true\u0026#34;! 浮点数的字面值可以直接写小数部分，像这样：\nconst e = 2.71828 // (approximately) 小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分：\nconst Avogadro = 6.02214129e23 // 阿伏伽德罗常数 const Planck = 6.62606957e-34 // 普朗克常数 用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。\nfor x := 0; x \u0026lt; 8; x++ { fmt.Printf(\u0026#34;x = %d e^x = %8.3f\\n\u0026#34;, x, math.Exp(float64(x))) } 上面代码打印e的幂，打印精度是小数点后三个小数精度和8个字符宽度：\nx = 0 e^x = 1.000 x = 1 e^x = 2.718 x = 2 e^x = 7.389 x = 3 e^x = 20.086 x = 4 e^x = 54.598 x = 5 e^x = 148.413 x = 6 e^x = 403.429 x = 7 e^x = 1096.633 math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).\nvar z float64 fmt.Println(z, -z, 1/z, -1/z, z/z) // \u0026#34;0 -0 +Inf -Inf NaN\u0026#34; 函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）：\nnan := math.NaN() fmt.Println(nan == nan, nan \u0026lt; nan, nan \u0026gt; nan) // \u0026#34;false false false\u0026#34; 如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败，像这样：\nfunc compute() (value float64, ok bool) { // ... \tif failed { return 0, false } return result, true } 接下来的程序演示了通过浮点计算生成的图形。它是带有两个参数的z = f(x, y)函数的三维形式，使用了可缩放矢量图形（SVG）格式输出，SVG是一个用于矢量线绘制的XML标准。图3.1显示了sin(r)/r函数的输出图形，其中r是sqrt(x*x+y*y)。\n gopl.io/ch3/surface\n// Surface computes an SVG rendering of a 3-D surface function. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) const ( width, height = 600, 320 // canvas size in pixels \tcells = 100 // number of grid cells \txyrange = 30.0 // axis ranges (-xyrange..+xyrange) \txyscale = width / 2 / xyrange // pixels per x or y unit \tzscale = height * 0.4 // pixels per z unit \tangle = math.Pi / 6 // angle of x, y axes (=30°) ) var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)  func main() { fmt.Printf(\u0026#34;\u0026lt;svg xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39; \u0026#34;+ \u0026#34;style=\u0026#39;stroke: grey; fill: white; stroke-width: 0.7\u0026#39; \u0026#34;+ \u0026#34;width=\u0026#39;%d\u0026#39; height=\u0026#39;%d\u0026#39;\u0026gt;\u0026#34;, width, height) for i := 0; i \u0026lt; cells; i++ { for j := 0; j \u0026lt; cells; j++ { ax, ay := corner(i+1, j) bx, by := corner(i, j) cx, cy := corner(i, j+1) dx, dy := corner(i+1, j+1) fmt.Printf(\u0026#34;\u0026lt;polygon points=\u0026#39;%g,%g %g,%g %g,%g %g,%g\u0026#39;/\u0026gt;\\n\u0026#34;, ax, ay, bx, by, cx, cy, dx, dy) } } fmt.Println(\u0026#34;\u0026lt;/svg\u0026gt;\u0026#34;) } func corner(i, j int) (float64, float64) { // Find point (x,y) at corner of cell (i,j). \tx := xyrange * (float64(i)/cells - 0.5) y := xyrange * (float64(j)/cells - 0.5) // Compute surface height z. \tz := f(x, y) // Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy). \tsx := width/2 + (x-y)*cos30*xyscale sy := height/2 + (x+y)*sin30*xyscale - z*zscale return sx, sy } func f(x, y float64) float64 { r := math.Hypot(x, y) // distance from (0,0) \treturn math.Sin(r) / r } 要注意的是corner函数返回了两个结果，分别对应每个网格顶点的坐标参数。\n要解释这个程序是如何工作的需要一些基本的几何学知识，但是我们可以跳过几何学原理，因为程序的重点是演示浮点数运算。程序的本质是三个不同的坐标系中映射关系，如图3.2所示。第一个是100x100的二维网格，对应整数坐标(i,j)，从远处的(0,0)位置开始。我们从远处向前面绘制，因此远处先绘制的多边形有可能被前面后绘制的多边形覆盖。\n第二个坐标系是一个三维的网格浮点坐标(x,y,z)，其中x和y是i和j的线性函数，通过平移转换为网格单元的中心，然后用xyrange系数缩放。高度z是函数f(x,y)的值。\n第三个坐标系是一个二维的画布，起点(0,0)在左上角。画布中点的坐标用(sx,sy)表示。我们使用等角投影将三维点(x,y,z)投影到二维的画布中。\n 画布中从远处到右边的点对应较大的x值和较大的y值。并且画布中x和y值越大，则对应的z值越小。x和y的垂直和水平缩放系数来自30度角的正弦和余弦值。z的缩放系数0.4，是一个任意选择的参数。\n对于二维网格中的每一个网格单元，main函数计算单元的四个顶点在画布中对应多边形ABCD的顶点，其中B对应(i,j)顶点位置，A、C和D是其它相邻的顶点，然后输出SVG的绘制指令。\n练习 3.1： 如果f函数返回的是无限制的float64值，那么SVG文件可能输出无效的多边形元素（虽然许多SVG渲染器会妥善处理这类问题）。修改程序跳过无效的多边形。\n练习 3.2： 试验math包中其他函数的渲染图形。你是否能输出一个egg box、moguls或a saddle图案?\n练习 3.3： 根据高度给每个多边形上色，那样峰值部将是红色（#ff0000），谷部将是蓝色（#0000ff）。\n练习 3.4： 参考1.7节Lissajous例子的函数，构造一个web服务器，用于计算函数曲面然后返回SVG数据给客户端。服务器必须设置Content-Type头部：\nw.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/svg+xml\u0026#34;) （这一步在Lissajous例子中不是必须的，因为服务器使用标准的PNG图像格式，可以根据前面的512个字节自动输出对应的头部。）允许客户端通过HTTP请求参数设置高度、宽度和颜色等参数。\n"});index.add({'id':50,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.2.-Unicode/','title':"3.5.2. Unicode",'section':"3.5. 字符串",'content':"3.5.2. Unicode #  在很久以前，世界还是比较简单的，起码计算机世界就只有一个ASCII字符集：美国信息交换标准代码。ASCII，更准确地说是美国的ASCII，使用7bit来表示128个字符：包含英文字母的大小写、数字、各种标点符号和设备控制符。对于早期的计算机程序来说，这些就足够了，但是这也导致了世界上很多其他地区的用户无法直接使用自己的符号系统。随着互联网的发展，混合多种语言的数据变得很常见（译注：比如本身的英文原文或中文翻译都包含了ASCII、中文、日文等多种语言字符）。如何有效处理这些包含了各种语言的丰富多样的文本数据呢？\n答案就是使用Unicode（ http://unicode.org ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。\n在第八版本的Unicode标准里收集了超过120,000个字符，涵盖超过100多种语言。这些在计算机程序和数据中是如何体现的呢？通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思。\n我们可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样大小的32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间，因为大多数计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节就能表示。而且即使是常用的字符也远少于65,536个，也就是说用16bit编码方式就能表达常用字符。但是，还有其它更好的编码方法吗？\n"});index.add({'id':51,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/3.6.2.-Untyped-Constants/','title':"3.6.2. 无类型常量",'section':"3.6. 常量",'content':"3.6.2. 无类型常量 #  Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。\n通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB/ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：\nfmt.Println(YiB/ZiB) // \u0026#34;1024\u0026#34; 另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：\nvar x float32 = math.Pi var y float64 = math.Pi var z complex128 = math.Pi 如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换：\nconst Pi64 float64 = math.Pi var x float32 = float32(Pi64) var y float64 = Pi64 var z complex128 = complex128(Pi64) 对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。\n前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果：\nvar f float64 = 212 fmt.Println((f - 32) * 5 / 9) // \u0026#34;100\u0026#34;; (f - 32) * 5 is a float64 fmt.Println(5 / 9 * (f - 32)) // \u0026#34;0\u0026#34;; 5/9 is an untyped integer, 0 fmt.Println(5.0 / 9.0 * (f - 32)) // \u0026#34;100\u0026#34;; 5.0/9.0 is an untyped float 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。\nvar f float64 = 3 + 0i // untyped complex -\u0026gt; float64 f = 2 // untyped integer -\u0026gt; float64 f = 1e123 // untyped floating-point -\u0026gt; float64 f = \u0026#39;a\u0026#39; // untyped rune -\u0026gt; float64 上面的语句相当于:\nvar f float64 = float64(3 + 0i) f = float64(2) f = float64(1e123) f = float64(\u0026#39;a\u0026#39;) 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：\nconst ( deadbeef = 0xdeadbeef // untyped int with value 3735928559 \ta = uint32(deadbeef) // uint32 with value 3735928559 \tb = float32(deadbeef) // float32 with value 3735928576 (rounded up) \tc = float64(deadbeef) // float64 with value 3735928559 (exact) \td = int32(deadbeef) // compile error: constant overflows int32 \te = float64(1e309) // compile error: constant overflows float64 \tf = uint(-1) // compile error: constant underflows uint ) 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：\ni := 0 // untyped integer; implicit int(0) r := \u0026#39;\\000\u0026#39; // untyped rune; implicit rune(\u0026#39;\\000\u0026#39;) f := 0.0 // untyped floating-point; implicit float64(0.0) c := 0i // untyped complex; implicit complex128(0i) 注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。\n如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：\nvar i = int8(0) var i int8 = 0 当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。\nfmt.Printf(\u0026#34;%T\\n\u0026#34;, 0) // \u0026#34;int\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, 0.0) // \u0026#34;float64\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, 0i) // \u0026#34;complex128\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, \u0026#39;\\000\u0026#39;) // \u0026#34;int32\u0026#34; (rune) 现在我们已经讲述了Go语言中全部的基础数据类型。下一步将演示如何用基础数据类型组合成数组或结构体等复杂数据类型，然后构建用于解决实际编程问题的数据结构，这将是第四章的讨论主题。\n"});index.add({'id':52,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/','title':"4.2. Slice",'section':"4. 复合数据类型",'content':"4.2. Slice #  Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。\n数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。\n多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。数组这样定义\nmonths := [...]string{1: \u0026#34;January\u0026#34;, /* ... */, 12: \u0026#34;December\u0026#34;} 因此一月份是months[1]，十二月份是months[12]。通常，数组的第一个元素从索引0开始，但是月份一般是从1开始的，因此我们声明数组时直接跳过第0个元素，第0个元素会被自动初始化为空字符串。\nslice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。因此，months[1:13]切片操作将引用全部有效的月份，和months[1:]操作等价；months[:]切片操作则是引用整个数组。让我们分别定义表示第二季度和北方夏天月份的slice，它们有重叠部分：\n Q2 := months[4:7] summer := months[6:9] fmt.Println(Q2) // [\u0026#34;April\u0026#34; \u0026#34;May\u0026#34; \u0026#34;June\u0026#34;] fmt.Println(summer) // [\u0026#34;June\u0026#34; \u0026#34;July\u0026#34; \u0026#34;August\u0026#34;] 两个slice都包含了六月份，下面的代码是一个包含相同月份的测试（性能较低）：\nfor _, s := range summer { for _, q := range Q2 { if s == q { fmt.Printf(\u0026#34;%s appears in both\\n\u0026#34;, s) } } } 如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大：\nfmt.Println(summer[:20]) // panic: out of range  endlessSummer := summer[:5] // extend a slice (within capacity) fmt.Println(endlessSummer) // \u0026#34;[June July August September October]\u0026#34; 另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。\n因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名（§2.3.2）。下面的reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice。\ngopl.io/ch4/rev\n// reverse reverses a slice of ints in place. func reverse(s []int) { for i, j := 0, len(s)-1; i \u0026lt; j; i, j = i+1, j-1 { s[i], s[j] = s[j], s[i] } } 这里我们反转数组的应用：\na := [...]int{0, 1, 2, 3, 4, 5} reverse(a[:]) fmt.Println(a) // \u0026#34;[5 4 3 2 1 0]\u0026#34; 一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数，第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。（如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。）\ns := []int{0, 1, 2, 3, 4, 5} // Rotate s left by two positions. reverse(s[:2]) reverse(s[2:]) reverse(s) fmt.Println(s) // \u0026#34;[2 3 4 5 0 1]\u0026#34; 要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。\n和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较：\nfunc equal(x, y []string) bool { if len(x) != len(y) { return false } for i := range x { if x[i] != y[i] { return false } } return true } 上面关于两个slice的深度相等测试，运行的时间并不比支持==操作的数组或字符串更多，但是为何slice不直接支持比较运算符呢？这方面有两个原因。第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身（译注：当slice声明为[]interface{}时，slice的元素可以是自身）。虽然有很多办法处理这种情形，但是没有一个是简单有效的。\n第二个原因，因为slice的元素是间接引用的，一个固定的slice值（译注：指slice本身的值，不是元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。而例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性（译注：例如slice扩容，就会导致其本身的值/地址变化）。而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，==相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的==操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。\nslice唯一合法的比较操作是和nil比较，例如：\nif summer == nil { /* ... */ } 一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。\nvar s []int // len(s) == 0, s == nil s = nil // len(s) == 0, s == nil s = []int(nil) // len(s) == 0, s == nil s = []int{} // len(s) == 0, s != nil 如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样；例如reverse(nil)也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。\n内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。\nmake([]T, len) make([]T, len, cap) // same as make([]T, cap)[:len] 在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。\n"});index.add({'id':53,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.2.-Slices/4.2.2.-In-Place-Slice-Techniques/','title':"4.2.2. Slice内存技巧",'section':"4.2. Slice",'content':"4.2.2. Slice内存技巧 #  让我们看看更多的例子，比如旋转slice、反转slice或在slice原有内存空间修改元素。给定一个字符串列表，下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表：\ngopl.io/ch4/nonempty\n// Nonempty is an example of an in-place slice algorithm. package main import \u0026#34;fmt\u0026#34; // nonempty returns a slice holding only the non-empty strings. // The underlying array is modified during the call. func nonempty(strings []string) []string { i := 0 for _, s := range strings { if s != \u0026#34;\u0026#34; { strings[i] = s i++ } } return strings[:i] } 比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样：\ndata := []string{\u0026#34;one\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;three\u0026#34;} fmt.Printf(\u0026#34;%q\\n\u0026#34;, nonempty(data)) // `[\u0026#34;one\u0026#34; \u0026#34;three\u0026#34;]` fmt.Printf(\u0026#34;%q\\n\u0026#34;, data) // `[\u0026#34;one\u0026#34; \u0026#34;three\u0026#34; \u0026#34;three\u0026#34;]` 因此我们通常会这样使用nonempty函数：data = nonempty(data)。\nnonempty函数也可以使用append函数实现：\nfunc nonempty2(strings []string) []string { out := strings[:0] // zero-length slice of original \tfor _, s := range strings { if s != \u0026#34;\u0026#34; { out = append(out, s) } } return out } 无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。\n一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack：\nstack = append(stack, v) // push v stack的顶部位置对应slice的最后一个元素：\ntop := stack[len(stack)-1] // top of stack 通过收缩stack可以弹出栈顶的元素\nstack = stack[:len(stack)-1] // pop 要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成：\nfunc remove(slice []int, i int) []int { copy(slice[i:], slice[i+1:]) return slice[:len(slice)-1] } func main() { s := []int{5, 6, 7, 8, 9} fmt.Println(remove(s, 2)) // \u0026#34;[5 6 8 9]\u0026#34; } 如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：\nfunc remove(slice []int, i int) []int { slice[i] = slice[len(slice)-1] return slice[:len(slice)-1] } func main() { s := []int{5, 6, 7, 8, 9} fmt.Println(remove(s, 2)) // \u0026#34;[5 6 9 8] } 练习 4.3： 重写reverse函数，使用数组指针代替slice。\n练习 4.4： 编写一个rotate函数，通过一次循环完成旋转。\n练习 4.5： 写一个函数在原地完成消除[]string中相邻重复的字符串的操作。\n练习 4.6： 编写一个函数，原地将一个UTF-8编码的[]byte类型的slice中相邻的空格（参考unicode.IsSpace）替换成一个空格返回\n练习 4.7： 修改reverse函数用于原地反转UTF-8编码的[]byte。是否可以不用分配额外的内存？\n"});index.add({'id':54,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.2.-Comparing-Structs/','title':"4.4.2. 结构体比较",'section':"4.4. 结构体",'content':"4.4.2. 结构体比较 #  如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：\ntype Point struct{ X, Y int } p := Point{1, 2} q := Point{2, 1} fmt.Println(p.X == q.X \u0026amp;\u0026amp; p.Y == q.Y) // \u0026#34;false\u0026#34; fmt.Println(p == q) // \u0026#34;false\u0026#34; 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。\ntype address struct { hostname string port int } hits := make(map[address]int) hits[address{\u0026#34;golang.org\u0026#34;, 443}]++ "});index.add({'id':55,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.2.-Recursion/','title':"5.2. 递归",'section':"5. 函数",'content':"5.2. 递归 #  函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我们通过遍历二叉树来实现简单的插入排序，在本章节，我们再次使用它来处理HTML文件。\n下文的示例代码使用了非标准包 golang.org/x/net/html ，解析HTML。golang.org/x/\u0026hellip; 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。\n例子中调用golang.org/x/net/html的部分api如下所示。html.Parse函数读入一组bytes解析后，返回html.Node类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）、commnets（注释）类型，在下面的例子中，我们 只关注\u0026lt; name key='value\u0026rsquo; \u0026gt;形式的结点。\ngolang.org/x/net/html\npackage html type Node struct { Type NodeType Data string Attr []Attribute FirstChild, NextSibling *Node } type NodeType int32 const ( ErrorNode NodeType = iota TextNode DocumentNode ElementNode CommentNode DoctypeNode ) type Attribute struct { Key, Val string } func Parse(r io.Reader) (*Node, error) main函数解析HTML标准输入，通过递归函数visit获得links（链接），并打印出这些links：\ngopl.io/ch5/findlinks1\n// Findlinks1 prints the links in an HTML document read from standard input. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;golang.org/x/net/html\u0026#34; ) func main() { doc, err := html.Parse(os.Stdin) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;findlinks1: %v\\n\u0026#34;, err) os.Exit(1) } for _, link := range visit(nil, doc) { fmt.Println(link) } } visit函数遍历HTML的节点树，从每一个anchor元素的href属性获得link,将这些links存入字符串数组中，并返回这个字符串数组。\n// visit appends to links each link found in n and returns the result. func visit(links []string, n *html.Node) []string { if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data == \u0026#34;a\u0026#34; { for _, a := range n.Attr { if a.Key == \u0026#34;href\u0026#34; { links = append(links, a.Val) } } } for c := n.FirstChild; c != nil; c = c.NextSibling { links = visit(links, c) } return links } 为了遍历结点n的所有后代结点，每次遇到n的孩子结点时，visit递归的调用自身。这些孩子结点存放在FirstChild链表中。\n让我们以Go的主页（golang.org）作为目标，运行findlinks。我们以fetch（1.5章）的输出作为findlinks的输入。下面的输出做了简化处理。\n$ go build gopl.io/ch1/fetch $ go build gopl.io/ch5/findlinks1 $ ./fetch https://golang.org | ./findlinks1 # /doc/ /pkg/ /help/ /blog/ http://play.golang.org/ //tour.golang.org/ https://golang.org/dl/ //blog.golang.org/ /LICENSE /doc/tos.html http://www.google.com/intl/en/policies/privacy/ 注意在页面中出现的链接格式，在之后我们会介绍如何将这些链接，根据根路径（ https://golang.org ）生成可以直接访问的url。\n在函数outline中，我们通过递归的方式遍历整个HTML结点树，并输出树的结构。在outline内部，每遇到一个HTML元素标签，就将其入栈，并输出。\ngopl.io/ch5/outline\nfunc main() { doc, err := html.Parse(os.Stdin) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;outline: %v\\n\u0026#34;, err) os.Exit(1) } outline(nil, doc) } func outline(stack []string, n *html.Node) { if n.Type == html.ElementNode { stack = append(stack, n.Data) // push tag \tfmt.Println(stack) } for c := n.FirstChild; c != nil; c = c.NextSibling { outline(stack, c) } } 有一点值得注意：outline有入栈操作，但没有相对应的出栈操作。当outline调用自身时，被调用者接收的是stack的拷贝。被调用者对stack的元素追加操作，修改的是stack的拷贝，其可能会修改slice底层的数组甚至是申请一块新的内存空间进行扩容；但这个过程并不会修改调用方的stack。因此当函数返回时，调用方的stack与其调用自身之前完全一致。\n下面是 https://golang.org 页面的简要结构:\n$ go build gopl.io/ch5/outline $ ./fetch https://golang.org | ./outline [html] [html head] [html head meta] [html head title] [html head link] [html body] [html body div] [html body div] [html body div div] [html body div div form] [html body div div form div] [html body div div form div a] ... 正如你在上面实验中所见，大部分HTML页面只需几层递归就能被处理，但仍然有些页面需要深层次的递归。\n大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加（初始时很小）。这使得我们使用递归时不必考虑溢出和安全问题。\n练习 5.1： 修改findlinks代码中遍历n.FirstChild链表的部分，将循环调用visit，改成递归调用。\n练习 5.2： 编写函数，记录在HTML树中出现的同名元素的次数。\n练习 5.3： 编写函数输出所有text结点的内容。注意不要访问\u0026lt;script\u0026gt;和\u0026lt;style\u0026gt;元素，因为这些元素对浏览者是不可见的。\n练习 5.4： 扩展visit函数，使其能够处理其他类型的结点，如images、scripts和style sheets。\n"});index.add({'id':56,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/5.4.2.-End-of-File-EOF/','title':"5.4.2. 文件结尾错误（EOF）",'section':"5.4. 错误",'content':"5.4.2. 文件结尾错误（EOF） #  函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义：\npackage io import \u0026#34;errors\u0026#34; // EOF is the error returned by Read when no more input is available. var EOF = errors.New(\u0026#34;EOF\u0026#34;) 调用者只需通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。（4.3的chartcount程序展示了更加复杂的代码）\nin := bufio.NewReader(os.Stdin) for { r, _, err := in.ReadRune() if err == io.EOF { break // finished reading \t} if err != nil { return fmt.Errorf(\u0026#34;read failed:%v\u0026#34;, err) } // ...use r… } 因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的错误信息。在7.11节中，我们会提出更系统的方法区分某些固定的错误值。\n"});index.add({'id':57,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.2.-Methods-with-a-Pointer-Receiver/','title':"6.2. 基于指针对象的方法",'section':"6. 方法",'content':"6.2. 基于指针对象的方法 #  当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：\nfunc (p *Point) ScaleBy(factor float64) { p.X *= factor p.Y *= factor } 这个方法的名字是(*Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为*(Point.ScaleBy)。\n在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。\n只有类型（Point）和指向他们的指针(*Point)，才可能是出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：\ntype P *int func (P) f() { /* ... */ } // compile error: invalid receiver type 想要调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针即可，像下面这样。\nr := \u0026amp;Point{1, 2} r.ScaleBy(2) fmt.Println(*r) // \u0026#34;{2, 4}\u0026#34; 或者这样：\np := Point{1, 2} pptr := \u0026amp;p pptr.ScaleBy(2) fmt.Println(p) // \u0026#34;{2, 4}\u0026#34; 或者这样:\np := Point{1, 2} (\u0026amp;p).ScaleBy(2) fmt.Println(p) // \u0026#34;{2, 4}\u0026#34; 不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：\np.ScaleBy(2) 编译器会隐式地帮我们用\u0026amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：\nPoint{1, 2}.ScaleBy(2) // compile error: can\u0026#39;t take address of Point literal 但是我们可以用一个*Point这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号*来取到该变量即可。编译器在这里也会给我们隐式地插入*这个操作符，所以下面这两种写法等价的：\npptr.Distance(q) (*pptr).Distance(q) 这里的几个例子可能让你有些困惑，所以我们总结一下：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：\n要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型*T：\nPoint{1, 2}.Distance(q) // Point pptr.ScaleBy(2) // *Point 或者接收器实参是类型T，但接收器形参是类型*T，这种情况下编译器会隐式地为我们取变量的地址：\np.ScaleBy(2) // implicit (\u0026amp;p) 或者接收器实参是类型*T，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：\npptr.Distance(q) // implicit (*pptr) 如果命名类型T（译注：用type xxx定义的类型）的所有方法都是用T类型自己来做接收器（而不是*T），那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如time.Duration的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对bytes.Buffer对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，实际上它们指向的对象是一样的。紧接着对拷贝后的变量进行修改可能会有让你有意外的结果。\n译注： 作者这里说的比较绕，其实有两点：\n 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。  "});index.add({'id':58,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.2.-Interface-Types/','title':"7.2. 接口类型",'section':"7. 接口",'content':"7.2. 接口类型 #  接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。\nio.Writer类型是用得最广泛的接口之一，因为它提供了所有类型的写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。io包中定义了很多其它有用的接口类型。Reader可以代表任意可以读取bytes的类型，Closer可以是任意可以关闭的值，例如一个文件或是网络链接。（到现在你可能注意到了很多Go语言中单方法接口的命名习惯）\npackage io type Reader interface { Read(p []byte) (n int, err error) } type Closer interface { Close() error } 再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：\ntype ReadWriter interface { Reader Writer } type ReadWriteCloser interface { Reader Writer Closer } 上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。尽管略失简洁，我们可以像下面这样，不使用内嵌来声明io.ReadWriter接口。\ntype ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } 或者甚至使用一种混合的风格：\ntype ReadWriter interface { Read(p []byte) (n int, err error) Writer } 上面3种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。\n练习 7.4： strings.NewReader函数通过读取一个string参数返回一个满足io.Reader接口类型的值（和其它值）。实现一个简单版本的NewReader，用它来构造一个接收字符串输入的HTML解析器（§5.2）\n练习 7.5： io包里面的LimitReader函数接收一个io.Reader接口类型的r和字节数n，并且返回另一个从r中读取字节但是当读完n个字节后就表示读到文件结束的Reader。实现这个LimitReader函数：\nfunc LimitReader(r io.Reader, n int64) io.Reader "});index.add({'id':59,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.2.-Example-Concurrent-Clock-Server/','title':"8.2. 示例: 并发的Clock服务",'section':"8. Goroutines和Channels",'content':"8.2. 示例: 并发的Clock服务 #  网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端。在本小节中，我们会讲解go语言的net包，这个包提供编写一个网络客户端或者服务器程序的基本组件，无论两者间通信是使用TCP、UDP或者Unix domain sockets。在第一章中我们使用过的net/http包里的方法，也算是net包的一部分。\n我们的第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：\ngopl.io/ch8/clock1\n// Clock1 is a TCP server that periodically writes the time. package main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;time\u0026#34; ) func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) if err != nil { log.Fatal(err) } for { conn, err := listener.Accept() if err != nil { log.Print(err) // e.g., connection aborted \tcontinue } handleConn(conn) // handle one connection at a time \t} } func handleConn(c net.Conn) { defer c.Close() for { _, err := io.WriteString(c, time.Now().Format(\u0026#34;15:04:05\\n\u0026#34;)) if err != nil { return // e.g., client disconnected \t} time.Sleep(1 * time.Second) } } Listen函数创建了一个net.Listener的对象，这个对象会监听一个网络端口上到来的连接，在这个例子里我们用的是TCP的localhost:8000端口。listener对象的Accept方法会直接阻塞，直到一个新的连接被创建，然后会返回一个net.Conn对象来表示这个连接。\nhandleConn函数会处理一个完整的客户端连接。在一个for死循环中，用time.Now()获取当前时刻，然后写到客户端。由于net.Conn实现了io.Writer接口，我们可以直接向其写入内容。这个死循环会一直执行，直到写入失败。最可能的原因是客户端主动断开连接。这种情况下handleConn函数会用defer调用关闭服务器侧的连接，然后返回到主函数，继续等待下一个连接请求。\ntime.Time.Format方法提供了一种格式化日期和时间信息的方式。它的参数是一个格式化模板，标识如何来格式化时间，而这个格式化模板限定为Mon Jan 2 03:04:05PM 2006 UTC-0700。有8个部分（周几、月份、一个月的第几天……）。可以以任意的形式来组合前面这个模板；出现在模板中的部分会作为参考来对时间格式进行输出。在上面的例子中我们只用到了小时、分钟和秒。time包里定义了很多标准时间格式，比如time.RFC1123。在进行格式化的逆向操作time.Parse时，也会用到同样的策略。（译注：这是go语言和其它语言相比比较奇葩的一个地方。你需要记住格式化字符串是1月2日下午3点4分5秒零六年UTC-0700，而不像其它语言那样Y-m-d H:i:s一样，当然了这里可以用1234567的方式来记忆，倒是也不麻烦。）\n为了连接例子里的服务器，我们需要一个客户端程序，比如netcat这个工具（nc命令），这个工具可以用来执行网络连接操作。\n$ go build gopl.io/ch8/clock1 $ ./clock1 \u0026amp; $ nc localhost 8000 13:58:54 13:58:55 13:58:56 13:58:57 ^C 客户端将服务器发来的时间显示了出来，我们用Control+C来中断客户端的执行，在Unix系统上，你会看到^C这样的响应。如果你的系统没有装nc这个工具，你可以用telnet来实现同样的效果，或者也可以用我们下面的这个用go写的简单的telnet程序，用net.Dial就可以简单地创建一个TCP连接：\ngopl.io/ch8/netcat1\n// Netcat1 is a read-only TCP client. package main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() mustCopy(os.Stdout, conn) } func mustCopy(dst io.Writer, src io.Reader) { if _, err := io.Copy(dst, src); err != nil { log.Fatal(err) } } 这个程序会从连接中读取数据，并将读到的内容写到标准输出中，直到遇到end of file的条件或者发生错误。mustCopy这个函数我们在本节的几个例子中都会用到。让我们同时运行两个客户端来进行一个测试，这里可以开两个终端窗口，下面左边的是其中的一个的输出，右边的是另一个的输出：\n$ go build gopl.io/ch8/netcat1 $ ./netcat1 13:58:54 $ ./netcat1 13:58:55 13:58:56 ^C 13:58:57 13:58:58 13:58:59 ^C $ killall clock1 killall命令是一个Unix命令行工具，可以用给定的进程名来杀掉所有名字匹配的进程。\n第二个客户端必须等待第一个客户端完成工作，这样服务端才能继续向后执行；因为我们这里的服务器程序同一时间只能处理一个客户端连接。我们这里对服务端程序做一点小改动，使其支持并发：在handleConn函数调用的地方增加go关键字，让每一次handleConn的调用都进入一个独立的goroutine。\ngopl.io/ch8/clock2\nfor { conn, err := listener.Accept() if err != nil { log.Print(err) // e.g., connection aborted \tcontinue } go handleConn(conn) // handle connections concurrently } 现在多个客户端可以同时接收到时间了：\n$ go build gopl.io/ch8/clock2 $ ./clock2 \u0026amp; $ go build gopl.io/ch8/netcat1 $ ./netcat1 14:02:54 $ ./netcat1 14:02:55 14:02:55 14:02:56 14:02:56 14:02:57 ^C 14:02:58 14:02:59 $ ./netcat1 14:03:00 14:03:00 14:03:01 14:03:01 ^C 14:03:02 ^C $ killall clock2 练习 8.1： 修改clock2来支持传入参数作为端口号，然后写一个clockwall的程序，这个程序可以同时与多个clock服务器通信，从多个服务器中读取时间，并且在一个表格中一次显示所有服务器传回的结果，类似于你在某些办公室里看到的时钟墙。如果你有地理学上分布式的服务器可以用的话，让这些服务器跑在不同的机器上面；或者在同一台机器上跑多个不同的实例，这些实例监听不同的端口，假装自己在不同的时区。像下面这样：\n$ TZ=US/Eastern ./clock2 -port 8010 \u0026amp; $ TZ=Asia/Tokyo ./clock2 -port 8020 \u0026amp; $ TZ=Europe/London ./clock2 -port 8030 \u0026amp; $ clockwall NewYork=localhost:8010 Tokyo=localhost:8020 London=localhost:8030 练习 8.2： 实现一个并发FTP服务器。服务器应该解析客户端发来的一些命令，比如cd命令来切换目录，ls来列出目录内文件，get和send来传输文件，close来关闭连接。你可以用标准的ftp命令来作为客户端，或者也可以自己实现一个。\n"});index.add({'id':60,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.2.-Pipelines/','title':"8.4.2. 串联的Channels（Pipeline）",'section':"8.4. Channels",'content':"8.4.2. 串联的Channels（Pipeline） #  Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来，如图8.1所示。\n 第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine。\ngopl.io/ch8/pipeline1\nfunc main() { naturals := make(chan int) squares := make(chan int) // Counter \tgo func() { for x := 0; ; x++ { naturals \u0026lt;- x } }() // Squarer \tgo func() { for { x := \u0026lt;-naturals squares \u0026lt;- x * x } }() // Printer (in main goroutine) \tfor { fmt.Println(\u0026lt;-squares) } } 如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？\n如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现：\nclose(naturals) 当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。\n没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel.\n// Squarer go func() { for { x, ok := \u0026lt;-naturals if !ok { break // channel was closed and drained \t} squares \u0026lt;- x * x } close(squares) }() 因为上面的语法是笨拙的，而且这种处理模式很常见，因此Go语言的range循环可直接在channels上面迭代。使用range循环是上面处理模式的简洁语法，它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环。\n在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。）最后，主goroutine也可以正常终止循环并退出程序。\ngopl.io/ch8/pipeline2\nfunc main() { naturals := make(chan int) squares := make(chan int) // Counter \tgo func() { for x := 0; x \u0026lt; 100; x++ { naturals \u0026lt;- x } close(naturals) }() // Squarer \tgo func() { for x := range naturals { squares \u0026lt;- x * x } close(squares) }() // Printer (in main goroutine) \tfor x := range squares { fmt.Println(x) } } 其实你并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。）\n试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制，我们将在8.9节讨论。\n"});index.add({'id':61,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.2.-Mutual-Exclusion-sync.Mutex/','title':"9.2. sync.Mutex互斥锁",'section':"9. 基于共享变量的并发",'content':"9.2. sync.Mutex互斥锁 #  在8.6节中，我们使用了一个buffered channel作为一个计数信号量，来保证最多只有20个goroutine会同时执行HTTP请求。同理，我们可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量（binary semaphore）。\ngopl.io/ch9/bank2\nvar ( sema = make(chan struct{}, 1) // a binary semaphore guarding balance \tbalance int ) func Deposit(amount int) { sema \u0026lt;- struct{}{} // acquire token \tbalance = balance + amount \u0026lt;-sema // release token } func Balance() int { sema \u0026lt;- struct{}{} // acquire token \tb := balance \u0026lt;-sema // release token \treturn b } 这种互斥很实用，而且被sync包里的Mutex类型直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token：\ngopl.io/ch9/bank3\nimport \u0026#34;sync\u0026#34; var ( mu sync.Mutex // guards balance \tbalance int ) func Deposit(amount int) { mu.Lock() balance = balance + amount mu.Unlock() } func Balance() int { mu.Lock() b := balance mu.Unlock() return b } 每次一个goroutine访问bank变量时（这里只有balance余额变量），它都会调用mutex的Lock方法来获取一个互斥锁。如果其它的goroutine已经获得了这个锁的话，这个操作会被阻塞直到其它goroutine调用了Unlock使该锁变回可用状态。mutex会保护共享变量。惯例来说，被mutex所保护的变量是在mutex变量声明之后立刻声明的。如果你的做法和惯例不符，确保在文档里对你的做法进行说明。\n在Lock和Unlock之间的代码段中的内容goroutine可以随便读取或者修改，这个代码段叫做临界区。锁的持有者在其他goroutine获取该锁之前需要调用Unlock。goroutine在结束后释放锁是必要的，无论以哪条路径通过函数都需要释放，即使是在错误路径中，也要记得释放。\n上面的bank程序例证了一种通用的并发模式。一系列的导出函数封装了一个或多个变量，那么访问这些变量唯一的方式就是通过这些函数来做（或者方法，对于一个对象的变量来说）。每一个函数在一开始就获取互斥锁并在最后释放锁，从而保证共享变量不会被并发访问。这种函数、互斥锁和变量的编排叫作监控monitor（这种老式单词的monitor是受“monitor goroutine”的术语启发而来的。两种用法都是一个代理人保证变量被顺序访问）。\n由于在存款和查询余额函数中的临界区代码这么短——只有一行，没有分支调用——在代码最后去调用Unlock就显得更为直截了当。在更复杂的临界区的应用中，尤其是必须要尽早处理错误并返回的情况下，就很难去（靠人）判断对Lock和Unlock的调用是在所有路径中都能够严格配对的了。Go语言里的defer简直就是这种情况下的救星：我们用defer来调用Unlock，临界区会隐式地延伸到函数作用域的最后，这样我们就从“总要记得在函数返回之后或者发生错误返回时要记得调用一次Unlock”这种状态中获得了解放。Go会自动帮我们完成这些事情。\nfunc Balance() int { mu.Lock() defer mu.Unlock() return balance } 上面的例子里Unlock会在return语句读取完balance的值之后执行，所以Balance函数是并发安全的。这带来的另一点好处是，我们再也不需要一个本地变量b了。\n此外，一个deferred Unlock即使在临界区发生panic时依然会执行，这对于用recover（§5.10）来恢复的程序来说是很重要的。defer调用只会比显式地调用Unlock成本高那么一点点，不过却在很大程度上保证了代码的整洁性。大多数情况下对于并发程序来说，代码的整洁性比过度的优化更重要。如果可能的话尽量使用defer来将临界区扩展到函数的结束。\n考虑一下下面的Withdraw函数。成功的时候，它会正确地减掉余额并返回true。但如果银行记录资金对交易来说不足，那么取款就会恢复余额，并返回false。\n// NOTE: not atomic! func Withdraw(amount int) bool { Deposit(-amount) if Balance() \u0026lt; 0 { Deposit(amount) return false // insufficient funds \t} return true } 函数终于给出了正确的结果，但是还有一点讨厌的副作用。当过多的取款操作同时执行时，balance可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。所以如果Bob尝试买一辆sports car时，Alice可能就没办法为她的早咖啡付款了。这里的问题是取款不是一个原子操作：它包含了三个步骤，每一步都需要去获取并释放互斥锁，但任何一次锁都不会锁上整个取款流程。\n理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的：\n// NOTE: incorrect! func Withdraw(amount int) bool { mu.Lock() defer mu.Unlock() Deposit(-amount) if Balance() \u0026lt; 0 { Deposit(amount) return false // insufficient funds \t} return true } 上面这个例子中，Deposit会调用mu.Lock()第二次去获取互斥锁，但因为mutex已经锁上了，而无法被重入（译注：go里没有重入锁，关于重入锁的概念，请参考java）——也就是说没法对一个已经锁上的mutex来再次上锁——这会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。\n关于Go的mutex不能重入这一点我们有很充分的理由。mutex的目的是确保共享变量在程序执行时的关键点上能够保证不变性。不变性的一层含义是“没有goroutine访问共享变量”，但实际上这里对于mutex保护的变量来说，不变性还包含更深层含义：当一个goroutine获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（译注：即没有其他代码块正在读写共享变量），在其获取并保持锁期间，可能会去更新共享变量，这样不变性只是短暂地被破坏，然而当其释放锁之后，锁必须保证共享变量重获不变性并且多个goroutine按顺序访问共享变量。尽管一个可以重入的mutex也可以保证没有其它的goroutine在访问共享变量，但它不具备不变性更深层含义。（译注： 更详细的解释，Russ Cox认为可重入锁是bug的温床，是一个失败的设计）\n一个通用的解决方案是将一个函数分离为多个函数，比如我们把Deposit分离成两个：一个不导出的函数deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数Deposit，这个函数会调用deposit，但在调用前会先去获取锁。同理我们可以将Withdraw也表示成这种形式：\nfunc Withdraw(amount int) bool { mu.Lock() defer mu.Unlock() deposit(-amount) if balance \u0026lt; 0 { deposit(amount) return false // insufficient funds \t} return true } func Deposit(amount int) { mu.Lock() defer mu.Unlock() deposit(amount) } func Balance() int { mu.Lock() defer mu.Unlock() return balance } // This function requires that the lock be held. func deposit(amount int) { balance += amount } 当然，这里的存款deposit函数很小，实际上取款Withdraw函数不需要理会对它的调用，尽管如此，这里的表达还是表明了规则。\n封装（§6.6），用限制一个程序中的意外交互的方式，可以使我们获得数据结构的不变性。因为某种原因，封装还帮我们获得了并发的不变性。当你使用mutex时，确保mutex和其保护的变量没有被导出（在go里也就是小写，且不要被大写字母开头的函数访问啦），无论这些变量是包级的变量还是一个struct的字段。\n"});index.add({'id':62,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.2.-Goroutine-Scheduling/','title':"9.8.2. Goroutine调度",'section':"9.8. Goroutines和线程",'content':"9.8.2. Goroutine调度 #  OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。\nGo的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工（调度）m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（译注：按程序独立）。\n和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。\n** 练习 9.5: ** 写一个有两个goroutine的程序，两个goroutine会向两个无buffer channel反复地发送ping-pong消息。这样的程序每秒可以支持多少次通信？\n"});index.add({'id':63,'href':'/docs/The-Go-Programming-Language/','title':"Go语言圣经",'section':"Docs",'content':"Go语言圣经（中文版） #  Go语言圣经 《The Go Programming Language》 中文版本，仅供学习交流之用。对于希望学习CGO、Go汇编语言等高级用法的同学，我们推荐 《Go语言高级编程》开源图书。\n \n 项目主页：http://github.com/golang-china/gopl-zh 原版官网：http://gopl.io  译者信息：\n 译者：柴树杉，Github @chai2010，Twitter @chaishushan 译者：Xargin, https://github.com/cch123 译者：CrazySssst 译者：foreversmart njutree@gmail.com  在线预览 #   https://docs.hacknode.org/gopl-zh/ https://books.studygolang.com/gopl-zh/ https://wizardforcel.gitbooks.io/gopl-zh/   译者序 #  在上个世纪70年代，贝尔实验室的[Ken Thompson][KenThompson]和[Dennis M. Ritchie][DennisRitchie]合作发明了 UNIX操作系统，同时[Dennis M. Ritchie][DennisRitchie]为了解决 UNIX系统的移植性问题而发明了C语言，贝尔实验室的 UNIX和C语言两大发明奠定了整个现代IT行业最重要的软件基础（目前的三大桌面操作系统的中 Linux和 Mac OS X都是源于 UNIX系统，两大移动平台的操作系统iOS和Android也都是源于 UNIX系统。C系家族的编程语言占据统治地位达几十年之久）。在 UNIX和C语言发明40年之后，目前已经在Google工作的 Ken Thompson和 Rob Pike（他们在贝尔实验室时就是同事）、还有 Robert Griesemer（设计了V8引擎和HotSpot虚拟机）一起合作，为了解决在21世纪多核和网络化环境下越来越复杂的编程问题而发明了Go语言。从Go语言库早期代码库日志可以看出它的演化历程（Git用git log --before={2008-03-03} --reverse命令查看）：\n 从早期提交日志中也可以看出，Go语言是从 Ken Thompson发明的B语言、 Dennis M. Ritchie发明的C语言逐步演化过来的，是C语言家族的成员，因此很多人将Go语言称为21世纪的C语言。纵观这几年来的发展趋势，Go语言已经成为云计算、云存储时代最重要的基础编程语言。\n在C语言发明之后约5年的时间之后（1978年）， Brian W. Kernighan和 Dennis M. Ritchie合作编写出版了C语言方面的经典教材《 The C Programming Language》，该书被誉为C语言程序员的圣经，作者也被大家亲切地称为 K\u0026amp;R。同样在Go语言正式发布（2009年）约5年之后（2014年开始写作，2015年出版），由Go语言核心团队成员 Alan A. A. Donovan和 K\u0026amp;R中的 Brian W. Kernighan合作编写了Go语言方面的经典教材《 The Go Programming Language》。Go语言被誉为21世纪的C语言，如果说 K\u0026amp;R所著的是圣经的旧约，那么D\u0026amp;K所著的必将成为圣经的新约。该书介绍了Go语言几乎全部特性，并且随着语言的深入层层递进，对每个细节都解读得非常细致，每一节内容都精彩不容错过，是广大Gopher的必读书目。大部分Go语言核心团队的成员都参与了该书校对工作，因此该书的质量是可以完全放心的。\n同时，单凭阅读和学习其语法结构并不能真正地掌握一门编程语言，必须进行足够多的编程实践——亲自编写一些程序并研究学习别人写的程序。要从利用Go语言良好的特性使得程序模块化，充分利用Go的标准函数库以Go语言自己的风格来编写程序。书中包含了上百个精心挑选的习题，希望大家能先用自己的方式尝试完成习题，然后再参考官方给出的解决方案。\n该书英文版约从2015年10月开始公开发售，其中日文版本最早参与翻译和审校（参考致谢部分）。在2015年10月，我们并不知道中文版是否会及时引进、将由哪家出版社引进、引进将由何人来翻译、何时能出版，这些信息都成了一个秘密。中国的Go语言社区是全球最大的Go语言社区，我们从一开始就始终紧跟着Go语言的发展脚步。我们应该也完全有能力以中国Go语言社区的力量同步完成Go语言圣经中文版的翻译工作。与此同时，国内有很多Go语言爱好者也在积极关注该书（本人也在第一时间购买了纸质版本， 亚马逊价格314人民币。补充：国内也即将出版英文版， 价格79元）。为了Go语言的学习和交流，大家决定合作免费翻译该书。\n翻译工作从2015年11月20日前后开始，到2016年1月底初步完成，前后历时约2个月时间（在其它语言版本中，全球第一个完成翻译的，基本做到和原版同步）。其中， chai2010翻译了前言、第2 ~ 4章、第10 ~ 13章， Xargin翻译了第1章、第6章、第8 ~ 9章， CrazySssst翻译了第5章， foreversmart翻译了第7章，大家共同参与了基本的校验工作，还有其他一些朋友提供了积极的反馈建议。如果大家还有任何问题或建议，可以直接到中文版项目页面提交 Issue，如果发现英文版原文在 勘误中未提到的任何错误，可以直接去 英文版项目提交。\n最后，希望这本书能够帮助大家用Go语言快乐地编程。\n2016年 1月 于 武汉\n"});index.add({'id':64,'href':'/docs/The-Go-Programming-Language/Preface/The-Go-Project/','title':"Go语言项目",'section':"前言",'content':"Go语言项目 #  所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。\n正如 Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。\n简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如 Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。\nGo项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。\nGo语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。\nGo语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。\nGo语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。\n"});index.add({'id':65,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.3.-Finding-Duplicate-Lines/','title':"1.3. 查找重复的行",'section':"1. 入门",'content':"1.3. 查找重复的行 #  对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为dup的程序的三个版本；灵感来自于Unix的uniq命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。\ndup的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入if语句，map数据类型以及bufio包。\ngopl.io/ch1/dup1\n// Dup1 prints the text of each line that appears more than // once in the standard input, preceded by its count. package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { counts := make(map[string]int) input := bufio.NewScanner(os.Stdin) for input.Scan() { counts[input.Text()]++ } // NOTE: ignoring potential errors from input.Err() \tfor line, n := range counts { if n \u0026gt; 1 { fmt.Printf(\u0026#34;%d\\t%s\\n\u0026#34;, n, line) } } } 正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。if语句的else部分是可选的，在if的条件为false时执行。\nmap存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用==运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数make创建空map，此外，它还有别的作用。4.3节讨论map。\n（译注：从功能和实现上说，Go的map类似于Java语言中的HashMap，Python语言中的dict，Lua语言中的table，通常使用hash实现。遗憾的是，对于该词的翻译并不统一，数学界术语为映射，而计算机界众说纷纭莫衷一是。为了防止对读者造成误解，保留不译。）\n每次dup读取一行输入，该行被当做键存入map，其对应的值递增。counts[input.Text()]++语句等价下面两句：\nline := input.Text() counts[line] = counts[line] + 1 map中不含某个键时不用担心，首次读到新行时，等号右边的表达式counts[line]的值将被计算为其类型的零值，对于int即0。\n为了打印结果，我们使用了基于range的循环，并在counts这个map上迭代。跟之前类似，每次迭代得到两个结果，键和其在map中对应的值。map的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化。这种设计是有意为之的，因为能防止程序依赖特定遍历顺序，而这是无法保证的。（译注：具体可以参见这里http://stackoverflow.com/questions/11853396/google-go-lang-assignment-order）\n继续来看bufio包，它使处理输入和输出方便又高效。Scanner类型是该包最有用的特性之一，它读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。\n程序使用短变量声明创建bufio.Scanner类型的变量input。\ninput := bufio.NewScanner(os.Stdin) 该变量从程序的标准输入中读取内容。每次调用input.Scan()，即读入下一行，并移除行末的换行符；读取的内容可以调用input.Text()得到。Scan函数在读到一行时返回true，不再有输入时返回false。\n类似于C或其它语言里的printf函数，fmt.Printf函数对一些表达式产生格式化输出。该函数的首个参数是个格式字符串，指定后续参数被如何格式化。各个参数的格式取决于“转换字符”（conversion character），形式为百分号后跟一个字母。举个例子，%d表示以十进制形式打印一个整型操作数，而%s则表示把字符串型操作数的值展开。\nPrintf有一大堆这种转换，Go程序员称之为动词（verb）。下面的表格虽然远不是完整的规范，但展示了可用的很多特性：\n%d 十进制整数 %x, %o, %b 十六进制，八进制，二进制整数。 %f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00 %t 布尔：true或false %c 字符（rune） (Unicode码点) %s 字符串 %q 带双引号的字符串\u0026quot;abc\u0026quot;或带单引号的字符'c' %v 变量的自然形式（natural format） %T 变量的类型 %% 字面上的百分号标志（无操作数） dup1的格式字符串中还含有制表符\\t和换行符\\n。字符串字面上可能含有这些代表不可见字符的转义字符（escape sequences）。默认情况下，Printf不会换行。按照惯例，以字母f结尾的格式化函数，如log.Printf和fmt.Errorf，都采用fmt.Printf的格式化准则。而以ln结尾的格式化函数，则遵循Println的方式，以跟%v差不多的方式格式化参数，并在最后添加一个换行符。（译注：后缀f指format，ln指line。）\n很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。dup程序的下个版本读取标准输入或是使用os.Open打开各个具名文件，并操作它们。\ngopl.io/ch1/dup2\n// Dup2 prints the count and text of lines that appear more than once // in the input. It reads from stdin or from a list of named files. package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { counts := make(map[string]int) files := os.Args[1:] if len(files) == 0 { countLines(os.Stdin, counts) } else { for _, arg := range files { f, err := os.Open(arg) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;dup2: %v\\n\u0026#34;, err) continue } countLines(f, counts) f.Close() } } for line, n := range counts { if n \u0026gt; 1 { fmt.Printf(\u0026#34;%d\\t%s\\n\u0026#34;, n, line) } } } func countLines(f *os.File, counts map[string]int) { input := bufio.NewScanner(f) for input.Scan() { counts[input.Text()]++ } // NOTE: ignoring potential errors from input.Err() } os.Open函数返回两个值。第一个值是被打开的文件(*os.File），其后被Scanner读取。\nos.Open返回的第二个值是内置error类型的值。如果err等于内置值nil（译注：相当于其它语言里的NULL），那么文件被成功打开。读取文件，直到文件结束，然后调用Close关闭该文件，并释放占用的所有资源。相反的话，如果err的值不是nil，说明打开文件时出错了。这种情况下，错误值描述了所遇到的问题。我们的错误处理非常简单，只是使用Fprintf与表示任意类型默认格式值的动词%v，向标准错误流打印一条信息，然后dup继续处理下一个文件；continue语句直接跳到for循环的下个迭代开始执行。\n为了使示例代码保持合理的大小，本书开始的一些示例有意简化了错误处理，显而易见的是，应该检查os.Open返回的错误值，然而，使用input.Scan读取文件过程中，不大可能出现错误，因此我们忽略了错误处理。我们会在跳过错误检查的地方做说明。5.4节中深入介绍错误处理。\n注意countLines函数在其声明前被调用。函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响其被调用。（译注：最好还是遵循一定的规范）\nmap是一个由make函数创建的数据结构的引用。map作为参数传递给某函数时，该函数接收这个引用的一份拷贝（copy，或译为副本），被调用函数对map底层数据结构的任何修改，调用者函数都可以通过持有的map引用看到。在我们的例子中，countLines函数向counts插入的值，也会被main函数看到。（译注：类似于C++里的引用传递，实际上指针是另一个指针了，但内部存的值指向同一块内存）\ndup的前两个版本以\u0026quot;流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。下面这个版本，dup3，就是这么操作的。这个例子引入了ReadFile函数（来自于io/ioutil包），其读取指定文件的全部内容，strings.Split函数把字符串分割成子串的切片。（Split的作用与前文提到的strings.Join相反。）\n我们略微简化了dup3。首先，由于ReadFile函数需要文件名作为参数，因此只读指定文件，不读标准输入。其次，由于行计数代码只在一处用到，故将其移回main函数。\ngopl.io/ch1/dup3\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { counts := make(map[string]int) for _, filename := range os.Args[1:] { data, err := ioutil.ReadFile(filename) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;dup3: %v\\n\u0026#34;, err) continue } for _, line := range strings.Split(string(data), \u0026#34;\\n\u0026#34;) { counts[line]++ } } for line, n := range counts { if n \u0026gt; 1 { fmt.Printf(\u0026#34;%d\\t%s\\n\u0026#34;, n, line) } } } ReadFile函数返回一个字节切片（byte slice），必须把它转换为string，才能用strings.Split分割。我们会在3.5.4节详细讲解字符串和字节切片。\n实现上，bufio.Scanner、ioutil.ReadFile和ioutil.WriteFile都使用*os.File的Read和Write方法，但是，大多数程序员很少需要直接调用那些低级（lower-level）函数。高级（higher-level）函数，像bufio和io/ioutil包中所提供的那些，用起来要容易点。\n练习 1.4： 修改dup2，出现重复的行时打印文件名称。\n"});index.add({'id':66,'href':'/docs/Clean-Code/1.-Clean-Code/1.3.-The-Total-Cost-of-Owning-a-Mess/','title':"1.3. 混乱的代价",'section':"1. 整洁代码",'content':"1.3 混乱的代价 #  If you have been a programmer for more than two or three years, you have probably been significantly slowed down by someone else’s messy code. If you have been a programmer for longer than two or three years, you have probably been slowed down by messy code. The degree of the slowdown can be significant. Over the span of a year or two, teams that were moving very fast at the beginning of a project can find themselves moving at a snail’s pace. Every change they make to the code breaks two or three other parts of the code. No change is trivial. Every addition or modification to the system requires that the tangles, twists, and knots be “understood” so that more tangles, twists, and knots can be added. Over time the mess becomes so big and so deep and so tall, they can not clean it up. There is no way at all.\n 只要你干过两三年编程，就有可能曾被某人的糟糕的代码绊倒过。如果你编程不止两三年，也有可能被这种代码拖过后腿。进度延缓的程度会很严重。有些团队在项目初期进展迅速，但有那么一两年的时间却慢如蜗行。对代码的每次修改都影响到其他两三处代码。修改无小事。每次添加或修改代码，都得对那堆扭纹柴了然于心，这样才能往上扔更多的扭纹柴。这团乱麻越来越大，再也无法理清，最后束手无策。\n As the mess builds, the productivity of the team continues to decrease, asymptotically approaching zero. As productivity decreases, management does the only thing they can; they add more staff to the project in hopes of increasing productivity. But that new staff is not versed in the design of the system. They don’t know the difference between a change that matches the design intent and a change that thwarts the design intent. Furthermore, they, and everyone else on the team, are under horrific pressure to increase productivity. So they all make more and more messes, driving the productivity ever further toward zero. (See Figure 1-1.)\n 随着混乱的增加，团队生产力也持续下降，趋向于零。当生产力下降时，管理层就只有一件事可做了：增加更多人手到项目中，期望提升生产力。可是新人并不熟悉系统的设计。他们搞不清楚什么样的修改符合设计意图，什么样的修改违背设计意图。而且，他们以及团队中的其他人都背负着提升生产力的可怕压力。于是，他们制造更多的混乱，驱动生产力向零那端不断下降。如图 1-1 所示\n Figure 1-1 Productivity vs. time\n 1.3.1 The Grand Redesign in the Sky 华丽新设计 #  Eventually the team rebels. They inform management that they cannot continue to develop in this odious code base. They demand a redesign. Management does not want to expend the resources on a whole new redesign of the project, but they cannot deny that productivity is terrible. Eventually they bend to the demands of the developers and authorize the grand redesign in the sky.\n 最后，开发团队造反了，他们告诉管理层，再也无法在这令人生厌的代码基础上做开发。他们要求做全新的设计。管理层不愿意投入资源完全重启炉灶，但他们也不能否认生产力低得可怕。他们只好同意开发者的要求，授权去做一套看上去很美的华丽新设计。\n A new tiger team is selected. Everyone wants to be on this team because it’s a green-field project. They get to start over and create something truly beautiful. But only the best and brightest are chosen for the tiger team. Everyone else must continue to maintain the current system.\n 于是就组建了一支新军。谁都想加入这个团队，因为它是张白纸。他们可以重新来过，搞出点真正漂亮的东西来。但只有最优秀、最聪明的家伙被选中。其余人等则继续维护现有系统。\n Now the two teams are in a race. The tiger team must build a new system that does everything that the old system does. Not only that, they have to keep up with the changes that are continuously being made to the old system. Management will not replace the old system until the new system can do everything that the old system does.\n 现在有两支队伍在竞赛了。新团队必须搭建一套新系统，要能实现旧系统的所有功能。另外，还得跟上对旧系统的持续改动。在新系统功能足以抗衡旧系统之前，管理层不会替换掉旧系统。\n This race can go on for a very long time. I’ve seen it take 10 years. And by the time it’s done, the original members of the tiger team are long gone, and the current members are demanding that the new system be redesigned because it’s such a mess.\n 竞赛可能会持续极长时间。我就见过延续了十年之久的。到了完成的时候，新团队的老成员早已不知去向，而现有成员则要求重新设计一套新系统，因为这套系统太烂了。\n If you have experienced even one small part of the story I just told, then you already know that spending time keeping your code clean is not just cost effective; it’s a matter of professional survival.\n 假使你经历过哪怕是一小段我谈到的这种事，那么你一定知道，花时间保持代码整洁不但有关效率，还有关生存。\n 1.3.2 Attitude 态度 #  Have you ever waded through a mess so grave that it took weeks to do what should have taken hours? Have you seen what should have been a one-line change, made instead in hundreds of different modules? These symptoms are all too common.\n 你是否遇到过某种严重到要花数个星期来做本来只需数小时即可完成的事的混乱状况？你是否见过本来只需做一行修改，结果却涉及上百个模块的情况？这种事太常见了。\n Why does this happen to code? Why does good code rot so quickly into bad code? We have lots of explanations for it. We complain that the requirements changed in ways that thwart the original design. We bemoan the schedules that were too tight to do things right. We blather about stupid managers and intolerant customers and useless marketing types and telephone sanitizers. But the fault, dear Dilbert, is not in our stars, but in ourselves. We are unprofessional.\n 怎么会发生这种事？为什么好代码会这么快就变质成糟糕的代码？理由多得很。我们抱怨需求变化背离了初期设计。我们哀叹进度太紧张，没法干好活。我们把问题归咎于那些愚蠢的经理、苛求的用户、没用的营销方式和那些电话消毒剂。不过，亲爱的呆伯特（Dilbert），我们是自作自受。我们太不专业了。\n This may be a bitter pill to swallow. How could this mess be our fault? What about the requirements? What about the schedule? What about the stupid managers and the useless marketing types? Don’t they bear some of the blame?\n 这话可不太中听。怎么会是自作自受呢？难道不关需求的事？难道不关进度的事？难道不关那些蠢经理和没用的营销手段的事？难道他们就不该负点责吗？\n No. The managers and marketers look to us for the information they need to make promises and commitments; and even when they don’t look to us, we should not be shy about telling them what we think. The users look to us to validate the way the requirements will fit into the system. The project managers look to us to help work out the schedule. We are deeply complicit in the planning of the project and share a great deal of the responsibility for any failures; especially if those failures have to do with bad code!\n 不。经理和营销人员指望从我们这里得到必须的信息，然后才能做出承诺和保证；即便他们没开口问，我们也不该羞于告知自己的想法。用户指望我们验证需求是否都在系统中实现了。项目经理指望我们遵守进度。我们与项目的规划脱不了干系，对失败负有极大的责任；特别是当失败与糟糕的代码有关时尤为如此！\n “But wait!” you say. “If I don’t do what my manager says, I’ll be fired.” Probably not. Most managers want the truth, even when they don’t act like it. Most managers want good code, even when they are obsessing about the schedule. They may defend the schedule and requirements with passion; but that’s their job. It’s your job to defend the code with equal passion.\n “且慢！”你说。“不听经理的，我就会被炒鱿鱼。”多半不会。多数经理想要知道实情，即便他们看起来不喜欢实情。多数经理想要好代码，即便他们总是痴缠于进度。他们会奋力卫护进度和需求；那是他们该干的。你则当以同等的热情卫护代码。\n To drive this point home, what if you were a doctor and had a patient who demanded that you stop all the silly hand-washing in preparation for surgery because it was taking too much time?2 Clearly the patient is the boss; and yet the doctor should absolutely refuse to comply. Why? Because the doctor knows more than the patient about the risks of disease and infection. It would be unprofessional (never mind criminal) for the doctor to comply with the patient.\n 再说明白些，假使你是位医生，病人请求你在给他做手术前别洗手，因为那会花太多时间，你会照办吗？本该是病人说了算；但医生却绝对应该拒绝遵从。为什么？因为医生比病人更了解疾病和感染的风险。医生如果按病人说的办，就是一种不专业的态度（更别说是犯罪了）。\n So too it is unprofessional for programmers to bend to the will of managers who don’t understand the risks of making messes.\n 同理，程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法。\n 1.3.3 The Primal Conundrum 迷题 #  Programmers face a conundrum of basic values. All developers with more than a few years experience know that previous messes slow them down. And yet all developers feel the pressure to make messes in order to meet deadlines. In short, they don’t take the time to go fast!\n 程序员面临着一种基础价值谜题。有那么几年经验的开发者都知道，之前的混乱拖了自己的后腿。但开发者们背负期限的压力，只好制造混乱。简言之，他们没花时间让自己做得更快！\n True professionals know that the second part of the conundrum is wrong. You will not make the deadline by making the mess. Indeed, the mess will slow you down instantly, and will force you to miss the deadline. The only way to make the deadline—the only way to go fast—is to keep the code as clean as possible at all times.\n 真正的专业人士明白，这道谜题的第二部分说错了。制造混乱无助于赶上期限。混乱只会立刻拖慢你，叫你错过期限。赶上期限的唯一方法——做得快的唯一方法 ——就是始终尽可能保持代码整洁。\n 1.3.4 The Art of Clean Code? 整洁代码的艺术 #  Let’s say you believe that messy code is a significant impediment. Let’s say that you accept that the only way to go fast is to keep your code clean. Then you must ask yourself: “How do I write clean code?” It’s no good trying to write clean code if you don’t know what it means for code to be clean!\n 假设你相信混乱的代码是祸首，假设你接受做得快的唯一方法是保持代码整洁的说法，你一定会自问：“我怎么才能写出整洁的代码？”不过，如果你不明白整洁对代码有何意义，尝试去写整洁代码就毫无所益！\n The bad news is that writing clean code is a lot like painting a picture. Most of us know when a picture is painted well or badly. But being able to recognize good art from bad does not mean that we know how to paint. So too being able to recognize clean code from dirty code does not mean that we know how to write clean code!\n 坏消息是写整洁代码很像是绘画。多数人都知道一幅画是好还是坏。但能分辨优劣并不表示懂得绘画。能分辨整洁代码和肮脏代码，也不意味着会写整洁代码！\n Writing clean code requires the disciplined use of a myriad little techniques applied through a painstakingly acquired sense of “cleanliness.” This “code-sense” is the key. Some of us are born with it. Some of us have to fight to acquire it. Not only does it let us see whether code is good or bad, but it also shows us the strategy for applying our discipline to transform bad code into clean code.\n 写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”。这种“代码感”就是关键所在。有些人生而有之。有些人费点劲才能得到。它不仅让我们看到代码的优劣，还予我们以借戒规之力化劣为优的攻略。\n A programmer without “code-sense” can look at a messy module and recognize the mess but will have no idea what to do about it. A programmer with “code-sense” will look at a messy module and see options and variations. The “code-sense” will help that programmer choose the best variation and guide him or her to plot a sequence of behavior preserving transformations to get from here to there.\n 缺乏“代码感”的程序员，看混乱是混乱，无处着手。有“代码感”的程序员能从混乱中看出其他的可能与变化。“代码感”帮助程序员选出最好的方案，并指导程序员制订修改行动计划，按图索骥。\n In short, a programmer who writes clean code is an artist who can take a blank screen through a series of transformations until it is an elegantly coded system.\n 简言之，编写整洁代码的程序员就像是艺术家，他能用一系列变换把一块白板变作由优雅代码构成的系统。\n 1.3.5 What Is Clean Code? 什么是整洁代码 #  There are probably as many definitions as there are programmers. So I asked some very well-known and deeply experienced programmers what they thought.\n 有多少程序员，就有多少定义。所以我只询问了一些非常知名且经验丰富的程序员。\n  Bjarne Stroustrup, inventor of C++ and author of The C++ Programming Language\n Bjarne Stroustrup，C++语言发明者，C++Programming Language（中译版《C++程序设计语言》）一书作者。\n I like my code to be elegant and efficient. The logic should be straightforward to make it hard for bugs to hide, the dependencies minimal to ease maintenance, error handling complete according to an articulated strategy, and performance close to optimal so as not to tempt people to make the code messy with unprincipled optimizations. Clean code does one thing well.\n 我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。\n Bjarne uses the word “elegant.” That’s quite a word! The dictionary in my MacBook® provides the following definitions: pleasingly graceful and stylish in appearance or manner; pleasingly ingenious and simple. Notice the emphasis on the word “pleasing.” Apparently Bjarne thinks that clean code is pleasing to read. Reading it should make you smile the way a well-crafted music box or well-designed car would.\n Bjarne 用了“优雅”一词。说得好！我 MacBook 上的词典提供了如下定义：外表或举止上令人愉悦的优美和雅观；令人愉悦的精致和简单。注意对“愉悦”一词的强调。Bjarne 显然认为整洁的代码读起来令人愉悦。读这种代码，就像见到手工精美的音乐盒或者设计精良的汽车一般，让你会心一笑。\n Bjarne also mentions efficiency—twice. Perhaps this should not surprise us coming from the inventor of C++; but I think there’s more to it than the sheer desire for speed. Wasted cycles are inelegant, they are not pleasing. And now note the word that Bjarne uses to describe the consequence of that inelegance. He uses the word “tempt.” There is a deep truth here. Bad code tempts the mess to grow! When others change bad code, they tend to make it worse.\n Bjarne 也提到效率——而且两次提及。这话出自 C++发明者之口，或许并不出奇；不过我认为并非是在单纯追求速度。被浪费掉的运算周期并不雅观，并不令人愉悦。留意 Bjarne 怎么描述那种不雅观的结果。他用了“引诱”这个词。诚哉斯言。糟糕的代码引发混乱！别人修改糟糕的代码时，往往会越改越烂。\n Pragmatic Dave Thomas and Andy Hunt said this a different way. They used the metaphor of broken windows.3 A building with broken windows looks like nobody cares about it. So other people stop caring. They allow more windows to become broken. Eventually they actively break them. They despoil the facade with graffiti and allow garbage to collect. One broken window starts the process toward decay.\n 务实的 Dave Thomas 和 Andy Hunt 从另一角度阐述了这种情况。他们提到破窗理论。窗户破损了的建筑让人觉得似乎无人照管。于是别人也再不关心。他们放任窗户继续破损。最终自己也参加破坏活动，在外墙上涂鸦，任垃圾堆积。一扇破损的窗户开辟了大厦走向倾颓的道路。\n Bjarne also mentions that error handing should be complete. This goes to the discipline of paying attention to details. Abbreviated error handling is just one way that programmers gloss over details. Memory leaks are another, race conditions still another. Inconsistent naming yet another. The upshot is that clean code exhibits close attention to detail.\n Bjarne 也提到完善错误处理代码。往深处说就是在细节上花心思。敷衍了事的错误处理代码只是程序员忽视细节的一种表现。此外还有内存泄漏，还有竞态条件代码。还有前后不一致的命名方式。结果就是凸现出整洁代码对细节的重视。\n Bjarne closes with the assertion that clean code does one thing well. It is no accident that there are so many principles of software design that can be boiled down to this simple admonition. Writer after writer has tried to communicate this thought. Bad code tries to do too much, it has muddled intent and ambiguity of purpose. Clean code is focused. Each function, each class, each module exposes a single-minded attitude that remains entirely undistracted, and unpolluted, by the surrounding details.\n Bjarne 以“整洁的代码只做好一件事”结束论断。毋庸置疑，软件设计的许多原则最终都会归结为这句警语。有那么多人发表过类似的言论。糟糕的代码想做太多事，它意图混乱、目的含混。整洁的代码力求集中。每个函数、每个类和每个模块都全神贯注于一事，完全不受四周细节的干扰和污染。\n Grady Booch, author of Object Oriented Analysis and Design with Applications\n Grady Booch，Object Oriented Analysis and Design with Applications（中译版《面向对象分析与设计》）一书作者。\n  Clean code is simple and direct. Clean code reads like well-written prose. Clean code never obscures the designer’s intent but rather is full of crisp abstractions and straightforward lines of control.\n 整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。\n Grady makes some of the same points as Bjarne, but he takes a readability perspective. I especially like his view that clean code should read like well-written prose. Think back on a really good book that you’ve read. Remember how the words disappeared to be replaced by images! It was like watching a movie, wasn’t it? Better! You saw the characters, you heard the sounds, you experienced the pathos and the humor.\n Grady 的观点与 Bjarne 的观点有类似之处，但他从可读性的角度来定义。我特别喜欢“整洁的代码如同优美的散文”这种看法。想想你读过的某本好书。回忆一下，那些文字是如何在脑中形成影像！就像是看了场电影，对吧？还不止！你还看到那些人物，听到那些声音，体验到那些喜怒哀乐。\n Reading clean code will never be quite like reading Lord of the Rings. Still, the literary metaphor is not a bad one. Like a good novel, clean code should clearly expose the tensions in the problem to be solved. It should build those tensions to a climax and then give the reader that “Aha! Of course!” as the issues and tensions are resolved in the revelation of an obvious solution.\n 阅读整洁的代码和阅读 Lord of the Rings（中译版《指环王》）自然不同。不过，仍有可类比之处。如同一本好的小说般，整洁的代码应当明确地展现出要解决问题的张力。它应当将这种张力推至高潮，以某种显而易见的方案解决问题和张力，使读者发出“啊哈！本当如此！”的感叹。\n I find Grady’s use of the phrase “crisp abstraction” to be a fascinating oxymoron! After all the word “crisp” is nearly a synonym for “concrete.” My MacBook’s dictionary holds the following definition of “crisp”: briskly decisive and matter-of-fact, without hesitation or unnecessary detail. Despite this seeming juxtaposition of meaning, the words carry a powerful message. Our code should be matter-of-fact as opposed to speculative. It should contain only what is necessary. Our readers should perceive us to have been decisive.\n 窃以为 Grady 所谓“干净利落的抽象”（crisp abstraction），乃是绝妙的矛盾修辞法。毕竟 crisp 几乎就是“具体”（concrete）的同义词。我 MacBook 上的词典这样定义 crisp 一词：果断决绝，就事论事，没有犹豫或不必要的细节。尽管有两种不同的定义，该词还是承载了有力的信息。代码应当讲述事实，不引人猜测。它只该包含必需之物。读者应当感受到我们的果断决绝。\n “Big” Dave Thomas, founder of OTI, godfather of the Eclipse strategy\n “老大”Dave Thomas，OTI 公司创始人，Eclipse 战略教父。\n  Clean code can be read, and enhanced by a developer other than its original author. It has unit and acceptance tests. It has meaningful names. It provides one way rather than many ways for doing one thing. It has minimal dependencies, which are explicitly defined, and provides a clear and minimal API. Code should be literate since depending on the language, not all necessary information can be expressed clearly in code alone.\n 整洁的代码应可由作者之外的开发者阅读和增补。它应当有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，而且要明确地定义和提供清晰、尽量少的 API。代码应通过其字面表达含义，因为不同的语言导致并非所有必需信息均可通过代码自身清晰表达。\n Big Dave shares Grady’s desire for readability, but with an important twist. Dave asserts that clean code makes it easy for other people to enhance it. This may seem obvious, but it cannot be overemphasized. There is, after all, a difference between code that is easy to read and code that is easy to change.\n Dave 老大在可读性上和 Grady 持相同观点，但有一个重要的不同之处。Dave 断言，整洁的代码便于其他人加以增补。这看似显而易见，但亦不可过分强调。毕竟易读的代码和易修改的代码之间还是有区别的。\n Dave ties cleanliness to tests! Ten years ago this would have raised a lot of eyebrows. But the discipline of Test Driven Development has made a profound impact upon our industry and has become one of our most fundamental disciplines. Dave is right. Code, without tests, is not clean. No matter how elegant it is, no matter how readable and accessible, if it hath not tests, it be unclean.\n Dave 将整洁系于测试之上！要在十年之前，这会让人大跌眼镜。但测试驱动开发（Test Driven Development）已在行业中造成了深远影响，成为基础规程之一。Dave 说得对。没有测试的代码不干净。不管它有多优雅，不管有多可读、多易理解，微乎测试，其不洁亦可知也。\n Dave uses the word minimal twice. Apparently he values code that is small, rather than code that is large. Indeed, this has been a common refrain throughout software literature since its inception. Smaller is better.\n Dave 两次提及“尽量少”。显然，他推崇小块的代码。实际上，从有软件起人们就在反复强调这一点。越小越好。\n Dave also says that code should be literate. This is a soft reference to Knuth’s literate programming.4 The upshot is that the code should be composed in such a form as to make it readable by humans.\n Dave 也提到，代码应在字面上表达其含义。这一观点源自 Knuth 的“字面编程”（literate programming）。结论就是应当用人类可读的方式来写代码。\n Michael Feathers, author of Working Effectively with Legacy Code\n Michael Feathers，Working Effectively with Legacy Code（中译版《修改代码的艺术》）一书作者。\n  I could list all of the qualities that I notice in clean code, but there is one overarching quality that leads to all of them. Clean code always looks like it was written by someone who cares. There is nothing obvious that you can do to make it better. All of those things were thought about by the code’s author, and if you try to imagine improvements, you’re led back to where you are, sitting in appreciation of the code someone left for you—code left by someone who cares deeply about the craft.\n 我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的。整洁的代码总是看起来像是某位特别在意它的人写的。几乎没有改进的余地。代码作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给你的代码——全心投入的某人留下的代码。\n One word: care. That’s really the topic of this book. Perhaps an appropriate subtitle would be How to Care for Code.\n 一言以蔽之：在意。这就是本书的题旨所在。或许该加个副标题，如何在意代码。\n Michael hit it on the head. Clean code is code that has been taken care of. Someone has taken the time to keep it simple and orderly. They have paid appropriate attention to details. They have cared.\n Michael 一针见血。整洁代码就是作者着力照料的代码。有人曾花时间让它保持简单有序。他们适当地关注到了细节。他们在意过。\n Ron Jeffries, author of Extreme Programming Installed and Extreme Programming Adventures in C#\n Ron Jeffries，Extreme Programming Installed（中译版《极限编程实施》）以及 Extreme Programming Adventures in C#（中译版《C#极限编程探险》）作者。\n Ron began his career programming in Fortran at the Strategic Air Command and has written code in almost every language and on almost every machine. It pays to consider his words carefully.\n Ron 初入行就在战略空军司令部（Strategic Air Command）编写 Fortran 程序，此后几乎在每种机器上编写过每种语言的代码。他的言论值得咀嚼。\n  In recent years I begin, and nearly end, with Beck’s rules of simple code. In priority order, simple code:\n 近年来，我开始研究贝克的简单代码规则，差不多也都琢磨透了。简单代码，依其重要顺序：\n  Runs all the tests; Contains no duplication; Expresses all the design ideas that are in the system; Minimizes the number of entities such as classes, methods, functions, and the like.     能通过所有测试； 没有重复代码； 体现系统中的全部设计理念； 包括尽量少的实体，比如类、方法、函数等。   Of these, I focus mostly on duplication. When the same thing is done over and over, it’s a sign that there is an idea in our mind that is not well represented in the code. I try to figure out what it is. Then I try to express that idea more clearly.\n 在以上诸项中，我最在意代码重复。如果同一段代码反复出现，就表示某种想法未在代码中得到良好的体现。我尽力去找出到底那是什么，然后再尽力更清晰地表达出来。\n Expressiveness to me includes meaningful names, and I am likely to change the names of things several times before I settle in. With modern coding tools such as Eclipse, renaming is quite inexpensive, so it doesn’t trouble me to change. Expressiveness goes beyond names, however. I also look at whether an object or method is doing more than one thing. If it’s an object, it probably needs to be broken into two or more objects. If it’s a method, I will always use the Extract Method refactoring on it, resulting in one method that says more clearly what it does, and some submethods saying how it is done.\n 在我看来，有意义的命名是体现表达力的一种方式，我往往会修改好几次才会定下名字来。借助 Eclipse 这样的现代编码工具，重命名代价极低，所以我无所顾忌。然而，表达力还不只体现在命名上。我也会检查对象或方法是否想做的事太多。如果对象功能太多，最好是切分为两个或多个对象。如果方法功能太多，我总是使用抽取手段（Extract Method）重构之，从而得到一个能较为清晰地说明自身功能的方法，以及另外数个说明如何实现这些功能的方法。\n Duplication and expressiveness take me a very long way into what I consider clean code, and improving dirty code with just these two things in mind can make a huge difference. There is, however, one other thing that I’m aware of doing, which is a bit harder to explain.\n 消除重复和提高表达力让我在整洁代码方面获益良多，只要铭记这两点，改进脏代码时就会大有不同。不过，我时常关注的另一规则就不太好解释了。\n After years of doing this work, it seems to me that all programs are made up of very similar elements. One example is “find things in a collection.” Whether we have a database of employee records, or a hash map of keys and values, or an array of items of some kind, we often find ourselves wanting a particular item from that collection. When I find that happening, I will often wrap the particular implementation in a more abstract method or class. That gives me a couple of interesting advantages.\n 这么多年下来，我发现所有程序都由极为相似的元素构成。例如“在集合中查找某物”。不管是雇员记录数据库还是名-值对哈希表，或者某类条目的数组，我们都会发现自己想要从集合中找到某一特定条目。一旦出现这种情况，我通常会把实现手段封装到更抽象的方法或类中。这样做好处多多。\n I can implement the functionality now with something simple, say a hash map, but since now all the references to that search are covered by my little abstraction, I can change the implementation any time I want. I can go forward quickly while preserving my ability to change later.\n 可以先用某种简单的手段，比如哈希表来实现这一功能，由于对搜索功能的引用指向了我那个小小的抽象，就能随需应变，修改实现手段。这样就既能快速前进，又能为未来的修改预留余地。\n In addition, the collection abstraction often calls my attention to what’s “really” going on, and keeps me from running down the path of implementing arbitrary collection behavior when all I really need is a few fairly simple ways of finding what I want.\n 另外，该集合抽象常常提醒我留意“真正”在发生的事，避免随意实现集合行为，因为我真正需要的不过是某种简单的查找手段。\n Reduced duplication, high expressiveness, and early building of simple abstractions. That’s what makes clean code for me.\n 减少重复代码，提高表达力，提早构建简单抽象。这就是我写整洁代码的方法。\n Here, in a few short paragraphs, Ron has summarized the contents of this book. No duplication, one thing, expressiveness, tiny abstractions. Everything is there.\n Ron 以寥寥数段文字概括了本书的全部内容。不要重复代码，只做一件事，表达力，小规模抽象。该有的都有了。\n Ward Cunningham, inventor of Wiki, inventor of Fit, coinventor of eXtreme Programming. Motive force behind Design Patterns. Smalltalk and OO thought leader. The godfather of all those who care about code.\n Ward Cunningham，Wiki 发明者，eXtreme Programming （极限编程）的创始人之一，Smalltalk 语言和面向对象的思想领袖。所有在意代码者的教父。\n  You know you are working on clean code when each routine you read turns out to be pretty much what you expected. You can call it beautiful code when the code also makes it look like the language was made for the problem.\n 如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。\n Statements like this are characteristic of Ward. You read it, nod your head, and then go on to the next topic. It sounds so reasonable, so obvious, that it barely registers as something profound. You might think it was pretty much what you expected. But let’s take a closer look.\n 这种说法很 Ward。它教你听了之后就点头，然后继续听下去。如此在理，如此浅显，绝不故作高深。你大概以为此言深合己意吧。再走近点看看。\n “… pretty much what you expected.” When was the last time you saw a module that was pretty much what you expected? Isn’t it more likely that the modules you look at will be puzzling, complicated, tangled? Isn’t misdirection the rule? Aren’t you used to flailing about trying to grab and hold the threads of reasoning that spew forth from the whole system and weave their way through the module you are reading? When was the last time you read through some code and nodded your head the way you might have nodded your head at Ward’s statement?\n “……深合己意”。你最近一次看到深合己意的模块是什么时候？模块多半都繁复难解吧？难道没有触犯规则吗？你不是也曾挣扎着想抓住些从整个系统中散落而出的线索，编织进你在读的那个模块吗？你最近一次读到某段代码、并且如同对 Ward 的说法点头一般对这段代码点头，是什么时候的事了？\n Ward expects that when you read clean code you won’t be surprised at all. Indeed, you won’t even expend much effort. You will read it, and it will be pretty much what you expected. It will be obvious, simple, and compelling. Each module will set the stage for the next. Each tells you how the next will be written. Programs that are that clean are so profoundly well written that you don’t even notice it. The designer makes it look ridiculously simple like all exceptional designs.\n Ward 期望你不会为整洁代码所震惊。你无需花太多力气。那代码就是深合你意。它明确、简单、有力。每个模块都为下一个模块做好准备。每个模块都告诉你下一个模块会是怎样的。整洁的程序好到你根本不会注意到它。设计者把它做得像一切其他设计般简单。\n And what about Ward’s notion of beauty? We’ve all railed against the fact that our languages weren’t designed for our problems. But Ward’s statement puts the onus back on us. He says that beautiful code makes the language look like it was made for the problem! So it’s our responsibility to make the language look simple! Language bigots everywhere, beware! It is not the language that makes programs appear simple. It is the programmer that make the language appear simple!\n 那 Ward 有关“美”的说法又如何呢？我们都曾面临语言不是为要解决的问题所设计的困境。但 Ward 的说法又把球踢回我们这边。他说，漂亮的代码让编程语言像是专为解决那个问题而存在！所以，让语言变得简单的责任就在我们身上了！当心，语言是冥顽不化的！是程序员让语言显得简单。\n "});index.add({'id':67,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.3.-The-Package-Declaration/','title':"10.3. 包声明",'section':"10. 包和工具",'content':"10.3. 包声明 #  在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。\n例如，math/rand包的每个源文件的开头都包含package rand包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(rand.Int()) } 通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。\n关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。\n第二个例外，包所在的目录中可能有一些文件名是以_test.go为后缀的Go源文件（译注：前面必须有其它的字符，因为以_或.开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。\n第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。\n"});index.add({'id':68,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.3.-Building-Packages/','title':"10.7.3. 构建包",'section':"10.7. 工具",'content':"10.7.3. 构建包 #  go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main，go build将调用链接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。\n由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org/x/tools/cmd/godoc命令就是放在cmd子目录（§10.7.4）。\n每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指定，相对路径必须以.或..开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包，虽然它们的写法各不相同：\n$ cd $GOPATH/src/gopl.io/ch1/helloworld $ go build 或者：\n$ cd anywhere $ go build gopl.io/ch1/helloworld 或者：\n$ cd $GOPATH $ go build ./src/gopl.io/ch1/helloworld 但不能这样：\n$ cd $GOPATH $ go build src/gopl.io/ch1/helloworld Error: cannot find package \u0026quot;src/gopl.io/ch1/helloworld\u0026quot;. 也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。\n$ cat quoteargs.go package main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) func main() { fmt.Printf(\u0026quot;%q\\n\u0026quot;, os.Args[1:]) } $ go build quoteargs.go $ ./quoteargs one \u0026quot;two three\u0026quot; four\\ five [\u0026quot;one\u0026quot; \u0026quot;two three\u0026quot; \u0026quot;four five\u0026quot;] 特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。go run命令实际上是结合了构建和运行的两个步骤：\n$ go run quoteargs.go one \u0026quot;two three\u0026quot; four\\ five [\u0026quot;one\u0026quot; \u0026quot;two three\u0026quot; \u0026quot;four five\u0026quot;] (译注：其实也可以偷懒，直接go run *.go)\n第一行的参数列表中，第一个不是以.go结尾的将作为可执行程序的参数运行。\n默认情况下，go build命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。依赖分析和编译过程虽然都是很快的，但是随着项目增加到几十个包和成千上万行代码，依赖关系分析和编译时间的消耗将变的可观，有时候可能需要几秒种，即使这些依赖项没有改变。\ngo install命令和go build命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH/pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH/bin目录。（很多用户会将$GOPATH/bin添加到可执行程序的搜索列表中。）还有，go install命令和go build命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，go build -i命令将安装每个目标所依赖的包。\n因为编译对应不同的操作系统平台和CPU架构，go install命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，golang.org/x/net/html包将被安装到$GOPATH/pkg/darwin_amd64目录下的golang.org/x/net/html.a文件。\n针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时的操作系统和CPU类型：\ngopl.io/ch10/cross\nfunc main() { fmt.Println(runtime.GOOS, runtime.GOARCH) } 下面以64位和32位环境分别编译和执行：\n$ go build gopl.io/ch10/cross $ ./cross darwin amd64 $ GOARCH=386 go build gopl.io/ch10/cross $ ./cross darwin 386 有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：\n// +build linux darwin 在包声明和包注释的前面，该构建注释参数告诉go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件：\n// +build ignore 更多细节，可以参考go/build包的构建约束部分的文档。\n$ go doc go/build "});index.add({'id':69,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.3.-White-Box-Testing/','title':"11.2.3. 白盒测试",'section':"11.2. 测试函数",'content':"11.2.3. 白盒测试 #  一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（白盒测试只是一个传统的名称，其实称为clear box测试会更准确。）\n黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。\n我们已经看到两种测试的例子。TestIsPalindrome测试仅仅使用导出的IsPalindrome函数，因此这是一个黑盒测试。TestEcho测试则调用了内部的echo函数，并且更新了内部的out包级变量，这两个都是未导出的，因此这是白盒测试。\n当我们准备TestEcho测试的时候，我们修改了echo函数使用包级的out变量作为输出对象，因此测试代码可以用另一个实现代替标准输出，这样可以方便对比echo输出的数据。使用类似的技术，我们可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。\n下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。（译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值=\u0026gt;触发报警的逻辑，所以是很实用的案例。）\ngopl.io/ch11/storage1\npackage storage import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/smtp\u0026#34; ) func bytesInUse(username string) int64 { return 0 /* ... */ } // Email sender configuration. // NOTE: never put passwords in source code! const sender = \u0026#34;notifications@example.com\u0026#34; const password = \u0026#34;correcthorsebatterystaple\u0026#34; const hostname = \u0026#34;smtp.example.com\u0026#34; const template = `Warning: you are using %d bytes of storage, %d%% of your quota.` func CheckQuota(username string) { used := bytesInUse(username) const quota = 1000000000 // 1GB \tpercent := 100 * used / quota if percent \u0026lt; 90 { return // OK \t} msg := fmt.Sprintf(template, used, percent) auth := smtp.PlainAuth(\u0026#34;\u0026#34;, sender, password, hostname) err := smtp.SendMail(hostname+\u0026#34;:587\u0026#34;, auth, sender, []string{username}, []byte(msg)) if err != nil { log.Printf(\u0026#34;smtp.SendMail(%s) failed: %s\u0026#34;, username, err) } } 我们想测试这段代码，但是我们并不希望发送真实的邮件。因此我们将邮件处理逻辑放到一个私有的notifyUser函数中。\ngopl.io/ch11/storage2\nvar notifyUser = func(username, msg string) { auth := smtp.PlainAuth(\u0026#34;\u0026#34;, sender, password, hostname) err := smtp.SendMail(hostname+\u0026#34;:587\u0026#34;, auth, sender, []string{username}, []byte(msg)) if err != nil { log.Printf(\u0026#34;smtp.SendEmail(%s) failed: %s\u0026#34;, username, err) } } func CheckQuota(username string) { used := bytesInUse(username) const quota = 1000000000 // 1GB \tpercent := 100 * used / quota if percent \u0026lt; 90 { return // OK \t} msg := fmt.Sprintf(template, used, percent) notifyUser(username, msg) } 现在我们可以在测试中用伪邮件发送函数替代真实的邮件发送函数。它只是简单记录要通知的用户和邮件的内容。\npackage storage import ( \u0026#34;strings\u0026#34; \u0026#34;testing\u0026#34; ) func TestCheckQuotaNotifiesUser(t *testing.T) { var notifiedUser, notifiedMsg string notifyUser = func(user, msg string) { notifiedUser, notifiedMsg = user, msg } // ...simulate a 980MB-used condition...  const user = \u0026#34;joe@example.org\u0026#34; CheckQuota(user) if notifiedUser == \u0026#34;\u0026#34; \u0026amp;\u0026amp; notifiedMsg == \u0026#34;\u0026#34; { t.Fatalf(\u0026#34;notifyUser not called\u0026#34;) } if notifiedUser != user { t.Errorf(\u0026#34;wrong user (%s) notified, want %s\u0026#34;, notifiedUser, user) } const wantSubstring = \u0026#34;98% of your quota\u0026#34; if !strings.Contains(notifiedMsg, wantSubstring) { t.Errorf(\u0026#34;unexpected notification message \u0026lt;\u0026lt;%s\u0026gt;\u0026gt;, \u0026#34;+ \u0026#34;want substring %q\u0026#34;, notifiedMsg, wantSubstring) } } 这里有一个问题：当测试函数返回后，CheckQuota将不能正常工作，因为notifyUsers依然使用的是测试函数的伪发送邮件函数（当更新全局对象的时候总会有这种风险）。 我们必须修改测试代码恢复notifyUsers原先的状态以便后续其他的测试没有影响，要确保所有的执行路径后都能恢复，包括测试失败或panic异常的情形。在这种情况下，我们建议使用defer语句来延后执行处理恢复的代码。\nfunc TestCheckQuotaNotifiesUser(t *testing.T) { // Save and restore original notifyUser. \tsaved := notifyUser defer func() { notifyUser = saved }() // Install the test\u0026#39;s fake notifyUser. \tvar notifiedUser, notifiedMsg string notifyUser = func(user, msg string) { notifiedUser, notifiedMsg = user, msg } // ...rest of test... } 这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。\n以这种方式使用全局变量是安全的，因为go test命令并不会同时并发地执行多个测试。\n"});index.add({'id':70,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.3.-Coverage/','title':"11.3. 测试覆盖率",'section':"11. 测试",'content':"11.3. 测试覆盖率 #  就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再多的测试也不能证明一个程序没有BUG。在最好的情况下，测试可以增强我们的信心：代码在很多重要场景下是可以正常工作的。\n对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化——即使最简单的程序的动态也是难以精确测量的——但是有启发式方法来帮助我们编写有效的测试代码。\n这些启发式方法中，语句的覆盖率是最简单和最广泛使用的。语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。在本节中，我们使用go test命令中集成的测试覆盖率工具，来度量下面代码的测试覆盖率，帮助我们识别测试和我们期望间的差距。\n下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：\ngopl.io/ch7/eval\nfunc TestCoverage(t *testing.T) { var tests = []struct { input string env Env want string // expected error from Parse/Check or result from Eval \t}{ {\u0026#34;x % 2\u0026#34;, nil, \u0026#34;unexpected \u0026#39;%\u0026#39;\u0026#34;}, {\u0026#34;!true\u0026#34;, nil, \u0026#34;unexpected \u0026#39;!\u0026#39;\u0026#34;}, {\u0026#34;log(10)\u0026#34;, nil, `unknown function \u0026#34;log\u0026#34;`}, {\u0026#34;sqrt(1, 2)\u0026#34;, nil, \u0026#34;call to sqrt has 2 args, want 1\u0026#34;}, {\u0026#34;sqrt(A / pi)\u0026#34;, Env{\u0026#34;A\u0026#34;: 87616, \u0026#34;pi\u0026#34;: math.Pi}, \u0026#34;167\u0026#34;}, {\u0026#34;pow(x, 3) + pow(y, 3)\u0026#34;, Env{\u0026#34;x\u0026#34;: 9, \u0026#34;y\u0026#34;: 10}, \u0026#34;1729\u0026#34;}, {\u0026#34;5 / 9 * (F - 32)\u0026#34;, Env{\u0026#34;F\u0026#34;: -40}, \u0026#34;-40\u0026#34;}, } for _, test := range tests { expr, err := Parse(test.input) if err == nil { err = expr.Check(map[Var]bool{}) } if err != nil { if err.Error() != test.want { t.Errorf(\u0026#34;%s: got %q, want %q\u0026#34;, test.input, err, test.want) } continue } got := fmt.Sprintf(\u0026#34;%.6g\u0026#34;, expr.Eval(test.env)) if got != test.want { t.Errorf(\u0026#34;%s: %v =\u0026gt; %s, want %s\u0026#34;, test.input, test.env, got, test.want) } } } 首先，我们要确保所有的测试都正常通过：\n$ go test -v -run=Coverage gopl.io/ch7/eval === RUN TestCoverage --- PASS: TestCoverage (0.00s) PASS ok gopl.io/ch7/eval 0.011s 下面这个命令可以显示测试覆盖率工具的使用用法：\n$ go tool cover Usage of 'go tool cover': Given a coverage profile produced by 'go test': go test -coverprofile=c.out Open a web browser displaying annotated source code: go tool cover -html=c.out ... go tool命令运行Go工具链的底层可执行程序。这些底层可执行程序放在$GOROOT/pkg/tool/${GOOS}_${GOARCH}目录。因为有go build命令的原因，我们很少直接调用这些底层工具。\n现在我们可以用-coverprofile标志参数重新运行测试：\n$ go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval ok gopl.io/ch7/eval 0.032s coverage: 68.5% of statements 这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用go test -cover。）\n如果使用了-covermode=count标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。\n为了收集数据，我们运行了测试覆盖率工具，打印了测试日志，生成一个HTML报告，然后在浏览器中打开（图11.3）。\n$ go tool cover -html=c.out  绿色的代码块被测试覆盖到了，红色的则表示没有被覆盖到。为了清晰起见，我们将背景红色文本的背景设置成了阴影效果。我们可以马上发现unary操作的Eval方法并没有被执行到。如果我们针对这部分未被覆盖的代码添加下面的测试用例，然后重新运行上面的命令，那么我们将会看到那个红色部分的代码也变成绿色了：\n{\u0026quot;-x * -x\u0026quot;, eval.Env{\u0026quot;x\u0026quot;: 2}, \u0026quot;4\u0026quot;} 不过两个panic语句依然是红色的。这是没有问题的，因为这两个语句并不会被执行到。\n实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；因为对于逻辑复杂的语句需要针对不同的输入执行多次。有一些语句，例如上面的panic语句则永远都不会被执行到。另外，还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试从本质上来说是一个比较务实的工作，编写测试代码和编写应用代码的成本对比是需要考虑的。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。\n"});index.add({'id':71,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.3.-Display-a-Recursive-Value-Printer/','title':"12.2. reflect.Type 和 reflect.Value",'section':"12. 反射",'content':"12.3. Display，一个递归的值打印器 #  接下来，让我们看看如何改善聚合数据类型的显示。我们并不想完全克隆一个fmt.Sprint函数，我们只是构建一个用于调试用的Display函数：给定任意一个复杂类型 x，打印这个值对应的完整结构，同时标记每个元素的发现路径。让我们从一个例子开始。\ne, _ := eval.Parse(\u0026#34;sqrt(A / pi)\u0026#34;) Display(\u0026#34;e\u0026#34;, e) 在上面的调用中，传入Display函数的参数是在7.9节一个表达式求值函数返回的语法树。Display函数的输出如下：\nDisplay e (eval.call): e.fn = \u0026#34;sqrt\u0026#34; e.args[0].type = eval.binary e.args[0].value.op = 47 e.args[0].value.x.type = eval.Var e.args[0].value.x.value = \u0026#34;A\u0026#34; e.args[0].value.y.type = eval.Var e.args[0].value.y.value = \u0026#34;pi\u0026#34; 你应该尽量避免在一个包的API中暴露涉及反射的接口。我们将定义一个未导出的display函数用于递归处理工作，导出的是Display函数，它只是display函数简单的包装以接受interface{}类型的参数：\ngopl.io/ch12/display\nfunc Display(name string, x interface{}) { fmt.Printf(\u0026#34;Display %s (%T):\\n\u0026#34;, name, x) display(name, reflect.ValueOf(x)) } 在display函数中，我们使用了前面定义的打印基础类型——基本类型、函数和chan等——元素值的formatAtom函数，但是我们会使用reflect.Value的方法来递归显示复杂类型的每一个成员。在递归下降过程中，path字符串，从最开始传入的起始值（这里是“e”），将逐步增长来表示是如何达到当前值（例如“e.args[0].value”）的。\n因为我们不再模拟fmt.Sprint函数，我们将直接使用fmt包来简化我们的例子实现。\nfunc display(path string, v reflect.Value) { switch v.Kind() { case reflect.Invalid: fmt.Printf(\u0026#34;%s = invalid\\n\u0026#34;, path) case reflect.Slice, reflect.Array: for i := 0; i \u0026lt; v.Len(); i++ { display(fmt.Sprintf(\u0026#34;%s[%d]\u0026#34;, path, i), v.Index(i)) } case reflect.Struct: for i := 0; i \u0026lt; v.NumField(); i++ { fieldPath := fmt.Sprintf(\u0026#34;%s.%s\u0026#34;, path, v.Type().Field(i).Name) display(fieldPath, v.Field(i)) } case reflect.Map: for _, key := range v.MapKeys() { display(fmt.Sprintf(\u0026#34;%s[%s]\u0026#34;, path, formatAtom(key)), v.MapIndex(key)) } case reflect.Ptr: if v.IsNil() { fmt.Printf(\u0026#34;%s = nil\\n\u0026#34;, path) } else { display(fmt.Sprintf(\u0026#34;(*%s)\u0026#34;, path), v.Elem()) } case reflect.Interface: if v.IsNil() { fmt.Printf(\u0026#34;%s = nil\\n\u0026#34;, path) } else { fmt.Printf(\u0026#34;%s.type = %s\\n\u0026#34;, path, v.Elem().Type()) display(path+\u0026#34;.value\u0026#34;, v.Elem()) } default: // basic types, channels, funcs \tfmt.Printf(\u0026#34;%s = %s\\n\u0026#34;, path, formatAtom(v)) } } 让我们针对不同类型分别讨论。\nSlice和数组： 两种的处理逻辑是一样的。Len方法返回slice或数组值中的元素个数，Index(i)获得索引i对应的元素，返回的也是一个reflect.Value；如果索引i超出范围的话将导致panic异常，这与数组或slice类型内建的len(a)和a[i]操作类似。display针对序列中的每个元素递归调用自身处理，我们通过在递归处理时向path附加“[i]”来表示访问路径。\n虽然reflect.Value类型带有很多方法，但是只有少数的方法能对任意值都安全调用。例如，Index方法只能对Slice、数组或字符串类型的值调用，如果对其它类型调用则会导致panic异常。\n结构体： NumField方法报告结构体中成员的数量，Field(i)以reflect.Value类型返回第i个成员的值。成员列表也包括通过匿名字段提升上来的成员。为了在path添加“.f”来表示成员路径，我们必须获得结构体对应的reflect.Type类型信息，然后访问结构体第i个成员的名字。\nMaps: MapKeys方法返回一个reflect.Value类型的slice，每一个元素对应map的一个key。和往常一样，遍历map时顺序是随机的。MapIndex(key)返回map中key对应的value。我们向path添加“[key]”来表示访问路径。（我们这里有一个未完成的工作。其实map的key的类型并不局限于formatAtom能完美处理的类型；数组、结构体和接口都可以作为map的key。针对这种类型，完善key的显示信息是练习12.1的任务。）\n指针： Elem方法返回指针指向的变量，依然是reflect.Value类型。即使指针是nil，这个操作也是安全的，在这种情况下指针是Invalid类型，但是我们可以用IsNil方法来显式地测试一个空指针，这样我们可以打印更合适的信息。我们在path前面添加“*”，并用括弧包含以避免歧义。\n接口： 再一次，我们使用IsNil方法来测试接口是否是nil，如果不是，我们可以调用v.Elem()来获取接口对应的动态值，并且打印对应的类型和值。\n现在我们的Display函数总算完工了，让我们看看它的表现吧。下面的Movie类型是在4.5节的电影类型上演变来的：\ntype Movie struct { Title, Subtitle string Year int Color bool Actor map[string]string Oscars []string Sequel *string } 让我们声明一个该类型的变量，然后看看Display函数如何显示它：\nstrangelove := Movie{ Title: \u0026#34;Dr. Strangelove\u0026#34;, Subtitle: \u0026#34;How I Learned to Stop Worrying and Love the Bomb\u0026#34;, Year: 1964, Color: false, Actor: map[string]string{ \u0026#34;Dr. Strangelove\u0026#34;: \u0026#34;Peter Sellers\u0026#34;, \u0026#34;Grp. Capt. Lionel Mandrake\u0026#34;: \u0026#34;Peter Sellers\u0026#34;, \u0026#34;Pres. Merkin Muffley\u0026#34;: \u0026#34;Peter Sellers\u0026#34;, \u0026#34;Gen. Buck Turgidson\u0026#34;: \u0026#34;George C. Scott\u0026#34;, \u0026#34;Brig. Gen. Jack D. Ripper\u0026#34;: \u0026#34;Sterling Hayden\u0026#34;, `Maj. T.J. \u0026#34;King\u0026#34; Kong`: \u0026#34;Slim Pickens\u0026#34;, }, Oscars: []string{ \u0026#34;Best Actor (Nomin.)\u0026#34;, \u0026#34;Best Adapted Screenplay (Nomin.)\u0026#34;, \u0026#34;Best Director (Nomin.)\u0026#34;, \u0026#34;Best Picture (Nomin.)\u0026#34;, }, } Display(\u0026ldquo;strangelove\u0026rdquo;, strangelove)调用将显示（strangelove电影对应的中文名是《奇爱博士》）：\nDisplay strangelove (display.Movie): strangelove.Title = \u0026#34;Dr. Strangelove\u0026#34; strangelove.Subtitle = \u0026#34;How I Learned to Stop Worrying and Love the Bomb\u0026#34; strangelove.Year = 1964 strangelove.Color = false strangelove.Actor[\u0026#34;Gen. Buck Turgidson\u0026#34;] = \u0026#34;George C. Scott\u0026#34; strangelove.Actor[\u0026#34;Brig. Gen. Jack D. Ripper\u0026#34;] = \u0026#34;Sterling Hayden\u0026#34; strangelove.Actor[\u0026#34;Maj. T.J. \\\u0026#34;King\\\u0026#34; Kong\u0026#34;] = \u0026#34;Slim Pickens\u0026#34; strangelove.Actor[\u0026#34;Dr. Strangelove\u0026#34;] = \u0026#34;Peter Sellers\u0026#34; strangelove.Actor[\u0026#34;Grp. Capt. Lionel Mandrake\u0026#34;] = \u0026#34;Peter Sellers\u0026#34; strangelove.Actor[\u0026#34;Pres. Merkin Muffley\u0026#34;] = \u0026#34;Peter Sellers\u0026#34; strangelove.Oscars[0] = \u0026#34;Best Actor (Nomin.)\u0026#34; strangelove.Oscars[1] = \u0026#34;Best Adapted Screenplay (Nomin.)\u0026#34; strangelove.Oscars[2] = \u0026#34;Best Director (Nomin.)\u0026#34; strangelove.Oscars[3] = \u0026#34;Best Picture (Nomin.)\u0026#34; strangelove.Sequel = nil 我们也可以使用Display函数来显示标准库中类型的内部结构，例如*os.File类型：\nDisplay(\u0026#34;os.Stderr\u0026#34;, os.Stderr) // Output: // Display os.Stderr (*os.File): // (*(*os.Stderr).file).fd = 2 // (*(*os.Stderr).file).name = \u0026#34;/dev/stderr\u0026#34; // (*(*os.Stderr).file).nepipe = 0 可以看出，反射能够访问到结构体中未导出的成员。需要当心的是这个例子的输出在不同操作系统上可能是不同的，并且随着标准库的发展也可能导致结果不同。（这也是将这些成员定义为私有成员的原因之一！）我们甚至可以用Display函数来显示reflect.Value 的内部构造（在这里设置为*os.File的类型描述体）。Display(\u0026quot;rV\u0026quot;, reflect.ValueOf(os.Stderr))调用的输出如下，当然不同环境得到的结果可能有差异：\nDisplay rV (reflect.Value): (*rV.typ).size = 8 (*rV.typ).hash = 871609668 (*rV.typ).align = 8 (*rV.typ).fieldAlign = 8 (*rV.typ).kind = 22 (*(*rV.typ).string) = \u0026#34;*os.File\u0026#34; (*(*(*rV.typ).uncommonType).methods[0].name) = \u0026#34;Chdir\u0026#34; (*(*(*(*rV.typ).uncommonType).methods[0].mtyp).string) = \u0026#34;func() error\u0026#34; (*(*(*(*rV.typ).uncommonType).methods[0].typ).string) = \u0026#34;func(*os.File) error\u0026#34; ... 观察下面两个例子的区别：\nvar i interface{} = 3 Display(\u0026#34;i\u0026#34;, i) // Output: // Display i (int): // i = 3  Display(\u0026#34;\u0026amp;i\u0026#34;, \u0026amp;i) // Output: // Display \u0026amp;i (*interface {}): // (*\u0026amp;i).type = int // (*\u0026amp;i).value = 3 在第一个例子中，Display函数调用reflect.ValueOf(i)，它返回一个Int类型的值。正如我们在12.2节中提到的，reflect.ValueOf总是返回一个具体类型的 Value，因为它是从一个接口值提取的内容。\n在第二个例子中，Display函数调用的是reflect.ValueOf(\u0026amp;i)，它返回一个指向i的指针，对应Ptr类型。在switch的Ptr分支中，对这个值调用 Elem 方法，返回一个Value来表示变量 i 本身，对应Interface类型。像这样一个间接获得的Value，可能代表任意类型的值，包括接口类型。display函数递归调用自身，这次它分别打印了这个接口的动态类型和值。\n对于目前的实现，如果遇到对象图中含有回环，Display将会陷入死循环，例如下面这个首尾相连的链表：\n// a struct that points to itself type Cycle struct{ Value int; Tail *Cycle } var c Cycle c = Cycle{42, \u0026amp;c} Display(\u0026#34;c\u0026#34;, c) Display会永远不停地进行深度递归打印：\nDisplay c (display.Cycle): c.Value = 42 (*c.Tail).Value = 42 (*(*c.Tail).Tail).Value = 42 (*(*(*c.Tail).Tail).Tail).Value = 42 ...ad infinitum... 许多Go语言程序都包含了一些循环的数据。让Display支持这类带环的数据结构需要些技巧，需要额外记录迄今访问的路径；相应会带来成本。通用的解决方案是采用 unsafe 的语言特性，我们将在13.3节看到具体的解决方案。\n带环的数据结构很少会对fmt.Sprint函数造成问题，因为它很少尝试打印完整的数据结构。例如，当它遇到一个指针的时候，它只是简单地打印指针的数字值。在打印包含自身的slice或map时可能卡住，但是这种情况很罕见，不值得付出为了处理回环所需的开销。\n练习 12.1： 扩展Display函数，使它可以显示包含以结构体或数组作为map的key类型的值。\n练习 12.2： 增强display函数的稳健性，通过记录边界的步数来确保在超出一定限制后放弃递归。（在13.3节，我们会看到另一种探测数据结构是否存在环的技术。）\n"});index.add({'id':72,'href':'/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.3.-Example-Deep-Equivalence/','title':"13.3. 示例: 深度相等判断",'section':"13. 底层编程",'content':"13.3. 示例: 深度相等判断 #  来自reflect包的DeepEqual函数可以对两个值进行深度相等判断。DeepEqual函数使用内建的==比较操作符对基础类型进行相等判断，对于复合类型则递归该变量的每个基础类型然后做类似的比较判断。因为它可以工作在任意的类型上，甚至对于一些不支持==操作运算符的类型也可以工作，因此在一些测试代码中广泛地使用该函数。比如下面的代码是用DeepEqual函数比较两个字符串slice是否相等。\nfunc TestSplit(t *testing.T) { got := strings.Split(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;) want := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}; if !reflect.DeepEqual(got, want) { /* ... */ } } 尽管DeepEqual函数很方便，而且可以支持任意的数据类型，但是它也有不足之处。例如，它将一个nil值的map和非nil值但是空的map视作不相等，同样nil值的slice 和非nil但是空的slice也视作不相等。\nvar a, b []string = nil, []string{} fmt.Println(reflect.DeepEqual(a, b)) // \u0026#34;false\u0026#34;  var c, d map[string]int = nil, make(map[string]int) fmt.Println(reflect.DeepEqual(c, d)) // \u0026#34;false\u0026#34; 我们希望在这里实现一个自己的Equal函数，用于比较类型的值。和DeepEqual函数类似的地方是它也是基于slice和map的每个元素进行递归比较，不同之处是它将nil值的slice（map类似）和非nil值但是空的slice视作相等的值。基础部分的比较可以基于reflect包完成，和12.3章的Display函数的实现方法类似。同样，我们也定义了一个内部函数equal，用于内部的递归比较。读者目前不用关心seen参数的具体含义。对于每一对需要比较的x和y，equal函数首先检测它们是否都有效（或都无效），然后检测它们是否是相同的类型。剩下的部分是一个巨大的switch分支，用于相同基础类型的元素比较。因为页面空间的限制，我们省略了一些相似的分支。\ngopl.io/ch13/equal\nfunc equal(x, y reflect.Value, seen map[comparison]bool) bool { if !x.IsValid() || !y.IsValid() { return x.IsValid() == y.IsValid() } if x.Type() != y.Type() { return false } // ...cycle check omitted (shown later)...  switch x.Kind() { case reflect.Bool: return x.Bool() == y.Bool() case reflect.String: return x.String() == y.String() // ...numeric cases omitted for brevity...  case reflect.Chan, reflect.UnsafePointer, reflect.Func: return x.Pointer() == y.Pointer() case reflect.Ptr, reflect.Interface: return equal(x.Elem(), y.Elem(), seen) case reflect.Array, reflect.Slice: if x.Len() != y.Len() { return false } for i := 0; i \u0026lt; x.Len(); i++ { if !equal(x.Index(i), y.Index(i), seen) { return false } } return true // ...struct and map cases omitted for brevity... \t} panic(\u0026#34;unreachable\u0026#34;) } 和前面的建议一样，我们并不公开reflect包相关的接口，所以导出的函数需要在内部自己将变量转为reflect.Value类型。\n// Equal reports whether x and y are deeply equal. func Equal(x, y interface{}) bool { seen := make(map[comparison]bool) return equal(reflect.ValueOf(x), reflect.ValueOf(y), seen) } type comparison struct { x, y unsafe.Pointer treflect.Type } 为了确保算法对于有环的数据结构也能正常退出，我们必须记录每次已经比较的变量，从而避免进入第二次的比较。Equal函数分配了一组用于比较的结构体，包含每对比较对象的地址（unsafe.Pointer形式保存）和类型。我们要记录类型的原因是，有些不同的变量可能对应相同的地址。例如，如果x和y都是数组类型，那么x和x[0]将对应相同的地址，y和y[0]也是对应相同的地址，这可以用于区分x与y之间的比较或x[0]与y[0]之间的比较是否进行过了。\n// cycle check if x.CanAddr() \u0026amp;\u0026amp; y.CanAddr() { xptr := unsafe.Pointer(x.UnsafeAddr()) yptr := unsafe.Pointer(y.UnsafeAddr()) if xptr == yptr { return true // identical references \t} c := comparison{xptr, yptr, x.Type()} if seen[c] { return true // already seen \t} seen[c] = true } 这是Equal函数用法的例子:\nfmt.Println(Equal([]int{1, 2, 3}, []int{1, 2, 3})) // \u0026#34;true\u0026#34; fmt.Println(Equal([]string{\u0026#34;foo\u0026#34;}, []string{\u0026#34;bar\u0026#34;})) // \u0026#34;false\u0026#34; fmt.Println(Equal([]string(nil), []string{})) // \u0026#34;true\u0026#34; fmt.Println(Equal(map[string]int(nil), map[string]int{})) // \u0026#34;true\u0026#34; Equal函数甚至可以处理类似12.3章中导致Display陷入死循环的带有环的数据。\n// Circular linked lists a -\u0026gt; b -\u0026gt; a and c -\u0026gt; c. type link struct { value string tail *link } a, b, c := \u0026amp;link{value: \u0026#34;a\u0026#34;}, \u0026amp;link{value: \u0026#34;b\u0026#34;}, \u0026amp;link{value: \u0026#34;c\u0026#34;} a.tail, b.tail, c.tail = b, a, c fmt.Println(Equal(a, a)) // \u0026#34;true\u0026#34; fmt.Println(Equal(b, b)) // \u0026#34;true\u0026#34; fmt.Println(Equal(c, c)) // \u0026#34;true\u0026#34; fmt.Println(Equal(a, b)) // \u0026#34;false\u0026#34; fmt.Println(Equal(a, c)) // \u0026#34;false\u0026#34; 练习 13.1： 定义一个深比较函数，对于十亿以内的数字比较，忽略类型差异。\n练习 13.2： 编写一个函数，报告其参数是否为循环数据结构。\n"});index.add({'id':73,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/','title':"2. 程序结构",'section':"Go语言圣经",'content':"第二章　程序结构 #  Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用if和for之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。\n我们已经在前面章节的例子中看到了很多例子。在本章中，我们将深入讨论Go程序基础结构方面的一些细节。每个示例程序都是刻意写的简单，这样我们可以减少复杂的算法或数据结构等不相关的问题带来的干扰，从而可以专注于Go语言本身的学习。\n"});index.add({'id':74,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/','title':"2.3. 变量",'section':"2. 程序结构",'content':"2.3. 变量 #  var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：\nvar 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。\n零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。例如：\nvar s string fmt.Println(s) // \u0026#34;\u0026#34; 这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。\n也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：\nvar i, j, k int // int, int, int var b, f, s = true, 2.3, \u0026#34;four\u0026#34; // bool, float64, string 初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。\n一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：\nvar f, err = os.Open(name) // os.Open returns a file and an error "});index.add({'id':75,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.3.-Avoid-Disinformation/','title':"2.3. 避免误导",'section':"2. 有意义的命名",'content':"2.3 避免误导 #  Programmers must avoid leaving false clues that obscure the meaning of code. We should avoid words whose entrenched meanings vary from our intended meaning. For example, hp, aix, and sco would be poor variable names because they are the names of Unix platforms or variants. Even if you are coding a hypotenuse and hp looks like a good abbreviation, it could be disinformative.\n 程序员必须避免留下掩藏代码本意的错误线索。应当避免使用与本意相悖的词。例如，hp、aix 和 sco 都不该用做变量名，因为它们都是 UNIX 平台或类 UNIX 平台的专有名称。即便你是在编写三角计算程序， hp 看起来是个不错的缩写，但那也可能会提供错误信息。\n Do not refer to a grouping of accounts as an accountList unless it’s actually a List. The word list means something specific to programmers. If the container holding the accounts is not actually a List, it may lead to false conclusions.1 So accountGroup or bunchOfAccounts or just plain accounts would be better.\n 别用 accountList 来指称一组账号，除非它真的是 List 类型。List 一词对程序员有特殊意义。如果包纳账号的容器并非真是个 List，就会引起错误的判断。所以，用 accountGroup 或 bunchOfAccounts，甚至直接用 accounts 都会好一些。\n Beware of using names which vary in small ways. How long does it take to spot the subtle difference between a XYZControllerForEfficientHandlingOfStrings in one module and, somewhere a little more distant, XYZControllerForEfficientStorageOfStrings? The words have frightfully similar shapes.\n 提防使用不同之处较小的名称。想区分模块中某处的 XYZControllerFor EfficientHandlingOfStrings 和另一处的 XYZControllerForEfficientStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。\n Spelling similar concepts similarly is information. Using inconsistent spellings is disinformation. With modern Java environments we enjoy automatic code completion. We write a few characters of a name and press some hotkey combination (if that) and are rewarded with a list of possible completions for that name. It is very helpful if names for very similar things sort together alphabetically and if the differences are very obvious, because the developer is likely to pick an object by name without seeing your copious comments or even the list of methods supplied by that class.\n 以同样的方式拼写出同样的概念才是信息。拼写前后不一致就是误导。我们很享受现代 Java 编程环境的自动代码完成特性。键入某个名称的前几个字母，按一下某个热键组合（如果有的话），就能得到一列该名称的可能形式。假如相似的名称依字母顺序放在一起，且差异很明显，那就会相当有助益，因为程序员多半会压根不看你的详细注释，甚至不看该类的方法列表就直接看名字挑一个对象。\n A truly awful example of disinformative names would be the use of lower-case L or uppercase O as variable names, especially in combination. The problem, of course, is that they look almost entirely like the constants one and zero, respectively.\n 误导性名称真正可怕的例子，是用小写字母 l 和大写字母 O 作为变量名，尤其是在组合使用的时候。当然，问题在于它们看起来完全像是常量“壹”和“零”。\n int a = l; if (O == l) a = O1; else l = 01; The reader may think this a contrivance, but we have examined code where such things were abundant. In one case the author of the code suggested using a different font so that the differences were more obvious, a solution that would have to be passed down to all future developers as oral tradition or in a written document. The problem is conquered with finality and without creating new work products by a simple renaming.\n 读者可能会认为这纯属虚构，但我们确曾见过充斥这类玩意的代码。有一次，代码作者建议用不同字体写变量名，好显得更清楚些，不过这种方案得要通过口头和书面传递给未来所有的开发者才行。后来，只是做了简单的重命名操作，就解决了问题，而且也没搞出别的事。\n "});index.add({'id':76,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.3.-The-new-Function/','title':"2.3.3. new函数",'section':"2.3. 变量",'content':"2.3.3. new函数 #  另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。\np := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // \u0026#34;0\u0026#34; *p = 2 // 设置 int 匿名变量的值为 2 fmt.Println(*p) // \u0026#34;2\u0026#34; 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。\n下面的两个newInt函数有着相同的行为：\nfunc newInt() *int { return new(int) } func newInt() *int { var dummy int return \u0026amp;dummy } 每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：\np := new(int) q := new(int) fmt.Println(p == q) // \u0026#34;false\u0026#34; 当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int，有可能有相同的地址（依赖具体的语言实现）（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）。\nnew函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活（§4.4.1）。\n由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。例如下面的例子：\nfunc delta(old, new int) int { return new - old } 由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。\n"});index.add({'id':77,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.3.-Complex-Numbers/','title':"3.3. 复数",'section':"3. 基础数据类型",'content':"3.3. 复数 #  Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：\nvar x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // \u0026#34;(-5+10i)\u0026#34; fmt.Println(real(x*y)) // \u0026#34;-5\u0026#34; fmt.Println(imag(x*y)) // \u0026#34;10\u0026#34; 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：\nfmt.Println(1i * 1i) // \u0026#34;(-1+0i)\u0026#34;, i^2 = -1 在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：\nx := 1 + 2i y := 3 + 4i 复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。\nmath/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。\nfmt.Println(cmplx.Sqrt(-1)) // \u0026#34;(0+1i)\u0026#34; 下面的程序使用complex128复数算法来生成一个Mandelbrot图像。\ngopl.io/ch3/mandelbrot\n// Mandelbrot emits a PNG image of the Mandelbrot fractal. package main import ( \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; \u0026#34;image/png\u0026#34; \u0026#34;math/cmplx\u0026#34; \u0026#34;os\u0026#34; ) func main() { const ( xmin, ymin, xmax, ymax = -2, -2, +2, +2 width, height = 1024, 1024 ) img := image.NewRGBA(image.Rect(0, 0, width, height)) for py := 0; py \u0026lt; height; py++ { y := float64(py)/height*(ymax-ymin) + ymin for px := 0; px \u0026lt; width; px++ { x := float64(px)/width*(xmax-xmin) + xmin z := complex(x, y) // Image point (px, py) represents complex value z. \timg.Set(px, py, mandelbrot(z)) } } png.Encode(os.Stdout, img) // NOTE: ignoring errors } func mandelbrot(z complex128) color.Color { const iterations = 200 const contrast = 15 var v complex128 for n := uint8(0); n \u0026lt; iterations; n++ { v = v*v + z if cmplx.Abs(v) \u0026gt; 2 { return color.Gray{255 - contrast*n} } } return color.Black } 用于遍历1024x1024图像每个点的两个嵌套的循环对应-2到+2区间的复数平面。程序反复测试每个点对应复数值平方值加一个增量值对应的点是否超出半径为2的圆。如果超过了，通过根据预设置的逃逸迭代次数对应的灰度颜色来代替。如果不是，那么该点属于Mandelbrot集合，使用黑色颜色标记。最终程序将生成的PNG格式分形图像输出到标准输出，如图3.3所示。\n 练习 3.5： 实现一个彩色的Mandelbrot图像，使用image.NewRGBA创建图像，使用color.RGBA或color.YCbCr生成颜色。\n练习 3.6： 升采样技术可以降低每个像素对计算颜色值和平均值的影响。简单的方法是将每个像素分成四个子像素，实现它。\n练习 3.7： 另一个生成分形图像的方式是使用牛顿法来求解一个复数方程，例如$z^4-1=0$。每个起点到四个根的迭代次数对应阴影的灰度。方程根对应的点用颜色表示。\n练习 3.8： 通过提高精度来生成更多级别的分形。使用四种不同精度类型的数字实现相同的分形：complex64、complex128、big.Float和big.Rat。（后面两种类型在math/big包声明。Float是有指定限精度的浮点数；Rat是无限精度的有理数。）它们间的性能和内存使用对比如何？当渲染图可见时缩放的级别是多少？\n练习 3.9： 编写一个web服务器，用于给客户端生成分形的图像。运行客户端通过HTTP参数指定x、y和zoom参数。\n"});index.add({'id':78,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.3.-UTF-8/','title':"3.5.3. UTF-8",'section':"3.5. 字符串",'content':"3.5.3. UTF-8 #  UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。更大的Unicode码点也是采用类似的策略处理。\n0xxxxxxx runes 0-127 (ASCII) 110xxxxx 10xxxxxx 128-2047 (values \u0026lt;128 unused) 1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values \u0026lt;2048 unused) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused) 变长的编码无法直接通过索引来访问第n个字符，但是UTF8编码获得了很多额外的优点。首先UTF8编码比较紧凑，完全兼容ASCII码，并且可以自动同步：它可以通过向前回朔最多3个字节就能确定当前字符编码的开始字节的位置。它也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看（译注：像GBK之类的编码，如果不知道起点位置则可能会出现歧义）。没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。同时UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列。同时因为没有嵌入的NUL(0)字节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言。\nGo语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能。\n有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符（译注：中文和日文就有很多相似但不同的字）。Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：\\uhhhh对应16bit的码点值，\\Uhhhhhhhh对应32bit的码点值，其中h是一个十六进制数字；一般很少需要使用32bit的形式。每一个对应码点的UTF8编码。例如：下面的字母串面值都表示相同的值：\n\u0026quot;世界\u0026quot; \u0026quot;\\xe4\\xb8\\x96\\xe7\\x95\\x8c\u0026quot; \u0026quot;\\u4e16\\u754c\u0026quot; \u0026quot;\\U00004e16\\U0000754c\u0026quot; 上面三个转义序列都为第一个字符串提供替代写法，但是它们的值都是相同的。\nUnicode转义也可以使用在rune字符中。下面三个字符是等价的：\n'世' '\\u4e16' '\\U00004e16' 对于小于256的码点值可以写在一个十六进制转义字节中，例如\\x41对应字符\u0026rsquo;A\u0026rsquo;，但是对于更大的码点则必须使用\\u或\\U转义形式。因此，\\xe4\\xb8\\x96并不是一个合法的rune字符，虽然这三个字节对应一个有效的UTF8编码的码点。\n得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀：\nfunc HasPrefix(s, prefix string) bool { return len(s) \u0026gt;= len(prefix) \u0026amp;\u0026amp; s[:len(prefix)] == prefix } 或者是后缀测试：\nfunc HasSuffix(s, suffix string) bool { return len(s) \u0026gt;= len(suffix) \u0026amp;\u0026amp; s[len(s)-len(suffix):] == suffix } 或者是包含子串测试：\nfunc Contains(s, substr string) bool { for i := 0; i \u0026lt; len(s); i++ { if HasPrefix(s[i:], substr) { return true } } return false } 对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这样的。（上面的函数都来自strings字符串处理包，真实的代码包含了一个用哈希技术优化的Contains 实现。）\n另一方面，如果我们真的关心每个Unicode字符，我们可以使用其它处理方式。考虑前面的第一个例子中的字符串，它混合了中西两种字符。图3.5展示了它的内存表示形式。字符串包含13个字节，以UTF8形式编码，但是只对应9个Unicode字符：\nimport \u0026#34;unicode/utf8\u0026#34; s := \u0026#34;Hello, 世界\u0026#34; fmt.Println(len(s)) // \u0026#34;13\u0026#34; fmt.Println(utf8.RuneCountInString(s)) // \u0026#34;9\u0026#34; 为了处理这些真实的字符，我们需要一个UTF8解码器。unicode/utf8包提供了该功能，我们可以这样使用：\nfor i := 0; i \u0026lt; len(s); { r, size := utf8.DecodeRuneInString(s[i:]) fmt.Printf(\u0026#34;%d\\t%c\\n\u0026#34;, i, r) i += size } 每一次调用DecodeRuneInString函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。长度可以用于更新第i个字符在字符串中的字节索引位置。但是这种编码方式是笨拙的，我们需要更简洁的语法。幸运的是，Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。下面的循环运行如图3.5所示；需要注意的是对于非ASCII，索引更新的步长将超过1个字节。\n for i, r := range \u0026#34;Hello, 世界\u0026#34; { fmt.Printf(\u0026#34;%d\\t%q\\t%d\\n\u0026#34;, i, r, r) } 我们可以使用一个简单的循环来统计字符串中字符的数目，像这样：\nn := 0 for _, _ = range s { n++ } 像其它形式的循环那样，我们也可以忽略不需要的变量：\nn := 0 for range s { n++ } 或者我们可以直接调用utf8.RuneCountInString(s)函数。\n正如我们前面提到的，文本字符串采用UTF8编码只是一种惯例，但是对于循环的真正字符串并不是一个惯例，这是正确的。如果用于循环的字符串只是一个普通的二进制数据，或者是含有错误编码的UTF8数据，将会发生什么呢？\n每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符\\uFFFD，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号\u0026rdquo;?\u0026quot;。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。\nUTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。\n将[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列：\n// \u0026#34;program\u0026#34; in Japanese katakana s := \u0026#34;プログラム\u0026#34; fmt.Printf(\u0026#34;% x\\n\u0026#34;, s) // \u0026#34;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0\u0026#34; r := []rune(s) fmt.Printf(\u0026#34;%x\\n\u0026#34;, r) // \u0026#34;[30d7 30ed 30b0 30e9 30e0]\u0026#34; （在第一个Printf中的% x参数用于在每个十六进制数字前插入一个空格。）\n如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：\nfmt.Println(string(r)) // \u0026#34;プログラム\u0026#34; 将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串：\nfmt.Println(string(65)) // \u0026#34;A\u0026#34;, not \u0026#34;65\u0026#34; fmt.Println(string(0x4eac)) // \u0026#34;京\u0026#34; 如果对应码点的字符是无效的，则用\\uFFFD无效字符作为替换：\nfmt.Println(string(1234567)) // \u0026#34;?\u0026#34; "});index.add({'id':79,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.3.-Maps/','title':"4.3. Map",'section':"4. 复合数据类型",'content':"4.3. Map #  哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。\n在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。\n内置的make函数可以创建一个map：\nages := make(map[string]int) // mapping from strings to ints 我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：\nages := map[string]int{ \u0026#34;alice\u0026#34;: 31, \u0026#34;charlie\u0026#34;: 34, } 这相当于\nages := make(map[string]int) ages[\u0026#34;alice\u0026#34;] = 31 ages[\u0026#34;charlie\u0026#34;] = 34 因此，另一种创建空的map的表达式是map[string]int{}。\nMap中的元素通过key对应的下标语法访问：\nages[\u0026#34;alice\u0026#34;] = 32 fmt.Println(ages[\u0026#34;alice\u0026#34;]) // \u0026#34;32\u0026#34; 使用内置的delete函数可以删除元素：\ndelete(ages, \u0026#34;alice\u0026#34;) // remove element ages[\u0026#34;alice\u0026#34;] 所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[\u0026ldquo;bob\u0026rdquo;]失败时将返回0。\nages[\u0026#34;bob\u0026#34;] = ages[\u0026#34;bob\u0026#34;] + 1 // happy birthday! 而且x += y和x++等简短赋值语法也可以用在map上，所以上面的代码可以改写成\nages[\u0026#34;bob\u0026#34;] += 1 更简单的写法\nages[\u0026#34;bob\u0026#34;]++ 但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：\n_ = \u0026amp;ages[\u0026#34;bob\u0026#34;] // compile error: cannot take address of map element 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。\n要想遍历map中全部的key/value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。下面的迭代语句将在每次迭代时设置name和age变量，它们对应下一个键/值对：\nfor name, age := range ages { fmt.Printf(\u0026#34;%s\\t%d\\n\u0026#34;, name, age) } Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。下面是常见的处理方式：\nimport \u0026#34;sort\u0026#34; var names []string for name := range ages { names = append(names, name) } sort.Strings(names) for _, name := range names { fmt.Printf(\u0026#34;%s\\t%d\\n\u0026#34;, name, ages[name]) } 因为我们一开始就知道names的最终大小，因此给slice分配一个合适的大小将会更有效。下面的代码创建了一个空的slice，但是slice的容量刚好可以放下map中全部的key：\nnames := make([]string, 0, len(ages)) 在上面的第一个range循环中，我们只关心map中的key，所以我们忽略了第二个循环变量。在第二个循环中，我们只关心names中的名字，所以我们使用“_”空白标识符来忽略第一个循环变量，也就是迭代slice时的索引。\nmap类型的零值是nil，也就是没有引用任何哈希表。\nvar ages map[string]int fmt.Println(ages == nil) // \u0026#34;true\u0026#34; fmt.Println(len(ages) == 0) // \u0026#34;true\u0026#34; map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常：\nages[\u0026#34;carol\u0026#34;] = 21 // panic: assignment to entry in nil map 在向map存数据前必须先创建map。\n通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值，正如我们前面看到的ages[\u0026ldquo;bob\u0026rdquo;]那样。这个规则很实用，但是有时候可能需要知道对应的元素是否真的是在map之中。例如，如果元素类型是一个数字，你可能需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试：\nage, ok := ages[\u0026#34;bob\u0026#34;] if !ok { /* \u0026#34;bob\u0026#34; is not a key in this map; age == 0. */ } 你会经常看到将这两个结合起来使用，像这样：\nif age, ok := ages[\u0026#34;bob\u0026#34;]; !ok { /* ... */ } 在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。\n和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现：\nfunc equal(x, y map[string]int) bool { if len(x) != len(y) { return false } for k, xv := range x { if yv, ok := y[k]; !ok || yv != xv { return false } } return true } 从例子中可以看到如何用!ok来区分元素不存在，与元素存在但为0的。我们不能简单地用xv != y[k]判断，那样会导致在判断下面两个map时产生错误的结果：\n// True if equal is written incorrectly. equal(map[string]int{\u0026#34;A\u0026#34;: 0}, map[string]int{\u0026#34;B\u0026#34;: 42}) Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。为了说明这一点，下面的dedup程序读取多行输入，但是只打印第一次出现的行。（它是1.3节中出现的dup程序的变体。）dedup程序通过map来表示所有的输入行所对应的set集合，以确保已经在集合存在的行不会被重复打印。\ngopl.io/ch4/dedup\nfunc main() { seen := make(map[string]bool) // a set of strings \tinput := bufio.NewScanner(os.Stdin) for input.Scan() { line := input.Text() if !seen[line] { seen[line] = true fmt.Println(line) } } if err := input.Err(); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;dedup: %v\\n\u0026#34;, err) os.Exit(1) } } Go程序员将这种忽略value的map当作一个字符串集合，并非所有map[string]bool类型value都是无关紧要的；有一些则可能会同时包含true和false的值。\n有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。\n下面的例子演示了如何使用map来记录提交相同的字符串列表的次数。它使用了fmt.Sprintf函数将字符串列表转换为一个字符串以用于map的key，通过%q参数忠实地记录每个字符串元素的信息：\nvar m = make(map[string]int) func k(list []string) string { return fmt.Sprintf(\u0026#34;%q\u0026#34;, list) } func Add(list []string) { m[k(list)]++ } func Count(list []string) int { return m[k(list)] } 使用同样的技术可以处理任何不可比较的key类型，而不仅仅是slice类型。这种技术对于想使用自定义key比较函数的时候也很有用，例如在比较字符串的时候忽略大小写。同时，辅助函数k(x)也不一定是字符串类型，它可以返回任何可比较的类型，例如整数、数组或结构体等。\n这是map的另一个例子，下面的程序用于统计输入中每个Unicode码点出现的次数。虽然Unicode全部码点的数量巨大，但是出现在特定文档中的字符种类并没有多少，使用map可以用比较自然的方式来跟踪那些出现过的字符的次数。\ngopl.io/ch4/charcount\n// Charcount computes counts of Unicode characters. package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;unicode\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { counts := make(map[rune]int) // counts of Unicode characters \tvar utflen [utf8.UTFMax + 1]int // count of lengths of UTF-8 encodings \tinvalid := 0 // count of invalid UTF-8 characters  in := bufio.NewReader(os.Stdin) for { r, n, err := in.ReadRune() // returns rune, nbytes, error \tif err == io.EOF { break } if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;charcount: %v\\n\u0026#34;, err) os.Exit(1) } if r == unicode.ReplacementChar \u0026amp;\u0026amp; n == 1 { invalid++ continue } counts[r]++ utflen[n]++ } fmt.Printf(\u0026#34;rune\\tcount\\n\u0026#34;) for c, n := range counts { fmt.Printf(\u0026#34;%q\\t%d\\n\u0026#34;, c, n) } fmt.Print(\u0026#34;\\nlen\\tcount\\n\u0026#34;) for i, n := range utflen { if i \u0026gt; 0 { fmt.Printf(\u0026#34;%d\\t%d\\n\u0026#34;, i, n) } } if invalid \u0026gt; 0 { fmt.Printf(\u0026#34;\\n%d invalid UTF-8 characters\\n\u0026#34;, invalid) } } ReadRune方法执行UTF-8解码并返回三个值：解码的rune字符的值，字符UTF-8编码后的长度，和一个错误值。我们可预期的错误值只有对应文件结尾的io.EOF。如果输入的是无效的UTF-8编码的字符，返回的将是unicode.ReplacementChar表示无效字符，并且编码长度是1。\ncharcount程序同时打印不同UTF-8编码长度的字符数目。对此，map并不是一个合适的数据结构；因为UTF-8编码的长度总是从1到utf8.UTFMax（最大是4个字节），使用数组将更有效。\n作为一个实验，我们用charcount程序对英文版原稿的字符进行了统计。虽然大部分是英语，但是也有一些非ASCII字符。下面是排名前10的非ASCII字符：\n 下面是不同UTF-8编码长度的字符的数目：\nlen count 1 765391 2 60 3 70 4 0 Map的value类型也可以是一个聚合类型，比如是一个map或slice。在下面的代码中，图graph的key类型是一个字符串，value类型map[string]bool代表一个字符串集合。从概念上讲，graph将一个字符串类型的key映射到一组相关的字符串集合，它们指向新的graph的key。\ngopl.io/ch4/graph\nvar graph = make(map[string]map[string]bool) func addEdge(from, to string) { edges := graph[from] if edges == nil { edges = make(map[string]bool) graph[from] = edges } edges[to] = true } func hasEdge(from, to string) bool { return graph[from][to] } 其中addEdge函数惰性初始化map是一个惯用方式，也就是说在每个值首次作为key时才初始化。addEdge函数显示了如何让map的零值也能正常工作；即使from到to的边不存在，graph[from][to]依然可以返回一个有意义的结果。\n练习 4.8： 修改charcount程序，使用unicode.IsLetter等相关的函数，统计字母、数字等Unicode中不同的字符类别。\n练习 4.9： 编写一个程序wordfreq程序，报告输入文本中每个单词出现的频率。在第一次调用Scan前先调用input.Split(bufio.ScanWords)函数，这样可以按单词而不是按行输入。\n"});index.add({'id':80,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/4.4.3.-Struct-Embedding-and-Anonymous-Fields/','title':"4.4.3. 结构体嵌入和匿名成员",'section':"4.4. 结构体",'content':"4.4.3. 结构体嵌入和匿名成员 #  在本节中，我们将看到如何使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。\n考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义：\ntype Circle struct { X, Y, Radius int } type Wheel struct { X, Y, Radius, Spokes int } 一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量：\nvar w Wheel w.X = 8 w.Y = 8 w.Radius = 5 w.Spokes = 20 随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来：\ntype Point struct { X, Y int } type Circle struct { Center Point Radius int } type Wheel struct { Circle Circle Spokes int } 这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐：\nvar w Wheel w.Circle.Center.X = 8 w.Circle.Center.Y = 8 w.Circle.Radius = 5 w.Spokes = 20 Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。\ntype Circle struct { Point Radius int } type Wheel struct { Circle Spokes int } 得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：\nvar w Wheel w.X = 8 // equivalent to w.Circle.Point.X = 8 w.Y = 8 // equivalent to w.Circle.Point.Y = 8 w.Radius = 5 // equivalent to w.Circle.Radius = 5 w.Spokes = 20 在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。\n不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：\nw = Wheel{8, 8, 5, 20} // compile error: unknown fields w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields 结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：\ngopl.io/ch4/embed\nw = Wheel{Circle{Point{8, 8}, 5}, 20} w = Wheel{ Circle: Circle{ Point: Point{X: 8, Y: 8}, Radius: 5, }, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, w) // Output: // Wheel{Circle:Circle{Point:Point{X:8, Y:8}, Radius:5}, Spokes:20}  w.X = 42 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, w) // Output: // Wheel{Circle:Circle{Point:Point{X:42, Y:8}, Radius:5}, Spokes:20} 需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。\n因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员\nw.X = 8 // equivalent to w.circle.point.X = 8 但是在包外部，因为circle和point没有导出，不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。\n到目前为止，我们看到匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。稍后，我们将会看到匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？\n答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心，我们将在6.3节中专门讨论。\n"});index.add({'id':81,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.3.-Multiple-Return-Values/','title':"5.3. 多返回值",'section':"5. 函数",'content':"5.3. 多返回值 #  在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。下面的例子会展示如何编写多返回值的函数。\n下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。这意味着如果findlinks函数失败了，很可能是由于I/O的错误导致的。\ngopl.io/ch5/findlinks2\nfunc main() { for _, url := range os.Args[1:] { links, err := findLinks(url) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;findlinks2: %v\\n\u0026#34;, err) continue } for _, link := range links { fmt.Println(link) } } } // findLinks performs an HTTP GET request for url, parses the // response as HTML, and extracts and returns the links. func findLinks(url string) ([]string, error) { resp, err := http.Get(url) if err != nil { return nil, err } if resp.StatusCode != http.StatusOK { resp.Body.Close() return nil, fmt.Errorf(\u0026#34;getting %s: %s\u0026#34;, url, resp.Status) } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return nil, fmt.Errorf(\u0026#34;parsing %s as HTML: %v\u0026#34;, url, err) } return visit(nil, doc), nil } 在findlinks中，有4处return语句，每一处return都返回了一组值。前三处return，将http和html包中的错误信息传递给findlinks的调用者。第一处return直接返回错误信息，其他两处通过fmt.Errorf（§7.8）输出详细的错误信息。如果findlinks成功结束，最后的return语句将一组解析获得的连接返回给用户。\n在findlinks中，我们必须确保resp.Body被关闭，释放网络资源。虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。\n调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:\nlinks, err := findLinks(url) 如果某个值不被使用，可以将其分配给blank identifier:\nlinks, _ := findLinks(url) // errors ignored 一个函数内部可以将另一个有多返回值的函数调用作为返回值，下面的例子展示了与findLinks有相同功能的函数，两者的区别在于下面的例子先输出参数：\nfunc findLinksLog(url string) ([]string, error) { log.Printf(\u0026#34;findLinks %s\u0026#34;, url) return findLinks(url) } 当你调用接受多参数的函数时，可以将一个返回多参数的函数调用作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的：\nlog.Println(findLinks(url)) links, err := findLinks(url) log.Println(links, err) 准确的变量名可以传达函数返回值的含义。尤其在返回值的类型都相同时，就像下面这样：\nfunc Size(rect image.Rectangle) (width, height int) func Split(path string) (dir, file string) func HourMinSec(t time.Time) (hour, minute, second int) 虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。\n如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。\n// CountWordsAndImages does an HTTP GET request for the HTML // document url and returns the number of words and images in it. func CountWordsAndImages(url string) (words, images int, err error) { resp, err := http.Get(url) if err != nil { return } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { err = fmt.Errorf(\u0026#34;parsing HTML: %s\u0026#34;, err) return } words, images = countWordsAndImages(doc) return } func countWordsAndImages(n *html.Node) (words, images int) { /* ... */ } 按照返回值列表的次序，返回所有的返回值，在上面的例子中，每一个return语句等价于：\nreturn words, images, err 当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words, image, nil。基于以上原因，不宜过度使用bare return。\n练习 5.5： 实现countWordsAndImages。（参考练习4.9如何分词）\n练习 5.6： 修改gopl.io/ch3/surface（§3.2）中的corner函数，将返回值命名，并使用bare return。\n"});index.add({'id':82,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.3.-Composing-Types-by-Struct-Embedding/','title':"6.3. 通过嵌入结构体来扩展类型",'section':"6. 方法",'content':"6.3. 通过嵌入结构体来扩展类型 #  来看看ColoredPoint这个类型：\ngopl.io/ch6/coloredpoint\nimport \u0026#34;image/color\u0026#34; type Point struct{ X, Y float64 } type ColoredPoint struct { Point Color color.RGBA } 我们完全可以将ColoredPoint定义为一个有三个字段的struct，但是我们却将Point这个类型嵌入到ColoredPoint来提供X和Y这两个字段。像我们在4.4节中看到的那样，内嵌可以使我们在定义ColoredPoint时得到一种句法上的简写形式，并使其包含Point类型所具有的一切字段，然后再定义一些自己的。如果我们想要的话，我们可以直接认为通过嵌入的字段就是ColoredPoint自身的字段，而完全不需要在调用时指出Point，比如下面这样。\nvar cp ColoredPoint cp.X = 1 fmt.Println(cp.Point.X) // \u0026#34;1\u0026#34; cp.Point.Y = 2 fmt.Println(cp.Y) // \u0026#34;2\u0026#34; 对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法：\nred := color.RGBA{255, 0, 0, 255} blue := color.RGBA{0, 0, 255, 255} var p = ColoredPoint{Point{1, 1}, red} var q = ColoredPoint{Point{5, 4}, blue} fmt.Println(p.Distance(q.Point)) // \u0026#34;5\u0026#34; p.ScaleBy(2) q.ScaleBy(2) fmt.Println(p.Distance(q.Point)) // \u0026#34;10\u0026#34; Point类的方法也被引入了ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。\n读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而ColoredPoint看作其子类或者继承类，或者将ColoredPoint看作\u0026quot;is a\u0026rdquo; Point类型。但这是错误的理解。请注意上面例子中对Distance方法的调用。Distance有一个参数是Point类型，但q并不是一个Point类，所以尽管q有着Point这个内嵌类型，我们也必须要显式地选择它。尝试直接传q的话你会看到下面这样的错误：\np.Distance(q) // compile error: cannot use q (ColoredPoint) as Point 一个ColoredPoint并不是一个Point，但他\u0026quot;has a\u0026quot;Point，并且它有从Point类里引入的Distance和ScaleBy方法。如果你喜欢从实现的角度来考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：\nfunc (p ColoredPoint) Distance(q Point) float64 { return p.Point.Distance(q) } func (p *ColoredPoint) ScaleBy(factor float64) { p.Point.ScaleBy(factor) } 当Point.Distance被第一个包装方法调用时，它的接收器值是p.Point，而不是p，当然了，在Point类的方法里，你是访问不到ColoredPoint的任何字段的。\n在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中（译注：访问需要通过该指针指向的对象去取）。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个ColoredPoint的声明内嵌了一个*Point的指针。\ntype ColoredPoint struct { *Point Color color.RGBA } p := ColoredPoint{\u0026amp;Point{1, 1}, red} q := ColoredPoint{\u0026amp;Point{5, 4}, blue} fmt.Println(p.Distance(*q.Point)) // \u0026#34;5\u0026#34; q.Point = p.Point // p and q now share the same Point p.ScaleBy(2) fmt.Println(*p.Point, *q.Point) // \u0026#34;{2 2} {2 2}\u0026#34; 一个struct类型也可能会有多个匿名字段。我们将ColoredPoint定义为下面这样：\ntype ColoredPoint struct { Point color.RGBA } 然后这种类型的值便会拥有Point和RGBA类型的所有方法，以及直接定义在ColoredPoint中的方法。当编译器解析一个选择器到方法时，比如p.ScaleBy，它会首先去找直接定义在这个类型里的ScaleBy方法，然后找被ColoredPoint的内嵌字段们引入的方法，然后去找Point和RGBA的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。\n方法只能在命名类型（像Point）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。\n下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量（§9.2）和它所操作的cache：\nvar ( mu sync.Mutex // guards mapping \tmapping = make(map[string]string) ) func Lookup(key string) string { mu.Lock() v := mapping[key] mu.Unlock() return v } 下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：\nvar cache = struct { sync.Mutex mapping map[string]string }{ mapping: make(map[string]string), } func Lookup(key string) string { cache.Lock() v := cache.mapping[key] cache.Unlock() return v } 我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。\n"});index.add({'id':83,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.3.-Interface-Satisfaction/','title':"7.3. 实现接口的条件",'section':"7. 接口",'content':"7.3. 实现接口的条件 #  一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。例如，*os.File类型实现了io.Reader，Writer，Closer，和ReadWriter接口。*bytes.Buffer实现了Reader，Writer，和ReadWriter这些接口，但是它没有实现Closer接口因为它不具有Close方法。Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，*bytes.Buffer是io.Writer；*os.Files是io.ReadWriter。\n接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：\nvar w io.Writer w = os.Stdout // OK: *os.File has Write method w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method w = time.Second // compile error: time.Duration lacks Write method  var rwc io.ReadWriteCloser rwc = os.Stdout // OK: *os.File has Read, Write, Close methods rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method 这个规则甚至适用于等式右边本身也是一个接口类型\nw = rwc // OK: io.ReadWriteCloser has Write method rwc = w // compile error: io.Writer lacks Close method 因为ReadWriter和ReadWriteCloser包含有Writer的方法，所以任何实现了ReadWriter和ReadWriteCloser的类型必定也实现了Writer接口\n在进一步学习前，必须先解释一个类型持有一个方法的表示当中的细节。回想在6.2章中，对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个*T的指针。还记得在T类型的参数上调用一个*T的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。但这仅仅是一个语法糖：T类型的值不拥有所有*T指针的方法，这样它就可能只实现了更少的接口。\n举个例子可能会更清晰一点。在第6.5章中，IntSet类型的String方法的接收者是一个指针类型，所以我们不能在一个不能寻址的IntSet值上调用这个方法：\ntype IntSet struct { /* ... */ } func (*IntSet) String() string var _ = IntSet{}.String() // compile error: String requires *IntSet receiver 但是我们可以在一个IntSet变量上调用这个方法：\nvar s IntSet var _ = s.String() // OK: s is a variable and \u0026amp;s has a String method 然而，由于只有*IntSet类型有String方法，所以也只有*IntSet类型实现了fmt.Stringer接口：\nvar _ fmt.Stringer = \u0026amp;s // OK var _ fmt.Stringer = s // compile error: IntSet lacks String method 12.8章包含了一个打印出任意值的所有方法的程序，然后可以使用godoc -analysis=type tool(§10.7.4)展示每个类型的方法和具体类型和接口之间的关系\n就像信封封装和隐藏起信件来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到：\nos.Stdout.Write([]byte(\u0026#34;hello\u0026#34;)) // OK: *os.File has Write method os.Stdout.Close() // OK: *os.File has Close method  var w io.Writer w = os.Stdout w.Write([]byte(\u0026#34;hello\u0026#34;)) // OK: io.Writer has Write method w.Close() // compile error: io.Writer lacks Close method 一个有更多方法的接口类型，比如io.ReadWriter，和少一些方法的接口类型例如io.Reader，进行对比；更多方法的接口类型会告诉我们更多关于它的值持有的信息，并且对实现它的类型要求更加严格。那么关于interface{}类型，它没有任何方法，请讲出哪些具体的类型实现了它？\n这看上去好像没有用，但实际上interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。\nvar any interface{} any = true any = 12.34 any = \u0026#34;hello\u0026#34; any = map[string]int{\u0026#34;one\u0026#34;: 1} any = new(bytes.Buffer) 尽管不是很明显，从本书最早的例子中我们就已经在使用空接口类型。它允许像fmt.Println或者5.7章中的errorf函数接受任何类型的参数。\n对于创建的一个interface{}值持有一个boolean，float，string，map，pointer，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法。我们会在7.10章中学到一种用类型断言来获取interface{}中值的方法。\n因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，有意地在文档里说明或者程序上断言这种关系偶尔是有用的，但程序上不强制这么做。下面的定义在编译期断言一个*bytes.Buffer的值实现了io.Writer接口类型:\n// *bytes.Buffer must satisfy io.Writer var w io.Writer = new(bytes.Buffer) 因为任意*bytes.Buffer的值，甚至包括nil通过(*bytes.Buffer)(nil)进行显示的转换都实现了这个接口，所以我们不必分配一个新的变量。并且因为我们绝不会引用变量w，我们可以使用空标识符来进行代替。总的看，这些变化可以让我们得到一个更朴素的版本：\n// *bytes.Buffer must satisfy io.Writer var _ io.Writer = (*bytes.Buffer)(nil) 非空的接口类型比如io.Writer经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。\n但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。我们已经看过slice类型的方法（geometry.Path，§6.1）和map类型的方法（url.Values，§6.2.1），后面还会看到函数类型的方法的例子（http.HandlerFunc，§7.7）。甚至基本的类型也可能会实现一些接口；就如我们在7.4章中看到的time.Duration类型实现了fmt.Stringer接口。\n一个具体的类型可能实现了很多不相关的接口。考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型：\nAlbum Book Movie Magazine Podcast TVEpisode Track 我们可以把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表。\ntype Artifact interface { Title() string Creators() []string Created() time.Time } 其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，还有只有movies和TV剧集和屏幕分辨率相关。\ntype Text interface { Pages() int Words() int PageSize() int } type Audio interface { Stream() (io.ReadCloser, error) RunningTime() time.Duration Format() string // e.g., \u0026#34;MP3\u0026#34;, \u0026#34;WAV\u0026#34; } type Video interface { Stream() (io.ReadCloser, error) RunningTime() time.Duration Format() string // e.g., \u0026#34;MP4\u0026#34;, \u0026#34;WMV\u0026#34; \tResolution() (x, y int) } 这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变。\ntype Streamer interface { Stream() (io.ReadCloser, error) RunningTime() time.Duration Format() string } 每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。\n"});index.add({'id':84,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.3.-Example-Concurrent-Echo-Server/','title':"8.3. 示例: 并发的Echo服务",'section':"8. Goroutines和Channels",'content':"8.3. 示例: 并发的Echo服务 #  clock服务器每一个连接都会起一个goroutine。在本节中我们会创建一个echo服务器，这个服务在每个连接中会有多个goroutine。大多数echo服务仅仅会返回他们读取到的内容，就像下面这个简单的handleConn函数所做的一样：\nfunc handleConn(c net.Conn) { io.Copy(c, c) // NOTE: ignoring errors \tc.Close() } 一个更有意思的echo服务应该模拟一个实际的echo的“回响”，并且一开始要用大写HELLO来表示“声音很大”，之后经过一小段延迟返回一个有所缓和的Hello，然后一个全小写字母的hello表示声音渐渐变小直至消失，像下面这个版本的handleConn(译注：笑看作者脑洞大开)：\ngopl.io/ch8/reverb1\nfunc echo(c net.Conn, shout string, delay time.Duration) { fmt.Fprintln(c, \u0026#34;\\t\u0026#34;, strings.ToUpper(shout)) time.Sleep(delay) fmt.Fprintln(c, \u0026#34;\\t\u0026#34;, shout) time.Sleep(delay) fmt.Fprintln(c, \u0026#34;\\t\u0026#34;, strings.ToLower(shout)) } func handleConn(c net.Conn) { input := bufio.NewScanner(c) for input.Scan() { echo(c, input.Text(), 1*time.Second) } // NOTE: ignoring potential errors from input.Err() \tc.Close() } 我们需要升级我们的客户端程序，这样它就可以发送终端的输入到服务器，并把服务端的返回输出到终端上，这使我们有了使用并发的另一个好机会：\ngopl.io/ch8/netcat2\nfunc main() { conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) if err != nil { log.Fatal(err) } defer conn.Close() go mustCopy(os.Stdout, conn) mustCopy(conn, os.Stdin) } 当main goroutine从标准输入流中读取内容并将其发送给服务器时，另一个goroutine会读取并打印服务端的响应。当main goroutine碰到输入终止时，例如，用户在终端中按了Control-D(^D)，在windows上是Control-Z，这时程序就会被终止，尽管其它goroutine中还有进行中的任务。（在8.4.1中引入了channels后我们会明白如何让程序等待两边都结束。）\n下面这个会话中，客户端的输入是左对齐的，服务端的响应会用缩进来区别显示。 客户端会向服务器“喊三次话”：\n$ go build gopl.io/ch8/reverb1 $ ./reverb1 \u0026amp; $ go build gopl.io/ch8/netcat2 $ ./netcat2 Hello? HELLO? Hello? hello? Is there anybody there? IS THERE ANYBODY THERE? Yooo-hooo! Is there anybody there? is there anybody there? YOOO-HOOO! Yooo-hooo! yooo-hooo! ^D $ killall reverb1 注意客户端的第三次shout在前一个shout处理完成之前一直没有被处理，这貌似看起来不是特别“现实”。真实世界里的回响应该是会由三次shout的回声组合而成的。为了模拟真实世界的回响，我们需要更多的goroutine来做这件事情。这样我们就再一次地需要go这个关键词了，这次我们用它来调用echo：\ngopl.io/ch8/reverb2\nfunc handleConn(c net.Conn) { input := bufio.NewScanner(c) for input.Scan() { go echo(c, input.Text(), 1*time.Second) } // NOTE: ignoring potential errors from input.Err() \tc.Close() } go后跟的函数的参数会在go语句自身执行时被求值；因此input.Text()会在main goroutine中被求值。 现在回响是并发并且会按时间来覆盖掉其它响应了：\n$ go build gopl.io/ch8/reverb2 $ ./reverb2 \u0026amp; $ ./netcat2 Is there anybody there? IS THERE ANYBODY THERE? Yooo-hooo! Is there anybody there? YOOO-HOOO! is there anybody there? Yooo-hooo! yooo-hooo! ^D $ killall reverb2 让服务使用并发不只是处理多个客户端的请求，甚至在处理单个连接时也可能会用到，就像我们上面的两个go关键词的用法。然而在我们使用go关键词的同时，需要慎重地考虑net.Conn中的方法在并发地调用时是否安全，事实上对于大多数类型来说也确实不安全。我们会在下一章中详细地探讨并发安全性。\n"});index.add({'id':85,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.3.-Unidirectional-Channel-Types/','title':"8.4.3. 单方向的Channel",'section':"8.4. Channels",'content':"8.4.3. 单方向的Channel #  随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels来连接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法：\nfunc counter(out chan int) func squarer(out, in chan int) func printer(in chan int) 其中计算平方的squarer函数在两个串联Channels的中间，因此拥有两个channel类型的参数，一个用于输入一个用于输出。两个channel都拥有相同的类型，但是它们的使用方式相反：一个只用于接收，另一个只用于发送。参数的名字in和out已经明确表示了这个意图，但是并无法保证squarer函数向一个in参数对应的channel发送数据或者从一个out参数对应的channel接收数据。\n这种场景是典型的。当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。\n为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan\u0026lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型\u0026lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头\u0026lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。\n因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。\n这是改进的版本，这一次参数使用了单方向channel类型：\ngopl.io/ch8/pipeline3\nfunc counter(out chan\u0026lt;- int) { for x := 0; x \u0026lt; 100; x++ { out \u0026lt;- x } close(out) } func squarer(out chan\u0026lt;- int, in \u0026lt;-chan int) { for v := range in { out \u0026lt;- v * v } close(out) } func printer(in \u0026lt;-chan int) { for v := range in { fmt.Println(v) } } func main() { naturals := make(chan int) squares := make(chan int) go counter(naturals) go squarer(squares, naturals) printer(squares) } 调用counter（naturals）时，naturals的类型将隐式地从chan int转换成chan\u0026lt;- int。调用printer(squares)也会导致相似的隐式转换，这一次是转换为\u0026lt;-chan int类型只接收型的channel。任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法：也就是不能将一个类似chan\u0026lt;- int类型的单向型的channel转换为chan int类型的双向型的channel。\n"});index.add({'id':86,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.3.-Read-Write-Mutexes-sync.RWMutex/','title':"9.3. sync.RWMutex读写锁",'section':"9. 基于共享变量的并发",'content':"9.3. sync.RWMutex读写锁 #  在100刀的存款消失时不做记录多少还是会让我们有一些恐慌，Bob写了一个程序，每秒运行几百次来检查他的银行余额。他会在家，在工作中，甚至会在他的手机上来运行这个程序。银行注意到这些陡增的流量使得存款和取款有了延时，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。\n由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁（multiple readers, single writer lock），Go语言提供的这样的锁是sync.RWMutex：\nvar mu sync.RWMutex var balance int func Balance() int { mu.RLock() // readers lock \tdefer mu.RUnlock() return balance } Balance函数现在调用了RLock和RUnlock方法来获取和释放一个读取或者共享锁。Deposit函数没有变化，会调用mu.Lock和mu.Unlock方法来获取和释放一个写或互斥锁。\n在这次修改后，Bob的余额查询请求就可以彼此并行地执行并且会很快地完成了。锁在更多的时间范围可用，并且存款请求也能够及时地被响应了。\nRLock只能在临界区共享变量没有任何写入操作时可用。一般来说，我们不应该假设逻辑上的只读函数/方法也不会去更新某一些变量。比如一个方法功能是访问一个变量，但它也有可能会同时去给一个内部的计数器+1（译注：可能是记录这个方法的访问次数啥的），或者去更新缓存——使即时的调用能够更快。如果有疑惑的话，请使用互斥锁。\nRWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。\n"});index.add({'id':87,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.3.-GOMAXPROCS/','title':"9.8.3. GOMAXPROCS",'section':"9.8. Goroutines和线程",'content':"9.8.3. GOMAXPROCS #  Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。（GOMAXPROCS是前面说的m:n调度中的n）。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。\n你可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。我们在下面的小程序中会看到GOMAXPROCS的效果，这个程序会无限打印0和1。\nfor { go fmt.Print(0) fmt.Print(1) } $ GOMAXPROCS=1 go run hacker-cliché.go 111111111111111111110000000000000000000011111... $ GOMAXPROCS=2 go run hacker-cliché.go 010101010101010101011001100101011010010100110... 在第一次执行时，最多同时只能有一个goroutine被执行。初始情况下只有main goroutine被执行，所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。我们必须强调的是goroutine的调度是受很多因子影响的，而runtime也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。\n** 练习9.6:** 测试一下计算密集型的并发程序（练习8.5那样的）会被GOMAXPROCS怎样影响到。在你的电脑上最佳的值是多少？你的电脑CPU有多少个核心？\n"});index.add({'id':88,'href':'/docs/The-Go-Programming-Language/Preface/Organization-of-the-Book/','title':"本书的组织",'section':"前言",'content':"本书的组织 #  我们假设你已经有一种或多种其他编程语言的使用经历，不管是类似C、C++或Java的编译型语言，还是类似Python、Ruby、JavaScript的脚本语言，因此我们不会像对完全的编程语言初学者那样解释所有的细节。因为，Go语言的变量、常量、表达式、控制流和函数等基本语法也是类似的。\n第一章包含了本教程的基本结构，通过十几个程序介绍了用Go语言如何实现类似读写文件、文本格式化、创建图像、网络客户端和服务器通讯等日常工作。\n第二章描述了Go语言程序的基本元素结构、变量、新类型定义、包和文件、以及作用域等概念。第三章讨论了数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符。第四章描述了复合类型，从简单的数组、字典、切片到动态列表。第五章涵盖了函数，并讨论了错误处理、panic和recover，还有defer语句。\n第一章到第五章是基础部分，主流命令式编程语言这部分都类似。个别之处，Go语言有自己特色的语法和风格，但是大多数程序员能很快适应。其余章节是Go语言特有的：方法、接口、并发、包、测试和反射等语言特性。\nGo语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。方法不仅可以定义在结构体上，而且，可以定义在任何用户自定义的类型上；并且，具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。方法在第六章讨论，接口在第七章讨论。\n第八章讨论了基于顺序通信进程（CSP）概念的并发编程，使用goroutines和channels处理并发编程。第九章则讨论了传统的基于共享变量的并发编程。\n第十章描述了包机制和包的组织结构。这一章还展示了如何有效地利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。\n第十一章讨论了单元测试，Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大但复杂的测试框架。测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件。\n第十二章讨论了反射，一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，不过要谨慎地使用；这一章利用反射机制实现一些重要的Go语言库函数，展示了反射的强大用法。第十三章解释了底层编程的细节，在必要时，可以使用unsafe包绕过Go语言安全的类型系统。\n每一章都有一些练习题，你可以用来测试你对Go的理解，你也可以探讨书中这些例子的扩展和替代。\n书中所有的代码都可以从 http://gopl.io 上的Git仓库下载。go get命令根据每个例子的导入路径智能地获取、构建并安装。只需要选择一个目录作为工作空间，然后将GOPATH环境变量设置为该路径。\n必要时，Go语言工具会创建目录。例如：\n$ export GOPATH=$HOME/gobook # 选择工作目录\r$ go get gopl.io/ch1/helloworld # 获取/编译/安装\r$ $GOPATH/bin/helloworld # 运行程序\rHello, 世界 # 这是中文\r运行这些例子需要安装Go1.5以上的版本。\n$ go version\rgo version go1.5 linux/amd64\r如果使用其他的操作系统，请参考 https://golang.org/doc/install 提供的说明安装。\n"});index.add({'id':89,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.4.-Animated-GIFs/','title':"1.4. GIF动画",'section':"1. 入门",'content':"1.4. GIF动画 #  下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形（Lissajous figures），这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。图1.1是这样的一个例子：\n 译注：要看这个程序的结果，需要将标准输出重定向到一个GIF图像文件（使用 ./lissajous \u0026gt; output.gif 命令）。下面是GIF图像动画效果：\n 这段代码里我们用了一些新的结构，包括const声明，struct结构体类型，复合声明。和我们举的其它的例子不太一样，这一个例子包含了浮点数运算。这些概念我们只在这里简单地说明一下，之后的章节会更详细地讲解。\ngopl.io/ch1/lissajous\n// Lissajous generates GIF animations of random Lissajous figures. package main import ( \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; \u0026#34;image/gif\u0026#34; \u0026#34;io\u0026#34; \u0026#34;math\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) var palette = []color.Color{color.White, color.Black} const ( whiteIndex = 0 // first color in palette \tblackIndex = 1 // next color in palette ) func main() { // The sequence of images is deterministic unless we seed \t// the pseudo-random number generator using the current time. \t// Thanks to Randall McPherson for pointing out the omission. \trand.Seed(time.Now().UTC().UnixNano()) lissajous(os.Stdout) } func lissajous(out io.Writer) { const ( cycles = 5 // number of complete x oscillator revolutions \tres = 0.001 // angular resolution \tsize = 100 // image canvas covers [-size..+size] \tnframes = 64 // number of animation frames \tdelay = 8 // delay between frames in 10ms units \t) freq := rand.Float64() * 3.0 // relative frequency of y oscillator \tanim := gif.GIF{LoopCount: nframes} phase := 0.0 // phase difference \tfor i := 0; i \u0026lt; nframes; i++ { rect := image.Rect(0, 0, 2*size+1, 2*size+1) img := image.NewPaletted(rect, palette) for t := 0.0; t \u0026lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) } phase += 0.1 anim.Delay = append(anim.Delay, delay) anim.Image = append(anim.Image, img) } gif.EncodeAll(out, \u0026amp;anim) // NOTE: ignoring encoding errors } 当我们import了一个包路径包含有多个单词的package时，比如image/color（image和color两个单词），通常我们只需要用最后那个单词表示这个包就可以。所以当我们写color.White时，这个变量指向的是image/color包里的变量，同理gif.GIF是属于image/gif包里的变量。\n这个程序里的常量声明给出了一系列的常量值，常量是指在程序编译后运行时始终都不会变化的值，比如圈数、帧数、延迟值。常量声明和变量声明一般都会出现在包级别，所以这些常量在整个包中都是可以共享的，或者你也可以把常量声明定义在函数体内部，那么这种常量就只能在函数体内用。目前常量声明的值必须是一个数字值、字符串或者一个固定的boolean值。\n[]color.Color{\u0026hellip;}和gif.GIF{\u0026hellip;}这两个表达式就是我们说的复合声明（4.2和4.4.1节有说明）。这是实例化Go语言里的复合类型的一种写法。这里的前者生成的是一个slice切片，后者生成的是一个struct结构体。\ngif.GIF是一个struct类型（参考4.4节）。struct是一组值或者叫字段的集合，不同的类型集合在一个struct可以让我们以一个统一的单元进行处理。anim是一个gif.GIF类型的struct变量。这种写法会生成一个struct变量，并且其内部变量LoopCount字段会被设置为nframes；而其它的字段会被设置为各自类型默认的零值。struct内部的变量可以以一个点（.）来进行访问，就像在最后两个赋值语句中显式地更新了anim这个struct的Delay和Image字段。\nlissajous函数内部有两层嵌套的for循环。外层循环会循环64次，每一次都会生成一个单独的动画帧。它生成了一个包含两种颜色的201*201大小的图片，白色和黑色。所有像素点都会被默认设置为其零值（也就是调色板palette里的第0个值），这里我们设置的是白色。每次外层循环都会生成一张新图片，并将一些像素设置为黑色。其结果会append到之前结果之后。这里我们用到了append(参考4.2.1)内置函数，将结果append到anim中的帧列表末尾，并设置一个默认的80ms的延迟值。循环结束后所有的延迟值被编码进了GIF图片中，并将结果写入到输出流。out这个变量是io.Writer类型，这个类型支持把输出结果写到很多目标，很快我们就可以看到例子。\n内层循环设置两个偏振值。x轴偏振使用sin函数。y轴偏振也是正弦波，但其相对x轴的偏振是一个0-3的随机值，初始偏振值是一个零值，随着动画的每一帧逐渐增加。循环会一直跑到x轴完成五次完整的循环。每一步它都会调用SetColorIndex来为(x,y)点来染黑色。\nmain函数调用lissajous函数，用它来向标准输出流打印信息，所以下面这个命令会像图1.1中产生一个GIF动画。\n$ go build gopl.io/ch1/lissajous $ ./lissajous \u0026gt;out.gif 练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。\n练习 1.6： 修改Lissajous程序，修改其调色板来生成更丰富的颜色，然后修改SetColorIndex的第三个参数，看看显示结果吧。\n"});index.add({'id':90,'href':'/docs/Clean-Code/1.-Clean-Code/1.4.-Schools-of-Thought/','title':"1.4. 思想流派",'section':"1. 整洁代码",'content':"1.4 思想流派 #  What about me (Uncle Bob)? What do I think clean code is? This book will tell you, in hideous detail, what I and my compatriots think about clean code. We will tell you what we think makes a clean variable name, a clean function, a clean class, etc. We will present these opinions as absolutes, and we will not apologize for our stridence. To us, at this point in our careers, they are absolutes. They are our school of thought about clean code.\n 我（鲍勃大叔）又是怎么想的呢？在我眼中整洁代码是什么样的？本书将以详细到吓死人的程度告诉你，我和我的同道对整洁代码的看法。我们会告诉你关于整洁变量名的想法，关于整洁函数的想法，关于整洁类的想法，如此等等。我们视这些观点为当然，且不为其逆耳而致歉。对我们而言，在职业生涯的这个阶段，这些观点确属当然，也是我们整洁代码派的圭旨。\n  Martial artists do not all agree about the best martial art, or the best technique within a martial art. Often master martial artists will form their own schools of thought and gather students to learn from them. So we see Gracie Jiu Jistu, founded and taught by the Gracie family in Brazil. We see Hakkoryu Jiu Jistu, founded and taught by Okuyama Ryuho in Tokyo. We see Jeet Kune Do, founded and taught by Bruce Lee in the United States.\n 武术家从不认同所谓最好的武术，也不认同所谓绝招。武术大师们常常创建自己的流派，聚徒而授。因此我们才看到格雷西家族在巴西开创并传授的格雷西柔术（Gracie Jiu Jistu），看到奥山龙峰（Okuyama Ryuho）在东京开创并传授的八光流柔术（Hakkoryu Jiu Jistu），看到李小龙（Bruce Lee）在美国开创并传授的截拳道（Jeet Kune Do）。\n Students of these approaches immerse themselves in the teachings of the founder. They dedicate themselves to learn what that particular master teaches, often to the exclusion of any other master’s teaching. Later, as the students grow in their art, they may become the student of a different master so they can broaden their knowledge and practice. Some eventually go on to refine their skills, discovering new techniques and founding their own schools.\n 弟子们沉浸于创始人的授业。他们全心师从某位师傅，排斥其他师傅。弟子有所成就后，可以转投另一位师傅，扩展自己的知识与技能。有些弟子最终百炼成钢，创出新招数，开宗立派。\n None of these different schools is absolutely right. Yet within a particular school we act as though the teachings and techniques are right. After all, there is a right way to practice Hakkoryu Jiu Jitsu, or Jeet Kune Do. But this rightness within a school does not invalidate the teachings of a different school.\n 任何门派都并非绝对正确。不过，身处某一门派时，我们总以其所传之技为善。归根结底，练习八光流柔术或截拳道，自有其善法，但这并不能否定其他门派所授之法。\n Consider this book a description of the Object Mentor School of Clean Code. The techniques and teachings within are the way that we practice our art. We are willing to claim that if you follow these teachings, you will enjoy the benefits that we have enjoyed, and you will learn to write code that is clean and professional. But don’t make the mistake of thinking that we are somehow “right” in any absolute sense. There are other schools and other masters that have just as much claim to professionalism as we. It would behoove you to learn from them as well.\n 可以把本书看作是对象导师（Object Mentor）整洁代码派的说明。里面要传授的就是我们勤操己艺的方法。如果你遵从这些教诲，你就会如我们一般乐受其益，你将学会如何编写整洁而专业的代码。但无论如何也别错以为我们是“正确的”。其他门派和师傅和我们一样专业。你有必要也向他们学习。\n Indeed, many of the recommendations in this book are controversial. You will probably not agree with all of them. You might violently disagree with some of them. That’s fine. We can’t claim final authority. On the other hand, the recommendations in this book are things that we have thought long and hard about. We have learned them through decades of experience and repeated trial and error. So whether you agree or disagree, it would be a shame if you did not see, and respect, our point of view.\n 实际上，书中很多建议都存在争议。或许你并不完全同意这些建议。你可能会强烈反对其中一些建议。这样挺好的。我们不能要求做最终权威。另外一方面，书中列出的建议，乃是我们长久苦思、从数十年的从业经验和无数尝试与错误中得来。无论你同意与否，如果你没看到或是不尊敬我们的观点，就真该自己害臊。\n "});index.add({'id':91,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.4.-Import-Declarations/','title':"10.4. 导入声明",'section':"10. 包和工具",'content':"10.4. 导入声明 #  可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。\nimport \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) 导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将不同分组导入的包独立排序。）\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;os\u0026#34; \u0026#34;golang.org/x/net/html\u0026#34; \u0026#34;golang.org/x/net/ipv4\u0026#34; ) 如果我们想同时导入两个有着名字相同的包，例如math/rand包和crypto/rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。\nimport ( \u0026#34;crypto/rand\u0026#34; mrand \u0026#34;math/rand\u0026#34; // alternative name mrand avoids conflict ) 导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。\n导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将“path”标准包重命名为pathpkg。\n每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。\n"});index.add({'id':92,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.4.-Documenting-Packages/','title':"10.7.4. 包文档",'section':"10.7. 工具",'content':"10.7.4. 包文档 #  Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。\nGo语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。\n// Fprintf formats according to a format specifier and writes to w. // It returns the number of bytes written and any write error encountered. func Fprintf(w io.Writer, format string, a ...interface{}) (int, error) Fprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。\n好的文档并不需要面面俱到，文档本身应该是简洁但不可忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。\n在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。\n首先是go doc命令，该命令打印其后所指定的实体的声明与文档注释，该实体可能是一个包：\n$ go doc time package time // import \u0026quot;time\u0026quot; Package time provides functionality for measuring and displaying time. const Nanosecond Duration = 1 ... func After(d Duration) \u0026lt;-chan Time func Sleep(d Duration) func Since(t Time) Duration func Now() Time type Duration int64 type Time struct { ... } ...many more... 或者是某个具体的包成员：\n$ go doc time.Since func Since(t Time) Duration Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). 或者是一个方法：\n$ go doc time.Duration.Seconds func (d Duration) Seconds() float64 Seconds returns the duration as a floating-point number of seconds. 该命令并不需要输入完整的包导入路径或正确的大小写。下面的命令将打印encoding/json包的(*json.Decoder).Decode方法的文档：\n$ go doc json.decode func (dec *Decoder) Decode(v interface{}) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. 第二个工具，名字也叫godoc，它提供可以相互交叉引用的HTML页面，但是包含和go doc命令相同以及更多的信息。图10.1演示了time包的文档，11.6节将看到godoc演示可以交互的示例程序。godoc的在线服务 https://godoc.org ，包含了成千上万的开源包的检索工具。\n 你也可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看 http://localhost:8000/pkg 页面：\n$ godoc -http :8000 其中-analysis=type和-analysis=pointer命令行标志参数用于打开文档和代码中关于静态分析的结果。\n"});index.add({'id':93,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.4.-External-Test-Packages/','title':"11.2.4. 外部测试包",'section':"11.2. 测试函数",'content':"11.2.4. 外部测试包 #  考虑下这两个包：net/url包，提供了URL解析的功能；net/http包，提供了web服务和HTTP客户端的功能。如我们所料，上层的net/http包依赖下层的net/url包。然后，net/url包中的一个测试是演示不同URL和HTTP客户端的交互行为。也就是说，一个下层包的测试代码导入了上层的包。\n 这样的行为在net/url包的测试代码中会导致包的循环依赖，正如图11.1中向上箭头所示，同时正如我们在10.1节所讲的，Go语言规范是禁止包的循环依赖的。\n不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net/url包所在的目录声明一个独立的url_test测试包。其中包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net/url_test会更容易理解，但实际上它并不能被其他任何包导入。\n因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。\n 通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。\n我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。\n{% raw %}\n$ go list -f={{.GoFiles}} fmt [doc.go format.go print.go scan.go] {% endraw %}\nTestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：\n{% raw %}\n$ go list -f={{.TestGoFiles}} fmt [export_test.go] {% endraw %}\n包的测试代码通常都在这些文件中，不过fmt包并非如此；稍后我们再解释export_test.go文件的作用。\nXTestGoFiles表示的是属于外部测试包的测试代码，也就是fmt_test包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：\n{% raw %}\n$ go list -f={{.XTestGoFiles}} fmt [fmt_test.go scan_test.go stringer_test.go] {% endraw %}\n有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在export_test.go文件中。\n例如，fmt包的fmt.Scanf函数需要unicode.IsSpace函数提供的功能。但是为了避免太多的依赖，fmt包并没有导入包含巨大表格数据的unicode包；相反fmt包有一个叫isSpace内部的简易实现。\n为了确保fmt.isSpace和unicode.IsSpace函数的行为保持一致，fmt包谨慎地包含了一个测试。一个在外部测试包内的白盒测试，是无法直接访问到isSpace内部函数的，因此fmt通过一个后门导出了isSpace函数。export_test.go文件就是专门用于外部测试包的后门。\npackage fmt var IsSpace = isSpace 这个测试文件并没有定义测试代码；它只是通过fmt.IsSpace简单导出了内部的isSpace函数，提供给外部测试包使用。这个技巧可以广泛用于位于外部测试包的白盒测试。\n"});index.add({'id':94,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.4.-Benchmark-Functions/','title':"11.4. 基准测试",'section':"11. 测试",'content':"11.4. 基准测试 #  基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个*testing.B类型的参数；*testing.B参数除了提供和*testing.T类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。\n下面是IsPalindrome函数的基准测试，其中循环将执行N次。\nimport \u0026#34;testing\u0026#34; func BenchmarkIsPalindrome(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { IsPalindrome(\u0026#34;A man, a plan, a canal: Panama\u0026#34;) } } 我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过-bench命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和-bench=IsPalindrome参数是等价的效果。\n$ cd $GOPATH/src/gopl.io/ch11/word2 $ go test -bench=. PASS BenchmarkIsPalindrome-8 1000000 1035 ns/op ok gopl.io/ch11/word2 2.179s 结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。\n报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。\n循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。\n现在我们有了一个基准测试和普通测试，我们可以很容易测试改进程序运行速度的想法。也许最明显的优化是在IsPalindrome函数中第二个循环的停止检查，这样可以避免每个比较都做两次：\nn := len(letters)/2 for i := 0; i \u0026lt; n; i++ { if letters[i] != letters[len(letters)-1-i] { return false } } return true 不过很多情况下，一个显而易见的优化未必能带来预期的效果。这个改进在基准测试中只带来了4%的性能提升。\n$ go test -bench=. PASS BenchmarkIsPalindrome-8 1000000 992 ns/op ok gopl.io/ch11/word2 2.093s 另一个改进想法是在开始为每个字符预先分配一个足够大的数组，这样就可以避免在append调用时可能会导致内存的多次重新分配。声明一个letters数组变量，并指定合适的大小，像下面这样，\nletters := make([]rune, 0, len(s)) for _, r := range s { if unicode.IsLetter(r) { letters = append(letters, unicode.ToLower(r)) } } 这个改进提升性能约35%，报告结果是基于2,000,000次迭代的平均运行时间统计。\n$ go test -bench=. PASS BenchmarkIsPalindrome-8 2000000 697 ns/op ok gopl.io/ch11/word2 1.468s 如这个例子所示，快的程序往往是伴随着较少的内存分配。-benchmem命令行标志参数将在报告中包含内存的分配数据统计。我们可以比较优化前后内存的分配情况：\n$ go test -bench=. -benchmem PASS BenchmarkIsPalindrome 1000000 1026 ns/op 304 B/op 4 allocs/op 这是优化之后的结果：\n$ go test -bench=. -benchmem PASS BenchmarkIsPalindrome 2000000 807 ns/op 128 B/op 1 allocs/op 用一次内存分配代替多次的内存分配节省了75%的分配调用次数和减少近一半的内存需求。\n这个基准测试告诉了我们某个具体操作所需的绝对时间，但我们往往想知道的是两个不同的操作的时间对比。例如，如果一个函数需要1ms处理1,000个元素，那么处理10000或1百万将需要多少时间呢？这样的比较揭示了渐近增长函数的运行时间。另一个例子：I/O缓存该设置为多大呢？基准测试可以帮助我们选择在性能达标情况下所需的最小内存。第三个例子：对于一个确定的工作哪种算法更好？基准测试可以评估两种不同算法对于相同的输入在不同的场景和负载下的优缺点。\n比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：\nfunc benchmark(b *testing.B, size int) { /* ... */ } func Benchmark10(b *testing.B) { benchmark(b, 10) } func Benchmark100(b *testing.B) { benchmark(b, 100) } func Benchmark1000(b *testing.B) { benchmark(b, 1000) } 通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。\n比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。\n练习 11.6: 为2.6.2节的练习2.4和练习2.5的PopCount函数编写基准测试。看看基于表格算法在不同情况下对提升性能会有多大帮助。\n练习 11.7: 为*IntSet（§6.5）的Add、UnionWith和其他方法编写基准测试，使用大量随机输入。你可以让这些方法跑多快？选择字的大小对于性能的影响如何？IntSet和基于内建map的实现相比有多快？\n"});index.add({'id':95,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.4.-Example-Encoding-S-Expressions/','title':"12.4. 示例: 编码为S表达式",'section':"12. 反射",'content':"12.4. 示例: 编码为S表达式 #  Display是一个用于显示结构化数据的调试工具，但是它并不能将任意的Go语言对象编码为通用消息然后用于进程间通信。\n正如我们在4.5节中中看到的，Go语言的标准库支持了包括JSON、XML和ASN.1等多种编码格式。还有另一种依然被广泛使用的格式是S表达式格式，采用Lisp语言的语法。但是和其他编码格式不同的是，Go语言自带的标准库并不支持S表达式，主要是因为它没有一个公认的标准规范。\n在本节中，我们将定义一个包用于将任意的Go语言对象编码为S表达式格式，它支持以下结构：\n42 integer \u0026quot;hello\u0026quot; string（带有Go风格的引号） foo symbol（未用引号括起来的名字） (1 2 3) list （括号包起来的0个或多个元素） 布尔型习惯上使用t符号表示true，空列表或nil符号表示false，但是为了简单起见，我们暂时忽略布尔类型。同时忽略的还有chan管道和函数，因为通过反射并无法知道它们的确切状态。我们忽略的还有浮点数、复数和interface。支持它们是练习12.3的任务。\n我们将Go语言的类型编码为S表达式的方法如下。整数和字符串以显而易见的方式编码。空值编码为nil符号。数组和slice被编码为列表。\n结构体被编码为成员对象的列表，每个成员对象对应一个有两个元素的子列表，子列表的第一个元素是成员的名字，第二个元素是成员的值。Map被编码为键值对的列表。传统上，S表达式使用点状符号列表(key . value)结构来表示key/value对，而不是用一个含双元素的列表，不过为了简单我们忽略了点状符号列表。\n编码是由一个encode递归函数完成，如下所示。它的结构本质上和前面的Display函数类似：\ngopl.io/ch12/sexpr\nfunc encode(buf *bytes.Buffer, v reflect.Value) error { switch v.Kind() { case reflect.Invalid: buf.WriteString(\u0026#34;nil\u0026#34;) case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: fmt.Fprintf(buf, \u0026#34;%d\u0026#34;, v.Int()) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: fmt.Fprintf(buf, \u0026#34;%d\u0026#34;, v.Uint()) case reflect.String: fmt.Fprintf(buf, \u0026#34;%q\u0026#34;, v.String()) case reflect.Ptr: return encode(buf, v.Elem()) case reflect.Array, reflect.Slice: // (value ...) \tbuf.WriteByte(\u0026#39;(\u0026#39;) for i := 0; i \u0026lt; v.Len(); i++ { if i \u0026gt; 0 { buf.WriteByte(\u0026#39; \u0026#39;) } if err := encode(buf, v.Index(i)); err != nil { return err } } buf.WriteByte(\u0026#39;)\u0026#39;) case reflect.Struct: // ((name value) ...) \tbuf.WriteByte(\u0026#39;(\u0026#39;) for i := 0; i \u0026lt; v.NumField(); i++ { if i \u0026gt; 0 { buf.WriteByte(\u0026#39; \u0026#39;) } fmt.Fprintf(buf, \u0026#34;(%s \u0026#34;, v.Type().Field(i).Name) if err := encode(buf, v.Field(i)); err != nil { return err } buf.WriteByte(\u0026#39;)\u0026#39;) } buf.WriteByte(\u0026#39;)\u0026#39;) case reflect.Map: // ((key value) ...) \tbuf.WriteByte(\u0026#39;(\u0026#39;) for i, key := range v.MapKeys() { if i \u0026gt; 0 { buf.WriteByte(\u0026#39; \u0026#39;) } buf.WriteByte(\u0026#39;(\u0026#39;) if err := encode(buf, key); err != nil { return err } buf.WriteByte(\u0026#39; \u0026#39;) if err := encode(buf, v.MapIndex(key)); err != nil { return err } buf.WriteByte(\u0026#39;)\u0026#39;) } buf.WriteByte(\u0026#39;)\u0026#39;) default: // float, complex, bool, chan, func, interface \treturn fmt.Errorf(\u0026#34;unsupported type: %s\u0026#34;, v.Type()) } return nil } Marshal函数是对encode的包装，以保持和encoding/\u0026hellip;下其它包有着相似的API：\n// Marshal encodes a Go value in S-expression form. func Marshal(v interface{}) ([]byte, error) { var buf bytes.Buffer if err := encode(\u0026amp;buf, reflect.ValueOf(v)); err != nil { return nil, err } return buf.Bytes(), nil } 下面是Marshal对12.3节的strangelove变量编码后的结果：\n((Title \u0026quot;Dr. Strangelove\u0026quot;) (Subtitle \u0026quot;How I Learned to Stop Worrying and Lo ve the Bomb\u0026quot;) (Year 1964) (Actor ((\u0026quot;Grp. Capt. Lionel Mandrake\u0026quot; \u0026quot;Peter Sell ers\u0026quot;) (\u0026quot;Pres. Merkin Muffley\u0026quot; \u0026quot;Peter Sellers\u0026quot;) (\u0026quot;Gen. Buck Turgidson\u0026quot; \u0026quot;Geor ge C. Scott\u0026quot;) (\u0026quot;Brig. Gen. Jack D. Ripper\u0026quot; \u0026quot;Sterling Hayden\u0026quot;) (\u0026quot;Maj. T.J. \\ \u0026quot;King\\\u0026quot; Kong\u0026quot; \u0026quot;Slim Pickens\u0026quot;) (\u0026quot;Dr. Strangelove\u0026quot; \u0026quot;Peter Sellers\u0026quot;))) (Oscars (\u0026quot;Best Actor (Nomin.)\u0026quot; \u0026quot;Best Adapted Screenplay (Nomin.)\u0026quot; \u0026quot;Best Director (N omin.)\u0026quot; \u0026quot;Best Picture (Nomin.)\u0026quot;)) (Sequel nil)) 整个输出编码为一行中以减少输出的大小，但是也很难阅读。下面是对S表达式手动格式化的结果。编写一个S表达式的美化格式化函数将作为一个具有挑战性的练习任务；不过 http://gopl.io 也提供了一个简单的版本。\n((Title \u0026quot;Dr. Strangelove\u0026quot;) (Subtitle \u0026quot;How I Learned to Stop Worrying and Love the Bomb\u0026quot;) (Year 1964) (Actor ((\u0026quot;Grp. Capt. Lionel Mandrake\u0026quot; \u0026quot;Peter Sellers\u0026quot;) (\u0026quot;Pres. Merkin Muffley\u0026quot; \u0026quot;Peter Sellers\u0026quot;) (\u0026quot;Gen. Buck Turgidson\u0026quot; \u0026quot;George C. Scott\u0026quot;) (\u0026quot;Brig. Gen. Jack D. Ripper\u0026quot; \u0026quot;Sterling Hayden\u0026quot;) (\u0026quot;Maj. T.J. \\\u0026quot;King\\\u0026quot; Kong\u0026quot; \u0026quot;Slim Pickens\u0026quot;) (\u0026quot;Dr. Strangelove\u0026quot; \u0026quot;Peter Sellers\u0026quot;))) (Oscars (\u0026quot;Best Actor (Nomin.)\u0026quot; \u0026quot;Best Adapted Screenplay (Nomin.)\u0026quot; \u0026quot;Best Director (Nomin.)\u0026quot; \u0026quot;Best Picture (Nomin.)\u0026quot;)) (Sequel nil)) 和fmt.Print、json.Marshal、Display函数类似，sexpr.Marshal函数处理带环的数据结构也会陷入死循环。\n在12.6节中，我们将给出S表达式解码器的实现步骤，但是在那之前，我们还需要先了解如何通过反射技术来更新程序的变量。\n练习 12.3： 实现encode函数缺少的分支。将布尔类型编码为t和nil，浮点数编码为Go语言的格式，复数1+2i编码为#C(1.0 2.0)格式。接口编码为类型名和值对，例如（\u0026quot;[]int\u0026rdquo; (1 2 3)），但是这个形式可能会造成歧义：reflect.Type.String方法对于不同的类型可能返回相同的结果。\n练习 12.4： 修改encode函数，以上面的格式化形式输出S表达式。\n练习 12.5： 修改encode函数，用JSON格式代替S表达式格式。然后使用标准库提供的json.Unmarshal解码器来验证函数是正确的。\n练习 12.6： 修改encode，作为一个优化，忽略对是零值对象的编码。\n练习 12.7： 创建一个基于流式的API，用于S表达式的解码，和json.Decoder(§4.5)函数功能类似。\n"});index.add({'id':96,'href':'/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.4.-Calling-C-Code-with-cgo/','title':"13.4. 通过cgo调用C代码",'section':"13. 底层编程",'content':"13.4. 通过cgo调用C代码 #  Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景，或者是从一个C++语言实现的嵌入式数据库查询记录的场景，或者是使用Fortran语言实现的一些线性代数库的场景。C语言作为一个通用语言，很多库会选择提供一个C兼容的API，然后用其他不同的编程语言实现（译者：Go语言需要也应该拥抱这些巨大的代码遗产）。\n在本节中，我们将构建一个简易的数据压缩程序，使用了一个Go语言自带的叫cgo的用于支援C语言函数调用的工具。这类工具一般被称为 foreign-function interfaces （简称ffi），并且在类似工具中cgo也不是唯一的。SWIG（http://swig.org）是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支援C++的特性，但SWIG并不是我们要讨论的主题。\n在标准库的compress/...子包有很多流行的压缩算法的编码和解码实现，包括流行的LZW压缩算法（Unix的compress命令用的算法）和DEFLATE压缩算法（GNU gzip命令用的算法）。这些包的API的细节虽然有些差异，但是它们都提供了针对 io.Writer类型输出的压缩接口和提供了针对io.Reader类型输入的解压缩接口。例如：\npackage gzip // compress/gzip func NewWriter(w io.Writer) io.WriteCloser func NewReader(r io.Reader) (io.ReadCloser, error) bzip2压缩算法，是基于优雅的Burrows-Wheeler变换算法，运行速度比gzip要慢，但是可以提供更高的压缩比。标准库的compress/bzip2包目前还没有提供bzip2压缩算法的实现。完全从头开始实现一个压缩算法是一件繁琐的工作，而且 http://bzip.org 已经有现成的libbzip2的开源实现，不仅文档齐全而且性能又好。\n如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了（译注：用os/exec包调用子进程的方法会导致程序运行时依赖那个应用程序）。下面我们将通过一个例子讲述cgo的具体用法。\n译注：本章采用的代码都是最新的。因为之前已经出版的书中包含的代码只能在Go1.5之前使用。从Go1.6开始，Go语言已经明确规定了哪些Go语言指针可以直接传入C语言函数。新代码重点是增加了bz2alloc和bz2free的两个函数，用于bz_stream对象空间的申请和释放操作。下面是新代码中增加的注释，说明这个问题：\n// The version of this program that appeared in the first and second // printings did not comply with the proposed rules for passing // pointers between Go and C, described here: // https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md // // The rules forbid a C function like bz2compress from storing \u0026#39;in\u0026#39; // and \u0026#39;out\u0026#39; (pointers to variables allocated by Go) into the Go // variable \u0026#39;s\u0026#39;, even temporarily. // // The version below, which appears in the third printing, has been // corrected. To comply with the rules, the bz_stream variable must // be allocated by C code. We have introduced two C functions, // bz2alloc and bz2free, to allocate and free instances of the // bz_stream type. Also, we have changed bz2compress so that before // it returns, it clears the fields of the bz_stream that contain // pointers to Go variables. 要使用libbzip2，我们需要先构建一个bz_stream结构体，用于保持输入和输出缓存。然后有三个函数：BZ2_bzCompressInit用于初始化缓存，BZ2_bzCompress用于将输入缓存的数据压缩到输出缓存，BZ2_bzCompressEnd用于释放不需要的缓存。（目前不要担心包的具体结构，这个例子的目的就是演示各个部分如何组合在一起的。）\n我们可以在Go代码中直接调用BZ2_bzCompressInit和BZ2_bzCompressEnd，但是对于BZ2_bzCompress，我们将定义一个C语言的包装函数，用它完成真正的工作。下面是C代码，对应一个独立的文件。\ngopl.io/ch13/bzip\n/* This file is gopl.io/ch13/bzip/bzip2.c, */ /* a simple wrapper for libbzip2 suitable for cgo. */ #include \u0026lt;bzlib.h\u0026gt; int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen) { s-\u0026gt;next_in = in; s-\u0026gt;avail_in = *inlen; s-\u0026gt;next_out = out; s-\u0026gt;avail_out = *outlen; int r = BZ2_bzCompress(s, action); *inlen -= s-\u0026gt;avail_in; *outlen -= s-\u0026gt;avail_out; s-\u0026gt;next_in = s-\u0026gt;next_out = NULL; return r; } 现在让我们转到Go语言部分，第一部分如下所示。其中import \u0026quot;C\u0026quot;的语句是比较特别的。其实并没有一个叫C的包，但是这行语句会让Go编译程序在编译之前先运行cgo工具。\n// Package bzip provides a writer that uses bzip2 compression (bzip.org). package bzip /* #cgo CFLAGS: -I/usr/include #cgo LDFLAGS: -L/usr/lib -lbz2 #include \u0026lt;bzlib.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; bz_stream* bz2alloc() { return calloc(1, sizeof(bz_stream)); } int bz2compress(bz_stream *s, int action, char *in, unsigned *inlen, char *out, unsigned *outlen); void bz2free(bz_stream* s) { free(s); } */ import \u0026#34;C\u0026#34; import ( \u0026#34;io\u0026#34; \u0026#34;unsafe\u0026#34; ) type writer struct { w io.Writer // underlying output stream \tstream *C.bz_stream outbuf [64 * 1024]byte } // NewWriter returns a writer for bzip2-compressed streams. func NewWriter(out io.Writer) io.WriteCloser { const blockSize = 9 const verbosity = 0 const workFactor = 30 w := \u0026amp;writer{w: out, stream: C.bz2alloc()} C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor) return w } 在预处理过程中，cgo工具生成一个临时包用于包含所有在Go语言中访问的C语言的函数或类型。例如C.bz_stream和C.BZ2_bzCompressInit。cgo工具通过以某种特殊的方式调用本地的C编译器来发现在Go源文件导入声明前的注释中包含的C头文件中的内容（译注：import \u0026quot;C\u0026quot;语句前紧挨着的注释是对应cgo的特殊语法，对应必要的构建参数选项和C语言代码）。\n在cgo注释中还可以包含#cgo指令，用于给C语言工具链指定特殊的参数。例如CFLAGS和LDFLAGS分别对应传给C语言编译器的编译参数和链接器参数，使它们可以从特定目录找到bzlib.h头文件和libbz2.a库文件。这个例子假设你已经在/usr目录成功安装了bzip2库。如果bzip2库是安装在不同的位置，你需要更新这些参数（译注：这里有一个从纯C代码生成的cgo绑定，不依赖bzip2静态库和操作系统的具体环境，具体请访问 https://github.com/chai2010/bzip2 ）。\nNewWriter函数通过调用C语言的BZ2_bzCompressInit函数来初始化stream中的缓存。在writer结构中还包括了另一个buffer，用于输出缓存。\n下面是Write方法的实现，返回成功压缩数据的大小，主体是一个循环中调用C语言的bz2compress函数实现的。从代码可以看到，Go程序可以访问C语言的bz_stream、char和uint类型，还可以访问bz2compress等函数，甚至可以访问C语言中像BZ_RUN那样的宏定义，全部都是以C.x语法访问。其中C.uint类型和Go语言的uint类型并不相同，即使它们具有相同的大小也是不同的类型。\nfunc (w *writer) Write(data []byte) (int, error) { if w.stream == nil { panic(\u0026#34;closed\u0026#34;) } var total int // uncompressed bytes written  for len(data) \u0026gt; 0 { inlen, outlen := C.uint(len(data)), C.uint(cap(w.outbuf)) C.bz2compress(w.stream, C.BZ_RUN, (*C.char)(unsafe.Pointer(\u0026amp;data[0])), \u0026amp;inlen, (*C.char)(unsafe.Pointer(\u0026amp;w.outbuf)), \u0026amp;outlen) total += int(inlen) data = data[inlen:] if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { return total, err } } return total, nil } 在循环的每次迭代中，向bz2compress传入数据的地址和剩余部分的长度，还有输出缓存w.outbuf的地址和容量。这两个长度信息通过它们的地址传入而不是值传入，因为bz2compress函数可能会根据已经压缩的数据和压缩后数据的大小来更新这两个值。每个块压缩后的数据被写入到底层的io.Writer。\nClose方法和Write方法有着类似的结构，通过一个循环将剩余的压缩数据刷新到输出缓存。\n// Close flushes the compressed data and closes the stream. // It does not close the underlying io.Writer. func (w *writer) Close() error { if w.stream == nil { panic(\u0026#34;closed\u0026#34;) } defer func() { C.BZ2_bzCompressEnd(w.stream) C.bz2free(w.stream) w.stream = nil }() for { inlen, outlen := C.uint(0), C.uint(cap(w.outbuf)) r := C.bz2compress(w.stream, C.BZ_FINISH, nil, \u0026amp;inlen, (*C.char)(unsafe.Pointer(\u0026amp;w.outbuf)), \u0026amp;outlen) if _, err := w.w.Write(w.outbuf[:outlen]); err != nil { return err } if r == C.BZ_STREAM_END { return nil } } } 压缩完成后，Close方法用了defer函数确保函数退出前调用C.BZ2_bzCompressEnd和C.bz2free释放相关的C语言运行时资源。此刻w.stream指针将不再有效，我们将它设置为nil以保证安全，然后在每个方法中增加了nil检测，以防止用户在关闭后依然错误使用相关方法。\n上面的实现中，不仅仅写是非并发安全的，甚至并发调用Close和Write方法也可能导致程序的的崩溃。修复这个问题是练习13.3的内容。\n下面的bzipper程序，使用我们自己包实现的bzip2压缩命令。它的行为和许多Unix系统的bzip2命令类似。\ngopl.io/ch13/bzipper\n// Bzipper reads input, bzip2-compresses it, and writes it out. package main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;gopl.io/ch13/bzip\u0026#34; ) func main() { w := bzip.NewWriter(os.Stdout) if _, err := io.Copy(w, os.Stdin); err != nil { log.Fatalf(\u0026#34;bzipper: %v\\n\u0026#34;, err) } if err := w.Close(); err != nil { log.Fatalf(\u0026#34;bzipper: close: %v\\n\u0026#34;, err) } } 在上面的场景中，我们使用bzipper压缩了/usr/share/dict/words系统自带的词典，从938,848字节压缩到335,405字节。大约是原始数据大小的三分之一。然后使用系统自带的bunzip2命令进行解压。压缩前后文件的SHA256哈希码是相同了，这也说明了我们的压缩工具是正确的。（如果你的系统没有sha256sum命令，那么请先按照练习4.2实现一个类似的工具）\n$ go build gopl.io/ch13/bzipper $ wc -c \u0026lt; /usr/share/dict/words 938848 $ sha256sum \u0026lt; /usr/share/dict/words 126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed - $ ./bzipper \u0026lt; /usr/share/dict/words | wc -c 335405 $ ./bzipper \u0026lt; /usr/share/dict/words | bunzip2 | sha256sum 126a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed - 我们演示了如何将一个C语言库链接到Go语言程序。相反，将Go编译为静态库然后链接到C程序，或者将Go程序编译为动态库然后在C程序中动态加载也都是可行的（译注：在Go1.5中，Windows系统的Go语言实现并不支持生成C语言动态库或静态库的特性。不过好消息是，目前已经有人在尝试解决这个问题，具体请访问 Issue11058 ）。这里我们只展示的cgo很小的一些方面，更多的关于内存管理、指针、回调函数、中断信号处理、字符串、errno处理、终结器，以及goroutines和系统线程的关系等，有很多细节可以讨论。特别是如何将Go语言的指针传入C函数的规则也是异常复杂的（译注：简单来说，要传入C函数的Go指针指向的数据本身不能包含指针或其他引用类型；并且C函数在返回后不能继续持有Go指针；并且在C函数返回之前，Go指针是被锁定的，不能导致对应指针数据被移动或栈的调整），部分的原因在13.2节有讨论到，但是在Go1.5中还没有被明确（译注：Go1.6将会明确cgo中的指针使用规则）。如果要进一步阅读，可以从 https://golang.org/cmd/cgo 开始。\n练习 13.3： 使用sync.Mutex以保证bzip2.writer在多个goroutines中被并发调用是安全的。\n练习 13.4： 因为C库依赖的限制。 使用os/exec包启动/bin/bzip2命令作为一个子进程，提供一个纯Go的bzip.NewWriter的替代实现（译注：虽然是纯Go实现，但是运行时将依赖/bin/bzip2命令，其他操作系统可能无法运行）。\n"});index.add({'id':97,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.3.-Variables/2.3.4.-Lifetime-of-Variables/','title':"2.3.4. 变量的生命周期",'section':"2.3. 变量",'content':"2.3.4. 变量的生命周期 #  变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。\n例如，下面是从1.4节的Lissajous程序摘录的代码片段：\nfor t := 0.0; t \u0026lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) } 译注：函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号。像下面这样：\nfor t := 0.0; t \u0026lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex( size+int(x*size+0.5), size+int(y*size+0.5), blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性 \t) // 小括弧另起一行缩进，和大括弧的风格保存一致 } 在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。\n那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。\n因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。\n编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。\nvar global *int func f() { var x int x = 1 global = \u0026amp;x } func g() { y := new(int) *y = 1 } f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。\nGo语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。\n"});index.add({'id':98,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.4.-Make-Meaningful-Distinctions/','title':"2.4. 做有意义的区分",'section':"2. 有意义的命名",'content':"2.4 做有意义的区分 #   Programmers create problems for themselves when they write code solely to satisfy a compiler or interpreter. For example, because you can’t use the same name to refer to two different things in the same scope, you might be tempted to change one name in an arbitrary way. Sometimes this is done by misspelling one, leading to the surprising situation where correcting spelling errors leads to an inability to compile.2\n 如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用范围内两样不同的东西不能重名，你可能会随手改掉其中一个的名称。有时干脆以错误的拼写充数，结果就是出现在更正拼写错误后导致编译器出错的情况。\n It is not sufficient to add number series or noise words, even though the compiler is satisfied. If names must be different, then they should also mean something different.\n 光是添加数字系列或是废话远远不够，即便这足以让编译器满意。如果名称必须相异，那其意思也应该不同才对。\n Number-series naming (a1, a2, .. aN) is the opposite of intentional naming. Such names are not disinformative—they are noninformative; they provide no clue to the author’s intention. Consider:\n 以数字系列命名（a1、a2，……aN）是依义命名的对立面。这样的名称纯属误导——完全没有提供正确信息；没有提供导向作者意图的线索。试看：\n public static void copyChars(char a1[], char a2[]) { for (int i = 0; i \u0026lt; a1.length; i++) { a2[i] = a1[i]; } } This function reads much better when source and destination are used for the argument names.\n 如果参数名改为 source 和 destination，这个函数就会像样许多。\n Noise words are another meaningless distinction. Imagine that you have a Product class. If you have another called ProductInfo or ProductData, you have made the names different without making them mean anything different. Info and Data are indistinct noise words like a, an, and the.\n 废话是另一种没意义的区分。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却无区别。Info 和 Data 就像 a、an 和 the 一样，是意义含混的废话。\n Note that there is nothing wrong with using prefix conventions like a and the so long as they make a meaningful distinction. For example you might use a for all local variables and the for all function arguments.3 The problem comes in when you decide to call a variable theZork because you already have another variable named zork.\n 注意，只要体现出有意义的区分，使用 a 和 the 这样的前缀就没错。例如，你可能把 a 用在域内变量，而把 the 用于函数参数。但如果你已经有一个名为 zork 的变量，又想调用一个名为 theZork 的变量，麻烦就来了。\n Noise words are redundant. The word variable should never appear in a variable name. The word table should never appear in a table name. How is NameString better than Name? Would a Name ever be a floating point number? If so, it breaks an earlier rule about disinformation. Imagine finding one class named Customer and another named CustomerObject. What should you understand as the distinction? Which one will represent the best path to a customer’s payment history?\n 废话都是冗余。Variable 一词永远不应当出现在变量名中。Table 一词永远不应当出现在表名中。NameString 会比 Name 好吗？难道 Name 会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为 Customer 的类，还有一个名为 CustomerObject 的类。区别何在呢？哪一个是表示客户历史支付情况的最佳途径？\n There is an application we know of where this is illustrated. we’ve changed the names to protect the guilty, but here’s the exact form of the error:\n 有个应用反映了这种状况。为当事者讳，我们改了一下，不过犯错的代码的确就是这个样子：\n getActiveAccount(); getActiveAccounts(); getActiveAccountInfo(); How are the programmers in this project supposed to know which of these functions to call?\n 程序员怎么能知道该调用哪个函数呢？\n In the absence of specific conventions, the variable moneyAmount is indistinguishable from money, customerInfo is indistinguishable from customer, accountData is indistinguishable from account, and theMessage is indistinguishable from message. Distinguish names in such a way that the reader knows what the differences offer.\n 如果缺少明确约定，变量 moneyAmount 就与 money 没区别， customerInfo 与 customer 没区别，accountData 与 account 没区别， theMessage 也与 message 没区别。要区分名称，就要以读者能鉴别不同之处的方式来区分。\n "});index.add({'id':99,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.4.-Assignments/','title':"2.4. 赋值",'section':"2. 程序结构",'content':"2.4. 赋值 #  使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。\nx = 1 // 命名变量的赋值 *p = true // 通过指针间接赋值 person.name = \u0026#34;bob\u0026#34; // 结构体字段赋值 count[x] = count[x] * scale // 数组、slice或map的元素赋值 特定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：\ncount[x] *= scale 这样可以省去对变量表达式的重复计算。\n数值变量也可以支持++递增和--递减语句（译注：自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的）：\nv := 1 v++ // 等价方式 v = v + 1；v 变成 2 v-- // 等价方式 v = v - 1；v 变成 1 "});index.add({'id':100,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/','title':"3. 基础数据类型",'section':"Go语言圣经",'content':"第三章　基础数据类型 #  虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。进一步将这些数组织在一起，就可表达更多的对象，例如数据包、像素点、诗歌，甚至其他任何对象。Go语言提供了丰富的数据组织形式，这依赖于Go语言内置的数据类型。这些内置的数据类型，兼顾了硬件的特性和表达复杂数据结构的便捷性。\nGo语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。本章介绍基础类型，包括：数字、字符串和布尔型。复合数据类型——数组（§4.1）和结构体（§4.2）——是通过组合简单类型，来表达更加复杂的数据结构。引用类型包括指针（§2.3.2）、切片（§4.2)）、字典（§4.3）、函数（§5）、通道（§8），虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。我们将在第7章介绍接口类型。\n"});index.add({'id':101,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.4.-Booleans/','title':"3.4. 布尔型",'section':"3. 基础数据类型",'content':"3.4. 布尔型 #  一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和\u0026lt;等比较操作也会产生布尔型的值。一元操作符!对应逻辑非操作，因此!true的值为false，更罗嗦的说法是(!true==false)==true，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用x来表示x==true。\n布尔值可以和\u0026amp;\u0026amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：\ns != \u0026#34;\u0026#34; \u0026amp;\u0026amp; s[0] == \u0026#39;x\u0026#39; 其中s[0]操作如果应用于空字符串将会导致panic异常。\n因为\u0026amp;\u0026amp;的优先级比||高（助记：\u0026amp;\u0026amp;对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：\nif \u0026#39;a\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39; || \u0026#39;A\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39; || \u0026#39;0\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39; { // ...ASCII letter or digit... } 布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换：\ni := 0 if b { i = 1 } 如果需要经常做类似的转换，包装成一个函数会更方便：\n// btoi returns 1 if b is true and 0 if false. func btoi(b bool) int { if b { return 1 } return 0 } 数字到布尔型的逆转换则非常简单，不过为了保持对称，我们也可以包装一个函数：\n// itob reports whether i is non-zero. func itob(i int) bool { return i != 0 } "});index.add({'id':102,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.4.-Strings-and-Byte-Slices/','title':"3.5.4. 字符串和Byte切片",'section':"3.5. 字符串",'content':"3.5.4. 字符串和Byte切片 #  标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。\nbytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。\nstrconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。\nunicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。\n下面例子的basename函数灵感源于Unix shell的同名工具。在我们实现的版本中，basename(s)将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除：\nfmt.Println(basename(\u0026#34;a/b/c.go\u0026#34;)) // \u0026#34;c\u0026#34; fmt.Println(basename(\u0026#34;c.d.go\u0026#34;)) // \u0026#34;c.d\u0026#34; fmt.Println(basename(\u0026#34;abc\u0026#34;)) // \u0026#34;abc\u0026#34; 第一个版本并没有使用任何库，全部手工硬编码实现：\ngopl.io/ch3/basename1\n// basename removes directory components and a .suffix. // e.g., a =\u0026gt; a, a.go =\u0026gt; a, a/b/c.go =\u0026gt; c, a/b.c.go =\u0026gt; b.c func basename(s string) string { // Discard last \u0026#39;/\u0026#39; and everything before. \tfor i := len(s) - 1; i \u0026gt;= 0; i-- { if s[i] == \u0026#39;/\u0026#39; { s = s[i+1:] break } } // Preserve everything before last \u0026#39;.\u0026#39;. \tfor i := len(s) - 1; i \u0026gt;= 0; i-- { if s[i] == \u0026#39;.\u0026#39; { s = s[:i] break } } return s } 这个简化版本使用了strings.LastIndex库函数：\ngopl.io/ch3/basename2\nfunc basename(s string) string { slash := strings.LastIndex(s, \u0026#34;/\u0026#34;) // -1 if \u0026#34;/\u0026#34; not found \ts = s[slash+1:] if dot := strings.LastIndex(s, \u0026#34;.\u0026#34;); dot \u0026gt;= 0 { s = s[:dot] } return s } path和path/filepath包提供了关于文件路径名更一般的函数操作。使用斜杠分隔路径可以在任何操作系统上工作。斜杠本身不应该用于文件名，但是在其他一些领域可能会用于文件名，例如URL路径组件。相比之下，path/filepath包则使用操作系统本身的路径规则，例如POSIX系统使用/foo/bar，而Microsoft Windows使用c:\\foo\\bar等。\n让我们继续另一个字符串的例子。函数的功能是将一个表示整数值的字符串，每隔三个字符插入一个逗号分隔符，例如“12345”处理后成为“12,345”。这个版本只适用于整数类型；支持浮点数类型的留作练习。\ngopl.io/ch3/comma\n// comma inserts commas in a non-negative decimal integer string. func comma(s string) string { n := len(s) if n \u0026lt;= 3 { return s } return comma(s[:n-3]) + \u0026#34;,\u0026#34; + s[n-3:] } 输入comma函数的参数是一个字符串。如果输入字符串的长度小于或等于3的话，则不需要插入逗号分隔符。否则，comma函数将在最后三个字符前的位置将字符串切割为两个子串并插入逗号分隔符，然后通过递归调用自身来得出前面的子串。\n一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。\n字符串和字节slice之间可以相互转换：\ns := \u0026#34;abc\u0026#34; b := []byte(s) s2 := string(b) 从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。\n为了避免转换中不必要的内存分配，bytes包和strings同时提供了许多实用函数。下面是strings包中的六个函数：\nfunc Contains(s, substr string) bool func Count(s, sep string) int func Fields(s string) []string func HasPrefix(s, prefix string) bool func Index(s, sep string) int func Join(a []string, sep string) string bytes包中也对应的六个函数：\nfunc Contains(b, subslice []byte) bool func Count(s, sep []byte) int func Fields(s []byte) [][]byte func HasPrefix(s, prefix []byte) bool func Index(s, sep []byte) int func Join(s [][]byte, sep []byte) []byte 它们之间唯一的区别是字符串类型参数被替换成了字节slice类型的参数。\nbytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：\ngopl.io/ch3/printints\n// intsToString is like fmt.Sprint(values) but adds commas. func intsToString(values []int) string { var buf bytes.Buffer buf.WriteByte(\u0026#39;[\u0026#39;) for i, v := range values { if i \u0026gt; 0 { buf.WriteString(\u0026#34;, \u0026#34;) } fmt.Fprintf(\u0026amp;buf, \u0026#34;%d\u0026#34;, v) } buf.WriteByte(\u0026#39;]\u0026#39;) return buf.String() } func main() { fmt.Println(intsToString([]int{1, 2, 3})) // \u0026#34;[1, 2, 3]\u0026#34; } 当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似\u0026rsquo;[\u0026lsquo;和\u0026rsquo;]\u0026lsquo;等ASCII字符则会更加有效。\nbytes.Buffer类型有着很多实用的功能，我们在第七章讨论接口时将会涉及到，我们将看看如何将它用作一个I/O的输入和输出对象，例如当做Fprintf的io.Writer输出对象，或者当作io.Reader类型的输入源对象。\n练习 3.10： 编写一个非递归版本的comma函数，使用bytes.Buffer代替字符串链接操作。\n练习 3.11： 完善comma函数，以支持浮点数处理和一个可选的正负号的处理。\n练习 3.12： 编写一个函数，判断两个字符串是否是相互打乱的，也就是说它们有着相同的字符，但是对应不同的顺序。\n"});index.add({'id':103,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.4.-Structs/','title':"4.4. 结构体",'section':"4. 复合数据类型",'content':"4.4. 结构体 #  结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。用结构体的经典案例是处理公司的员工信息，每个员工信息包含一个唯一的员工编号、员工的名字、家庭住址、出生日期、工作岗位、薪资、上级领导等等。所有的这些信息都需要绑定到一个实体中，可以作为一个整体单元被复制，作为函数的参数或返回值，或者是被存储到数组中，等等。\n下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert：\ntype Employee struct { ID int Name string Address string DoB time.Time Position string Salary int ManagerID int } var dilbert Employee dilbert结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值：\ndilbert.Salary -= 5000 // demoted, for writing too few lines of code 或者是对成员取地址，然后通过指针访问：\nposition := \u0026amp;dilbert.Position *position = \u0026#34;Senior \u0026#34; + *position // promoted, for outsourcing to Elbonia 点操作符也可以和指向结构体的指针一起工作：\nvar employeeOfTheMonth *Employee = \u0026amp;dilbert employeeOfTheMonth.Position += \u0026#34; (proactive team player)\u0026#34; 相当于下面语句\n(*employeeOfTheMonth).Position += \u0026#34; (proactive team player)\u0026#34; 下面的EmployeeByID函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：\nfunc EmployeeByID(id int) *Employee { /* ... */ } fmt.Println(EmployeeByID(dilbert.ManagerID).Position) // \u0026#34;Pointy-haired boss\u0026#34;  id := dilbert.ID EmployeeByID(id).Salary = 0 // fired for... no real reason 后面的语句通过EmployeeByID返回的结构体指针更新了Employee结构体的成员。如果将EmployeeByID函数的返回值从*Employee指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。\n通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样：\ntype Employee struct { ID int Name, Address string DoB time.Time Position string Salary int ManagerID int } 结构体成员的输入顺序也有重要的意义。我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。通常，我们只是将相关的成员写到一起。\n如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。\n结构体类型往往是冗长的，因为它的每个成员可能都会占一行。虽然我们每次都可以重写整个结构体成员，但是重复会令人厌烦。因此，完整的结构体写法通常只在类型声明语句的地方出现，就像Employee类型声明语句那样。\n一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。在下面的代码中，我们使用一个二叉树来实现一个插入排序：\ngopl.io/ch4/treesort\ntype tree struct { value int left, right *tree } // Sort sorts values in place. func Sort(values []int) { var root *tree for _, v := range values { root = add(root, v) } appendValues(values[:0], root) } // appendValues appends the elements of t to values in order // and returns the resulting slice. func appendValues(values []int, t *tree) []int { if t != nil { values = appendValues(values, t.left) values = append(values, t.value) values = appendValues(values, t.right) } return values } func add(t *tree, value int) *tree { if t == nil { // Equivalent to return \u0026amp;tree{value: value}. \tt = new(tree) t.value = value return t } if value \u0026lt; t.value { t.left = add(t.left, value) } else { t.right = add(t.right, value) } return t } 结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。例如，对于bytes.Buffer类型，结构体初始值就是一个随时可用的空缓存，还有在第9章将会讲到的sync.Mutex的零值也是有效的未锁定状态。有时候这种零值可用的特性是自然获得的，但是也有些类型需要一些额外的工作。\n如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。\nseen := make(map[string]struct{}) // set of strings // ... if _, ok := seen[s]; !ok { seen[s] = struct{}{} // ...first time seeing s... } "});index.add({'id':104,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.4.-Errors/','title':"5.4. 错误",'section':"5. 函数",'content':"5.4. 错误 #  在Go中有一部分函数总是能成功的运行。比如strings.Contains和strconv.FormatBool函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低。\n还有一部分函数只要输入的参数满足一定条件，也能保证运行成功。比如time.Date函数，该函数将年月日等参数构造成time.Time对象，除非最后一个参数（时区）是nil。这种情况下会引发panic异常。panic是来自被调用函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生panic异常。\n对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。\n在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。\n对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。比如，cache.Lookup失败的唯一原因是key不存在，那么代码可以按照下面的方式组织：\nvalue, ok := cache.Lookup(key) if !ok { // ...cache[key] does not exist… } 通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。\n内置的error是接口类型。我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。\nfmt.Println(err) fmt.Printf(\u0026#34;%v\u0026#34;, err) 通常，当函数返回non-nil的error时，其他的返回值是未定义的（undefined），这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。\n在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。对于Go的异常机制我们将在5.9介绍。\nGo这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。\n正因此，Go使用控制流机制（如if和return）处理错误，这使得编码人员能更多的关注错误处理。\n"});index.add({'id':105,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.4.-Method-Values-and-Expressions/','title':"6.4. 方法值和方法表达式",'section':"6. 方法",'content':"6.4. 方法值和方法表达式 #  我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法“值”-\u0026gt;一个将方法（Point.Distance）绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器（译注：因为已经在前文中指定过了），只要传入函数的参数即可：\np := Point{1, 2} q := Point{4, 6} distanceFromP := p.Distance // method value fmt.Println(distanceFromP(q)) // \u0026#34;5\u0026#34; var origin Point // {0, 0} fmt.Println(distanceFromP(origin)) // \u0026#34;2.23606797749979\u0026#34;, sqrt(5)  scaleP := p.ScaleBy // method value scaleP(2) // p becomes (2, 4) scaleP(3) // then (6, 12) scaleP(10) // then (60, 120) 在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法“值”会非常实用（``=_=`真是绕）。举例来说，下面例子中的time.AfterFunc这个函数的功能是在指定的延迟时间之后来执行一个（译注：另外的）函数。且这个函数操作的是一个Rocket对象r\ntype Rocket struct { /* ... */ } func (r *Rocket) Launch() { /* ... */ } r := new(Rocket) time.AfterFunc(10 * time.Second, func() { r.Launch() }) 直接用方法“值”传入AfterFunc的话可以更为简短：\ntime.AfterFunc(10 * time.Second, r.Launch) 译注：省掉了上面那个例子里的匿名函数。\n和方法“值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（p.Distance）语法来指定方法的接收器。\n当T是一个类型时，方法表达式可能会写作T.f或者(*T).f，会返回一个函数“值”，这种函数会将其第一个参数用作接收器，所以可以用通常（译注：不写选择器）的方式来对其进行调用：\np := Point{1, 2} q := Point{4, 6} distance := Point.Distance // method expression fmt.Println(distance(p, q)) // \u0026#34;5\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, distance) // \u0026#34;func(Point, Point) float64\u0026#34;  scale := (*Point).ScaleBy scale(\u0026amp;p, 2) fmt.Println(p) // \u0026#34;{2 4}\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, scale) // \u0026#34;func(*Point, float64)\u0026#34;  // 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()， // 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数， // 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。 // 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。 当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量op代表Point类型的addition或者subtraction方法，Path.TranslateBy方法会为其Path数组中的每一个Point来调用对应的方法：\ntype Point struct{ X, Y float64 } func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} } func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} } type Path []Point func (path Path) TranslateBy(offset Point, add bool) { var op func(p, q Point) Point if add { op = Point.Add } else { op = Point.Sub } for i := range path { // Call either path[i].Add(offset) or path[i].Sub(offset). \tpath[i] = op(path[i], offset) } } "});index.add({'id':106,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.4.-Parsing-Flags-with-flag.Value/','title':"7.4. flag.Value接口",'section':"7. 接口",'content':"7.4. flag.Value接口 #  在本章，我们会学到另一个标准的接口类型flag.Value是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特定时间的程序：\ngopl.io/ch7/sleep\nvar period = flag.Duration(\u0026#34;period\u0026#34;, 1*time.Second, \u0026#34;sleep period\u0026#34;) func main() { flag.Parse() fmt.Printf(\u0026#34;Sleeping for %v...\u0026#34;, *period) time.Sleep(*period) fmt.Println() } 在它休眠前它会打印出休眠的时间周期。fmt包调用time.Duration的String方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字：\n$ go build gopl.io/ch7/sleep $ ./sleep Sleeping for 1s... 默认情况下，休眠周期是一秒，但是可以通过 -period 这个命令行标记来控制。flag.Duration函数创建一个time.Duration类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和String方法相同的符号排版形式。这种对称设计使得用户交互良好。\n$ ./sleep -period 50ms Sleeping for 50ms... $ ./sleep -period 2m30s Sleeping for 2m30s... $ ./sleep -period 1.5h Sleeping for 1h30m0s... $ ./sleep -period \u0026quot;1 day\u0026quot; invalid value \u0026quot;1 day\u0026quot; for flag -period: time: invalid duration 1 day 因为时间周期标记值非常的有用，所以这个特性被构建到了flag包中；但是我们为我们自己的数据类型定义新的标记符号是简单容易的。我们只需要定义一个实现flag.Value接口的类型，如下：\npackage flag // Value is the interface to the value stored in a flag. type Value interface { String() string Set(string) error } String方法格式化标记的值用在命令行帮助消息中；这样每一个flag.Value也是一个fmt.Stringer。Set方法解析它的字符串参数并且更新标记变量的值。实际上，Set方法和String是两个相反的操作，所以最好的办法就是对他们使用相同的注解方式。\n让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。注意celsiusFlag内嵌了一个Celsius类型（§2.5），因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法：\ngopl.io/ch7/tempconv\n// *celsiusFlag satisfies the flag.Value interface. type celsiusFlag struct{ Celsius } func (f *celsiusFlag) Set(s string) error { var unit string var value float64 fmt.Sscanf(s, \u0026#34;%f%s\u0026#34;, \u0026amp;value, \u0026amp;unit) // no error check needed \tswitch unit { case \u0026#34;C\u0026#34;, \u0026#34;°C\u0026#34;: f.Celsius = Celsius(value) return nil case \u0026#34;F\u0026#34;, \u0026#34;°F\u0026#34;: f.Celsius = FToC(Fahrenheit(value)) return nil } return fmt.Errorf(\u0026#34;invalid temperature %q\u0026#34;, s) } 调用fmt.Sscanf函数从输入s中解析一个浮点数（value）和一个字符串（unit）。虽然通常必须检查Sscanf的错误返回，但是在这个例子中我们不需要因为如果有错误发生，就没有switch case会匹配到。\n下面的CelsiusFlag函数将所有逻辑都封装在一起。它返回一个内嵌在celsiusFlag变量f中的Celsius指针给调用者。Celsius字段是一个会通过Set方法在标记处理的过程中更新的变量。调用Var方法将标记加入应用的命令行标记集合中，有异常复杂命令行接口的全局变量flag.CommandLine.Programs可能有几个这个类型的变量。调用Var方法将一个*celsiusFlag参数赋值给一个flag.Value参数，导致编译器去检查*celsiusFlag是否有必须的方法。\n// CelsiusFlag defines a Celsius flag with the specified name, // default value, and usage, and returns the address of the flag variable. // The flag argument must have a quantity and a unit, e.g., \u0026#34;100C\u0026#34;. func CelsiusFlag(name string, value Celsius, usage string) *Celsius { f := celsiusFlag{value} flag.CommandLine.Var(\u0026amp;f, name, usage) return \u0026amp;f.Celsius } 现在我们可以开始在我们的程序中使用新的标记：\ngopl.io/ch7/tempflag\nvar temp = tempconv.CelsiusFlag(\u0026#34;temp\u0026#34;, 20.0, \u0026#34;the temperature\u0026#34;) func main() { flag.Parse() fmt.Println(*temp) } 下面是典型的场景：\n$ go build gopl.io/ch7/tempflag $ ./tempflag 20°C $ ./tempflag -temp -18C -18°C $ ./tempflag -temp 212°F 100°C $ ./tempflag -temp 273.15K invalid value \u0026quot;273.15K\u0026quot; for flag -temp: invalid temperature \u0026quot;273.15K\u0026quot; Usage of ./tempflag: -temp value the temperature (default 20°C) $ ./tempflag -help Usage of ./tempflag: -temp value the temperature (default 20°C) 练习 7.6： 对tempFlag加入支持开尔文温度。\n练习 7.7： 解释为什么帮助信息在它的默认值是20.0没有包含°C的情况下输出了°C。\n"});index.add({'id':107,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/','title':"8.4. Channels",'section':"8. Goroutines和Channels",'content':"8.4. Channels #  如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。\n使用内置的make函数，我们可以创建一个channel：\nch := make(chan int) // ch has type \u0026#39;chan int\u0026#39; 和map类似，channel也对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。\n两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。\n一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用\u0026lt;-运算符。在发送语句中，\u0026lt;-运算符分割channel和要发送的值。在接收语句中，\u0026lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。\nch \u0026lt;- x // a send statement x = \u0026lt;-ch // a receive expression in an assignment statement \u0026lt;-ch // a receive statement; result is discarded Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。\n使用内置的close函数就可以关闭一个channel：\nclose(ch) 以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。\nch = make(chan int) // unbuffered channel ch = make(chan int, 0) // unbuffered channel ch = make(chan int, 3) // buffered channel with capacity 3 我们将先讨论无缓存的channel，然后在8.4.4节讨论带缓存的channel。\n"});index.add({'id':108,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.4.-Channels/8.4.4.-Buffered-Channels/','title':"8.4.4. 带缓存的Channels",'section':"8.4. Channels",'content':"8.4.4. 带缓存的Channels #  带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。图8.2是ch变量对应的channel的图形表示形式。\nch = make(chan string, 3)  向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。\n我们可以在无阻塞的情况下连续向新创建的channel发送三个值：\nch \u0026lt;- \u0026#34;A\u0026#34; ch \u0026lt;- \u0026#34;B\u0026#34; ch \u0026lt;- \u0026#34;C\u0026#34; 此刻，channel的内部缓存队列将是满的（图8.3），如果有第四个发送操作将发生阻塞。\n 如果我们接收一个值，\nfmt.Println(\u0026lt;-ch) // \u0026#34;A\u0026#34; 那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发生阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。\n 在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：\nfmt.Println(cap(ch)) // \u0026#34;3\u0026#34; 同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。\nfmt.Println(len(ch)) // \u0026#34;2\u0026#34; 在继续执行两次接收操作后channel内部的缓存队列将又成为空的，如果有第四个接收操作将发生阻塞：\nfmt.Println(\u0026lt;-ch) // \u0026#34;B\u0026#34; fmt.Println(\u0026lt;-ch) // \u0026#34;C\u0026#34; 在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在真实的程序中它们一般由不同的goroutine执行。Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了。\n下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。（顺便说一下，多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。）\nfunc mirroredQuery() string { responses := make(chan string, 3) go func() { responses \u0026lt;- request(\u0026#34;asia.gopl.io\u0026#34;) }() go func() { responses \u0026lt;- request(\u0026#34;europe.gopl.io\u0026#34;) }() go func() { responses \u0026lt;- request(\u0026#34;americas.gopl.io\u0026#34;) }() return \u0026lt;-responses // return the quickest response } func request(hostname string) (response string) { /* ... */ } 如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。\n关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。\nChannel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。\n如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。\n另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。\n生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。\n我们没有太多的空间展示全部细节，但是gopl.io/ch8/cake包模拟了这个蛋糕店，可以通过不同的参数调整。它还对上面提到的几种场景提供对应的基准测试（§11.4） 。\n"});index.add({'id':109,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.4.-Memory-Synchronization/','title':"9.4. 内存同步",'section':"9. 基于共享变量的并发",'content':"9.4. 内存同步 #  你可能比较纠结为什么Balance方法需要用到互斥条件，无论是基于channel还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它goroutine在其执行“期间”执行其它逻辑的风险。这里使用mutex有两方面考虑。第一Balance不会在其它操作比如Withdraw“中间”执行。第二（更重要的）是“同步”不仅仅是一堆goroutine执行顺序的问题，同样也会涉及到内存的问题。\n在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存（local cache）。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。\n考虑一下下面代码片段的可能输出：\nvar x, y int go func() { x = 1 // A1 \tfmt.Print(\u0026#34;y:\u0026#34;, y, \u0026#34; \u0026#34;) // A2 }() go func() { y = 1 // B1 \tfmt.Print(\u0026#34;x:\u0026#34;, x, \u0026#34; \u0026#34;) // B2 }() 因为两个goroutine是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：\ny:0 x:1 x:0 y:1 x:1 y:1 y:1 x:1 第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。然而实际运行时还是有些情况让我们有点惊讶：\nx:0 y:0 y:0 x:0 根据所使用的编译器，CPU，或者其它很多影响因子，这两种情况也是有可能发生的。那么这两种情况要怎么解释呢？\n在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。\n尽管去理解并发的一种尝试是去将其运行理解为不同goroutine语句的交错执行，但看看上面的例子，这已经不是现代的编译器和cpu的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。\n所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。\n"});index.add({'id':110,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/9.8.4.-Goroutines-Have-No-Identity/','title':"9.8.4. Goroutine没有ID号",'section':"9.8. Goroutines和线程",'content':"9.8.4. Goroutine没有ID号 #  在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份（id），并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个integer或者指针值。这种情况下我们做一个抽象化的thread-local storage（线程本地存储，多线程编程中不希望其它线程访问的内容）就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。\ngoroutine没有可以被程序员获取到的身份（id）的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层（这个存储层有可能是tls）查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变——比如一些worker线程之类的——那么函数的行为就会变得神秘莫测。\nGo鼓励更为简单的模式，这种模式下参数（译注：外部显式参数和内部显式参数。tls 中的内容算是\u0026quot;外部\u0026quot;隐式参数）对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。\n你现在应该已经明白了写一个Go程序所需要的所有语言特性信息。在后面两章节中，我们会回顾一些之前的实例和工具，支持我们写出更大规模的程序：如何将一个工程组织成一系列的包，如何获取，构建，测试，性能测试，剖析，写文档，并且将这些包分享出去。\n"});index.add({'id':111,'href':'/docs/The-Go-Programming-Language/Preface/Where-to-Find-More-Information/','title':"更多的信息",'section':"前言",'content':"更多的信息 #  最佳的帮助信息来自Go语言的官方网站，https://golang.org ，它提供了完善的参考文档，包括编程语言规范和标准库等诸多权威的帮助信息。同时也包含了如何编写更地道的Go程序的基本教程，还有各种各样的在线文本资源和视频资源，它们是本书最有价值的补充。Go语言的官方博客 https://blog.golang.org 会不定期发布一些Go语言最好的实践文章，包括当前语言的发展状态、未来的计划、会议报告和Go语言相关的各种会议的主题等信息（译注： http://talks.golang.org/ 包含了官方收录的各种报告的讲稿）。\n在线访问的一个有价值的地方是可以从web页面运行Go语言的程序（而纸质书则没有这么便利了）。这个功能由来自 https://play.golang.org 的 Go Playground 提供，并且可以方便地嵌入到其他页面中，例如 https://golang.org 的主页，或 godoc 提供的文档页面中。\nPlayground可以简单的通过执行一个小程序来测试对语法、语义和对程序库的理解，类似其他很多语言提供的REPL即时运行的工具。同时它可以生成对应的url，非常适合共享Go语言代码片段，汇报bug或提供反馈意见等。\n基于 Playground 构建的 Go Tour，https://tour.golang.org ，是一个系列的Go语言入门教程，它包含了诸多基本概念和结构相关的并可在线运行的互动小程序。\n当然，Playground 和 Tour 也有一些限制，它们只能导入标准库，而且因为安全的原因对一些网络库做了限制。如果要在编译和运行时需要访问互联网，对于一些更复杂的实验，你可能需要在自己的电脑上构建并运行程序。幸运的是下载Go语言的过程很简单，从 https://golang.org 下载安装包应该不超过几分钟（译注：感谢伟大的长城，让大陆的Gopher们都学会了自己打洞的基本生活技能，下载时间可能会因为洞的大小等因素从几分钟到几天或更久），然后就可以在自己电脑上编写和运行Go程序了。\nGo语言是一个开源项目，你可以在 https://golang.org/pkg 阅读标准库中任意函数和类型的实现代码，和下载安装包的代码完全一致。这样，你可以知道很多函数是如何工作的， 通过挖掘找出一些答案的细节，或者仅仅是出于欣赏专业级Go代码。\n"});index.add({'id':112,'href':'/docs/Clean-Code/1.-Clean-Code/1.5.-We-Are-Authors/','title':"1.5. 我们是作者",'section':"1. 整洁代码",'content':"1.5 我们是作者 #  The @author field of a Javadoc tells us who we are. We are authors. And one thing about authors is that they have readers. Indeed, authors are responsible for communicating well with their readers. The next time you write a line of code, remember you are an author, writing for readers who will judge your effort.\n Javadoc 中的@author 字段告诉我们自己是什么人。我们是作者。作者都有读者。实际上，作者有责任与读者做良好沟通。下次你写代码的时候，记得自己是作者，要为评判你工作的读者写代码。\n You might ask: How much is code really read? Doesn’t most of the effort go into writing it?\n 你或许会问：代码真正“读”的成分有多少呢？难道力量主要不是用在“写”上吗？\n Have you ever played back an edit session? In the 80s and 90s we had editors like Emacs that kept track of every keystroke. You could work for an hour and then play back your whole edit session like a high-speed movie. When I did this, the results were fascinating.\n 你是否玩过“编辑器回放”？20 世纪 80、90 年代，Emac 之类编辑器记录每次击键动作。你可以在一小时工作之后，回放击键过程，就像是看一部高速电影。我这么做过，结果很有趣。\n  The vast majority of the playback was scrolling and navigating to other modules! Bob enters the module. He scrolls down to the function needing change. He pauses, considering his options. Oh, he’s scrolling up to the top of the module to check the initialization of a variable. Now he scrolls back down and begins to type. Ooops, he’s erasing what he typed! He types it again. He erases it again! He types half of something else but then erases that! He scrolls down to another function that calls the function he’s changing to see how it is called. He scrolls back up and types the same code he just erased. He pauses. He erases that code again! He pops up another window and looks at a subclass. Is that function overridden? …     回放过程显示，多数时间都是在滚动屏幕、浏览其他模块！ 鲍勃进入模块。 他向下滚动到要修改的函数。 他停下来考虑可以做什么。 哦，他滚动到模块顶端，检查变量初始化。 现在他回到修改处，开始键入。 喔，他删掉了键入的内容。 他重新键入。 他又删除了！ 他键入了一半什么东西，又删除掉。 他滚动到调用要修改函数的另一函数，看看是怎么调用的。 他回到修改处，重新键入刚才删掉的代码。 他停下来。 他再一次删掉代码！ 他打开另一个窗口，查看别的子类。那是个复载函数吗？ ……   You get the drift. Indeed, the ratio of time spent reading vs. writing is well over 10:1. We are constantly reading old code as part of the effort to write new code.\n 你该明白了。读与写花费时间的比例超过 10:1。写新代码时，我们一直在读旧代码。\n Because this ratio is so high, we want the reading of code to be easy, even if it makes the writing harder. Of course there’s no way to write code without reading it, so making it easy to read actually makes it easier to write.\n 既然比例如此之高，我们就想让读的过程变得轻松，即便那会使得编写过程更难。没可能光写不读，所以使之易读实际也使之易写。\n There is no escape from this logic. You cannot write code if you cannot read the surrounding code. The code you are trying to write today will be hard or easy to write depending on how hard or easy the surrounding code is to read. So if you want to go fast, if you want to get done quickly, if you want your code to be easy to write, make it easy to read.\n 这事概无例外。不读周边代码的话就没法写代码。编写代码的难度，取决于读周边代码的难度。要想干得快，要想早点做完，要想轻松写代码，先让代码易读吧。\n "});index.add({'id':113,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.5.-Fetching-a-URL/','title':"1.5. 获取URL",'section':"1. 入门",'content':"1.5. 获取URL #  对于很多现代应用来说，访问互联网上的信息和访问本地文件系统一样重要。Go语言在net这个强大package的帮助下提供了一系列的package来做这件事情，使用这些包可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。在这些情景下，Go语言原生的并发特性（在第八章中会介绍）显得尤其好用。\n为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具（译注：unix下的一个用来发http请求的工具，具体可以man curl）。当然，curl提供的功能更为复杂丰富，这里只编写最简单的样例。这个样例之后还会多次被用到。\ngopl.io/ch1/fetch\n// Fetch prints the content found at a URL. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { for _, url := range os.Args[1:] { resp, err := http.Get(url) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;fetch: %v\\n\u0026#34;, err) os.Exit(1) } b, err := ioutil.ReadAll(resp.Body) resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;fetch: reading %s: %v\\n\u0026#34;, url, err) os.Exit(1) } fmt.Printf(\u0026#34;%s\u0026#34;, b) } } 这个程序从两个package中导入了函数，net/http和io/ioutil包，http.Get函数是创建HTTP请求的函数，如果获取过程没有出错，那么会在resp这个结构体中得到访问的请求结果。resp的Body字段包括一个可读的服务器响应流。ioutil.ReadAll函数从response中读取到全部内容；将其结果保存在变量b中。resp.Body.Close关闭resp的Body流，防止资源泄露，Printf函数会将结果b写出到标准输出流中。\n$ go build gopl.io/ch1/fetch $ ./fetch http://gopl.io \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;The Go Programming Language\u0026lt;/title\u0026gt;title\u0026gt; ... HTTP请求如果失败了的话，会得到下面这样的结果：\n$ ./fetch http://bad.gopl.io fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host 译注：在大天朝的网络环境下很容易重现这种错误，下面是Windows下运行得到的错误信息：\n$ go run main.go http://gopl.io fetch: Get http://gopl.io: dial tcp: lookup gopl.io: getaddrinfow: No such host is known. 无论哪种失败原因，我们的程序都用了os.Exit函数来终止进程，并且返回一个status错误码，其值为1。\n练习 1.7： 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。\n练习 1.8： 修改fetch这个范例，如果输入的url参数没有 http:// 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。\n练习 1.9： 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。\n"});index.add({'id':114,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.5.-Blank-Imports/','title':"10.5. 包的匿名导入",'section':"10. 包和工具",'content':"10.5. 包的匿名导入 #  如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线_来重命名导入的包。像往常一样，下划线_为空白标识符，并不能被访问。\nimport _ \u0026#34;image/png\u0026#34; // register PNG decoder 这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。首先，让我们看看如何使用该特性，然后再看看它是如何工作的。\n标准库的image图像包包含了一个Decode函数，用于从io.Reader接口读取数据并解码图像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使用image.Decode很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另一种图像格式：\ngopl.io/ch10/jpeg\n// The jpeg command reads a PNG image from the standard input // and writes it as a JPEG image to the standard output. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;image\u0026#34; \u0026#34;image/jpeg\u0026#34; _ \u0026#34;image/png\u0026#34; // register PNG decoder \t\u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { if err := toJPEG(os.Stdin, os.Stdout); err != nil { fmt.Fprintf(os.Stderr, \u0026#34;jpeg: %v\\n\u0026#34;, err) os.Exit(1) } } func toJPEG(in io.Reader, out io.Writer) error { img, kind, err := image.Decode(in) if err != nil { return err } fmt.Fprintln(os.Stderr, \u0026#34;Input format =\u0026#34;, kind) return jpeg.Encode(out, img, \u0026amp;jpeg.Options{Quality: 95}) } 如果我们将gopl.io/ch3/mandelbrot（§3.3）的输出导入到这个程序的标准输入，它将解码输入的PNG格式图像，然后转换为JPEG格式的图像输出（图3.3）。\n$ go build gopl.io/ch3/mandelbrot $ go build gopl.io/ch10/jpeg $ ./mandelbrot | ./jpeg \u0026gt;mandelbrot.jpg Input format = png 要注意image/png包的匿名导入语句。如果没有这一行语句，程序依然可以编译和运行，但是它将不能正确识别和解码PNG格式的图像：\n$ go build gopl.io/ch10/jpeg $ ./mandelbrot | ./jpeg \u0026gt;mandelbrot.jpg jpeg: image: unknown format 下面的代码演示了它的工作机制。标准库还提供了GIF、PNG和JPEG等格式图像的解码器，用户也可以提供自己的解码器，但是为了保持程序体积较小，很多解码器并没有被全部包含，除非是明确需要支持的格式。image.Decode函数在解码时会依次查询支持的格式列表。每个格式驱动列表的每个入口指定了四件事情：格式的名称；一个用于描述这种图像数据开头部分模式的字符串，用于解码器检测识别；一个Decode函数用于完成解码图像工作；一个DecodeConfig函数用于解码图像的大小和颜色空间的信息。每个驱动入口是通过调用image.RegisterFormat函数注册，一般是在每个格式包的init初始化函数中调用，例如image/png包是这样注册的：\npackage png // image/png  func Decode(r io.Reader) (image.Image, error) func DecodeConfig(r io.Reader) (image.Config, error) func init() { const pngHeader = \u0026#34;\\x89PNG\\r\\n\\x1a\\n\u0026#34; image.RegisterFormat(\u0026#34;png\u0026#34;, pngHeader, Decode, DecodeConfig) } 最终的效果是，主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式的图像了。\n数据库包database/sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。例如：\nimport ( \u0026#34;database/sql\u0026#34; _ \u0026#34;github.com/lib/pq\u0026#34; // enable support for Postgres \t_ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; // enable support for MySQL ) db, err = sql.Open(\u0026#34;postgres\u0026#34;, dbname) // OK db, err = sql.Open(\u0026#34;mysql\u0026#34;, dbname) // OK db, err = sql.Open(\u0026#34;sqlite3\u0026#34;, dbname) // returns error: unknown driver \u0026#34;sqlite3\u0026#34; 练习 10.1： 扩展jpeg程序，以支持任意图像格式之间的相互转换，使用image.Decode检测支持的格式类型，然后通过flag命令行标志参数选择输出的格式。\n练习 10.2： 设计一个通用的压缩文件读取框架，用来读取ZIP（archive/zip）和POSIX tar（archive/tar）格式压缩的文档。使用类似上面的注册技术来扩展支持不同的压缩格式，然后根据需要通过匿名导入选择导入要支持的压缩格式的驱动包。\n"});index.add({'id':115,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.5.-Internal-Packages/','title':"10.7.5. 内部包",'section':"10.7. 工具",'content':"10.7.5. 内部包 #  在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。\n有时候，一个中间的状态可能也是有用的，标识符对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。\n为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。\nnet/http net/http/internal/chunked net/http/httputil net/url "});index.add({'id':116,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.5.-Writing-Effective-Tests/','title':"11.2.5. 编写有效的测试",'section':"11.2. 测试函数",'content':"11.2.5. 编写有效的测试 #  许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 == 1”或成页的海量跟踪日志。\nGo语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。\n下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;testing\u0026#34; ) // A poor assertion function. func assertEqual(x, y int) { if x != y { panic(fmt.Sprintf(\u0026#34;%d != %d\u0026#34;, x, y)) } } func TestSplit(t *testing.T) { words := strings.Split(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;) assertEqual(len(words), 3) // ... } 从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。\nfunc TestSplit(t *testing.T) { s, sep := \u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34; words := strings.Split(s, sep) if got, want := len(words), 3; got != want { t.Errorf(\u0026#34;Split(%q, %q) returned %d words, want %d\u0026#34;, s, sep, got, want) } // ... } 现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像IsPalindrome的表驱动测试那样来准备更多的s和sep测试用例。\n前面的例子并不需要额外的辅助函数，如果有可以使测试代码更简单的方法我们也乐意接受。（我们将在13.3节看到一个类似reflect.DeepEqual辅助函数。）一个好的测试的关键是首先实现你期望的具体行为，然后才是考虑简化测试代码、避免重复。如果直接从抽象、通用的测试库着手，很难取得良好结果。\n练习11.5: 用表格驱动的技术扩展TestSplit测试，并打印期望的输出结果。\n"});index.add({'id':117,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.5.-Profiling/','title':"11.5. 剖析",'section':"11. 测试",'content':"11.5. 剖析 #  基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每个码农都应该知道Donald Knuth在1974年的“Structured Programming with go to Statements”上所说的格言。虽然经常被解读为不重视性能的意思，但是从原文我们可以看到不同的含义：\n 毫无疑问，对效率的片面追求会导致各种滥用。程序员会浪费大量的时间在非关键程序的速度上，实际上这些尝试提升效率的行为反倒可能产生很大的负面影响，特别是当调试和维护的时候。我们不应该过度纠结于细节的优化，应该说约97%的场景：过早的优化是万恶之源。\n当然我们也不应该放弃对那关键3%的优化。一个好的程序员不会因为这个比例小就裹足不前，他们会明智地观察和识别哪些是关键的代码；但是仅当关键代码已经被确认的前提下才会进行优化。对于很多程序员来说，判断哪部分是关键的性能瓶颈，是很容易犯经验上的错误的，因此一般应该借助测量工具来证明。\n 当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。\nGo语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的go test工具对几种分析方式都提供了支持。\nCPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。\n堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。\n阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。\n只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。\n$ go test -cpuprofile=cpu.out $ go test -blockprofile=block.out $ go test -memprofile=mem.out 对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。\n一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应go tool pprof命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。\n为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然go test通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。\n下面的命令演示了如何收集并展示一个CPU分析文件。我们选择net/http包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run=NONE参数禁止那些简单测试。\n$ go test -run=NONE -bench=ClientServerParallelTLS64 \\ -cpuprofile=cpu.log net/http PASS BenchmarkClientServerParallelTLS64-8 1000 3141325 ns/op 143010 B/op 1747 allocs/op ok net/http 3.395s $ go tool pprof -text -nodecount=10 ./http.test cpu.log 2570ms of 3590ms total (71.59%) Dropped 129 nodes (cum \u0026lt;= 17.95ms) Showing top 10 nodes out of 166 (cum \u0026gt;= 60ms) flat flat% sum% cum cum% 1730ms 48.19% 48.19% 1750ms 48.75% crypto/elliptic.p256ReduceDegree 230ms 6.41% 54.60% 250ms 6.96% crypto/elliptic.p256Diff 120ms 3.34% 57.94% 120ms 3.34% math/big.addMulVVW 110ms 3.06% 61.00% 110ms 3.06% syscall.Syscall 90ms 2.51% 63.51% 1130ms 31.48% crypto/elliptic.p256Square 70ms 1.95% 65.46% 120ms 3.34% runtime.scanobject 60ms 1.67% 67.13% 830ms 23.12% crypto/elliptic.p256Mul 60ms 1.67% 68.80% 190ms 5.29% math/big.nat.montgomery 50ms 1.39% 70.19% 50ms 1.39% crypto/elliptic.p256ReduceCarry 50ms 1.39% 71.59% 60ms 1.67% crypto/elliptic.p256Sum 参数-text用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中-nodecount=10参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。\n这个概要文件告诉我们，HTTPS基准测试中crypto/elliptic.p256ReduceDegree函数占用了将近一半的CPU资源，对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略。\n对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 http://www.graphviz.org 下载。参数-web用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。\n这一节我们只是简单看了下Go语言的数据分析工具。如果想了解更多，可以阅读Go官方博客的“Profiling Go Programs”一文。\n"});index.add({'id':118,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.5.-Setting-Variables-with-reflect.Value/','title':"12.5. 通过reflect.Value修改值",'section':"12. 反射",'content':"12.5. 通过reflect.Value修改值 #  到目前为止，反射还只是程序中变量的另一种读取方式。然而，在本节中我们将重点讨论如何通过反射机制来修改变量。\n回想一下，Go语言中类似x、x.f[1]和*p形式的表达式都可以表示变量，但是其它如x + 1和f(2)则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。\n对于reflect.Values也有类似的区别。有一些reflect.Values是可取地址的；其它一些则不可以。考虑以下的声明语句：\nx := 2 // value type variable? a := reflect.ValueOf(2) // 2 int no b := reflect.ValueOf(x) // 2 int no c := reflect.ValueOf(\u0026amp;x) // \u0026amp;x *int no d := c.Elem() // 2 int yes (x) 其中a对应的变量不可取地址。因为a中的值仅仅是整数2的拷贝副本。b中的值也同样不可取地址。c中的值还是不可取地址，它只是一个指针\u0026amp;x的拷贝。实际上，所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的。但是对于d，它是c的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用reflect.ValueOf(\u0026amp;x).Elem()，来获取任意变量x对应的可取地址的Value。\n我们可以通过调用reflect.Value的CanAddr方法来判断其是否可以被取地址：\nfmt.Println(a.CanAddr()) // \u0026#34;false\u0026#34; fmt.Println(b.CanAddr()) // \u0026#34;false\u0026#34; fmt.Println(c.CanAddr()) // \u0026#34;false\u0026#34; fmt.Println(d.CanAddr()) // \u0026#34;true\u0026#34; 每当我们通过指针间接地获取的reflect.Value都是可取地址的，即使开始的是一个不可取地址的Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice的索引表达式e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。以此类推，reflect.ValueOf(e).Index(i)对应的值也是可取地址的，即使原始的reflect.ValueOf(e)不支持也没有关系。\n要从变量对应的可取地址的reflect.Value来访问变量需要三个步骤。第一步是调用Addr()方法，它返回一个Value，里面保存了指向变量的指针。然后是在Value上调用Interface()方法，也就是返回一个interface{}，里面包含指向变量的指针。最后，如果我们知道变量的类型，我们可以使用类型的断言机制将得到的interface{}类型的接口强制转为普通的类型指针。这样我们就可以通过这个普通指针来更新变量了：\nx := 2 d := reflect.ValueOf(\u0026amp;x).Elem() // d refers to the variable x px := d.Addr().Interface().(*int) // px := \u0026amp;x *px = 3 // x = 3 fmt.Println(x) // \u0026#34;3\u0026#34; 或者，不使用指针，而是通过调用可取地址的reflect.Value的reflect.Value.Set方法来更新对应的值：\nd.Set(reflect.ValueOf(4)) fmt.Println(x) // \u0026#34;4\u0026#34; Set方法将在运行时执行和编译时进行类似的可赋值性约束的检查。以上代码，变量和值都是int类型，但是如果变量是int64类型，那么程序将抛出一个panic异常，所以关键问题是要确保改类型的变量可以接受对应的值：\nd.Set(reflect.ValueOf(int64(5))) // panic: int64 is not assignable to int 同样，对一个不可取地址的reflect.Value调用Set方法也会导致panic异常：\nx := 2 b := reflect.ValueOf(x) b.Set(reflect.ValueOf(3)) // panic: Set using unaddressable value 这里有很多用于基本数据类型的Set方法：SetInt、SetUint、SetString和SetFloat等。\nd := reflect.ValueOf(\u0026amp;x).Elem() d.SetInt(3) fmt.Println(x) // \u0026#34;3\u0026#34; 从某种程度上说，这些Set方法总是尽可能地完成任务。以SetInt为例，只要变量是某种类型的有符号整数就可以工作，即使是一些命名的类型、甚至只要底层数据类型是有符号整数就可以，而且如果对于变量类型值太大的话会被自动截断。但需要谨慎的是：对于一个引用interface{}类型的reflect.Value调用SetInt会导致panic异常，即使那个interface{}变量对于整数类型也不行。\nx := 1 rx := reflect.ValueOf(\u0026amp;x).Elem() rx.SetInt(2) // OK, x = 2 rx.Set(reflect.ValueOf(3)) // OK, x = 3 rx.SetString(\u0026#34;hello\u0026#34;) // panic: string is not assignable to int rx.Set(reflect.ValueOf(\u0026#34;hello\u0026#34;)) // panic: string is not assignable to int  var y interface{} ry := reflect.ValueOf(\u0026amp;y).Elem() ry.SetInt(2) // panic: SetInt called on interface Value ry.Set(reflect.ValueOf(3)) // OK, y = int(3) ry.SetString(\u0026#34;hello\u0026#34;) // panic: SetString called on interface Value ry.Set(reflect.ValueOf(\u0026#34;hello\u0026#34;)) // OK, y = \u0026#34;hello\u0026#34; 当我们用Display显示os.Stdout结构时，我们发现反射可以越过Go语言的导出规则的限制读取结构体中未导出的成员，比如在类Unix系统上os.File结构体中的fd int成员。然而，利用反射机制并不能修改这些未导出的成员：\nstdout := reflect.ValueOf(os.Stdout).Elem() // *os.Stdout, an os.File var fmt.Println(stdout.Type()) // \u0026#34;os.File\u0026#34; fd := stdout.FieldByName(\u0026#34;fd\u0026#34;) fmt.Println(fd.Int()) // \u0026#34;1\u0026#34; fd.SetInt(2) // panic: unexported field 一个可取地址的reflect.Value会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。因此，CanAddr方法并不能正确反映一个变量是否是可以被修改的。另一个相关的方法CanSet是用于检查对应的reflect.Value是否是可取地址并可被修改的：\nfmt.Println(fd.CanAddr(), fd.CanSet()) // \u0026#34;true false\u0026#34; "});index.add({'id':119,'href':'/docs/The-Go-Programming-Language/13.-Low-Level-Programming/13.5.-Another-Word-of-Caution/','title':"13.5. 几点忠告",'section':"13. 底层编程",'content':"13.5. 几点忠告 #  我们在前一章结尾的时候，我们警告要谨慎使用reflect包。那些警告同样适用于本章的unsafe包。\n高级语言使得程序员不用再关心真正运行程序的指令细节，同时也不再需要关注许多如内存布局之类的实现细节。因为高级语言这个绝缘的抽象层，我们可以编写安全健壮的，并且可以运行在不同操作系统上的具有高度可移植性的程序。\n但是unsafe包，它让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，虽然可能是为了获得更好的性能。但是代价就是牺牲了可移植性和程序安全，因此使用unsafe包是一个危险的行为。我们对何时以及如何使用unsafe包的建议和我们在11.5节提到的Knuth对过早优化的建议类似。大多数Go程序员可能永远不会需要直接使用unsafe包。当然，也永远都会有一些需要使用unsafe包实现会更简单的场景。如果确实认为使用unsafe包是最理想的方式，那么应该尽可能将它限制在较小的范围，这样其它代码就可以忽略unsafe的影响。\n现在，赶紧将最后两章抛入脑后吧。编写一些实实在在的应用是真理。请远离reflect和unsafe包，除非你确实需要它们。\n最后，用Go快乐地编程。我们希望你能像我们一样喜欢Go语言。\n"});index.add({'id':120,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.5.-Use-Pronounceable-Names/','title':"2.5. 使用读得出来的名称",'section':"2. 有意义的命名",'content':"2.5 使用读得出来的名称 #  Humans are good at words. A significant part of our brains is dedicated to the concept of words. And words are, by definition, pronounceable. It would be a shame not to take advantage of that huge portion of our brains that has evolved to deal with spoken language. So make your names pronounceable.\n 人类长于记忆和使用单词。大脑的相当一部分就是用来容纳和处理单词的。单词能读得出来。人类进化到大脑中有那么大的一块地方用来处理言语，若不善加利用，实在是种耻辱。\n If you can’t pronounce it, you can’t discuss it without sounding like an idiot. “Well, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?” This matters because programming is a social activity.\n 如果名称读不出来，讨论的时候就会像个傻鸟。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？”这不是小事，因为编程本就是一种社会活动。\n A company I know has genymdhms (generation date, year, month, day, hour, minute, and second) so they walked around saying “gen why emm dee aich emm ess”. I have an annoying habit of pronouncing everything as written, so I started saying “gen-yah-muddahims.” It later was being called this by a host of designers and analysts, and we still sounded silly. But we were in on the joke, so it was fun. Fun or not, we were tolerating poor naming. New developers had to have the variables explained to them, and then they spoke about it in silly made-up words instead of using proper English terms. Compare\n 有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作“gen why emm dee aich emm ess”。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎的。我们知道典故，所以会觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较\n class DtaRcrd102 { private Date genymdhms; private Date modymdhms; private final String pszqint = \u0026#34;102\u0026#34;; /* … */ }; to\n 和\n class Customer { private Date generationTimestamp; private Date modificationTimestamp; private final String recordId = \u0026#34;102\u0026#34;; /* … */ } Intelligent conversation is now possible: “Hey, Mikey, take a look at this record! The generation timestamp is set to tomorrow’s date! How can that be?”\n现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”\n"});index.add({'id':121,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.5.-Type-Declarations/','title':"2.5. 类型",'section':"2. 程序结构",'content':"2.5. 类型 #  变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。\n在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个float64类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。\n一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。\ntype 类型名字 底层类型 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。\n译注：对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。下面是RobPik在 Issue763 的回复：\n A solution that\u0026rsquo;s been kicking around for a while:\nFor Go 2 (can\u0026rsquo;t do it before then): Change the definition to “lower case letters and _ are package-local; all else is exported”. Then with non-cased languages, such as Japanese, we can write 日本语 for an exported name and _日本语 for a local name. This rule has no effect, relative to the Go 1 rule, with cased languages. They behave exactly the same.\n 为了说明类型声明，我们将不同温度单位分别定义为不同的类型：\ngopl.io/ch2/tempconv0\n// Package tempconv performs Celsius and Fahrenheit temperature computations. package tempconv import \u0026#34;fmt\u0026#34; type Celsius float64 // 摄氏温度 type Fahrenheit float64 // 华氏温度  const ( AbsoluteZeroC Celsius = -273.15 // 绝对零度 \tFreezingC Celsius = 0 // 结冰点温度 \tBoilingC Celsius = 100 // 沸水温度 ) func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) } 我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。\n对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0)）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要。\n数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，在下一章我们会看到这样的例子。这类转换可能改变值的表现。例如，将一个浮点数转为整数将丢弃小数部分，将一个字符串转为[]byte类型的slice将拷贝一个字符串数据的副本。在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。\n底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的，正如我们所期望的那样。\nfmt.Printf(\u0026#34;%g\\n\u0026#34;, BoilingC-FreezingC) // \u0026#34;100\u0026#34; °C boilingF := CToF(BoilingC) fmt.Printf(\u0026#34;%g\\n\u0026#34;, boilingF-CToF(FreezingC)) // \u0026#34;180\u0026#34; °F fmt.Printf(\u0026#34;%g\\n\u0026#34;, boilingF-FreezingC) // compile error: type mismatch 比较运算符==和\u0026lt;也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较：\nvar c Celsius var f Fahrenheit fmt.Println(c == 0) // \u0026#34;true\u0026#34; fmt.Println(f \u0026gt;= 0) // \u0026#34;true\u0026#34; fmt.Println(c == f) // compile error: type mismatch fmt.Println(c == Celsius(f)) // \u0026#34;true\u0026#34;! 注意最后那个语句。尽管看起来像函数调用，但是Celsius(f)是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。测试为真的原因是因为c和g都是零值。\n一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型（译注：例如用匿名的结构体定义变量）。虽然对于像float64这种简单的底层类型没有简洁很多，但是如果是复杂的类型将会简洁很多，特别是我们即将讨论的结构体类型。\n命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。我们将在第六章中讨论方法的细节，这里只说些简单用法。\n下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串：\nfunc (c Celsius) String() string { return fmt.Sprintf(\u0026#34;%g°C\u0026#34;, c) } 许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印，我们将在7.1节讲述。\nc := FToC(212.0) fmt.Println(c.String()) // \u0026#34;100°C\u0026#34; fmt.Printf(\u0026#34;%v\\n\u0026#34;, c) // \u0026#34;100°C\u0026#34;; no need to call String explicitly fmt.Printf(\u0026#34;%s\\n\u0026#34;, c) // \u0026#34;100°C\u0026#34; fmt.Println(c) // \u0026#34;100°C\u0026#34; fmt.Printf(\u0026#34;%g\\n\u0026#34;, c) // \u0026#34;100\u0026#34;; does not call String fmt.Println(float64(c)) // \u0026#34;100\u0026#34;; does not call String "});index.add({'id':122,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/','title':"3.5. 字符串",'section':"3. 基础数据类型",'content':"3.5. 字符串 #  一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列，我们稍后会详细讨论这个问题。\n内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i\u0026lt; len(s)条件约束。\ns := \u0026#34;hello, world\u0026#34; fmt.Println(len(s)) // \u0026#34;12\u0026#34; fmt.Println(s[0], s[7]) // \u0026#34;104 119\u0026#34; (\u0026#39;h\u0026#39; and \u0026#39;w\u0026#39;) 如果试图访问超出字符串索引范围的字节将会导致panic异常：\nc := s[len(s)] // panic: index out of range 第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。我们先简单说下字符的工作方式。\n子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。\nfmt.Println(s[0:5]) // \u0026#34;hello\u0026#34; 同样，如果索引超出字符串范围或者j小于i的话将导致panic异常。\n不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。\nfmt.Println(s[:5]) // \u0026#34;hello\u0026#34; fmt.Println(s[7:]) // \u0026#34;world\u0026#34; fmt.Println(s[:]) // \u0026#34;hello, world\u0026#34; 其中+操作符将两个字符串连接构造一个新字符串：\nfmt.Println(\u0026#34;goodbye\u0026#34; + s[5:]) // \u0026#34;goodbye, world\u0026#34; 字符串可以用==和\u0026lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。\n字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。可以像下面这样将一个字符串追加到另一个字符串：\ns := \u0026#34;left foot\u0026#34; t := s s += \u0026#34;, right foot\u0026#34; 这并不会导致原始的字符串值被改变，但是变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。\nfmt.Println(s) // \u0026#34;left foot, right foot\u0026#34; fmt.Println(t) // \u0026#34;left foot\u0026#34; 因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：\ns[0] = \u0026#39;L\u0026#39; // compile error: cannot assign to s[0] 不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。 图3.4演示了一个字符串和两个子串共享相同的底层数据。\n"});index.add({'id':123,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.5.-Strings/3.5.5.-Conversions-between-Strings-and-Numbers/','title':"3.5.5. 字符串和数字的转换",'section':"3.5. 字符串",'content':"3.5.5. 字符串和数字的转换 #  除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。\n将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)：\nx := 123 y := fmt.Sprintf(\u0026#34;%d\u0026#34;, x) fmt.Println(y, strconv.Itoa(x)) // \u0026#34;123 123\u0026#34; FormatInt和FormatUint函数可以用不同的进制来格式化数字：\nfmt.Println(strconv.FormatInt(int64(x), 2)) // \u0026#34;1111011\u0026#34; fmt.Printf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含有附加额外信息的时候：\ns := fmt.Sprintf(\u0026#34;x=%b\u0026#34;, x) // \u0026#34;x=1111011\u0026#34; 如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：\nx, err := strconv.Atoi(\u0026#34;123\u0026#34;) // x is an int y, err := strconv.ParseInt(\u0026#34;123\u0026#34;, 10, 64) // base 10, up to 64 bits ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。\n有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。\n"});index.add({'id':124,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/','title':"4. 复合数据类型",'section':"Go语言圣经",'content':"第四章　复合数据类型 #  在第三章我们讨论了基本数据类型，它们可以用于构建程序中数据的结构，是Go语言世界的原子。在本章，我们将讨论复合数据类型，它是以不同的方式组合基本类型而构造出来的复合数据类型。我们主要讨论四种类型——数组、slice、map和结构体——同时在本章的最后，我们将演示如何使用结构体来解码和编码到对应JSON格式的数据，并且通过结合使用模板来生成HTML页面。\n数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。\n"});index.add({'id':125,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.5.-JSON/','title':"4.5. JSON",'section':"4. 复合数据类型",'content':"4.5. JSON #  JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。\nGo语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持（译注：Protocol Buffers的支持由 github.com/golang/protobuf 包提供），并且这类包都有着相似的API接口。本节，我们将对重要的encoding/json包的用法做个概述。\nJSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它可以用有效可读的方式表示第三章的基础数据类型和本章的数组、slice、结构体和map等聚合数据类型。\n基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是\\Uhhhh转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。\n这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：\nboolean true number -273.15 string \u0026quot;She said \\\u0026quot;Hello, BF\\\u0026quot;\u0026quot; array [\u0026quot;gold\u0026quot;, \u0026quot;silver\u0026quot;, \u0026quot;bronze\u0026quot;] object {\u0026quot;year\u0026quot;: 1980, \u0026quot;event\u0026quot;: \u0026quot;archery\u0026quot;, \u0026quot;medals\u0026quot;: [\u0026quot;gold\u0026quot;, \u0026quot;silver\u0026quot;, \u0026quot;bronze\u0026quot;]} 考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。）\ngopl.io/ch4/movie\ntype Movie struct { Title string Year int `json:\u0026#34;released\u0026#34;` Color bool `json:\u0026#34;color,omitempty\u0026#34;` Actors []string } var movies = []Movie{ {Title: \u0026#34;Casablanca\u0026#34;, Year: 1942, Color: false, Actors: []string{\u0026#34;Humphrey Bogart\u0026#34;, \u0026#34;Ingrid Bergman\u0026#34;}}, {Title: \u0026#34;Cool Hand Luke\u0026#34;, Year: 1967, Color: true, Actors: []string{\u0026#34;Paul Newman\u0026#34;}}, {Title: \u0026#34;Bullitt\u0026#34;, Year: 1968, Color: true, Actors: []string{\u0026#34;Steve McQueen\u0026#34;, \u0026#34;Jacqueline Bisset\u0026#34;}}, // ... } 这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成：\ndata, err := json.Marshal(movies) if err != nil { log.Fatalf(\u0026#34;JSON marshaling failed: %s\u0026#34;, err) } fmt.Printf(\u0026#34;%s\\n\u0026#34;, data) Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示：\n[{\u0026quot;Title\u0026quot;:\u0026quot;Casablanca\u0026quot;,\u0026quot;released\u0026quot;:1942,\u0026quot;Actors\u0026quot;:[\u0026quot;Humphrey Bogart\u0026quot;,\u0026quot;Ingr id Bergman\u0026quot;]},{\u0026quot;Title\u0026quot;:\u0026quot;Cool Hand Luke\u0026quot;,\u0026quot;released\u0026quot;:1967,\u0026quot;color\u0026quot;:true,\u0026quot;Ac tors\u0026quot;:[\u0026quot;Paul Newman\u0026quot;]},{\u0026quot;Title\u0026quot;:\u0026quot;Bullitt\u0026quot;,\u0026quot;released\u0026quot;:1968,\u0026quot;color\u0026quot;:true,\u0026quot; Actors\u0026quot;:[\u0026quot;Steve McQueen\u0026quot;,\u0026quot;Jacqueline Bisset\u0026quot;]}] 这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：\ndata, err := json.MarshalIndent(movies, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { log.Fatalf(\u0026#34;JSON marshaling failed: %s\u0026#34;, err) } fmt.Printf(\u0026#34;%s\\n\u0026#34;, data) 上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）：\n[ { \u0026#34;Title\u0026#34;: \u0026#34;Casablanca\u0026#34;, \u0026#34;released\u0026#34;: 1942, \u0026#34;Actors\u0026#34;: [ \u0026#34;Humphrey Bogart\u0026#34;, \u0026#34;Ingrid Bergman\u0026#34; ] }, { \u0026#34;Title\u0026#34;: \u0026#34;Cool Hand Luke\u0026#34;, \u0026#34;released\u0026#34;: 1967, \u0026#34;color\u0026#34;: true, \u0026#34;Actors\u0026#34;: [ \u0026#34;Paul Newman\u0026#34; ] }, { \u0026#34;Title\u0026#34;: \u0026#34;Bullitt\u0026#34;, \u0026#34;released\u0026#34;: 1968, \u0026#34;color\u0026#34;: true, \u0026#34;Actors\u0026#34;: [ \u0026#34;Steve McQueen\u0026#34;, \u0026#34;Jacqueline Bisset\u0026#34; ] } ] 在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。\n细心的读者可能已经注意到，其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为结构体成员Tag所导致的。一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：\nYear int `json:\u0026quot;released\u0026quot;` Color bool `json:\u0026quot;color,omitempty\u0026quot;` 结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:\u0026ldquo;value\u0026quot;键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/\u0026hellip;下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里false为零值）。果然，Casablanca是一个黑白电影，并没有输出Color成员。\n编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。\nvar titles []struct{ Title string } if err := json.Unmarshal(data, \u0026amp;titles); err != nil { log.Fatalf(\u0026#34;JSON unmarshaling failed: %s\u0026#34;, err) } fmt.Println(titles) // \u0026#34;[{Casablanca} {Cool Hand Luke} {Bullitt}]\u0026#34; 许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量：\ngopl.io/ch4/github\n// Package github provides a Go API for the GitHub issue tracker. // See https://developer.github.com/v3/search/#search-issues. package github import \u0026#34;time\u0026#34; const IssuesURL = \u0026#34;https://api.github.com/search/issues\u0026#34; type IssuesSearchResult struct { TotalCount int `json:\u0026#34;total_count\u0026#34;` Items []*Issue } type Issue struct { Number int HTMLURL string `json:\u0026#34;html_url\u0026#34;` Title string State string User *User CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` Body string // in Markdown format } type User struct { Login string HTMLURL string `json:\u0026#34;html_url\u0026#34;` } 和前面一样，即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。\nSearchIssues函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似?和\u0026amp;之类的特殊字符，为了避免对URL造成冲突，我们用url.QueryEscape来对查询中的特殊字符进行转义操作。\ngopl.io/ch4/github\npackage github import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; ) // SearchIssues queries the GitHub issue tracker. func SearchIssues(terms []string) (*IssuesSearchResult, error) { q := url.QueryEscape(strings.Join(terms, \u0026#34; \u0026#34;)) resp, err := http.Get(IssuesURL + \u0026#34;?q=\u0026#34; + q) if err != nil { return nil, err } // We must close resp.Body on all execution paths. \t// (Chapter 5 presents \u0026#39;defer\u0026#39;, which makes this simpler.) \tif resp.StatusCode != http.StatusOK { resp.Body.Close() return nil, fmt.Errorf(\u0026#34;search query failed: %s\u0026#34;, resp.Status) } var result IssuesSearchResult if err := json.NewDecoder(resp.Body).Decode(\u0026amp;result); err != nil { resp.Body.Close() return nil, err } resp.Body.Close() return \u0026amp;result, nil } 在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。\n我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如何利用模板来输出复杂的格式。\ngopl.io/ch4/issues\n// Issues prints a table of GitHub issues matching the search terms. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;gopl.io/ch4/github\u0026#34; ) func main() { result, err := github.SearchIssues(os.Args[1:]) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%d issues:\\n\u0026#34;, result.TotalCount) for _, item := range result.Items { fmt.Printf(\u0026#34;#%-5d %9.9s %.55s\\n\u0026#34;, item.Number, item.User.Login, item.Title) } } 通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果：\n$ go build gopl.io/ch4/issues $ ./issues repo:golang/go is:open json decoder 13 issues: #5680 eaigner encoding/json: set key converter on en/decoder #6050 gopherbot encoding/json: provide tokenizer #8658 gopherbot encoding/json: use bufio #8462 kortschak encoding/json: UnmarshalText confuses json.Unmarshal #5901 rsc encoding/json: allow override type marshaling #9812 klauspost encoding/json: string tag not symmetric #7872 extempora encoding/json: Encoder internally buffers full output #9650 cespare encoding/json: Decoding gives errPhase when unmarshalin #6716 gopherbot encoding/json: include field name in unmarshal error me #6901 lukescott encoding/json, encoding/xml: option to treat unknown fi #6384 joeshaw encoding/json: encode precise floating point integers u #6647 btracey x/tools/cmd/godoc: display type kind of each named type #4237 gjemiller encoding/base64: URLEncoding padding is optional GitHub的Web服务接口 https://developer.github.com/v3/ 包含了更多的特性。\n练习 4.10： 修改issues程序，根据问题的时间进行分类，比如不到一个月的、不到一年的、超过一年。\n练习 4.11： 编写一个工具，允许用户在命令行创建、读取、更新和关闭GitHub上的issue，当必要的时候自动打开用户默认的编辑器用于输入文本信息。\n练习 4.12： 流行的web漫画服务xkcd也提供了JSON接口。例如，一个 https://xkcd.com/571/info.0.json 请求将返回一个很多人喜爱的571编号的详细描述。下载每个链接（只下载一次）然后创建一个离线索引。编写一个xkcd工具，使用这些离线索引，打印和命令行输入的检索词相匹配的漫画的URL。\n练习 4.13： 使用开放电影数据库的JSON服务接口，允许你检索和下载 https://omdbapi.com/ 上电影的名字和对应的海报图像。编写一个poster工具，通过命令行输入的电影名字，下载对应的海报。\n"});index.add({'id':126,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.5.-Function-Values/','title':"5.5. 函数值",'section':"5. 函数",'content':"5.5. 函数值 #  在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。例子如下：\nfunc square(n int) int { return n * n } func negative(n int) int { return -n } func product(m, n int) int { return m * n } f := square fmt.Println(f(3)) // \u0026#34;9\u0026#34;  f = negative fmt.Println(f(3)) // \u0026#34;-3\u0026#34; \tfmt.Printf(\u0026#34;%T\\n\u0026#34;, f) // \u0026#34;func(int) int\u0026#34;  f = product // compile error: can\u0026#39;t assign func(int, int) int to func(int) int 函数类型的零值是nil。调用值为nil的函数值会引起panic错误：\nvar f func(int) int f(3) // 此处f的值为nil, 会引起panic错误 函数值可以与nil比较：\nvar f func(int) int if f != nil { f(3) } 但是函数值之间是不可比较的，也不能用函数值作为map的key。\n函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。\nfunc add1(r rune) rune { return r + 1 } fmt.Println(strings.Map(add1, \u0026#34;HAL-9000\u0026#34;)) // \u0026#34;IBM.:111\u0026#34; \tfmt.Println(strings.Map(add1, \u0026#34;VMS\u0026#34;)) // \u0026#34;WNT\u0026#34; \tfmt.Println(strings.Map(add1, \u0026#34;Admix\u0026#34;)) // \u0026#34;Benjy\u0026#34; 5.2节的findLinks函数使用了辅助函数visit，遍历和操作了HTML页面的所有结点。使用函数值，我们可以将遍历结点的逻辑和操作结点的逻辑分离，使得我们可以复用遍历的逻辑，从而对结点进行不同的操作。\ngopl.io/ch5/outline2\n// forEachNode针对每个结点x，都会调用pre(x)和post(x)。 // pre和post都是可选的。 // 遍历孩子结点之前，pre被调用 // 遍历孩子结点之后，post被调用 func forEachNode(n *html.Node, pre, post func(n *html.Node)) { if pre != nil { pre(n) } for c := n.FirstChild; c != nil; c = c.NextSibling { forEachNode(c, pre, post) } if post != nil { post(n) } } 该函数接收2个函数作为参数，分别在结点的孩子被访问前和访问后调用。这样的设计给调用者更大的灵活性。举个例子，现在我们有startElemen和endElement两个函数用于输出HTML元素的开始标签和结束标签\u0026lt;b\u0026gt;...\u0026lt;/b\u0026gt;：\nvar depth int func startElement(n *html.Node) { if n.Type == html.ElementNode { fmt.Printf(\u0026#34;%*s\u0026lt;%s\u0026gt;\\n\u0026#34;, depth*2, \u0026#34;\u0026#34;, n.Data) depth++ } } func endElement(n *html.Node) { if n.Type == html.ElementNode { depth-- fmt.Printf(\u0026#34;%*s\u0026lt;/%s\u0026gt;\\n\u0026#34;, depth*2, \u0026#34;\u0026#34;, n.Data) } } 上面的代码利用fmt.Printf的一个小技巧控制输出的缩进。%*s中的*会在字符串之前填充一些空格。在例子中，每次输出会先填充depth*2数量的空格，再输出\u0026rdquo;\u0026quot;，最后再输出HTML标签。\n如果我们像下面这样调用forEachNode：\nforEachNode(doc, startElement, endElement) 与之前的outline程序相比，我们得到了更加详细的页面结构：\n$ go build gopl.io/ch5/outline2 $ ./outline2 http://gopl.io \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta\u0026gt; \u0026lt;/meta\u0026gt; \u0026lt;title\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a\u0026gt; \u0026lt;img\u0026gt; \u0026lt;/img\u0026gt; ... 练习 5.7： 完善startElement和endElement函数，使其成为通用的HTML输出器。要求：输出注释结点，文本结点以及每个元素的属性（\u0026lt; a href=\u0026rsquo;\u0026hellip;\u0026lsquo;\u0026gt;）。使用简略格式输出没有孩子结点的元素（即用\u0026lt;img/\u0026gt;代替\u0026lt;img\u0026gt;\u0026lt;/img\u0026gt;）。编写测试，验证程序输出的格式正确。（详见11章）\n练习 5.8： 修改pre和post函数，使其返回布尔类型的返回值。返回false时，中止forEachNoded的遍历。使用修改后的代码编写ElementByID函数，根据用户输入的id查找第一个拥有该id元素的HTML元素，查找成功后，停止遍历。\nfunc ElementByID(doc *html.Node, id string) *html.Node 练习 5.9： 编写函数expand，将s中的\u0026quot;foo\u0026quot;替换为f(\u0026ldquo;foo\u0026rdquo;)的返回值。\nfunc expand(s string, f func(string) string) string "});index.add({'id':127,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.5.-Example-Bit-Vector-Type/','title':"6.5. 示例: Bit数组",'section':"6. 方法",'content':"6.5. 示例: Bit数组 #  Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。（译注：这里再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组。）\n一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i。下面的这个程序展示了一个简单的bit数组类型，并且实现了三个函数来对这个bit数组来进行操作：\ngopl.io/ch6/intset\n// An IntSet is a set of small non-negative integers. // Its zero value represents the empty set. type IntSet struct { words []uint64 } // Has reports whether the set contains the non-negative value x. func (s *IntSet) Has(x int) bool { word, bit := x/64, uint(x%64) return word \u0026lt; len(s.words) \u0026amp;\u0026amp; s.words[word]\u0026amp;(1\u0026lt;\u0026lt;bit) != 0 } // Add adds the non-negative value x to the set. func (s *IntSet) Add(x int) { word, bit := x/64, uint(x%64) for word \u0026gt;= len(s.words) { s.words = append(s.words, 0) } s.words[word] |= 1 \u0026lt;\u0026lt; bit } // UnionWith sets s to the union of s and t. func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u0026lt; len(s.words) { s.words[i] |= tword } else { s.words = append(s.words, tword) } } } 因为每一个字都有64个二进制位，所以为了定位x的bit位，我们用了x/64的商作为字的下标，并且用x%64得到的值作为这个字内的bit的所在位置。UnionWith这个方法里用到了bit位的“或”逻辑操作符号|来一次完成64个元素的或计算。（在练习6.5中我们还会有程序用到这个64位字的例子。）\n当前这个实现还缺少了很多必要的特性，我们把其中一些作为练习题列在本小节之后。但是有一个方法如果缺失的话我们的bit数组可能会比较难混：将IntSet作为一个字符串来打印。这里我们来实现它，让我们来给上面的例子添加一个String方法，类似2.5节中做的那样：\n// String returns the set as a string of the form \u0026#34;{1 2 3}\u0026#34;. func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte(\u0026#39;{\u0026#39;) for i, word := range s.words { if word == 0 { continue } for j := 0; j \u0026lt; 64; j++ { if word\u0026amp;(1\u0026lt;\u0026lt;uint(j)) != 0 { if buf.Len() \u0026gt; len(\u0026#34;{\u0026#34;) { buf.WriteByte(\u0026#39; \u0026#39;) } fmt.Fprintf(\u0026amp;buf, \u0026#34;%d\u0026#34;, 64*i+j) } } } buf.WriteByte(\u0026#39;}\u0026#39;) return buf.String() } 这里留意一下String方法，是不是和3.5.4节中的intsToString方法很相似；bytes.Buffer在String方法里经常这么用。当你为一个复杂的类型定义了一个String方法时，fmt包就会特殊对待这种类型的值，这样可以让这些类型在打印的时候看起来更加友好，而不是直接打印其原始的值。fmt会直接调用用户定义的String方法。这种机制依赖于接口和类型断言，在第7章中我们会详细介绍。\n现在我们就可以在实战中直接用上面定义好的IntSet了：\nvar x, y IntSet x.Add(1) x.Add(144) x.Add(9) fmt.Println(x.String()) // \u0026#34;{1 9 144}\u0026#34;  y.Add(9) y.Add(42) fmt.Println(y.String()) // \u0026#34;{9 42}\u0026#34;  x.UnionWith(\u0026amp;y) fmt.Println(x.String()) // \u0026#34;{1 9 42 144}\u0026#34; fmt.Println(x.Has(9), x.Has(123)) // \u0026#34;true false\u0026#34; 这里要注意：我们声明的String和Has两个方法都是以指针类型*IntSet来作为接收器的，但实际上对于这两个类型来说，把接收器声明为指针类型也没什么必要。不过另外两个函数就不是这样了，因为另外两个函数操作的是s.words对象，如果你不把接收器声明为指针对象，那么实际操作的是拷贝对象，而不是原来的那个对象。因此，因为我们的String方法定义在IntSet指针上，所以当我们的变量是IntSet类型而不是IntSet指针时，可能会有下面这样让人意外的情况：\nfmt.Println(\u0026amp;x) // \u0026#34;{1 9 42 144}\u0026#34; fmt.Println(x.String()) // \u0026#34;{1 9 42 144}\u0026#34; fmt.Println(x) // \u0026#34;{[4398046511618 0 65536]}\u0026#34; 在第一个Println中，我们打印一个*IntSet的指针，这个类型的指针确实有自定义的String方法。第二Println，我们直接调用了x变量的String()方法；这种情况下编译器会隐式地在x前插入\u0026amp;操作符，这样相当于我们还是调用的IntSet指针的String方法。在第三个Println中，因为IntSet类型没有String方法，所以Println方法会直接以原始的方式理解并打印。所以在这种情况下\u0026amp;符号是不能忘的。在我们这种场景下，你把String方法绑定到IntSet对象上，而不是IntSet指针上可能会更合适一些，不过这也需要具体问题具体分析。\n练习6.1: 为bit数组实现下面这些方法\nfunc (*IntSet) Len() int // return the number of elements func (*IntSet) Remove(x int) // remove x from the set func (*IntSet) Clear() // remove all elements from the set func (*IntSet) Copy() *IntSet // return a copy of the set 练习 6.2： 定义一个变参方法(*IntSet).AddAll(\u0026hellip;int)，这个方法可以添加一组IntSet，比如s.AddAll(1,2,3)。\n练习 6.3： (*IntSet).UnionWith会用|操作符计算两个集合的并集，我们再为IntSet实现另外的几个函数IntersectWith（交集：元素在A集合B集合均出现），DifferenceWith（差集：元素出现在A集合，未出现在B集合），SymmetricDifference（并差集：元素出现在A但没有出现在B，或者出现在B没有出现在A）。\n***练习6.4: ** 实现一个Elems方法，返回集合中的所有元素，用于做一些range之类的遍历操作。\n练习 6.5： 我们这章定义的IntSet里的每个字都是用的uint64类型，但是64位的数值可能在32位的平台上不高效。修改程序，使其使用uint类型，这种类型对于32位平台来说更合适。当然了，这里我们可以不用简单粗暴地除64，可以定义一个常量来决定是用32还是64，这里你可能会用到平台的自动判断的一个智能表达式：32 \u0026laquo; (^uint(0) \u0026raquo; 63)\n"});index.add({'id':128,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.5.-Interface-Values/','title':"7.5. 接口值",'section':"7. 接口",'content':"7.5. 接口值 #  概念上讲一个接口的值，接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。\n下面4个语句中，变量w得到了3个不同的值。（开始和最后的值是相同的）\nvar w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil 让我们进一步观察在每一个语句后的w变量的值和动态行为。第一个语句定义了变量w:\nvar w io.Writer 在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil（图7.1）。\n 一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生panic:\nw.Write([]byte(\u0026#34;hello\u0026#34;)) // panic: nil pointer dereference 第二个语句将一个*os.File类型的值赋给变量w:\nw = os.Stdout 这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为*os.File指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针（图7.2）。\n 调用一个包含*os.File类型指针的接口值的Write方法，使得(*os.File).Write方法被调用。这个调用输出“hello”。\nw.Write([]byte(\u0026#34;hello\u0026#34;)) // \u0026#34;hello\u0026#34; 通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：\nos.Stdout.Write([]byte(\u0026#34;hello\u0026#34;)) // \u0026#34;hello\u0026#34; 第三个语句给接口值赋了一个*bytes.Buffer类型的值\nw = new(bytes.Buffer) 现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针（图7.3）。\n Write方法的调用也使用了和之前一样的机制：\nw.Write([]byte(\u0026#34;hello\u0026#34;)) // writes \u0026#34;hello\u0026#34; to the bytes.Buffers 这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。\n最后，第四个语句将nil赋给了接口值：\nw = nil 这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态，在图7.1中可以看到。\n一个接口值可以持有任意大的动态值。例如，表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值：\nvar x interface{} = time.Now() 结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同）\n 接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。\n然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:\nvar x interface{} = []int{1, 2, 3} fmt.Println(x == x) // panic: comparing uncomparable type []int 考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。\n当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作:\nvar w io.Writer fmt.Printf(\u0026#34;%T\\n\u0026#34;, w) // \u0026#34;\u0026lt;nil\u0026gt;\u0026#34; w = os.Stdout fmt.Printf(\u0026#34;%T\\n\u0026#34;, w) // \u0026#34;*os.File\u0026#34; w = new(bytes.Buffer) fmt.Printf(\u0026#34;%T\\n\u0026#34;, w) // \u0026#34;*bytes.Buffer\u0026#34; 在fmt包内部，使用反射来获取接口动态类型的名称。我们会在第12章中学到反射相关的知识。\n"});index.add({'id':129,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.5.-Looping-in-Parallel/','title':"8.5. 并发的循环",'section':"8. Goroutines和Channels",'content':"8.5. 并发的循环 #  本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io/ch8/thumbnail包提供了ImageFile函数来帮我们拉伸图片。我们不会说明这个函数的实现，只需要从gopl.io下载它。\ngopl.io/ch8/thumbnail\npackage thumbnail // ImageFile reads an image from infile and writes // a thumbnail-size version of it in the same directory. // It returns the generated file name, e.g., \u0026#34;foo.thumb.jpg\u0026#34;. func ImageFile(infile string) (string, error) 下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：\ngopl.io/ch8/thumbnail\n// makeThumbnails makes thumbnails of the specified files. func makeThumbnails(filenames []string) { for _, f := range filenames { if _, err := thumbnail.ImageFile(f); err != nil { log.Println(err) } } } 显然我们处理文件的顺序无关紧要，因为每一个图片的拉伸操作和其它图片的处理操作都是彼此独立的。像这种子问题都是完全彼此独立的问题被叫做易并行问题（译注：embarrassingly parallel，直译的话更像是尴尬并行）。易并行问题是最容易被实现成并行的一类问题（废话），并且最能够享受到并发带来的好处，能够随着并行的规模线性地扩展。\n下面让我们并行地执行这些操作，从而将文件IO的延迟隐藏掉，并用上多核cpu的计算能力来拉伸图像。我们的第一个并发程序只是使用了一个go关键字。这里我们先忽略掉错误，之后再进行处理。\n// NOTE: incorrect! func makeThumbnails2(filenames []string) { for _, f := range filenames { go thumbnail.ImageFile(f) // NOTE: ignoring errors \t} } 这个版本运行的实在有点太快，实际上，由于它比最早的版本使用的时间要短得多，即使当文件名的slice中只包含有一个元素。这就有点奇怪了，如果程序没有并发执行的话，那为什么一个并发的版本还是要快呢？答案其实是makeThumbnails在它还没有完成工作之前就已经返回了。它启动了所有的goroutine，每一个文件名对应一个，但没有等待它们一直到执行完毕。\n没有什么直接的办法能够等待goroutine完成，但是我们可以改变goroutine里的代码让其能够将完成情况报告给外部的goroutine知晓，使用的方式是向一个共享的channel中发送事件。因为我们已经确切地知道有len(filenames)个内部goroutine，所以外部的goroutine只需要在返回之前对这些事件计数。\n// makeThumbnails3 makes thumbnails of the specified files in parallel. func makeThumbnails3(filenames []string) { ch := make(chan struct{}) for _, f := range filenames { go func(f string) { thumbnail.ImageFile(f) // NOTE: ignoring errors \tch \u0026lt;- struct{}{} }(f) } // Wait for goroutines to complete. \tfor range filenames { \u0026lt;-ch } } 注意我们将f的值作为一个显式的变量传给了函数，而不是在循环的闭包中声明：\nfor _, f := range filenames { go func() { thumbnail.ImageFile(f) // NOTE: incorrect! \t// ... \t}() } 回忆一下之前在5.6.1节中，匿名函数中的循环变量快照问题。上面这个单独的变量f是被所有的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了f并且开始了另一轮的迭代或者（更有可能的）已经结束了整个循环，所以当这些goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。显式地添加这个参数，我们能够确保使用的f是当go语句执行时的“当前”那个f。\n如果我们想要从每一个worker goroutine往主goroutine中返回值时该怎么办呢？当我们调用thumbnail.ImageFile创建文件失败的时候，它会返回一个错误。下一个版本的makeThumbnails会返回其在做拉伸操作时接收到的第一个错误：\n// makeThumbnails4 makes thumbnails for the specified files in parallel. // It returns an error if any step failed. func makeThumbnails4(filenames []string) error { errors := make(chan error) for _, f := range filenames { go func(f string) { _, err := thumbnail.ImageFile(f) errors \u0026lt;- err }(f) } for range filenames { if err := \u0026lt;-errors; err != nil { return err // NOTE: incorrect: goroutine leak! \t} } return nil } 这个程序有一个微妙的bug。当它遇到第一个非nil的error时会直接将error返回到调用方，使得没有一个goroutine去排空errors channel。这样剩下的worker goroutine在向这个channel中发送值时，都会永远地阻塞下去，并且永远都不会退出。这种情况叫做goroutine泄露（§8.4.4），可能会导致整个程序卡住或者跑出out of memory的错误。\n最简单的解决办法就是用一个具有合适大小的buffered channel，这样这些worker goroutine向channel中发送错误时就不会被阻塞。（一个可选的解决办法是创建一个另外的goroutine，当main goroutine返回第一个错误的同时去排空channel。）\n下一个版本的makeThumbnails使用了一个buffered channel来返回生成的图片文件的名字，附带生成时的错误。\n// makeThumbnails5 makes thumbnails for the specified files in parallel. // It returns the generated file names in an arbitrary order, // or an error if any step failed. func makeThumbnails5(filenames []string) (thumbfiles []string, err error) { type item struct { thumbfile string err error } ch := make(chan item, len(filenames)) for _, f := range filenames { go func(f string) { var it item it.thumbfile, it.err = thumbnail.ImageFile(f) ch \u0026lt;- it }(f) } for range filenames { it := \u0026lt;-ch if it.err != nil { return nil, it.err } thumbfiles = append(thumbfiles, it.thumbfile) } return thumbfiles, nil } 我们最后一个版本的makeThumbnails返回了新文件们的大小总计数（bytes）。和前面的版本都不一样的一点是我们在这个版本里没有把文件名放在slice里，而是通过一个string的channel传过来，所以我们无法对循环的次数进行预测。\n为了知道最后一个goroutine什么时候结束（最后一个结束并不一定是最后一个开始），我们需要一个递增的计数器，在每一个goroutine启动时加一，在goroutine退出时减一。这需要一种特殊的计数器，这个计数器需要在多个goroutine操作时做到安全并且提供在其减为零之前一直等待的一种方法。这种计数类型被称为sync.WaitGroup，下面的代码就用到了这种方法：\n// makeThumbnails6 makes thumbnails for each file received from the channel. // It returns the number of bytes occupied by the files it creates. func makeThumbnails6(filenames \u0026lt;-chan string) int64 { sizes := make(chan int64) var wg sync.WaitGroup // number of working goroutines \tfor f := range filenames { wg.Add(1) // worker \tgo func(f string) { defer wg.Done() thumb, err := thumbnail.ImageFile(f) if err != nil { log.Println(err) return } info, _ := os.Stat(thumb) // OK to ignore error \tsizes \u0026lt;- info.Size() }(f) } // closer \tgo func() { wg.Wait() close(sizes) }() var total int64 for size := range sizes { total += size } return total } 注意Add和Done方法的不对称。Add是为计数器加一，必须在worker goroutine开始之前调用，而不是在goroutine中；否则的话我们没办法确定Add是在\u0026quot;closer\u0026rdquo; goroutine调用Wait之前被调用。并且Add还有一个参数，但Done却没有任何参数；其实它和Add(-1)是等价的。我们使用defer来确保计数器即使是在出错的情况下依然能够正确地被减掉。上面的程序代码结构是当我们使用并发循环，但又不知道迭代次数时很通常而且很地道的写法。\nsizes channel携带了每一个文件的大小到main goroutine，在main goroutine中使用了range loop来计算总和。观察一下我们是怎样创建一个closer goroutine，并让其在所有worker goroutine们结束之后再关闭sizes channel的。两步操作：wait和close，必须是基于sizes的循环的并发。考虑一下另一种方案：如果等待操作被放在了main goroutine中，在循环之前，这样的话就永远都不会结束了，如果在循环之后，那么又变成了不可达的部分，因为没有任何东西去关闭这个channel，这个循环就永远都不会终止。\n图8.5 表明了makethumbnails6函数中事件的序列。纵列表示goroutine。窄线段代表sleep，粗线段代表活动。斜线箭头代表用来同步两个goroutine的事件。时间向下流动。注意main goroutine是如何大部分的时间被唤醒执行其range循环，等待worker发送值或者closer来关闭channel的。\n 练习 8.4： 修改reverb2服务器，在每一个连接中使用sync.WaitGroup来计数活跃的echo goroutine。当计数减为零时，关闭TCP连接的写入，像练习8.3中一样。验证一下你的修改版netcat3客户端会一直等待所有的并发“喊叫”完成，即使是在标准输入流已经关闭的情况下。\n练习 8.5： 使用一个已有的CPU绑定的顺序程序，比如在3.3节中我们写的Mandelbrot程序或者3.2节中的3-D surface计算程序，并将他们的主循环改为并发形式，使用channel来进行通信。在多核计算机上这个程序得到了多少速度上的改进？使用多少个goroutine是最合适的呢？\n"});index.add({'id':130,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.5.-Lazy-Initialization-sync.Once/','title':"9.5. sync.Once惰性初始化",'section':"9. 基于共享变量的并发",'content':"9.5. sync.Once惰性初始化 #  如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。让我们来看在本章早一些时候的icons变量：\nvar icons map[string]image.Image 这个版本的Icon用到了懒初始化（lazy initialization）。\nfunc loadIcons() { icons = map[string]image.Image{ \u0026#34;spades.png\u0026#34;: loadIcon(\u0026#34;spades.png\u0026#34;), \u0026#34;hearts.png\u0026#34;: loadIcon(\u0026#34;hearts.png\u0026#34;), \u0026#34;diamonds.png\u0026#34;: loadIcon(\u0026#34;diamonds.png\u0026#34;), \u0026#34;clubs.png\u0026#34;:\tloadIcon(\u0026#34;clubs.png\u0026#34;), } } // NOTE: not concurrency-safe! func Icon(name string) image.Image { if icons == nil { loadIcons() // one-time initialization \t} return icons[name] } 如果一个变量只被一个单独的goroutine所访问的话，我们可以使用上面的这种模板，但这种模板在Icon被并发调用时并不安全。就像前面银行的那个Deposit(存款)函数一样，Icon函数也是由多个步骤组成的：首先测试icons是否为空，然后load这些icons，之后将icons更新为一个非空的值。直觉会告诉我们最差的情况是loadIcons函数被多次访问会带来数据竞争。当第一个goroutine在忙着loading这些icons的时候，另一个goroutine进入了Icon函数，发现变量是nil，然后也会调用loadIcons函数。\n不过这种直觉是错误的。（我们希望你从现在开始能够构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的！），回忆一下9.4节。因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。其中一种可能loadIcons的语句重排是下面这样。它会在填写icons变量的值之前先用一个空map来初始化icons变量。\nfunc loadIcons() { icons = make(map[string]image.Image) icons[\u0026#34;spades.png\u0026#34;] = loadIcon(\u0026#34;spades.png\u0026#34;) icons[\u0026#34;hearts.png\u0026#34;] = loadIcon(\u0026#34;hearts.png\u0026#34;) icons[\u0026#34;diamonds.png\u0026#34;] = loadIcon(\u0026#34;diamonds.png\u0026#34;) icons[\u0026#34;clubs.png\u0026#34;] = loadIcon(\u0026#34;clubs.png\u0026#34;) } 因此，一个goroutine在检查icons是非空时，也并不能就假设这个变量的初始化流程已经走完了（译注：可能只是塞了个空map，里面的值还没填完，也就是说填值的语句都没执行完呢）。\n最简单且正确的保证所有goroutine能够观察到loadIcons效果的方式，是用一个mutex来同步检查。\nvar mu sync.Mutex // guards icons var icons map[string]image.Image // Concurrency-safe. func Icon(name string) image.Image { mu.Lock() defer mu.Unlock() if icons == nil { loadIcons() } return icons[name] } 然而使用互斥访问icons的代价就是没有办法对该变量进行并发访问，即使变量已经被初始化完毕且再也不会进行变动。这里我们可以引入一个允许多读的锁：\nvar mu sync.RWMutex // guards icons var icons map[string]image.Image // Concurrency-safe. func Icon(name string) image.Image { mu.RLock() if icons != nil { icon := icons[name] mu.RUnlock() return icon } mu.RUnlock() // acquire an exclusive lock \tmu.Lock() if icons == nil { // NOTE: must recheck for nil \tloadIcons() } icon := icons[name] mu.Unlock() return icon } 上面的代码有两个临界区。goroutine首先会获取一个读锁，查询map，然后释放锁。如果条目被找到了（一般情况下），那么会直接返回。如果没有找到，那goroutine会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查icons变量是否为nil，以防止在执行这一段代码的时候，icons变量已经被其它gorouine初始化过了。\n上面的模板使我们的程序能够更好的并发，但是有一点太复杂且容易出错。幸运的是，sync包为我们提供了一个专门的方案来解决这种一次性初始化的问题：sync.Once。概念上来讲，一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了；互斥量用来保护boolean变量和客户端数据结构。Do这个唯一的方法需要接收初始化函数作为其参数。让我们用sync.Once来简化前面的Icon函数吧：\nvar loadIconsOnce sync.Once var icons map[string]image.Image // Concurrency-safe. func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 每一次对Do(loadIcons)的调用都会锁定mutex，并会检查boolean变量（译注：Go1.9中会先判断boolean变量是否为1(true)，只有不为1才锁定mutex，不再需要每次都锁定mutex）。在第一次调用时，boolean变量的值是false，Do会调用loadIcons并会将boolean变量设置为true。随后的调用什么都不会做，但是mutex同步会保证loadIcons对内存（这里其实就是指icons变量啦）产生的效果能够对所有goroutine可见。用这种方式来使用sync.Once的话，我们能够避免在变量被构建完成之前和其它goroutine共享该变量。\n练习 9.2： 重写2.6.2节中的PopCount的例子，使用sync.Once，只在第一次需要用到的时候进行初始化。（虽然实际上，对PopCount这样很小且高度优化的函数进行同步可能代价没法接受。）\n"});index.add({'id':131,'href':'/docs/The-Go-Programming-Language/Preface/Acknowledgments/','title':"致谢",'section':"前言",'content':"致谢 #   Rob Pike和 Russ Cox，以及很多其他Go团队的核心成员多次仔细阅读了本书的手稿，他们对本书的组织结构和表述用词等给出了很多宝贵的建议。在准备日文版翻译的时候，Yoshiki Shibata更是仔细地审阅了本书的每个部分，及时发现了诸多英文和代码的错误。我们非常感谢本书的每一位审阅者，并感谢对本书给出了重要的建议的Brian Goetz、Corey Kosak、Arnold Robbins、Josh Bleecher Snyder和Peter Weinberger等人。\n我们还感谢Sameer Ajmani、Ittai Balaban、David Crawshaw、Billy Donohue、Jonathan Feinberg、Andrew Gerrand、Robert Griesemer、John Linderman、Minux Ma（译注：中国人，Go团队成员。）、Bryan Mills、Bala Natarajan、Cosmos Nicolaou、Paul Staniforth、Nigel Tao（译注：好像是陶哲轩的兄弟）以及Howard Trickey给出的许多有价值的建议。我们还要感谢David Brailsford和Raph Levien关于类型设置的建议。\n我们从来自Addison-Wesley的编辑Greg Doench收到了很多帮助，从最开始就得到了越来越多的帮助。来自AW生产团队的John Fuller、Dayna Isley、Julie Nahil、Chuti Prasertsith到Barbara Wood，感谢你们的热心帮助。\n Alan Donovan特别感谢：Sameer Ajmani、Chris Demetriou、Walt Drummond和Google公司的Reid Tatge允许他有充裕的时间去写本书；感谢Stephen Donovan的建议和始终如一的鼓励，以及他的妻子Leila Kazemi并没有让他为了家庭琐事而分心，并热情坚定地支持这个项目。\n Brian Kernighan特别感谢：朋友和同事对他的耐心和宽容，让他慢慢地梳理本书的写作思路。同时感谢他的妻子Meg和其他很多朋友对他写作事业的支持。\n2015年 10月 于 纽约\n"});index.add({'id':132,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.6.-Fetching-URLs-Concurrently/','title':"1.6. 并发获取多个URL",'section':"1. 入门",'content':"1.6. 并发获取多个URL #  Go语言最有意思并且最新奇的特性就是对并发编程的支持。并发编程是一个大话题，在第八章和第九章中会专门讲到。这里我们只浅尝辄止地来体验一下Go语言里的goroutine和channel。\n下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。\ngopl.io/ch1/fetchall\n// Fetchall fetches URLs in parallel and reports their times and sizes. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) func main() { start := time.Now() ch := make(chan string) for _, url := range os.Args[1:] { go fetch(url, ch) // start a goroutine \t} for range os.Args[1:] { fmt.Println(\u0026lt;-ch) // receive from channel ch \t} fmt.Printf(\u0026#34;%.2fs elapsed\\n\u0026#34;, time.Since(start).Seconds()) } func fetch(url string, ch chan\u0026lt;- string) { start := time.Now() resp, err := http.Get(url) if err != nil { ch \u0026lt;- fmt.Sprint(err) // send to channel ch \treturn } nbytes, err := io.Copy(ioutil.Discard, resp.Body) resp.Body.Close() // don\u0026#39;t leak resources \tif err != nil { ch \u0026lt;- fmt.Sprintf(\u0026#34;while reading %s: %v\u0026#34;, url, err) return } secs := time.Since(start).Seconds() ch \u0026lt;- fmt.Sprintf(\u0026#34;%.2fs %7d %s\u0026#34;, secs, nbytes, url) } 下面使用fetchall来请求几个地址：\n$ go build gopl.io/ch1/fetchall $ ./fetchall https://golang.org http://gopl.io https://godoc.org 0.14s 6852 https://godoc.org 0.16s 7261 https://golang.org 0.48s 2475 http://gopl.io 0.48s elapsed goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。\nmain函数中用make函数创建了一个传递string类型参数的channel，对每一个命令行参数，我们都用go这个关键字来创建一个goroutine，并且让函数在这个goroutine异步执行http.Get方法。这个程序里的io.Copy会把响应的Body内容拷贝到ioutil.Discard输出流中（译注：可以把这个变量看作一个垃圾桶，可以向里面写一些不需要的数据），因为我们需要这个方法返回的字节数，但是又不想要其内容。每当请求返回内容时，fetch函数都会往ch这个channel里写入一个字符串，由main函数里的第二个for循环来处理并打印channel里的这个字符串。\n当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine从这个channel里接收或者写入值，这样两个goroutine才会继续执行channel操作之后的逻辑。在这个例子中，每一个fetch函数在执行时都会往channel里发送一个值（ch \u0026lt;- expression），主函数负责接收这些值（\u0026lt;-ch）。这个程序中我们用main函数来接收所有fetch函数传回的字符串，可以避免在goroutine异步执行还没有完成时main函数提前退出。\n练习 1.10： 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。\n练习 1.11： 在fetchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？（Section8.9 描述了在这种情况下的应对机制）。\n"});index.add({'id':133,'href':'/docs/Clean-Code/1.-Clean-Code/1.6.-The-Boy-Scout-Rule/','title':"1.6. 童子军军规",'section':"1. 整洁代码",'content':"1.6 童子军军规 #  It’s not enough to write the code well. The code has to be kept clean over time. We’ve all seen code rot and degrade as time passes. So we must take an active role in preventing this degradation.\n 光把代码写好可不够。必须时时保持代码整洁。我们都见过代码随时间流逝而腐坏。我们应当更积极地阻止腐坏的发生。\n The Boy Scouts of America have a simple rule that we can apply to our profession.\n 借用美国童子军一条简单的军规，应用到我们的专业领域：\n Leave the campground cleaner than you found it.5\n 让营地比你来时更干净。\n If we all checked-in our code a little cleaner than when we checked it out, the code simply could not rot. The cleanup doesn’t have to be something big. Change one variable name for the better, break up one function that’s a little too large, eliminate one small bit of duplication, clean up one composite if statement.\n 如果每次签入时，代码都比签出时干净，那么代码就不会腐坏。清理并不一定要花多少功夫，也许只是改好一个变量名，拆分一个有点过长的函数，消除一点点重复代码，清理一个嵌套 if 语句。\n Can you imagine working on a project where the code simply got better as time passed? Do you believe that any other option is professional? Indeed, isn’t continuous improvement an intrinsic part of professionalism?\n 你想要为一个代码随时间流逝而越变越好的项目工作吗？你还能相信有其他更专业的做法吗？难道持续改进不是专业性的内在组成部分吗？\n "});index.add({'id':134,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.6.-Packages-and-Naming/','title':"10.6. 包和命名",'section':"10. 包和工具",'content':"10.6. 包和命名 #  在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。\n当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。\n尽可能让命名有描述性且无歧义。例如，类似imageutil或ioutilis的工具包命名已经足够简洁了，就无须再命名为util了。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的path包。\n包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。\n要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段时间使用了temperature作为包名，显然名字并没有表达包的真实用途。最后我们改成了和strconv标准包类似的tempconv包名，这个名字比之前的就好多了。\n现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子：\nbytes.Equal flag.Int http.Get json.Marshal 我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作：\npackage strings func Index(needle, haystack string) int type Replacer struct{ /* ... */ } func NewReplacer(oldnew ...string) *Replacer type Reader struct{ /* ... */ } func NewReader(s string) *Reader 包名strings并没有出现在任何成员名字中。因为用户会这样引用这些成员strings.Index、strings.Replacer等。\n其它一些包，可能只描述了单一的数据类型，例如html/template和math/rand等，只暴露一个主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。\npackage rand // \u0026#34;math/rand\u0026#34;  type Rand struct{ /* ... */ } func New(source Source) *Rand 这可能导致一些名字重复，例如template.Template或rand.Rand，这就是这些种类的包名往往特别短的原因之一。\n在另一个极端，还有像net/http包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。\n"});index.add({'id':135,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/10.7.6.-Querying-Packages/','title':"10.7.6. 查询包",'section':"10.7. 工具",'content':"10.7.6. 查询包 #  go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径：\n$ go list github.com/go-sql-driver/mysql github.com/go-sql-driver/mysql go list命令的参数还可以用\u0026quot;...\u0026quot;表示匹配任意的包的导入路径。我们可以用它来列出工作区中的所有包：\n$ go list ... archive/tar archive/zip bufio bytes cmd/addr2line cmd/api ...many more... 或者是特定子目录下的所有包：\n$ go list gopl.io/ch3/... gopl.io/ch3/basename1 gopl.io/ch3/basename2 gopl.io/ch3/comma gopl.io/ch3/mandelbrot gopl.io/ch3/netflag gopl.io/ch3/printints gopl.io/ch3/surface 或者是和某个主题相关的所有包:\n$ go list ...xml... encoding/xml gopl.io/ch7/xmlselect go list命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中-json命令行参数表示用JSON格式打印每个包的元信息。\n$ go list -json hash { \u0026quot;Dir\u0026quot;: \u0026quot;/home/gopher/go/src/hash\u0026quot;, \u0026quot;ImportPath\u0026quot;: \u0026quot;hash\u0026quot;, \u0026quot;Name\u0026quot;: \u0026quot;hash\u0026quot;, \u0026quot;Doc\u0026quot;: \u0026quot;Package hash provides interfaces for hash functions.\u0026quot;, \u0026quot;Target\u0026quot;: \u0026quot;/home/gopher/go/pkg/darwin_amd64/hash.a\u0026quot;, \u0026quot;Goroot\u0026quot;: true, \u0026quot;Standard\u0026quot;: true, \u0026quot;Root\u0026quot;: \u0026quot;/home/gopher/go\u0026quot;, \u0026quot;GoFiles\u0026quot;: [ \u0026quot;hash.go\u0026quot; ], \u0026quot;Imports\u0026quot;: [ \u0026quot;io\u0026quot; ], \u0026quot;Deps\u0026quot;: [ \u0026quot;errors\u0026quot;, \u0026quot;io\u0026quot;, \u0026quot;runtime\u0026quot;, \u0026quot;sync\u0026quot;, \u0026quot;sync/atomic\u0026quot;, \u0026quot;unsafe\u0026quot; ] } 命令行参数-f则允许用户使用text/template包（§4.6）的模板语言定义输出文本的格式。下面的命令将打印strconv包的依赖的包，然后用join模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔：\n{% raw %}\n$ go list -f '{{join .Deps \u0026quot; \u0026quot;}}' strconv errors math runtime unicode/utf8 unsafe {% endraw %}\n译注：上面的命令在Windows的命令行运行会遇到template: main:1: unclosed action的错误。产生这个错误的原因是因为命令行对命令中的\u0026quot; \u0026quot;参数进行了转义处理。可以按照下面的方法解决转义字符串的问题：\n{% raw %}\n$ go list -f \u0026quot;{{join .Deps \\\u0026quot; \\\u0026quot;}}\u0026quot; strconv {% endraw %}\n下面的命令打印compress子目录下所有包的导入包列表：\n{% raw %}\n$ go list -f '{{.ImportPath}} -\u0026gt; {{join .Imports \u0026quot; \u0026quot;}}' compress/... compress/bzip2 -\u0026gt; bufio io sort compress/flate -\u0026gt; bufio fmt io math sort strconv compress/gzip -\u0026gt; bufio compress/flate errors fmt hash hash/crc32 io time compress/lzw -\u0026gt; bufio errors fmt io compress/zlib -\u0026gt; bufio compress/flate errors fmt hash hash/adler32 io {% endraw %}\n译注：Windows下有同样有问题，要避免转义字符串的干扰：\n{% raw %}\n$ go list -f \u0026quot;{{.ImportPath}} -\u0026gt; {{join .Imports \\\u0026quot; \\\u0026quot;}}\u0026quot; compress/... {% endraw %}\ngo list命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。我们将在11.2.4节中再次使用它。每个子命令的更多信息，包括可设置的字段和意义，可以用go help list命令查看。\n在本章，我们解释了Go语言工具中除了测试命令之外的所有重要的子命令。在下一章，我们将看到如何用go test命令去运行Go语言程序中的测试代码。\n练习 10.4： 创建一个工具，根据命令行指定的参数，报告工作区所有依赖包指定的其它包集合。提示：你需要运行go list命令两次，一次用于初始化包，一次用于所有包。你可能需要用encoding/json（§4.5）包来分析输出的JSON格式的信息。\n"});index.add({'id':136,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.2.-Test-Functions/11.2.6.-Avoiding-Brittle-Tests/','title':"11.2.6. 避免脆弱的测试",'section':"11.2. 测试函数",'content':"11.2.6. 避免脆弱的测试 #  如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就失败则称为脆弱。就像一个不够稳健的程序会挫败它的用户一样，一个脆弱的测试同样会激怒它的维护者。最脆弱的测试代码会在程序没有任何变化的时候产生不同的结果，时好时坏，处理它们会耗费大量的时间但是并不会得到任何好处。\n当一个测试函数会产生一个复杂的输出如一个很长的字符串、一个精心设计的数据结构或一个文件时，人们很容易想预先写下一系列固定的用于对比的标杆数据。但是随着项目的发展，有些输出可能会发生变化，尽管很可能是一个改进的实现导致的。而且不仅仅是输出部分，函数复杂的输入部分可能也跟着变化了，因此测试使用的输入也就不再有效了。\n避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。\n"});index.add({'id':137,'href':'/docs/The-Go-Programming-Language/11.-Testing/11.6.-Example-Functions/','title':"11.6. 示例函数",'section':"11. 测试",'content':"11.6. 示例函数 #  第三种被go test特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是IsPalindrome函数对应的示例函数：\nfunc ExampleIsPalindrome() { fmt.Println(IsPalindrome(\u0026#34;A man, a plan, a canal: Panama\u0026#34;)) fmt.Println(IsPalindrome(\u0026#34;palindrome\u0026#34;)) // Output: \t// true \t// false } 示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。\n根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。\n示例函数的第二个用处是，在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的// Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。\n示例函数的第三个目的提供一个真实的演练场。 http://golang.org 就是由godoc提供的文档服务，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式。\n 本书最后的两章是讨论reflect和unsafe包，一般的Go程序员很少使用它们，事实上也很少需要用到。因此，如果你还没有写过任何真实的Go程序的话，现在可以先去写些代码了。\n"});index.add({'id':138,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.6.-Example-Decoding-S-Expressions/','title':"12.6. 示例: 解码S表达式",'section':"12. 反射",'content':"12.6. 示例: 解码S表达式 #  标准库中encoding/\u0026hellip;下每个包中提供的Marshal编码函数都有一个对应的Unmarshal函数用于解码。例如，我们在4.5节中看到的，要将包含JSON编码格式的字节slice数据解码为我们自己的Movie类型（§12.3），我们可以这样做：\ndata := []byte{/* ... */} var movie Movie err := json.Unmarshal(data, \u0026amp;movie) Unmarshal函数使用了反射机制类修改movie变量的每个成员，根据输入的内容为Movie成员创建对应的map、结构体和slice。\n现在让我们为S表达式编码实现一个简易的Unmarshal，类似于前面的json.Unmarshal标准库函数，对应我们之前实现的sexpr.Marshal函数的逆操作。我们必须提醒一下，一个健壮的和通用的实现通常需要比例子更多的代码，为了便于演示我们采用了精简的实现。我们只支持S表达式有限的子集，同时处理错误的方式也比较粗暴，代码的目的是为了演示反射的用法，而不是构造一个实用的S表达式的解码器。\n词法分析器lexer使用了标准库中的text/scanner包将输入流的字节数据解析为一个个类似注释、标识符、字符串面值和数字面值之类的标记。输入扫描器scanner的Scan方法将提前扫描和返回下一个记号，对于rune类型。大多数记号，比如“(”，对应一个单一rune可表示的Unicode字符，但是text/scanner也可以用小的负数表示记号标识符、字符串等由多个字符组成的记号。调用Scan方法将返回这些记号的类型，接着调用TokenText方法将返回记号对应的文本内容。\n因为每个解析器可能需要多次使用当前的记号，但是Scan会一直向前扫描，所以我们包装了一个lexer扫描器辅助类型，用于跟踪最近由Scan方法返回的记号。\ngopl.io/ch12/sexpr\ntype lexer struct { scan scanner.Scanner token rune // the current token } func (lex *lexer) next() { lex.token = lex.scan.Scan() } func (lex *lexer) text() string { return lex.scan.TokenText() } func (lex *lexer) consume(want rune) { if lex.token != want { // NOTE: Not an example of good error handling. \tpanic(fmt.Sprintf(\u0026#34;got %q, want %q\u0026#34;, lex.text(), want)) } lex.next() } 现在让我们转到语法解析器。它主要包含两个功能。第一个是read函数，用于读取S表达式的当前标记，然后根据S表达式的当前标记更新可取地址的reflect.Value对应的变量v。\nfunc read(lex *lexer, v reflect.Value) { switch lex.token { case scanner.Ident: // The only valid identifiers are \t// \u0026#34;nil\u0026#34; and struct field names. \tif lex.text() == \u0026#34;nil\u0026#34; { v.Set(reflect.Zero(v.Type())) lex.next() return } case scanner.String: s, _ := strconv.Unquote(lex.text()) // NOTE: ignoring errors \tv.SetString(s) lex.next() return case scanner.Int: i, _ := strconv.Atoi(lex.text()) // NOTE: ignoring errors \tv.SetInt(int64(i)) lex.next() return case \u0026#39;(\u0026#39;: lex.next() readList(lex, v) lex.next() // consume \u0026#39;)\u0026#39; \treturn } panic(fmt.Sprintf(\u0026#34;unexpected token %q\u0026#34;, lex.text())) } 我们的S表达式使用标识符区分两个不同类型，结构体成员名和nil值的指针。read函数值处理nil类型的标识符。当遇到scanner.Ident为“nil”是，使用reflect.Zero函数将变量v设置为零值。而其它任何类型的标识符，我们都作为错误处理。后面的readList函数将处理结构体的成员名。\n一个“(”标记对应一个列表的开始。第二个函数readList，将一个列表解码到一个聚合类型中（map、结构体、slice或数组），具体类型依然于传入待填充变量的类型。每次遇到这种情况，循环继续解析每个元素直到遇到于开始标记匹配的结束标记“)”，endList函数用于检测结束标记。\n最有趣的部分是递归。最简单的是对数组类型的处理。直到遇到“)”结束标记，我们使用Index函数来获取数组每个元素的地址，然后递归调用read函数处理。和其它错误类似，如果输入数据导致解码器的引用超出了数组的范围，解码器将抛出panic异常。slice也采用类似方法解析，不同的是我们将为每个元素创建新的变量，然后将元素添加到slice的末尾。\n在循环处理结构体和map每个元素时必须解码一个(key value)格式的对应子列表。对于结构体，key部分对于成员的名字。和数组类似，我们使用FieldByName找到结构体对应成员的变量，然后递归调用read函数处理。对于map，key可能是任意类型，对元素的处理方式和slice类似，我们创建一个新的变量，然后递归填充它，最后将新解析到的key/value对添加到map。\nfunc readList(lex *lexer, v reflect.Value) { switch v.Kind() { case reflect.Array: // (item ...) \tfor i := 0; !endList(lex); i++ { read(lex, v.Index(i)) } case reflect.Slice: // (item ...) \tfor !endList(lex) { item := reflect.New(v.Type().Elem()).Elem() read(lex, item) v.Set(reflect.Append(v, item)) } case reflect.Struct: // ((name value) ...) \tfor !endList(lex) { lex.consume(\u0026#39;(\u0026#39;) if lex.token != scanner.Ident { panic(fmt.Sprintf(\u0026#34;got token %q, want field name\u0026#34;, lex.text())) } name := lex.text() lex.next() read(lex, v.FieldByName(name)) lex.consume(\u0026#39;)\u0026#39;) } case reflect.Map: // ((key value) ...) \tv.Set(reflect.MakeMap(v.Type())) for !endList(lex) { lex.consume(\u0026#39;(\u0026#39;) key := reflect.New(v.Type().Key()).Elem() read(lex, key) value := reflect.New(v.Type().Elem()).Elem() read(lex, value) v.SetMapIndex(key, value) lex.consume(\u0026#39;)\u0026#39;) } default: panic(fmt.Sprintf(\u0026#34;cannot decode list into %v\u0026#34;, v.Type())) } } func endList(lex *lexer) bool { switch lex.token { case scanner.EOF: panic(\u0026#34;end of file\u0026#34;) case \u0026#39;)\u0026#39;: return true } return false } 最后，我们将解析器包装为导出的Unmarshal解码函数，隐藏了一些初始化和清理等边缘处理。内部解析器以panic的方式抛出错误，但是Unmarshal函数通过在defer语句调用recover函数来捕获内部panic（§5.10），然后返回一个对panic对应的错误信息。\n// Unmarshal parses S-expression data and populates the variable // whose address is in the non-nil pointer out. func Unmarshal(data []byte, out interface{}) (err error) { lex := \u0026amp;lexer{scan: scanner.Scanner{Mode: scanner.GoTokens}} lex.scan.Init(bytes.NewReader(data)) lex.next() // get the first token \tdefer func() { // NOTE: this is not an example of ideal error handling. \tif x := recover(); x != nil { err = fmt.Errorf(\u0026#34;error at %s: %v\u0026#34;, lex.scan.Position, x) } }() read(lex, reflect.ValueOf(out).Elem()) return nil } 生产实现不应该对任何输入问题都用panic形式报告，而且应该报告一些错误相关的信息，例如出现错误输入的行号和位置等。尽管如此，我们希望通过这个例子来展示类似encoding/json等包底层代码的实现思路，以及如何使用反射机制来填充数据结构。\n练习 12.8： sexpr.Unmarshal函数和json.Unmarshal一样，都要求在解码前输入完整的字节slice。定义一个和json.Decoder类似的sexpr.Decoder类型，支持从一个io.Reader流解码。修改sexpr.Unmarshal函数，使用这个新的类型实现。\n练习 12.9： 编写一个基于标记的API用于解码S表达式，参考xml.Decoder（7.14）的风格。你将需要五种类型的标记：Symbol、String、Int、StartList和EndList。\n练习 12.10： 扩展sexpr.Unmarshal函数，支持布尔型、浮点数和interface类型的解码，使用 练习 12.3： 的方案。（提示：要解码接口，你需要将name映射到每个支持类型的reflect.Type。）\n"});index.add({'id':139,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.6.-Use-Searchable-Names/','title':"2.6. 使用可搜索的名称",'section':"2. 有意义的命名",'content':"2.6 使用可搜索的名称 #  Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.\n 单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。\n One might easily grep for MAX_CLASSES_PER_STUDENT, but the number 7 could be more troublesome. Searches may turn up the digit as part of file names, other constant definitions, and in various expressions where the value is used with different intent. It is even worse when a constant is a long number and someone might have transposed digits, thereby creating a bug while simultaneously evading the programmer’s search.\n 找 MAX_CLASSES_PER_STUDENT 很容易，但想找数字 7 就麻烦了，它可能是某些文件名或其他常量定义的一部分，出现在因不同意图而采用的各种表达式中。如果该常量是个长数字，又被人错改过，就会逃过搜索，从而造成错误。\n Likewise, the name e is a poor choice for any variable for which a programmer might need to search. It is the most common letter in the English language and likely to show up in every passage of text in every program. In this regard, longer names trump shorter names, and any searchable name trumps a constant in code.\n 同样，e 也不是个便于搜索的好变量名。它是英文中最常用的字母，在每个程序、每段代码中都有可能出现。由此而见，长名称胜于短名称，搜得到的名称胜于用自造编码代写就的名称。\n My personal preference is that single-letter names can ONLY be used as local variables inside short methods. The length of a name should correspond to the size of its scope [N5]. If a variable or constant might be seen or used in multiple places in a body of code, it is imperative to give it a search-friendly name. Once again compare\n 窃以为单字母名称仅用于短方法中的本地变量。名称长短应与其作用域大小相对应[N5]。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。再比较\n for (int j=0; j\u0026lt;34; j++) { s += (t[j]*4)/5; } to\n 和\n int realDaysPerIdealDay = 4; const int WORK_DAYS_PER_WEEK = 5; int sum = 0; for (int j=0; j \u0026lt; NUMBER_OF_TASKS; j++) { int realTaskDays = taskEstimate[j] * realDaysPerIdealDay; int realTaskWeeks = (realdays / WORK_DAYS_PER_WEEK); sum += realTaskWeeks; } Note that sum, above, is not a particularly useful name but at least is searchable. The intentionally named code makes for a longer function, but consider how much easier it will be to find WORK_DAYS_PER_WEEK than to find all the places where 5 was used and filter the list down to just the instances with the intended meaning.\n 注意，上面代码中的 sum 并非特别有用的名称，不过它至少搜得到。采用能表达意图的名称，貌似拉长了函数代码，但要想想看，WORK_DAYS_PER_WEEK 要比数字 5 好找得多，而列表中也只剩下了体现作者意图的名称。\n "});index.add({'id':140,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.6.-Packages-and-Files/','title':"2.6. 包和文件",'section':"2. 程序结构",'content':"2.6. 包和文件 #  Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。\n每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。\n包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。\n为了演示包基本的用法，先假设我们的温度转换软件已经很流行，我们希望到Go语言社区也能使用这个包。我们该如何做呢？\n让我们创建一个名为gopl.io/ch2/tempconv的包，这是前面例子的一个改进版本。（这里我们没有按照惯例按顺序对例子进行编号，因此包路径看起来更像一个真实的包）包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问；虽然在现实中，这样小的包一般只需要一个文件。\n我们把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中：\ngopl.io/ch2/tempconv\n// Package tempconv performs Celsius and Fahrenheit conversions. package tempconv import \u0026#34;fmt\u0026#34; type Celsius float64 type Fahrenheit float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(\u0026#34;%g°C\u0026#34;, c) } func (f Fahrenheit) String() string { return fmt.Sprintf(\u0026#34;%g°F\u0026#34;, f) } 转换函数则放在另一个conv.go源文件中：\npackage tempconv // CToF converts a Celsius temperature to Fahrenheit. func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } // FToC converts a Fahrenheit temperature to Celsius. func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) } 每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将通过类似tempconv.CToF的形式访问。而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。要注意的是tempconv.go源文件导入了fmt包，但是conv.go源文件并没有，因为这个源文件中的代码并没有用到fmt包。\n因为包级别的常量名都是以大写字母开头，它们可以像tempconv.AbsoluteZeroC这样被外部代码访问：\nfmt.Printf(\u0026#34;Brrrr! %v\\n\u0026#34;, tempconv.AbsoluteZeroC) // \u0026#34;Brrrr! -273.15°C\u0026#34; 要将摄氏温度转换为华氏温度，需要先用import语句导入gopl.io/ch2/tempconv包，然后就可以使用下面的代码进行转换了：\nfmt.Println(tempconv.CToF(tempconv.BoilingC)) // \u0026#34;212°F\u0026#34; 在每个源文件的包声明前紧跟着的注释是包注释（§10.7.4）。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。\n练习 2.1： 向tempconv包添加类型、常量和函数用来处理Kelvin绝对温度的转换，Kelvin 绝对零度是−273.15°C，Kelvin绝对温度1K和摄氏度1°C的单位间隔是一样的。\n"});index.add({'id':141,'href':'/docs/The-Go-Programming-Language/3.-Basic-Data-Types/3.6.-Constants/','title':"3.6. 常量",'section':"3. 基础数据类型",'content':"3.6. 常量 #  常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。\n一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。例如，常量比变量更适合用于表达像π之类的数学常数，因为它们的值不会发生变化：\nconst pi = 3.14159 // approximately; math.Pi is a better approximation 和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量：\nconst ( e = 2.71828182845904523536028747135266249775724709369995957496696763 pi = 3.14159265358979323846264338327950288419716939937510582097494459 ) 所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。\n常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof（§13.1）。\n因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：\nconst IPv4Len = 4 // parseIPv4 parses an IPv4 address (d.d.d.d). func parseIPv4(s string) IP { var p [IPv4Len]byte // ... } 一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，time.Duration是一个命名类型，底层类型是int64，time.Minute是对应类型的常量。下面声明的两个常量都是time.Duration类型，可以通过%T参数打印类型信息：\nconst noDelay time.Duration = 0 const timeout = 5 * time.Minute fmt.Printf(\u0026#34;%T %[1]v\\n\u0026#34;, noDelay) // \u0026#34;time.Duration 0\u0026#34; fmt.Printf(\u0026#34;%T %[1]v\\n\u0026#34;, timeout) // \u0026#34;time.Duration 5m0s\u0026#34; fmt.Printf(\u0026#34;%T %[1]v\\n\u0026#34;, time.Minute) // \u0026#34;time.Duration 1m0s\u0026#34; 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：\nconst ( a = 1 b c = 2 d ) fmt.Println(a, b, c, d) // \u0026#34;1 1 2 2\u0026#34; 如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是iota常量生成器语法。\n"});index.add({'id':142,'href':'/docs/The-Go-Programming-Language/4.-Composite-Types/4.6.-Text-and-HTML-Templates/','title':"4.6. 文本和HTML模板",'section':"4. 复合数据类型",'content':"4.6. 文本和HTML模板 #  前面的例子，只是最简单的格式化，使用Printf是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由text/template和html/template等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。\n一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的{{action}}对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：\n{% raw %}\ngopl.io/ch4/issuesreport\nconst templ = `{{.TotalCount}}issues: {{range .Items}}---------------------------------------- Number: {{.Number}}User: {{.User.Login}}Title: {{.Title | printf \u0026#34;%.64s\u0026#34;}}Age: {{.CreatedAt | daysAgo}}days {{end}}` {% endraw %}\n{% raw %}\n这个模板先打印匹配到的issue总数，然后打印每个issue的编号、创建用户、标题还有存在的时间。对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。当前值“.”最初被初始化为调用模板时的参数，在当前例子中对应github.IssuesSearchResult类型的变量。模板中{{.TotalCount}}对应action将展开为结构体中TotalCount成员以默认的方式打印的值。模板中{{range .Items}}和{{end}}对应一个循环action，因此它们之间的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。\n{% endraw %}\n在一个action中，|操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。对于Age部分，第二个动作是一个叫daysAgo的函数，通过time.Since函数将CreatedAt成员转换为过去的时间长度：\nfunc daysAgo(t time.Time) int { return int(time.Since(t).Hours() / 24) } 需要注意的是CreatedAt的参数类型是time.Time，并不是字符串。以同样的方式，我们可以通过定义一些方法来控制字符串的格式化（§2.5），一个类型同样可以定制自己的JSON编码和解码行为。time.Time类型对应的JSON值是一个标准时间格式的字符串。\n生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。下面的代码创建并分析上面定义的模板templ。注意方法调用链的顺序：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。\nreport, err := template.New(\u0026#34;report\u0026#34;). Funcs(template.FuncMap{\u0026#34;daysAgo\u0026#34;: daysAgo}). Parse(templ) if err != nil { log.Fatal(err) } 因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。template.Must辅助函数可以简化这个致命错误的处理：它接受一个模板和一个error类型的参数，检测error是否为nil（如果不是nil则发出panic异常），然后返回传入的模板。我们将在5.9节再讨论这个话题。\n一旦模板已经创建、注册了daysAgo函数、并通过分析和检测，我们就可以使用github.IssuesSearchResult作为输入源、os.Stdout作为输出源来执行模板：\nvar report = template.Must(template.New(\u0026#34;issuelist\u0026#34;). Funcs(template.FuncMap{\u0026#34;daysAgo\u0026#34;: daysAgo}). Parse(templ)) func main() { result, err := github.SearchIssues(os.Args[1:]) if err != nil { log.Fatal(err) } if err := report.Execute(os.Stdout, result); err != nil { log.Fatal(err) } } 程序输出一个纯文本报告：\n$ go build gopl.io/ch4/issuesreport $ ./issuesreport repo:golang/go is:open json decoder 13 issues: ---------------------------------------- Number: 5680 User: eaigner Title: encoding/json: set key converter on en/decoder Age: 750 days ---------------------------------------- Number: 6050 User: gopherbot Title: encoding/json: provide tokenizer Age: 695 days ---------------------------------------- ... 现在让我们转到html/template模板包。它使用和text/template包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。这个特性还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。\n下面的模板以HTML格式输出issue列表。注意import语句的不同：\n{% raw %}\ngopl.io/ch4/issueshtml\nimport \u0026#34;html/template\u0026#34; var issueList = template.Must(template.New(\u0026#34;issuelist\u0026#34;).Parse(` \u0026lt;h1\u0026gt;{{.TotalCount}}issues\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr style=\u0026#39;text-align: left\u0026#39;\u0026gt; \u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;State\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;User\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Title\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {{range .Items}}\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#39;{{.HTMLURL}}\u0026#39;\u0026gt;{{.Number}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{.State}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#39;{{.User.HTMLURL}}\u0026#39;\u0026gt;{{.User.Login}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#39;{{.HTMLURL}}\u0026#39;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {{end}}\u0026lt;/table\u0026gt; `)) {% endraw %}\n下面的命令将在新的模板上执行一个稍微不同的查询：\n$ go build gopl.io/ch4/issueshtml $ ./issueshtml repo:golang/go commenter:gopherbot json encoder \u0026gt;issues.html 图4.4显示了在web浏览器中的效果图。每个issue包含到Github对应页面的链接。\n 图4.4中issue没有包含会对HTML格式产生冲突的特殊字符，但是我们马上将看到标题中含有\u0026amp;和\u0026lt;字符的issue。下面的命令选择了两个这样的issue：\n$ ./issueshtml repo:golang/go 3133 10535 \u0026gt;issues2.html 图4.5显示了该查询的结果。注意，html/template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text/template包的话，这2个issue将会产生错误，其中“\u0026amp;lt;”四个字符将会被当作小于字符“\u0026lt;”处理，同时“\u0026lt;link\u0026gt;”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。\n我们也可以通过对信任的HTML字符串使用template.HTML类型来抑制这种自动转义的行为。还有很多采用类型命名的字符串类型分别对应信任的JavaScript、CSS和URL。下面的程序演示了两个使用不同类型的相同字符串产生的不同结果：A是一个普通字符串，B是一个信任的template.HTML字符串类型。\n {% raw %}\ngopl.io/ch4/autoescape\nfunc main() { const templ = `\u0026lt;p\u0026gt;A: {{.A}}\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;B: {{.B}}\u0026lt;/p\u0026gt;` t := template.Must(template.New(\u0026#34;escape\u0026#34;).Parse(templ)) var data struct { A string // untrusted plain text \tB template.HTML // trusted HTML \t} data.A = \u0026#34;\u0026lt;b\u0026gt;Hello!\u0026lt;/b\u0026gt;\u0026#34; data.B = \u0026#34;\u0026lt;b\u0026gt;Hello!\u0026lt;/b\u0026gt;\u0026#34; if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } {% endraw %}\n图4.6显示了出现在浏览器中的模板输出。我们看到A的黑体标记被转义失效了，但是B没有。\n 我们这里只讲述了模板系统中最基本的特性。一如既往，如果想了解更多的信息，请自己查看包文档：\n$ go doc text/template $ go doc html/template 练习 4.14： 创建一个web服务器，查询一次GitHub，然后生成BUG报告、里程碑和对应的用户信息。\n"});index.add({'id':143,'href':'/docs/The-Go-Programming-Language/5.-Functions/','title':"5. 函数",'section':"Go语言圣经",'content':"第五章　函数 #  函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用。函数的机制可以让我们将一个大的工作分解为小的任务，这样的小任务可以让不同程序员在不同时间、不同地方独立完成。一个函数同时对用户隐藏了其实现细节。由于这些因素，对于任何编程语言来说，函数都是一个至关重要的部分。\n我们已经见过许多函数了。现在，让我们多花一点时间来彻底地讨论函数特性。本章的运行示例是一个网络蜘蛛，也就是web搜索引擎中负责抓取网页部分的组件，它们根据抓取网页中的链接继续抓取链接指向的页面。一个网络蜘蛛的例子给我们足够的机会去探索递归函数、匿名函数、错误处理和函数其它的很多特性。\n"});index.add({'id':144,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.6.-Anonymous-Functions/','title':"5.6. 匿名函数",'section':"5. 函数",'content':"5.6. 匿名函数 #  拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。\n函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对strings.Map的调用：\nstrings.Map(func(r rune) rune { return r + 1 }, \u0026#34;HAL-9000\u0026#34;) 更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：\ngopl.io/ch5/squares\n// squares返回一个匿名函数。 // 该匿名函数每次被调用时都会返回下一个数的平方。 func squares() func() int { var x int return func() int { x++ return x * x } } func main() { f := squares() fmt.Println(f()) // \u0026#34;1\u0026#34; \tfmt.Println(f()) // \u0026#34;4\u0026#34; \tfmt.Println(f()) // \u0026#34;9\u0026#34; \tfmt.Println(f()) // \u0026#34;16\u0026#34; } 函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。\nsquares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。\n通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。\n接下来，我们讨论一个有点学术性的例子，考虑这样一个问题：给定一些计算机课程，每个课程都有前置课程，只有完成了前置课程才可以开始当前课程的学习；我们的目标是选择出一组课程，这组课程必须确保按顺序学习时，能全部被完成。每个课程的前置课程如下：\ngopl.io/ch5/toposort\n// prereqs记录了每个课程的前置课程 var prereqs = map[string][]string{ \u0026#34;algorithms\u0026#34;: {\u0026#34;data structures\u0026#34;}, \u0026#34;calculus\u0026#34;: {\u0026#34;linear algebra\u0026#34;}, \u0026#34;compilers\u0026#34;: { \u0026#34;data structures\u0026#34;, \u0026#34;formal languages\u0026#34;, \u0026#34;computer organization\u0026#34;, }, \u0026#34;data structures\u0026#34;: {\u0026#34;discrete math\u0026#34;}, \u0026#34;databases\u0026#34;: {\u0026#34;data structures\u0026#34;}, \u0026#34;discrete math\u0026#34;: {\u0026#34;intro to programming\u0026#34;}, \u0026#34;formal languages\u0026#34;: {\u0026#34;discrete math\u0026#34;}, \u0026#34;networks\u0026#34;: {\u0026#34;operating systems\u0026#34;}, \u0026#34;operating systems\u0026#34;: {\u0026#34;data structures\u0026#34;, \u0026#34;computer organization\u0026#34;}, \u0026#34;programming languages\u0026#34;: {\u0026#34;data structures\u0026#34;, \u0026#34;computer organization\u0026#34;}, } 这类问题被称作拓扑排序。从概念上说，前置条件可以构成有向图。图中的顶点表示课程，边表示课程间的依赖关系。显然，图中应该无环，这也就是说从某点出发的边，最终不会回到该点。下面的代码用深度优先搜索了整张图，获得了符合要求的课程序列。\nfunc main() { for i, course := range topoSort(prereqs) { fmt.Printf(\u0026#34;%d:\\t%s\\n\u0026#34;, i+1, course) } } func topoSort(m map[string][]string) []string { var order []string seen := make(map[string]bool) var visitAll func(items []string) visitAll = func(items []string) { for _, item := range items { if !seen[item] { seen[item] = true visitAll(m[item]) order = append(order, item) } } } var keys []string for key := range m { keys = append(keys, key) } sort.Strings(keys) visitAll(keys) return order } 当匿名函数需要被递归调用时，我们必须首先声明一个变量（在上面的例子中，我们首先声明了 visitAll），再将匿名函数赋值给这个变量。如果不分成两步，函数字面量无法与visitAll绑定，我们也无法递归调用该匿名函数。\nvisitAll := func(items []string) { // ... \tvisitAll(m[item]) // compile error: undefined: visitAll \t// ... } 在toposort程序的输出如下所示，它的输出顺序是大多人想看到的固定顺序输出，但是这需要我们多花点心思才能做到。哈希表prepreqs的value是遍历顺序固定的切片，而不再试遍历顺序随机的map，所以我们对prereqs的key值进行排序，保证每次运行toposort程序，都以相同的遍历顺序遍历prereqs。\n1: intro to programming 2: discrete math 3: data structures 4: algorithms 5: linear algebra 6: calculus 7: formal languages 8: computer organization 9: compilers 10: databases 11: operating systems 12: networks 13: programming languages 让我们回到findLinks这个例子。我们将代码移动到了links包下，将函数重命名为Extract，在第八章我们会再次用到这个函数。新的匿名函数被引入，用于替换原来的visit函数。该匿名函数负责将新连接添加到切片中。在Extract中，使用forEachNode遍历HTML页面，由于Extract只需要在遍历结点前操作结点，所以forEachNode的post参数被传入nil。\ngopl.io/ch5/links\n// Package links provides a link-extraction function. package links import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;golang.org/x/net/html\u0026#34; ) // Extract makes an HTTP GET request to the specified URL, parses // the response as HTML, and returns the links in the HTML document. func Extract(url string) ([]string, error) { resp, err := http.Get(url) if err != nil { return nil, err } if resp.StatusCode != http.StatusOK { resp.Body.Close() return nil, fmt.Errorf(\u0026#34;getting %s: %s\u0026#34;, url, resp.Status) } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return nil, fmt.Errorf(\u0026#34;parsing %s as HTML: %v\u0026#34;, url, err) } var links []string visitNode := func(n *html.Node) { if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data == \u0026#34;a\u0026#34; { for _, a := range n.Attr { if a.Key != \u0026#34;href\u0026#34; { continue } link, err := resp.Request.URL.Parse(a.Val) if err != nil { continue // ignore bad URLs \t} links = append(links, link.String()) } } } forEachNode(doc, visitNode, nil) return links, nil } 上面的代码对之前的版本做了改进，现在links中存储的不是href属性的原始值，而是通过resp.Request.URL解析后的值。解析后，这些连接以绝对路径的形式存在，可以直接被http.Get访问。\n网页抓取的核心问题就是如何遍历图。在topoSort的例子中，已经展示了深度优先遍历，在网页抓取中，我们会展示如何用广度优先遍历图。在第8章，我们会介绍如何将深度优先和广度优先结合使用。\n下面的函数实现了广度优先算法。调用者需要输入一个初始的待访问列表和一个函数f。待访问列表中的每个元素被定义为string类型。广度优先算法会为每个元素调用一次f。每次f执行完毕后，会返回一组待访问元素。这些元素会被加入到待访问列表中。当待访问列表中的所有元素都被访问后，breadthFirst函数运行结束。为了避免同一个元素被访问两次，代码中维护了一个map。\ngopl.io/ch5/findlinks3\n// breadthFirst calls f for each item in the worklist. // Any items returned by f are added to the worklist. // f is called at most once for each item. func breadthFirst(f func(item string) []string, worklist []string) { seen := make(map[string]bool) for len(worklist) \u0026gt; 0 { items := worklist worklist = nil for _, item := range items { if !seen[item] { seen[item] = true worklist = append(worklist, f(item)...) } } } } 就像我们在章节3解释的那样，append的参数“f(item)\u0026hellip;”，会将f返回的一组元素一个个添加到worklist中。\n在我们网页抓取器中，元素的类型是url。crawl函数会将URL输出，提取其中的新链接，并将这些新链接返回。我们会将crawl作为参数传递给breadthFirst。\nfunc crawl(url string) []string { fmt.Println(url) list, err := links.Extract(url) if err != nil { log.Print(err) } return list } 为了使抓取器开始运行，我们用命令行输入的参数作为初始的待访问url。\nfunc main() { // Crawl the web breadth-first, \t// starting from the command-line arguments. \tbreadthFirst(crawl, os.Args[1:]) } 让我们从 https://golang.org 开始，下面是程序的输出结果：\n$ go build gopl.io/ch5/findlinks3 $ ./findlinks3 https://golang.org https://golang.org/ https://golang.org/doc/ https://golang.org/pkg/ https://golang.org/project/ https://code.google.com/p/go-tour/ https://golang.org/doc/code.html https://www.youtube.com/watch?v=XCsL89YtqCs http://research.swtch.com/gotour 当所有发现的链接都已经被访问或电脑的内存耗尽时，程序运行结束。\n练习5.10： 重写topoSort函数，用map代替切片并移除对key的排序代码。验证结果的正确性（结果不唯一）。\n练习5.11： 现在线性代数的老师把微积分设为了前置课程。完善topSort，使其能检测有向图中的环。\n练习5.12： gopl.io/ch5/outline2（5.5节）的startElement和endElement共用了全局变量depth，将它们修改为匿名函数，使其共享outline中的局部变量。\n练习5.13： 修改crawl，使其能保存发现的页面，必要时，可以创建目录来保存这些页面。只保存来自原始域名下的页面。假设初始页面在golang.org下，就不要保存vimeo.com下的页面。\n练习5.14： 使用breadthFirst遍历其他数据结构。比如，topoSort例子中的课程依赖关系（有向图）、个人计算机的文件层次结构（树）；你所在城市的公交或地铁线路（无向图）。\n"});index.add({'id':145,'href':'/docs/The-Go-Programming-Language/6.-Methods/6.6.-Encapsulation/','title':"6.6. 封装",'section':"6. 方法",'content':"6.6. 封装 #  一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。\nGo语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。\n这也就是前面的小节中IntSet被定义为struct类型的原因，尽管它只有一个字段：\ntype IntSet struct { words []uint64 } 当然，我们也可以把IntSet定义为一个slice类型，但这样我们就需要把代码中所有方法里用到的s.words用*s替换掉了：\ntype IntSet []uint64 尽管这个版本的IntSet在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个slice。换句话说，相对于*s这个表达式会出现在所有的包中，s.words只需要在定义IntSet的包中出现（译注：所以还是推荐后者吧的意思）。\n这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。\n封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。\n第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。\n把bytes.Buffer这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为Buffer是一个struct类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer和其增长算法我们列在这里，为了简洁性稍微做了一些精简：\ntype Buffer struct { buf []byte initial [64]byte /* ... */ } // Grow expands the buffer\u0026#39;s capacity, if necessary, // to guarantee space for another n bytes. [...] func (b *Buffer) Grow(n int) { if b.buf == nil { b.buf = b.initial[:0] // use preallocated space initially  } if len(b.buf)+n \u0026gt; cap(b.buf) { buf := make([]byte, b.Len(), 2*cap(b.buf) + n) copy(buf, b.buf) b.buf = buf } } 封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的Counter类型允许调用方来增加counter变量的值，并且允许将这个值reset为0，但是不允许随便设置这个值（译注：因为压根就访问不到）：\ntype Counter struct { n int } func (c *Counter) N() int { return c.n } func (c *Counter) Increment() { c.n++ } func (c *Counter) Reset() { c.n = 0 } 只用来访问或修改内部变量的函数被称为setter或者getter，例子如下，比如log包里的Logger类型对应的一些函数。在命名一个getter方法时，我们通常会省略掉前面的Get前缀。这种简洁上的偏好也可以推广到各种类型的前缀比如Fetch，Find或者Lookup。\npackage log type Logger struct { flags int prefix string // ... } func (l *Logger) Flags() int func (l *Logger) SetFlags(flag int) func (l *Logger) Prefix() string func (l *Logger) SetPrefix(prefix string) Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。\n封装并不总是理想的。 虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：time.Duration将其表现暴露为一个int64数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：\nconst day = 24 * time.Hour fmt.Println(day.Seconds()) // \u0026#34;86400\u0026#34; 另一个例子，将IntSet和本章开头的geometry.Path进行对比。Path被定义为一个slice类型，这允许其调用slice的字面方法来对其内部的points用range进行迭代遍历；在这一点上，IntSet是没有办法让你这么做的。\n这两种类型决定性的不同：geometry.Path的本质是一个坐标点的序列，不多也不少，我们可以预见到之后也并不会给他增加额外的字段，所以在geometry包中将Path暴露为一个slice。相比之下，IntSet仅仅是在这里用了一个[]uint64的slice。这个类型还可以用[]uint类型来表示，或者我们甚至可以用其它完全不同的占用更小内存空间的东西来表示这个集合，所以我们可能还会需要额外的字段来在这个类型中记录元素的个数。也正是因为这些原因，我们让IntSet对调用方不透明。\n在这章中，我们学到了如何将方法与命名类型进行组合，并且知道了如何调用这些方法。尽管方法对于OOP编程来说至关重要，但他们只是OOP编程里的半边天。为了完成OOP，我们还需要接口。Go里的接口会在下一章中介绍。\n"});index.add({'id':146,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.6.-Sorting-with-sort.Interface/','title':"7.6. sort.Interface接口",'section':"7. 接口",'content':"7.6. sort.Interface接口 #  排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要15行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。\n幸运的是，sort包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。相比之下，Go语言的sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。\n一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是sort.Interface的三个方法：\npackage sort type Interface interface { Len() int Less(i, j int) bool // i, j are indices of sequence elements \tSwap(i, j int) } 为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型StringSlice和它的Len，Less和Swap方法\ntype StringSlice []string func (p StringSlice) Len() int { return len(p) } func (p StringSlice) Less(i, j int) bool { return p[i] \u0026lt; p[j] } func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } 现在我们可以通过像下面这样将一个切片转换为一个StringSlice类型来进行排序：\nsort.Sort(StringSlice(names)) 这个转换得到一个相同长度，容量，和基于names数组的切片值；并且这个切片值的类型有三个排序需要的方法。\n对字符串切片的排序是很常用的需要，所以sort包提供了StringSlice类型，也提供了Strings函数能让上面这些调用简化成sort.Strings(names)。\n这里用到的技术很容易适用到其它排序序列中，例如我们可以忽略大小写或者含有的特殊字符。（本书使用Go程序对索引词和页码进行排序也用到了这个技术，对罗马数字做了额外逻辑处理。）对于更复杂的排序，我们使用相同的方法，但是会用更复杂的数据结构和更复杂地实现sort.Interface的方法。\n我们会运行上面的例子来对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。让我们看下每个点击会发生什么响应。\n下面的变量tracks包含了一个播放列表。（One of the authors apologizes for the other author’s musical tastes.）每个元素都不是Track本身而是指向它的指针。尽管我们在下面的代码中直接存储Tracks也可以工作，sort函数会交换很多对元素，所以如果每个元素都是指针而不是Track类型会更快，指针是一个机器字码长度而Track类型可能是八个或更多。\ngopl.io/ch7/sorting\ntype Track struct { Title string Artist string Album string Year int Length time.Duration } var tracks = []*Track{ {\u0026#34;Go\u0026#34;, \u0026#34;Delilah\u0026#34;, \u0026#34;From the Roots Up\u0026#34;, 2012, length(\u0026#34;3m38s\u0026#34;)}, {\u0026#34;Go\u0026#34;, \u0026#34;Moby\u0026#34;, \u0026#34;Moby\u0026#34;, 1992, length(\u0026#34;3m37s\u0026#34;)}, {\u0026#34;Go Ahead\u0026#34;, \u0026#34;Alicia Keys\u0026#34;, \u0026#34;As I Am\u0026#34;, 2007, length(\u0026#34;4m36s\u0026#34;)}, {\u0026#34;Ready 2 Go\u0026#34;, \u0026#34;Martin Solveig\u0026#34;, \u0026#34;Smash\u0026#34;, 2011, length(\u0026#34;4m24s\u0026#34;)}, } func length(s string) time.Duration { d, err := time.ParseDuration(s) if err != nil { panic(s) } return d } printTracks函数将播放列表打印成一个表格。一个图形化的展示可能会更好点，但是这个小程序使用text/tabwriter包来生成一个列整齐对齐和隔开的表格，像下面展示的这样。注意到*tabwriter.Writer是满足io.Writer接口的。它会收集每一片写向它的数据；它的Flush方法会格式化整个表格并且将它写向os.Stdout（标准输出）。\nfunc printTracks(tracks []*Track) { const format = \u0026#34;%v\\t%v\\t%v\\t%v\\t%v\\t\\n\u0026#34; tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, \u0026#39; \u0026#39;, 0) fmt.Fprintf(tw, format, \u0026#34;Title\u0026#34;, \u0026#34;Artist\u0026#34;, \u0026#34;Album\u0026#34;, \u0026#34;Year\u0026#34;, \u0026#34;Length\u0026#34;) fmt.Fprintf(tw, format, \u0026#34;-----\u0026#34;, \u0026#34;------\u0026#34;, \u0026#34;-----\u0026#34;, \u0026#34;----\u0026#34;, \u0026#34;------\u0026#34;) for _, t := range tracks { fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length) } tw.Flush() // calculate column widths and print table } 为了能按照Artist字段对播放列表进行排序，我们会像对StringSlice那样定义一个新的带有必须的Len，Less和Swap方法的切片类型。\ntype byArtist []*Track func (x byArtist) Len() int { return len(x) } func (x byArtist) Less(i, j int) bool { return x[i].Artist \u0026lt; x[j].Artist } func (x byArtist) Swap(i, j int) { x[i], x[j] = x[j], x[i] } 为了调用通用的排序程序，我们必须先将tracks转换为新的byArtist类型，它定义了具体的排序：\nsort.Sort(byArtist(tracks)) 在按照artist对这个切片进行排序后，printTrack的输出如下\nTitle Artist Album Year Length ----- ------ ----- ---- ------ Go Ahead Alicia Keys As I Am 2007 4m36s Go Delilah From the Roots Up 2012 3m38s Ready 2 Go Martin Solveig Smash 2011 4m24s Go Moby Moby 1992 3m37s 如果用户第二次请求“按照artist排序”，我们会对tracks进行逆向排序。然而我们不需要定义一个有颠倒Less方法的新类型byReverseArtist，因为sort包中提供了Reverse函数将排序顺序转换成逆序。\nsort.Sort(sort.Reverse(byArtist(tracks))) 在按照artist对这个切片进行逆向排序后，printTrack的输出如下\nTitle Artist Album Year Length ----- ------ ----- ---- ------ Go Moby Moby 1992 3m37s Ready 2 Go Martin Solveig Smash 2011 4m24s Go Delilah From the Roots Up 2012 3m38s Go Ahead Alicia Keys As I Am 2007 4m36s sort.Reverse函数值得进行更近一步的学习，因为它使用了（§6.3）章中的组合，这是一个重要的思路。sort包定义了一个不公开的struct类型reverse，它嵌入了一个sort.Interface。reverse的Less方法调用了内嵌的sort.Interface值的Less方法，但是通过交换索引的方式使排序结果变成逆序。\npackage sort type reverse struct{ Interface } // that is, sort.Interface  func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } func Reverse(data Interface) Interface { return reverse{data} } reverse的另外两个方法Len和Swap隐式地由原有内嵌的sort.Interface提供。因为reverse是一个不公开的类型，所以导出函数Reverse返回一个包含原有sort.Interface值的reverse类型实例。\n为了可以按照不同的列进行排序，我们必须定义一个新的类型例如byYear：\ntype byYear []*Track func (x byYear) Len() int { return len(x) } func (x byYear) Less(i, j int) bool { return x[i].Year \u0026lt; x[j].Year } func (x byYear) Swap(i, j int) { x[i], x[j] = x[j], x[i] } 在使用sort.Sort(byYear(tracks))按照年对tracks进行排序后，printTrack展示了一个按时间先后顺序的列表：\nTitle Artist Album Year Length ----- ------ ----- ---- ------ Go Moby Moby 1992 3m37s Go Ahead Alicia Keys As I Am 2007 4m36s Ready 2 Go Martin Solveig Smash 2011 4m24s Go Delilah From the Roots Up 2012 3m38s 对于我们需要的每个切片元素类型和每个排序函数，我们需要定义一个新的sort.Interface实现。如你所见，Len和Swap方法对于所有的切片类型都有相同的定义。下个例子，具体的类型customSort会将一个切片和函数结合，使我们只需要写比较函数就可以定义一个新的排序。顺便说下，实现了sort.Interface的具体类型不一定是切片类型；customSort是一个结构体类型。\ntype customSort struct { t []*Track less func(x, y *Track) bool } func (x customSort) Len() int { return len(x.t) } func (x customSort) Less(i, j int) bool { return x.less(x.t[i], x.t[j]) } func (x customSort) Swap(i, j int)\t{ x.t[i], x.t[j] = x.t[j], x.t[i] } 让我们定义一个多层的排序函数，它主要的排序键是标题，第二个键是年，第三个键是运行时间Length。下面是该排序的调用，其中这个排序使用了匿名排序函数：\nsort.Sort(customSort{tracks, func(x, y *Track) bool { if x.Title != y.Title { return x.Title \u0026lt; y.Title } if x.Year != y.Year { return x.Year \u0026lt; y.Year } if x.Length != y.Length { return x.Length \u0026lt; y.Length } return false }}) 这下面是排序的结果。注意到两个标题是“Go”的track按照标题排序是相同的顺序，但是在按照year排序上更久的那个track优先。\nTitle Artist Album Year Length ----- ------ ----- ---- ------ Go Moby Moby 1992 3m37s Go Delilah From the Roots Up 2012 3m38s Go Ahead Alicia Keys As I Am 2007 4m36s Ready 2 Go Martin Solveig Smash 2011 4m24s 尽管对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。sort包中的IsSorted函数帮我们做这样的检查。像sort.Sort一样，它也使用sort.Interface对这个序列和它的排序函数进行抽象，但是它从不会调用Swap方法：这段代码示范了IntsAreSorted和Ints函数在IntSlice类型上的使用：\nvalues := []int{3, 1, 4, 1} fmt.Println(sort.IntsAreSorted(values)) // \u0026#34;false\u0026#34; sort.Ints(values) fmt.Println(values) // \u0026#34;[1 1 3 4]\u0026#34; fmt.Println(sort.IntsAreSorted(values)) // \u0026#34;true\u0026#34; sort.Sort(sort.Reverse(sort.IntSlice(values))) fmt.Println(values) // \u0026#34;[4 3 1 1]\u0026#34; fmt.Println(sort.IntsAreSorted(values)) // \u0026#34;false\u0026#34; 为了使用方便，sort包为[]int、[]string和[]float64的正常排序提供了特定版本的函数和类型。对于其他类型，例如[]int64或者[]uint，尽管路径也很简单，还是依赖我们自己实现。\n练习 7.8： 很多图形界面提供了一个有状态的多重排序表格插件：主要的排序键是最近一次点击过列头的列，第二个排序键是第二最近点击过列头的列，等等。定义一个sort.Interface的实现用在这样的表格中。比较这个实现方式和重复使用sort.Stable来排序的方式。\n练习 7.9： 使用html/template包（§4.6）替代printTracks将tracks展示成一个HTML表格。将这个解决方案用在前一个练习中，让每次点击一个列的头部产生一个HTTP请求来排序这个表格。\n练习 7.10： sort.Interface类型也可以适用在其它地方。编写一个IsPalindrome(s sort.Interface) bool函数表明序列s是否是回文序列，换句话说反向排序不会改变这个序列。假设如果!s.Less(i, j) \u0026amp;\u0026amp; !s.Less(j, i)则索引i和j上的元素相等。\n"});index.add({'id':147,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.6.-Example-Concurrent-Web-Crawler/','title':"8.6. 示例: 并发的Web爬虫",'section':"8. Goroutines和Channels",'content':"8.6. 示例: 并发的Web爬虫 #  在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。\ngopl.io/ch8/crawl1\nfunc crawl(url string) []string { fmt.Println(url) list, err := links.Extract(url) if err != nil { log.Print(err) } return list } 主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。\nfunc main() { worklist := make(chan []string) // Start with the command-line arguments. \tgo func() { worklist \u0026lt;- os.Args[1:] }() // Crawl the web concurrently. \tseen := make(map[string]bool) for list := range worklist { for _, link := range list { if !seen[link] { seen[link] = true go func(link string) { worklist \u0026lt;- crawl(link) }(link) } } } } 注意这里的crawl所在的goroutine会将link作为一个显式的参数传入，来避免“循环变量快照”的问题（在5.6.1中有讲解）。另外注意这里将命令行参数传入worklist也是在一个另外的goroutine中进行的，这是为了避免channel两端的main goroutine与crawler goroutine都尝试向对方发送内容，却没有一端接收内容时发生死锁。当然，这里我们也可以用buffered channel来解决问题，这里不再赘述。\n现在爬虫可以高并发地运行起来，并且可以产生一大坨的URL了，不过还是会有俩问题。一个问题是在运行一段时间后可能会出现在log的错误信息里的：\n$ go build gopl.io/ch8/crawl1 $ ./crawl1 http://gopl.io/ http://gopl.io/ https://golang.org/help/ https://golang.org/doc/ https://golang.org/blog/ ... 2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host 2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files ... 最初的错误信息是一个让人莫名的DNS查找失败，即使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，既而导致了在调用net.Dial像DNS查找失败这样的问题。\n这个程序实在是太他妈并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一些个限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对links.Extract在同一时间最多不会有超过n次调用，这里的n一般小于文件描述符的上限值，比如20。这和一个夜店里限制客人数目是一个道理，只有当有客人离开时，才会允许新的客人进入店内。\n我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。从概念上讲，channel里的n个空槽代表n个可以处理内容的token（通行证），从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。（这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧。）由于channel里的元素类型并不重要，我们用一个零值的struct{}来作为其元素。\n让我们重写crawl函数，将对links.Extract的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。\ngopl.io/ch8/crawl2\n// tokens is a counting semaphore used to // enforce a limit of 20 concurrent requests. var tokens = make(chan struct{}, 20) func crawl(url string) []string { fmt.Println(url) tokens \u0026lt;- struct{}{} // acquire a token \tlist, err := links.Extract(url) \u0026lt;-tokens // release the token \tif err != nil { log.Print(err) } return list } 第二个问题是这个程序永远都不会终止，即使它已经爬到了所有初始链接衍生出的链接。（当然，除非你慎重地选择了合适的初始化URL或者已经实现了练习8.6中的深度限制，你应该还没有意识到这个问题。）为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。\nfunc main() { worklist := make(chan []string) var n int // number of pending sends to worklist  // Start with the command-line arguments. \tn++ go func() { worklist \u0026lt;- os.Args[1:] }() // Crawl the web concurrently. \tseen := make(map[string]bool) for ; n \u0026gt; 0; n-- { list := \u0026lt;-worklist for _, link := range list { if !seen[link] { seen[link] = true n++ go func(link string) { worklist \u0026lt;- crawl(link) }(link) } } } } 这个版本中，计数器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会对n进行++操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次++操作。这里的操作++是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。\n现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。\n下面的程序是避免过度并发的另一种思路。这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个常驻的crawler goroutine，这样来保证最多20个HTTP请求在并发。\nfunc main() { worklist := make(chan []string) // lists of URLs, may have duplicates \tunseenLinks := make(chan string) // de-duplicated URLs  // Add command-line arguments to worklist. \tgo func() { worklist \u0026lt;- os.Args[1:] }() // Create 20 crawler goroutines to fetch each unseen link. \tfor i := 0; i \u0026lt; 20; i++ { go func() { for link := range unseenLinks { foundLinks := crawl(link) go func() { worklist \u0026lt;- foundLinks }() } }() } // The main goroutine de-duplicates worklist items \t// and sends the unseen ones to the crawlers. \tseen := make(map[string]bool) for list := range worklist { for _, link := range list { if !seen[link] { seen[link] = true unseenLinks \u0026lt;- link } } } } 所有的爬虫goroutine现在都是被同一个channel - unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。\nseen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。例如，内部变量不能够在函数外部被访问到；变量（§2.3.4）在没有发生变量逃逸（译注：局部变量被全局变量引用地址导致变量被分配在堆上）的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。\ncrawl函数爬到的链接在一个专有的goroutine中被发送到worklist中来避免死锁。为了节省篇幅，这个例子的终止问题我们先不进行详细阐述了。\n练习 8.6： 为并发爬虫增加深度限制。也就是说，如果用户设置了depth=3，那么只有从首页跳转三次以内能够跳到的页面才能被抓取到。\n练习 8.7： 完成一个并发程序来创建一个线上网站的本地镜像，把该站点的所有可达的页面都抓取到本地硬盘。为了省事，我们这里可以只取出现在该域下的所有页面（比如golang.org开头，译注：外链的应该就不算了。）当然了，出现在页面里的链接你也需要进行一些处理，使其能够在你的镜像站点上进行跳转，而不是指向原始的链接。\n译注： 拓展阅读 Handling 1 Million Requests per Minute with Go。\n"});index.add({'id':148,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.6.-The-Race-Detector/','title':"9.6. 竞争条件检测",'section':"9. 基于共享变量的并发",'content':"9.6. 竞争条件检测 #  即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器（the race detector）。\n只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。（完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：https://golang.org/ref/mem ）\n竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。\n竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。\n由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的程序（工作）来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。（译注：多少服务端C和C++程序员为此竞折腰。）\n"});index.add({'id':149,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.7.-A-Web-Server/','title':"1.7. Web服务",'section':"1. 入门",'content':"1.7. Web服务 #  Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 http://localhost:8000/hello ，那么响应是URL.Path = \u0026ldquo;hello\u0026rdquo;。\ngopl.io/ch1/server1\n// Server1 is a minimal \u0026#34;echo\u0026#34; server. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) // each request calls handler \tlog.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } // handler echoes the Path component of the request URL r. func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } 我们只用了八九行代码就实现了一个Web服务程序，这都是多亏了标准库里的方法已经帮我们完成了大量工作。main函数将所有发送到/路径下的请求和handler函数关联起来，/开头的请求其实就是所有发送到当前站点上的请求，服务监听8000端口。发送到这个服务的“请求”是一个http.Request类型的对象，这个对象中包含了请求中的一系列相关字段，其中就包括我们需要的URL。当请求到达服务器时，这个请求会被传给handler函数来处理，这个函数会将/hello这个路径从请求的URL中解析出来，然后把其发送到响应中，这里我们用的是标准输出流的fmt.Fprintf。Web服务会在第7.7节中做更详细的阐述。\n让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个\u0026amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。\n$ go run src/gopl.io/ch1/server1/main.go \u0026amp; 现在可以通过命令行来发送客户端请求了：\n$ go build gopl.io/ch1/fetch $ ./fetch http://localhost:8000 URL.Path = \u0026quot;/\u0026quot; $ ./fetch http://localhost:8000/help URL.Path = \u0026quot;/help\u0026quot; 还可以直接在浏览器里访问这个URL，然后得到返回结果，如图1.2：\n 在这个服务的基础上叠加特性是很容易的。一种比较实用的修改是为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算；对URL的请求结果会包含各种URL被访问的总次数，直接对/count这个URL的访问要除外。\ngopl.io/ch1/server2\n// Server2 is a minimal \u0026#34;echo\u0026#34; and counter server. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; ) var mu sync.Mutex var count int func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/count\u0026#34;, counter) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } // handler echoes the Path component of the requested URL. func handler(w http.ResponseWriter, r *http.Request) { mu.Lock() count++ mu.Unlock() fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } // counter echoes the number of calls so far. func counter(w http.ResponseWriter, r *http.Request) { mu.Lock() fmt.Fprintf(w, \u0026#34;Count %d\\n\u0026#34;, count) mu.Unlock() } 这个服务器有两个请求处理函数，根据请求的url不同会调用不同的函数：对/count这个url的请求会调用到counter这个函数，其它的url都会调用默认的处理函数。如果你的请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。在这些代码的背后，服务器每一次接收请求处理时都会另起一个goroutine，这样服务器就可以同一时间处理多个请求。然而在并发情况下，假如真的有两个请求同一时刻去更新count，那么这个值可能并不会被正确地增加；这个程序可能会引发一个严重的bug：竞态条件（参见9.1）。为了避免这个问题，我们必须保证每次修改变量的最多只能有一个goroutine，这也就是代码里的mu.Lock()和mu.Unlock()调用将修改count的所有行为包在中间的目的。第九章中我们会进一步讲解共享变量。\n下面是一个更为丰富的例子，handler函数会把请求的http头和请求的form数据都打印出来，这样可以使检查和调试这个服务更为方便：\ngopl.io/ch1/server3\n// handler echoes the HTTP request. func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;%s %s %s\\n\u0026#34;, r.Method, r.URL, r.Proto) for k, v := range r.Header { fmt.Fprintf(w, \u0026#34;Header[%q] = %q\\n\u0026#34;, k, v) } fmt.Fprintf(w, \u0026#34;Host = %q\\n\u0026#34;, r.Host) fmt.Fprintf(w, \u0026#34;RemoteAddr = %q\\n\u0026#34;, r.RemoteAddr) if err := r.ParseForm(); err != nil { log.Print(err) } for k, v := range r.Form { fmt.Fprintf(w, \u0026#34;Form[%q] = %q\\n\u0026#34;, k, v) } } 我们用http.Request这个struct里的字段来输出下面这样的内容：\nGET /?q=query HTTP/1.1 Header[\u0026quot;Accept-Encoding\u0026quot;] = [\u0026quot;gzip, deflate, sdch\u0026quot;] Header[\u0026quot;Accept-Language\u0026quot;] = [\u0026quot;en-US,en;q=0.8\u0026quot;] Header[\u0026quot;Connection\u0026quot;] = [\u0026quot;keep-alive\u0026quot;] Header[\u0026quot;Accept\u0026quot;] = [\u0026quot;text/html,application/xhtml+xml,application/xml;...\u0026quot;] Header[\u0026quot;User-Agent\u0026quot;] = [\u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5)...\u0026quot;] Host = \u0026quot;localhost:8000\u0026quot; RemoteAddr = \u0026quot;127.0.0.1:59911\u0026quot; Form[\u0026quot;q\u0026quot;] = [\u0026quot;query\u0026quot;] 可以看到这里的ParseForm被嵌套在了if语句中。Go语言允许这样的一个简单的语句结果作为局部的变量声明出现在if语句的最前面，这一点对错误处理很有用处。我们还可以像下面这样写（当然看起来就长了一些）：\nerr := r.ParseForm() if err != nil { log.Print(err) } 用if和ParseForm结合可以让代码更加简单，并且可以限制err这个变量的作用域，这么做是很不错的。我们会在2.7节中讲解作用域。\n在这些程序中，我们看到了很多不同的类型被输出到标准输出流中。比如前面的fetch程序，把HTTP的响应数据拷贝到了os.Stdout，lissajous程序里我们输出的是一个文件。fetchall程序则完全忽略到了HTTP的响应Body，只是计算了一下响应Body的大小，这个程序中把响应Body拷贝到了ioutil.Discard。在本节的web服务器程序中则是用fmt.Fprintf直接写到了http.ResponseWriter中。\n尽管三种具体的实现流程并不太一样，他们都实现一个共同的接口，即当它们被调用需要一个标准流输出时都可以满足。这个接口叫作io.Writer，在7.1节中会详细讨论。\nGo语言的接口机制会在第7章中讲解，为了在这里简单说明接口能做什么，让我们简单地将这里的web服务器和之前写的lissajous函数结合起来，这样GIF动画可以被写到HTTP的客户端，而不是之前的标准输出流。只要在web服务器的代码里加入下面这几行。\nhandler := func(w http.ResponseWriter, r *http.Request) { lissajous(w) } http.HandleFunc(\u0026#34;/\u0026#34;, handler) 或者另一种等价形式：\nhttp.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { lissajous(w) }) HandleFunc函数的第二个参数是一个函数的字面值，也就是一个在使用时定义的匿名函数。这些内容我们会在5.6节中讲解。\n做完这些修改之后，在浏览器里访问 http://localhost:8000 。每次你载入这个页面都可以看到一个像图1.3那样的动画。\n 练习 1.12： 修改Lissajour服务，从URL读取变量，比如你可以访问 http://localhost:8000/?cycles=20 这个URL，这样访问可以将程序里的cycles默认的5修改为20。字符串转换为数字可以调用strconv.Atoi函数。你可以在godoc里查看strconv.Atoi的详细说明。\n"});index.add({'id':150,'href':'/docs/Clean-Code/1.-Clean-Code/1.7.-Prequel-and-Principles/','title':"1.7. 前传与原则",'section':"1. 整洁代码",'content':"1.7 前传与原则 #  In many ways this book is a “prequel” to a book I wrote in 2002 entitled Agile Software Development: Principles, Patterns, and Practices (PPP). The PPP book concerns itself with the principles of object-oriented design, and many of the practices used by professional developers. If you have not read PPP, then you may find that it continues the story told by this book. If you have already read it, then you’ll find many of the sentiments of that book echoed in this one at the level of code.\n 从许多角度看，本书都是我 2002 年写那本 Agile SoftwareDevelopment：Principles，Patterns，and Practices（中译版《敏捷软件开发：原则、模式与实践》，简称 PPP）的“前传”。PPP 关注面向对象设计的原则，以及专业开发者采用的许多实践方法。假如你没读过 PPP，你会发现它像这本书的延续。如果你读过，会发现那本书的主张在代码层面于本书中回响。\n In this book you will find sporadic references to various principles of design. These include the Single Responsibility Principle (SRP), the Open Closed Principle (OCP), and the Dependency Inversion Principle (DIP) among others. These principles are described in depth in PPP.\n 在本书中，你会发现对不同设计原则的引用，包括单一权责原则（Single Responsibility Principle，SRP）、开放闭合原则（Open Closed Principle，OCP）和依赖倒置原则（Dependency Inversion Principle，DIP）等。\n "});index.add({'id':151,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/10.7.-The-Go-Tool/','title':"10.7. 工具",'section':"10. 包和工具",'content':"10.7. 工具 #  本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。\nGo语言的工具箱集合了一系列功能的命令集。它可以看作是一个包管理器（类似于Linux中的apt和rpm工具），用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和链接器构建程序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的驱动程序，我们将在第11章讨论测试话题。\nGo语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打的子命令，有一些我们经常用到，例如get、run、build和fmt等。你可以运行go或go help命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令：\n$ go ... build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fmt run gofmt on package sources get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages version print Go version vet run go tool vet on packages Use \u0026quot;go help [command]\u0026quot; for more information about a command. ... 为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码的仓库的远程服务器URL。\n"});index.add({'id':152,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.7.-Accessing-Struct-Field-Tags/','title':"12.7. 获取结构体字段标签",'section':"12. 反射",'content':"12.7. 获取结构体字段标签 #  在4.5节我们使用构体成员标签用于设置对应JSON对应的名字。其中json成员标签让我们可以选择成员的名字和抑制零值成员的输出。在本节，我们将看到如何通过反射机制类获取成员标签。\n对于一个web服务，大部分HTTP处理函数要做的第一件事情就是展开请求中的参数到本地变量中。我们定义了一个工具函数，叫params.Unpack，通过使用结构体成员标签机制来让HTTP处理函数解析请求参数更方便。\n首先，我们看看如何使用它。下面的search函数是一个HTTP请求处理函数。它定义了一个匿名结构体类型的变量，用结构体的每个成员表示HTTP请求的参数。其中结构体成员标签指明了对于请求参数的名字，为了减少URL的长度这些参数名通常都是神秘的缩略词。Unpack将请求参数填充到合适的结构体成员中，这样我们可以方便地通过合适的类型类来访问这些参数。\ngopl.io/ch12/search\nimport \u0026#34;gopl.io/ch12/params\u0026#34; // search implements the /search URL endpoint. func search(resp http.ResponseWriter, req *http.Request) { var data struct { Labels []string `http:\u0026#34;l\u0026#34;` MaxResults int `http:\u0026#34;max\u0026#34;` Exact bool `http:\u0026#34;x\u0026#34;` } data.MaxResults = 10 // set default \tif err := params.Unpack(req, \u0026amp;data); err != nil { http.Error(resp, err.Error(), http.StatusBadRequest) // 400 \treturn } // ...rest of handler... \tfmt.Fprintf(resp, \u0026#34;Search: %+v\\n\u0026#34;, data) } 下面的Unpack函数主要完成三件事情。第一，它调用req.ParseForm()来解析HTTP请求。然后，req.Form将包含所有的请求参数，不管HTTP客户端使用的是GET还是POST请求方法。\n下一步，Unpack函数将构建每个结构体成员有效参数名字到成员变量的映射。如果结构体成员有成员标签的话，有效参数名字可能和实际的成员名字不相同。reflect.Type的Field方法将返回一个reflect.StructField，里面含有每个成员的名字、类型和可选的成员标签等信息。其中成员标签信息对应reflect.StructTag类型的字符串，并且提供了Get方法用于解析和根据特定key提取的子串，例如这里的http:\u0026rdquo;\u0026hellip;\u0026ldquo;形式的子串。\ngopl.io/ch12/params\n// Unpack populates the fields of the struct pointed to by ptr // from the HTTP request parameters in req. func Unpack(req *http.Request, ptr interface{}) error { if err := req.ParseForm(); err != nil { return err } // Build map of fields keyed by effective name. \tfields := make(map[string]reflect.Value) v := reflect.ValueOf(ptr).Elem() // the struct variable \tfor i := 0; i \u0026lt; v.NumField(); i++ { fieldInfo := v.Type().Field(i) // a reflect.StructField \ttag := fieldInfo.Tag // a reflect.StructTag \tname := tag.Get(\u0026#34;http\u0026#34;) if name == \u0026#34;\u0026#34; { name = strings.ToLower(fieldInfo.Name) } fields[name] = v.Field(i) } // Update struct field for each parameter in the request. \tfor name, values := range req.Form { f := fields[name] if !f.IsValid() { continue // ignore unrecognized HTTP parameters \t} for _, value := range values { if f.Kind() == reflect.Slice { elem := reflect.New(f.Type().Elem()).Elem() if err := populate(elem, value); err != nil { return fmt.Errorf(\u0026#34;%s: %v\u0026#34;, name, err) } f.Set(reflect.Append(f, elem)) } else { if err := populate(f, value); err != nil { return fmt.Errorf(\u0026#34;%s: %v\u0026#34;, name, err) } } } } return nil } 最后，Unpack遍历HTTP请求的name/valu参数键值对，并且根据更新相应的结构体成员。回想一下，同一个名字的参数可能出现多次。如果发生这种情况，并且对应的结构体成员是一个slice，那么就将所有的参数添加到slice中。其它情况，对应的成员值将被覆盖，只有最后一次出现的参数值才是起作用的。\npopulate函数小心用请求的字符串类型参数值来填充单一的成员v（或者是slice类型成员中的单一的元素）。目前，它仅支持字符串、有符号整数和布尔型。其中其它的类型将留做练习任务。\nfunc populate(v reflect.Value, value string) error { switch v.Kind() { case reflect.String: v.SetString(value) case reflect.Int: i, err := strconv.ParseInt(value, 10, 64) if err != nil { return err } v.SetInt(i) case reflect.Bool: b, err := strconv.ParseBool(value) if err != nil { return err } v.SetBool(b) default: return fmt.Errorf(\u0026#34;unsupported kind %s\u0026#34;, v.Type()) } return nil } 如果我们上上面的处理程序添加到一个web服务器，则可以产生以下的会话：\n$ go build gopl.io/ch12/search $ ./search \u0026amp; $ ./fetch 'http://localhost:12345/search' Search: {Labels:[] MaxResults:10 Exact:false} $ ./fetch 'http://localhost:12345/search?l=golang\u0026amp;l=programming' Search: {Labels:[golang programming] MaxResults:10 Exact:false} $ ./fetch 'http://localhost:12345/search?l=golang\u0026amp;l=programming\u0026amp;max=100' Search: {Labels:[golang programming] MaxResults:100 Exact:false} $ ./fetch 'http://localhost:12345/search?x=true\u0026amp;l=golang\u0026amp;l=programming' Search: {Labels:[golang programming] MaxResults:10 Exact:true} $ ./fetch 'http://localhost:12345/search?q=hello\u0026amp;x=123' x: strconv.ParseBool: parsing \u0026quot;123\u0026quot;: invalid syntax $ ./fetch 'http://localhost:12345/search?q=hello\u0026amp;max=lots' max: strconv.ParseInt: parsing \u0026quot;lots\u0026quot;: invalid syntax 练习 12.11： 编写相应的Pack函数，给定一个结构体值，Pack函数将返回合并了所有结构体成员和值的URL。\n练习 12.12： 扩展成员标签以表示一个请求参数的有效值规则。例如，一个字符串可以是有效的email地址或一个信用卡号码，还有一个整数可能需要是有效的邮政编码。修改Unpack函数以检查这些规则。\n练习 12.13： 修改S表达式的编码器（§12.4）和解码器（§12.6），采用和encoding/json包（§4.5）类似的方式使用成员标签中的sexpr:\u0026rdquo;\u0026hellip;\u0026ldquo;字串。\n"});index.add({'id':153,'href':'/docs/The-Go-Programming-Language/2.-Program-Structure/2.7.-Scope/','title':"2.7. 作用域",'section':"2. 程序结构",'content':"2.7. 作用域 #  一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。\n不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。\n句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。\n声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。\n控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。\n一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。例如，你可以声明一个局部变量，和包级的变量同名。或者是像2.3.3节的例子那样，你可以将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。\n当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：\nfunc f() {} var g = \u0026#34;g\u0026#34; func main() { f := \u0026#34;f\u0026#34; fmt.Println(f) // \u0026#34;f\u0026#34;; local var f shadows package-level func f \tfmt.Println(g) // \u0026#34;g\u0026#34;; package-level var \tfmt.Println(h) // compile error: undefined: h } 在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。\nfunc main() { x := \u0026#34;hello!\u0026#34; for i := 0; i \u0026lt; len(x); i++ { x := x[i] if x != \u0026#39;!\u0026#39; { x := x + \u0026#39;A\u0026#39; - \u0026#39;a\u0026#39; fmt.Printf(\u0026#34;%c\u0026#34;, x) // \u0026#34;HELLO\u0026#34; (one letter per iteration) \t} } } 在x[i]和x + 'A' - 'a'声明语句的初始化的表达式中都引用了外部作用域声明的x变量，稍后我们会解释这个。（注意，后面的表达式与unicode.ToUpper并不等价。）\n正如上面例子所示，并不是所有的词法域都显式地对应到由花括弧包含的语句；还有一些隐含的规则。上面的for语句创建了两个词法域：花括弧包含的是显式的部分，是for的循环体部分词法域，另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（i++），当然也包含循环体词法域。\n下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：\nfunc main() { x := \u0026#34;hello\u0026#34; for _, x := range x { x := x + \u0026#39;A\u0026#39; - \u0026#39;a\u0026#39; fmt.Printf(\u0026#34;%c\u0026#34;, x) // \u0026#34;HELLO\u0026#34; (one letter per iteration) \t} } 和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：\nif x := f(); x == 0 { fmt.Println(x) } else if y := g(x); x == y { fmt.Println(x, y) } else { fmt.Println(x, y) } fmt.Println(x, y) // compile error: x and y are not visible here 第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后是每个分支的词法域。\n在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。\n在这个程序中：\nif f, err := os.Open(fname); err != nil { // compile error: unused: f \treturn err } f.ReadByte() // compile error: undefined f f.Close() // compile error: undefined f 变量f的作用域只在if语句内，因此后面的语句将无法引入它，这将导致编译错误。你可能会收到一个局部变量f没有声明的错误提示，具体错误信息依赖编译器的实现。\n通常需要在if之前声明变量，这样可以确保后面的语句依然可以访问变量：\nf, err := os.Open(fname) if err != nil { return err } f.ReadByte() f.Close() 你可能会考虑通过将ReadByte和Close移动到if的else块来解决这个问题：\nif f, err := os.Open(fname); err != nil { return err } else { // f and err are visible here too \tf.ReadByte() f.Close() } 但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。\n要特别注意短变量声明语句的作用域范围，考虑下面的程序，它的目的是获取当前的工作目录然后保存到一个包级的变量中。这本来可以通过直接调用os.Getwd完成，但是将这个从主逻辑中分离出来可能会更好，特别是在需要处理错误的时候。函数log.Fatalf用于打印日志信息，然后调用os.Exit(1)终止程序。\nvar cwd string func init() { cwd, err := os.Getwd() // compile error: unused: cwd \tif err != nil { log.Fatalf(\u0026#34;os.Getwd failed: %v\u0026#34;, err) } } 虽然cwd在外部已经声明过，但是:=语句还是将cwd和err重新声明为新的局部变量。因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。\n由于当前的编译器会检测到局部声明的cwd并没有使用，然后报告这可能是一个错误，但是这种检测并不可靠。因为一些小的代码变更，例如增加一个局部cwd的打印语句，就可能导致这种检测失效。\nvar cwd string func init() { cwd, err := os.Getwd() // NOTE: wrong! \tif err != nil { log.Fatalf(\u0026#34;os.Getwd failed: %v\u0026#34;, err) } log.Printf(\u0026#34;Working directory = %s\u0026#34;, cwd) } 全局的cwd变量依然是没有被正确初始化的，而且看似正常的日志输出更是让这个BUG更加隐晦。\n有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用:=的简短声明方式：\nvar cwd string func init() { var err error cwd, err = os.Getwd() if err != nil { log.Fatalf(\u0026#34;os.Getwd failed: %v\u0026#34;, err) } } 我们已经看到包、文件、声明和语句如何来表达一个程序结构。在下面的两个章节，我们将探讨数据的结构。\n"});index.add({'id':154,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.7.-Avoid-Encodings/','title':"2.7. 避免使用编码",'section':"2. 有意义的命名",'content':"2.7 避免使用编码 #  We have enough encodings to deal with without adding more to our burden. Encoding type or scope information into names simply adds an extra burden of deciphering. It hardly seems reasonable to require each new employee to learn yet another encoding “language” in addition to learning the (usually considerable) body of code that they’ll be working in. It is an unnecessary mental burden when trying to solve a problem. Encoded names are seldom pronounceable and are easy to mis-type.\n 编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的代码之外（那算是正常的），还要再搞懂另一种编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。\n 2.7.1 Hungarian Notation 匈牙利语标记法 #  In days of old, when we worked in name-length-challenged languages, we violated this rule out of necessity, and with regret. Fortran forced encodings by making the first letter a code for the type. Early versions of BASIC allowed only a letter plus one digit. Hungarian Notation (HN) took this to a whole new level.\n 在往昔名称长短很要命的时代，我们毫无必要地破坏了不编码的规矩，如今后悔不迭。Fortran 语言要求首字母体现出类型，导致了编码的产生。BASIC 早期版本只允许使用一个字母再加上一位数字。匈牙利语标记法（Hungarian Notation，HN）将这种态势愈演愈烈。\n HN was considered to be pretty important back in the Windows C API, when everything was an integer handle or a long pointer or a void pointer, or one of several implementations of “string” (with different uses and attributes). The compiler did not check types in those days, so the programmers needed a crutch to help them remember the types.\n 在 Windows 的 C 语言 API 的时代，HN 相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者 void 指针，要不然就是 string 的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利语标记法来帮助自己记住类型。\n In modern languages we have much richer type systems, and the compilers remember and enforce the types. What’s more, there is a trend toward smaller classes and shorter functions so that people can usually see the point of declaration of each variable they’re using.\n 现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围之内。\n Java programmers don’t need type encoding. Objects are strongly typed, and editing environments have advanced such that they detect a type error long before you can run a compile! So nowadays HN and other forms of type encoding are simply impediments. They make it harder to change the name or type of a variable, function, or class. They make it harder to read the code. And they create the possibility that the encoding system will mislead the reader.\n Java 程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今 HN 和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。\n PhoneNumber phoneString; // name not changed when type changed! 2.7.2 Member Prefixes 成员前缀 #  You also don’t need to prefix member variables with m_ anymore. Your classes and functions should be small enough that you don’t need them. And you should be using an editing environment that highlights or colorizes members to make them distinct.\n 也不必用 m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。\n public class Part { private String m_dsc; // The textual description  void setName(String name) { m_dsc = name; } } _________________________________________________ public class Part { String description; void setDescription(String description) { this.description = description; } } Besides, people quickly learn to ignore the prefix (or suffix) to see the meaningful part of the name. The more we read the code, the less we see the prefixes. Eventually the prefixes become unseen clutter and a marker of older code.\n 此外，人们会很快学会无视前缀（或后缀），只看到名称中有意义的部分。代码读得越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。\n 2.7.3 Interfaces and Implementations 接口和实现 #  These are sometimes a special case for encodings. For example, say you are building an ABSTRACT FACTORY for the creation of shapes. This factory will be an interface and will be implemented by a concrete class. What should you name them? IShapeFactory and ShapeFactory? I prefer to leave interfaces unadorned. The preceding I, so common in today’s legacy wads, is a distraction at best and too much information at worst. I don’t want my users knowing that I’m handing them an interface. I just want them to know that it’s a ShapeFactory. So if I must encode either the interface or the implementation, I choose the implementation. Calling it ShapeFactoryImp, or even the hideous CShapeFactory, is preferable to encoding the interface.\n 有时也会出现采用编码的特殊情形。比如，你在做一个创建形状用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么来命名工厂和具体类呢？IShapeFactory 和 ShapeFactory 吗？我喜欢不加修饰的接口。前导字母 I 被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个 ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的 CShapeFactory，都比对接口名称编码来得好。\n "});index.add({'id':155,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.7.-Variadic-Functions/','title':"5.7. 可变参数",'section':"5. 函数",'content':"5.7. 可变参数 #  参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。\n在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“\u0026hellip;”，这表示该函数会接收任意数量的该类型参数。\ngopl.io/ch5/sum\nfunc sum(vals ...int) int { total := 0 for _, val := range vals { total += val } return total } sum函数返回任意个int型参数的和。在函数体中，vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数：\nfmt.Println(sum()) // \u0026#34;0\u0026#34; fmt.Println(sum(3)) // \u0026#34;3\u0026#34; fmt.Println(sum(1, 2, 3, 4)) // \u0026#34;10\u0026#34; 在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。\nvalues := []int{1, 2, 3, 4} fmt.Println(sum(values...)) // \u0026#34;10\u0026#34; 虽然在可变参数函数内部，\u0026hellip;int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。\nfunc f(...int) {} func g([]int) {} fmt.Printf(\u0026#34;%T\\n\u0026#34;, f) // \u0026#34;func(...int)\u0026#34; fmt.Printf(\u0026#34;%T\\n\u0026#34;, g) // \u0026#34;func([]int)\u0026#34; 可变参数函数经常被用于格式化字符串。下面的errorf函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。\nfunc errorf(linenum int, format string, args ...interface{}) { fmt.Fprintf(os.Stderr, \u0026#34;Line %d: \u0026#34;, linenum) fmt.Fprintf(os.Stderr, format, args...) fmt.Fprintln(os.Stderr) } linenum, name := 12, \u0026#34;count\u0026#34; errorf(linenum, \u0026#34;undefined: %s\u0026#34;, name) // \u0026#34;Line 12: undefined: count\u0026#34; interface{}表示函数的最后一个参数可以接收任意类型，我们会在第7章详细介绍。\n练习5.15： 编写类似sum的可变参数函数max和min。考虑不传参时，max和min该如何处理，再编写至少接收1个参数的版本。\n**练习5.16：**编写多参数版本的strings.Join。\n**练习5.17：**编写多参数版本的ElementsByTagName，函数接收一个HTML结点树以及任意数量的标签名，返回与这些标签名匹配的所有元素。下面给出了2个例子：\nfunc ElementsByTagName(doc *html.Node, name...string) []*html.Node images := ElementsByTagName(doc, \u0026#34;img\u0026#34;) headings := ElementsByTagName(doc, \u0026#34;h1\u0026#34;, \u0026#34;h2\u0026#34;, \u0026#34;h3\u0026#34;, \u0026#34;h4\u0026#34;) "});index.add({'id':156,'href':'/docs/The-Go-Programming-Language/6.-Methods/','title':"6. 方法",'section':"Go语言圣经",'content':"第六章　方法 #  从90年代早期开始，面向对象编程（OOP）就成为了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对OOP的支持，go语言也不例外。\n尽管没有被大众所接受的明确的OOP的定义，从我们的理解来讲，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。\n在早些的章节中，我们已经使用了标准库提供的一些方法，比如time.Duration这个类型的Seconds方法：\nconst day = 24 * time.Hour fmt.Println(day.Seconds()) // \u0026#34;86400\u0026#34; 并且在2.5节中，我们定义了一个自己的方法，Celsius类型的String方法:\nfunc (c Celsius) String() string { return fmt.Sprintf(\u0026#34;%g°C\u0026#34;, c) } 在本章中，OOP编程的第一方面，我们会向你展示如何有效地定义和使用方法。我们会覆盖到OOP编程的两个关键点，封装和组合。\n"});index.add({'id':157,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.7.-The-http.Handler-Interface/','title':"7.7. http.Handler接口",'section':"7. 接口",'content':"7.7. http.Handler接口 #  在第一章中，我们粗略的了解了怎么用net/http包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于http.Handler接口的服务器API做更进一步的学习：\nnet/http\npackage http type Handler interface { ServeHTTP(w ResponseWriter, r *Request) } func ListenAndServe(address string, h Handler) error ListenAndServe函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。\n想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个ServeHttp方法，这样它可以满足http.Handler接口。这个handler会遍历整个map并输出物品信息。\ngopl.io/ch7/http1\nfunc main() { db := database{\u0026#34;shoes\u0026#34;: 50, \u0026#34;socks\u0026#34;: 5} log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, db)) } type dollars float32 func (d dollars) String() string { return fmt.Sprintf(\u0026#34;$%.2f\u0026#34;, d) } type database map[string]dollars func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) { for item, price := range db { fmt.Fprintf(w, \u0026#34;%s: %s\\n\u0026#34;, item, price) } } 如果我们启动这个服务，\n$ go build gopl.io/ch7/http1 $ ./http1 \u0026amp; 然后用1.5节中的获取程序（如果你更喜欢可以使用web浏览器）来连接服务器，我们得到下面的输出：\n$ go build gopl.io/ch1/fetch $ ./fetch http://localhost:8000 shoes: $50.00 socks: $5.00 目前为止，这个服务器不考虑URL，只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用/list来调用已经存在的这个行为并且增加另一个/price调用表明单个货品的价格，像这样/price?item=socks来指定一个请求参数。\ngopl.io/ch7/http2\nfunc (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) { switch req.URL.Path { case \u0026#34;/list\u0026#34;: for item, price := range db { fmt.Fprintf(w, \u0026#34;%s: %s\\n\u0026#34;, item, price) } case \u0026#34;/price\u0026#34;: item := req.URL.Query().Get(\u0026#34;item\u0026#34;) price, ok := db[item] if !ok { w.WriteHeader(http.StatusNotFound) // 404 \tfmt.Fprintf(w, \u0026#34;no such item: %q\\n\u0026#34;, item) return } fmt.Fprintf(w, \u0026#34;%s\\n\u0026#34;, price) default: w.WriteHeader(http.StatusNotFound) // 404 \tfmt.Fprintf(w, \u0026#34;no such page: %s\\n\u0026#34;, req.URL) } } 现在handler基于URL的路径部分（req.URL.Path）来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用w.WriteHeader(http.StatusNotFound)返回客户端一个HTTP错误；这个检查应该在向w写入任何值前完成。（顺便提一下，http.ResponseWriter是另一个接口。它在io.Writer上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的http.Error函数：\nmsg := fmt.Sprintf(\u0026#34;no such page: %s\\n\u0026#34;, req.URL) http.Error(w, msg, http.StatusNotFound) // 404 /price的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个net/url包中url.Values(§6.2.1)类型的多重映射。然后找到第一个item参数并查找它的价格。如果这个货品没有找到会返回一个错误。\n这里是一个和新服务器会话的例子：\n$ go build gopl.io/ch7/http2 $ go build gopl.io/ch1/fetch $ ./http2 \u0026amp; $ ./fetch http://localhost:8000/list shoes: $50.00 socks: $5.00 $ ./fetch http://localhost:8000/price?item=socks $5.00 $ ./fetch http://localhost:8000/price?item=shoes $50.00 $ ./fetch http://localhost:8000/price?item=hat no such item: \u0026quot;hat\u0026quot; $ ./fetch http://localhost:8000/help no such page: /help 显然我们可以继续向ServeHTTP方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如/gopl/images/*.png的URL。因为这些原因，net/http包提供了一个请求多路器ServeMux来简化URL和handlers的联系。一个ServeMux将一批http.Handler聚集到一个单一的http.Handler中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的http.Handler 而不需要考虑它后面的具体类型。\n对于更复杂的应用，一些ServeMux可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，就像Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。\n在下面的程序中，我们创建一个ServeMux并且使用它将URL和相应处理/list和/price操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用ListenAndServe函数中使用ServeMux为主要的handler。\ngopl.io/ch7/http3\nfunc main() { db := database{\u0026#34;shoes\u0026#34;: 50, \u0026#34;socks\u0026#34;: 5} mux := http.NewServeMux() mux.Handle(\u0026#34;/list\u0026#34;, http.HandlerFunc(db.list)) mux.Handle(\u0026#34;/price\u0026#34;, http.HandlerFunc(db.price)) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, mux)) } type database map[string]dollars func (db database) list(w http.ResponseWriter, req *http.Request) { for item, price := range db { fmt.Fprintf(w, \u0026#34;%s: %s\\n\u0026#34;, item, price) } } func (db database) price(w http.ResponseWriter, req *http.Request) { item := req.URL.Query().Get(\u0026#34;item\u0026#34;) price, ok := db[item] if !ok { w.WriteHeader(http.StatusNotFound) // 404 \tfmt.Fprintf(w, \u0026#34;no such item: %q\\n\u0026#34;, item) return } fmt.Fprintf(w, \u0026#34;%s\\n\u0026#34;, price) } 让我们关注这两个注册到handlers上的调用。第一个db.list是一个方法值（§6.4），它是下面这个类型的值。\nfunc(w http.ResponseWriter, req *http.Request) 也就是说db.list的调用会援引一个接收者是db的database.list方法。所以db.list是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足http.Handler接口并且不能直接传给mux.Handle。\n语句http.HandlerFunc(db.list)是一个转换而非一个函数调用，因为http.HandlerFunc是一个类型。它有如下的定义：\nnet/http\npackage http type HandlerFunc func(w ResponseWriter, r *Request) func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } HandlerFunc显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口http.Handler的方法的函数类型。ServeHTTP方法的行为是调用了它的函数本身。因此HandlerFunc是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足http.Handler接口：一种通过它的list方法，一种通过它的price方法等等。\n因为handler通过这种方式注册非常普遍，ServeMux有一个方便的HandleFunc方法，它帮我们简化handler注册代码成这样：\ngopl.io/ch7/http3a\nmux.HandleFunc(\u0026#34;/list\u0026#34;, db.list) mux.HandleFunc(\u0026#34;/price\u0026#34;, db.price) 从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个ServeMux并且再调用一次ListenAndServe（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显式地注册到这个应用的ServeMux实例上会比较麻烦。\n所以为了方便，net/http包提供了一个全局的ServeMux实例DefaultServerMux和包级别的http.Handle和http.HandleFunc函数。现在，为了使用DefaultServeMux作为服务器的主handler，我们不需要将它传给ListenAndServe函数；nil值就可以工作。\n然后服务器的主函数可以简化成：\ngopl.io/ch7/http4\nfunc main() { db := database{\u0026#34;shoes\u0026#34;: 50, \u0026#34;socks\u0026#34;: 5} http.HandleFunc(\u0026#34;/list\u0026#34;, db.list) http.HandleFunc(\u0026#34;/price\u0026#34;, db.price) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } 最后，一个重要的提示：就像我们在1.7节中提到的，web服务器在一个新的协程中调用每一个handler，所以当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。我们后面的两章中将讲到并发相关的知识。\n练习 7.11： 增加额外的handler让客户端可以创建，读取，更新和删除数据库记录。例如，一个形如 /update?item=socks\u0026amp;price=6 的请求会更新库存清单里一个货品的价格并且当这个货品不存在或价格无效时返回一个错误值。（注意：这个修改会引入变量同时更新的问题）\n练习 7.12： 修改/list的handler让它把输出打印成一个HTML的表格而不是文本。html/template包（§4.6）可能会对你有帮助。\n"});index.add({'id':158,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.7.-Multiplexing-with-select/','title':"8.7. 基于select的多路复用",'section':"8. Goroutines和Channels",'content':"8.7. 基于select的多路复用 #  下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。\ngopl.io/ch8/countdown1\nfunc main() { fmt.Println(\u0026#34;Commencing countdown.\u0026#34;) tick := time.Tick(1 * time.Second) for countdown := 10; countdown \u0026gt; 0; countdown-- { fmt.Println(countdown) \u0026lt;-tick } launch() } 现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。\ngopl.io/ch8/countdown2\nabort := make(chan struct{}) go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte \tabort \u0026lt;- struct{}{} }() 现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：当一切正常时的ticker channel（就像NASA jorgon的\u0026quot;nominal\u0026rdquo;，译注：这梗估计我们是不懂了）或者异常时返回的abort事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用（multiplex）这些操作了，为了能够多路复用，我们使用了select语句。\nselect { case \u0026lt;-ch1: // ... case x := \u0026lt;-ch2: // ...use x... case ch3 \u0026lt;- y: // ... default: // ... } 上面是select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身（译注：不把接收到的值赋值给变量什么的），就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。\nselect会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。\n让我们回到我们的火箭发射程序。time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句会一直等待直到两个事件中的一个到达，无论是abort事件或者一个10秒经过的事件。如果10秒经过了还没有abort事件进入，那么火箭就会发射。\nfunc main() { // ...create abort channel...  fmt.Println(\u0026#34;Commencing countdown. Press return to abort.\u0026#34;) select { case \u0026lt;-time.After(10 * time.Second): // Do nothing. \tcase \u0026lt;-abort: fmt.Println(\u0026#34;Launch aborted!\u0026#34;) return } launch() } 下面这个例子更微妙。ch这个channel的buffer大小是1，所以会交替的为空或为满，所以只有一个case可以进行下去，无论i是奇数或者偶数，它都会打印0 2 4 6 8。\nch := make(chan int, 1) for i := 0; i \u0026lt; 10; i++ { select { case x := \u0026lt;-ch: fmt.Println(x) // \u0026#34;0\u0026#34; \u0026#34;2\u0026#34; \u0026#34;4\u0026#34; \u0026#34;6\u0026#34; \u0026#34;8\u0026#34; \tcase ch \u0026lt;- i: } } 如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。增加前一个例子的buffer大小会使其输出变得不确定，因为当buffer既不为满也不为空时，select语句的执行情况就像是抛硬币的行为一样是随机的。\n下面让我们的发射程序打印倒计时。这里的select语句会使每次循环迭代等待一秒来执行退出操作。\ngopl.io/ch8/countdown3\nfunc main() { // ...create abort channel...  fmt.Println(\u0026#34;Commencing countdown. Press return to abort.\u0026#34;) tick := time.Tick(1 * time.Second) for countdown := 10; countdown \u0026gt; 0; countdown-- { fmt.Println(countdown) select { case \u0026lt;-tick: // Do nothing. \tcase \u0026lt;-abort: fmt.Println(\u0026#34;Launch aborted!\u0026#34;) return } } launch() } time.Tick函数表现得好像它创建了一个在循环中调用time.Sleep的goroutine，每次被唤醒时发送一个事件。当countdown函数返回时，它会停止从tick中接收事件，但是ticker这个goroutine还依然存活，继续徒劳地尝试向channel中发送值，然而这时候已经没有其它的goroutine会从该channel中接收值了——这被称为goroutine泄露（§8.4.4）。\nTick函数挺方便，但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适。否则的话，我们应该使用下面的这种模式：\nticker := time.NewTicker(1 * time.Second) \u0026lt;-ticker.C // receive from the ticker\u0026#39;s channel ticker.Stop() // cause the ticker\u0026#39;s goroutine to terminate 有时候我们希望能够从channel中发送或者接收值，并避免因为发送或者接收导致的阻塞，尤其是当channel没有准备好写或者读时。select语句就可以实现这样的功能。select会有一个default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。\n下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。\nselect { case \u0026lt;-abort: fmt.Printf(\u0026#34;Launch aborted!\\n\u0026#34;) return default: // do nothing } channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。\n这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。我们会在下一节中看到一个例子。\n练习 8.8： 使用select来改造8.3节中的echo服务器，为其增加超时，这样服务器可以在客户端10秒中没有任何喊话时自动断开连接。\n"});index.add({'id':159,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.7.-Example-Concurrent-Non-Blocking-Cache/','title':"9.7. 示例: 并发的非阻塞缓存",'section':"9. 基于共享变量的并发",'content':"9.7. 示例: 并发的非阻塞缓存 #  本节中我们会做一个无阻塞的缓存，这种工具可以帮助我们来解决现实世界中并发程序出现但没有现成的库可以解决的问题。这个问题叫作缓存（memoizing）函数（译注：Memoization的定义： memoization 一词是Donald Michie 根据拉丁语memorandum杜撰的一个词。相应的动词、过去分词、ing形式有memoiz、memoized、memoizing），也就是说，我们需要缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。我们的解决方案会是并发安全且会避免对整个缓存加锁而导致所有操作都去争一个锁的设计。\n我们将使用下面的httpGetBody函数作为我们需要缓存的函数的一个样例。这个函数会去进行HTTP GET请求并且获取http响应body。对这个函数的调用本身开销是比较大的，所以我们尽量避免在不必要的时候反复调用。\nfunc httpGetBody(url string) (interface{}, error) { resp, err := http.Get(url) if err != nil { return nil, err } defer resp.Body.Close() return ioutil.ReadAll(resp.Body) } 最后一行稍微隐藏了一些细节。ReadAll会返回两个结果，一个[]byte数组和一个错误，不过这两个对象可以被赋值给httpGetBody的返回声明里的interface{}和error类型，所以我们也就可以这样返回结果并且不需要额外的工作了。我们在httpGetBody中选用这种返回类型是为了使其可以与缓存匹配。\n下面是我们要设计的cache的第一个“草稿”：\ngopl.io/ch9/memo1\n// Package memo provides a concurrency-unsafe // memoization of a function of type Func. package memo // A Memo caches the results of calling a Func. type Memo struct { f Func cache map[string]result } // Func is the type of the function to memoize. type Func func(key string) (interface{}, error) type result struct { value interface{} err error } func New(f Func) *Memo { return \u0026amp;Memo{f: f, cache: make(map[string]result)} } // NOTE: not concurrency-safe! func (memo *Memo) Get(key string) (interface{}, error) { res, ok := memo.cache[key] if !ok { res.value, res.err = memo.f(key) memo.cache[key] = res } return res.value, res.err } Memo实例会记录需要缓存的函数f（类型为Func），以及缓存内容（里面是一个string到result映射的map）。每一个result都是简单的函数返回的值对儿——一个值和一个错误值。继续下去我们会展示一些Memo的变种，不过所有的例子都会遵循上面的这些方面。\n下面是一个使用Memo的例子。对于流入的URL的每一个元素我们都会调用Get，并打印调用延时以及其返回的数据大小的log：\nm := memo.New(httpGetBody) for url := range incomingURLs() { start := time.Now() value, err := m.Get(url) if err != nil { log.Print(err) } fmt.Printf(\u0026#34;%s, %s, %d bytes\\n\u0026#34;, url, time.Since(start), len(value.([]byte))) } 我们可以使用测试包（第11章的主题）来系统地鉴定缓存的效果。从下面的测试输出，我们可以看到URL流包含了一些重复的情况，尽管我们第一次对每一个URL的(*Memo).Get的调用都会花上几百毫秒，但第二次就只需要花1毫秒就可以返回完整的数据了。\n$ go test -v gopl.io/ch9/memo1 === RUN Test https://golang.org, 175.026418ms, 7537 bytes https://godoc.org, 172.686825ms, 6878 bytes https://play.golang.org, 115.762377ms, 5767 bytes http://gopl.io, 749.887242ms, 2856 bytes https://golang.org, 721ns, 7537 bytes https://godoc.org, 152ns, 6878 bytes https://play.golang.org, 205ns, 5767 bytes http://gopl.io, 326ns, 2856 bytes --- PASS: Test (1.21s) PASS ok gopl.io/ch9/memo1 1.257s 这个测试是顺序地去做所有的调用的。\n由于这种彼此独立的HTTP请求可以很好地并发，我们可以把这个测试改成并发形式。可以使用sync.WaitGroup来等待所有的请求都完成之后再返回。\nm := memo.New(httpGetBody) var n sync.WaitGroup for url := range incomingURLs() { n.Add(1) go func(url string) { start := time.Now() value, err := m.Get(url) if err != nil { log.Print(err) } fmt.Printf(\u0026#34;%s, %s, %d bytes\\n\u0026#34;, url, time.Since(start), len(value.([]byte))) n.Done() }(url) } n.Wait() 这次测试跑起来更快了，然而不幸的是貌似这个测试不是每次都能够正常工作。我们注意到有一些意料之外的cache miss（缓存未命中），或者命中了缓存但却返回了错误的值，或者甚至会直接崩溃。\n但更糟糕的是，有时候这个程序还是能正确的运行（译：也就是最让人崩溃的偶发bug），所以我们甚至可能都不会意识到这个程序有bug。但是我们可以使用-race这个flag来运行程序，竞争检测器（§9.6）会打印像下面这样的报告：\n$ go test -run=TestConcurrent -race -v gopl.io/ch9/memo1 === RUN TestConcurrent ... WARNING: DATA RACE Write by goroutine 36: runtime.mapassign1() ~/go/src/runtime/hashmap.go:411 +0x0 gopl.io/ch9/memo1.(*Memo).Get() ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205 ... Previous write by goroutine 35: runtime.mapassign1() ~/go/src/runtime/hashmap.go:411 +0x0 gopl.io/ch9/memo1.(*Memo).Get() ~/gobook2/src/gopl.io/ch9/memo1/memo.go:32 +0x205 ... Found 1 data race(s) FAIL gopl.io/ch9/memo1 2.393s memo.go的32行出现了两次，说明有两个goroutine在没有同步干预的情况下更新了cache map。这表明Get不是并发安全的，存在数据竞争。\n28 func (memo *Memo) Get(key string) (interface{}, error) { 29 res, ok := memo.cache(key) 30 if !ok { 31 res.value, res.err = memo.f(key) 32 memo.cache[key] = res 33 } 34 return res.value, res.err 35 } 最简单的使cache并发安全的方式是使用基于监控的同步。只要给Memo加上一个mutex，在Get的一开始获取互斥锁，return的时候释放锁，就可以让cache的操作发生在临界区内了：\ngopl.io/ch9/memo2\ntype Memo struct { f Func mu sync.Mutex // guards cache \tcache map[string]result } // Get is concurrency-safe. func (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() res, ok := memo.cache[key] if !ok { res.value, res.err = memo.f(key) memo.cache[key] = res } memo.mu.Unlock() return res.value, res.err } 测试依然并发进行，但这回竞争检查器“沉默”了。不幸的是对于Memo的这一点改变使我们完全丧失了并发的性能优点。每次对f的调用期间都会持有锁，Get将本来可以并行运行的I/O操作串行化了。我们本章的目的是完成一个无锁缓存，而不是现在这样的将所有请求串行化的函数的缓存。\n下一个Get的实现，调用Get的goroutine会两次获取锁：查找阶段获取一次，如果查找没有返回任何内容，那么进入更新阶段会再次获取。在这两次获取锁的中间阶段，其它goroutine可以随意使用cache。\ngopl.io/ch9/memo3\nfunc (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() res, ok := memo.cache[key] memo.mu.Unlock() if !ok { res.value, res.err = memo.f(key) // Between the two critical sections, several goroutines \t// may race to compute f(key) and update the map. \tmemo.mu.Lock() memo.cache[key] = res memo.mu.Unlock() } return res.value, res.err } 这些修改使性能再次得到了提升，但有一些URL被获取了两次。这种情况在两个以上的goroutine同一时刻调用Get来请求同样的URL时会发生。多个goroutine一起查询cache，发现没有值，然后一起调用f这个慢不拉叽的函数。在得到结果后，也都会去更新map。其中一个获得的结果会覆盖掉另一个的结果。\n理想情况下是应该避免掉多余的工作的。而这种“避免”工作一般被称为duplicate suppression（重复抑制/避免）。下面版本的Memo每一个map元素都是指向一个条目的指针。每一个条目包含对函数f调用结果的内容缓存。与之前不同的是这次entry还包含了一个叫ready的channel。在条目的结果被设置之后，这个channel就会被关闭，以向其它goroutine广播（§8.9）去读取该条目内的结果是安全的了。\ngopl.io/ch9/memo4\ntype entry struct { res result ready chan struct{} // closed when res is ready } func New(f Func) *Memo { return \u0026amp;Memo{f: f, cache: make(map[string]*entry)} } type Memo struct { f Func mu sync.Mutex // guards cache \tcache map[string]*entry } func (memo *Memo) Get(key string) (value interface{}, err error) { memo.mu.Lock() e := memo.cache[key] if e == nil { // This is the first request for this key. \t// This goroutine becomes responsible for computing \t// the value and broadcasting the ready condition. \te = \u0026amp;entry{ready: make(chan struct{})} memo.cache[key] = e memo.mu.Unlock() e.res.value, e.res.err = memo.f(key) close(e.ready) // broadcast ready condition \t} else { // This is a repeat request for this key. \tmemo.mu.Unlock() \u0026lt;-e.ready // wait for ready condition \t} return e.res.value, e.res.err } 现在Get函数包括下面这些步骤了：获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成（也就是有其它的goroutine在调用f这个慢函数）时，goroutine必须等待值ready之后才能读到条目的结果。而想知道是否ready的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。\n如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经ready可读的消息了。\n条目中的e.res.value和e.res.err变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到\u0026quot;ready\u0026quot;的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。\n这样并发、不重复、无阻塞的cache就完成了。\n上面这样Memo的实现使用了一个互斥量来保护多个goroutine调用Get时的共享map变量。不妨把这种设计和前面提到的把map变量限制在一个单独的monitor goroutine的方案做一些对比，后者在调用Get时需要发消息。\nFunc、result和entry的声明和之前保持一致：\n// Func is the type of the function to memoize. type Func func(key string) (interface{}, error) // A result is the result of calling a Func. type result struct { value interface{} err error } type entry struct { res result ready chan struct{} // closed when res is ready } 然而Memo类型现在包含了一个叫做requests的channel，Get的调用方用这个channel来和monitor goroutine来通信。requests channel中的元素类型是request。Get的调用方会把这个结构中的两组key都填充好，实际上用这两个变量来对函数进行缓存的。另一个叫response的channel会被拿来发送响应结果。这个channel只会传回一个单独的值。\ngopl.io/ch9/memo5\n// A request is a message requesting that the Func be applied to key. type request struct { key string response chan\u0026lt;- result // the client wants a single result } type Memo struct{ requests chan request } // New returns a memoization of f. Clients must subsequently call Close. func New(f Func) *Memo { memo := \u0026amp;Memo{requests: make(chan request)} go memo.server(f) return memo } func (memo *Memo) Get(key string) (interface{}, error) { response := make(chan result) memo.requests \u0026lt;- request{key, response} res := \u0026lt;-response return res.value, res.err } func (memo *Memo) Close() { close(memo.requests) } 上面的Get方法，会创建一个response channel，把它放进request结构中，然后发送给monitor goroutine，然后马上又会接收它。\ncache变量被限制在了monitor goroutine ``(*Memo).server`中，下面会看到。monitor会在循环中一直读取请求，直到request channel被Close方法关闭。每一个请求都会去查询cache，如果没有找到条目的话，那么就会创建/插入一个新的条目。\nfunc (memo *Memo) server(f Func) { cache := make(map[string]*entry) for req := range memo.requests { e := cache[req.key] if e == nil { // This is the first request for this key. \te = \u0026amp;entry{ready: make(chan struct{})} cache[req.key] = e go e.call(f, req.key) // call f(key) \t} go e.deliver(req.response) } } func (e *entry) call(f Func, key string) { // Evaluate the function. \te.res.value, e.res.err = f(key) // Broadcast the ready condition. \tclose(e.ready) } func (e *entry) deliver(response chan\u0026lt;- result) { // Wait for the ready condition. \t\u0026lt;-e.ready // Send the result to the client. \tresponse \u0026lt;- e.res } 和基于互斥量的版本类似，第一个对某个key的请求需要负责去调用函数f并传入这个key，将结果存在条目里，并关闭ready channel来广播条目的ready消息。使用(*entry).call来完成上述工作。\n紧接着对同一个key的请求会发现map中已经有了存在的条目，然后会等待结果变为ready，并将结果从response发送给客户端的goroutien。上述工作是用(*entry).deliver来完成的。对call和deliver方法的调用必须让它们在自己的goroutine中进行以确保monitor goroutines不会因此而被阻塞住而没法处理新的请求。\n这个例子说明我们无论用上锁，还是通信来建立并发程序都是可行的。\n上面的两种方案并不好说特定情境下哪种更好，不过了解他们还是有价值的。有时候从一种方式切换到另一种可以使你的代码更为简洁。（译注：不是说好的golang推崇通信并发么。）\n练习 9.3： 扩展Func类型和(*Memo).Get方法，支持调用方提供一个可选的done channel，使其具备通过该channel来取消整个操作的能力（§8.9）。一个被取消了的Func的调用结果不应该被缓存。\n"});index.add({'id':160,'href':'/docs/Clean-Code/1.-Clean-Code/1.8.-Conclusion/','title':"1.8. 小结",'section':"1. 整洁代码",'content':"1.8 小结 #  Books on art don’t promise to make you an artist. All they can do is give you some of the tools, techniques, and thought processes that other artists have used. So too this book cannot promise to make you a good programmer. It cannot promise to give you “code-sense.” All it can do is show you the thought processes of good programmers and the tricks, techniques, and tools that they use.\n 艺术书并不保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。本书同样也不担保让你成为好程序员。它不担保能给你“代码感”。它所能做的，只是展示好程序员的思维过程，还有他们使用的技巧、技术和工具。\n Just like a book on art, this book will be full of details. There will be lots of code. You’ll see good code and you’ll see bad code. You’ll see bad code transformed into good code. You’ll see lists of heuristics, disciplines, and techniques. You’ll see example after example. After that, it’s up to you.\n 和艺术书一样，本书也充满了细节。代码会很多。你会看到好代码，也会看到糟糕的代码。你会看到糟糕的代码如何转化为好代码。你会看到启发、规条和技巧的列表。你会看到一个又一个例子。但最终结果取决于你自己。\n Remember the old joke about the concert violinist who got lost on his way to a performance? He stopped an old man on the corner and asked him how to get to Carnegie Hall. The old man looked at the violinist and the violin tucked under his arm, and said: “Practice, son. Practice!”\n 还记得那个关于小提琴家在去表演的路上迷路的老笑话吗？他在街角拦住一位长者，问他怎么才能去卡耐基音乐厅（Carnegie Hall）。长者看了看小提琴家，又看了看他手中的琴，说道：“你还得练，孩子，还得练！”\n "});index.add({'id':161,'href':'/docs/The-Go-Programming-Language/1.-Tutorial/1.8.-Loose-Ends/','title':"1.8. 本章要点",'section':"1. 入门",'content':"1.8. 本章要点 #  本章对Go语言做了一些介绍，Go语言很多方面在有限的篇幅中无法覆盖到。本节会把没有讲到的内容也做一些简单的介绍，这样读者在读到完整的内容之前，可以有个简单的印象。\n控制流： 在本章我们只介绍了if控制和for，但是没有提到switch多路选择。这里是一个简单的switch的例子：\nswitch coinflip() { case \u0026#34;heads\u0026#34;: heads++ case \u0026#34;tails\u0026#34;: tails++ default: fmt.Println(\u0026#34;landed on edge!\u0026#34;) } 在翻转硬币的时候，例子里的coinflip函数返回几种不同的结果，每一个case都会对应一个返回结果，这里需要注意，Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。\nGo语言里的switch还可以不带操作对象（译注：switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较）；可以直接罗列多种条件，像其它语言里面的多个if else一样，下面是一个例子：\nfunc Signum(x int) int { switch { case x \u0026gt; 0: return +1 default: return 0 case x \u0026lt; 0: return -1 } } 这种形式叫做无tag switch(tagless switch)；这和switch true是等价的。\n像for和if控制语句一样，switch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用（译注：比其它语言丰富）。\nbreak和continue语句会改变控制流。和其它语言中的break和continue一样，break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。这两个语句除了可以控制for循环，还可以用来控制switch和select语句（之后会讲到），在1.3节中我们看到，continue会跳过内层的循环，如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中。\n命名类型： 类型声明使得我们可以很方便地给一个特殊类型一个名字。因为struct类型声明通常非常地长，所以我们总要给这种struct取一个名字。本章中就有这样一个例子，二维点类型：\ntype Point struct { X, Y int } var p Point 类型声明和命名类型会在第二章中介绍。\n指针： Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，\u0026amp;操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。我们会在2.3.2中进行详细介绍。\n方法和接口： 方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。在第六章我们会详细地讲方法。接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。第七章中会详细说明这些内容。\n包（packages）： Go语言提供了一些很好用的package，并且这些package是可以扩展的。Go语言社区已经创造并且分享了很多很多。所以Go语言编程大多数情况下就是用已有的package来写我们自己的代码。通过这本书，我们会讲解一些重要的标准库内的package，但是还是有很多限于篇幅没有去说明，因为我们没法在这样的厚度的书里去做一部代码大全。\n在你开始写一个新程序之前，最好先去检查一下是不是已经有了现成的库可以帮助你更高效地完成这件事情。你可以在 https://golang.org/pkg 和 https://godoc.org 中找到标准库和社区写的package。godoc这个工具可以让你直接在本地命令行阅读标准库的文档。比如下面这个例子。\n$ go doc http.ListenAndServe package http // import \u0026quot;net/http\u0026quot; func ListenAndServe(addr string, handler Handler) error ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. ... 注释： 我们之前已经提到过了在源文件的开头写的注释是这个源文件的文档。在每一个函数之前写一个说明函数行为的注释也是一个好习惯。这些惯例很重要，因为这些内容会被像godoc这样的工具检测到，并且在执行命令时显示这些注释。具体可以参考10.7.4。\n多行注释可以用 /* ... */ 来包裹，和其它大多数语言一样。在文件一开头的注释一般都是这种形式，或者一大段的解释性的注释文字也会被这符号包住，来避免每一行都需要加//。在注释中//和/*是没什么意义的，所以不要在注释中再嵌入注释。\n"});index.add({'id':162,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.8.-Displaying-the-Methods-of-a-Type/','title':"12.8. 显示一个类型的方法集",'section':"12. 反射",'content':"12.8. 显示一个类型的方法集 #  我们的最后一个例子是使用reflect.Type来打印任意值的类型和枚举它的方法：\ngopl.io/ch12/methods\n// Print prints the method set of the value x. func Print(x interface{}) { v := reflect.ValueOf(x) t := v.Type() fmt.Printf(\u0026#34;type %s\\n\u0026#34;, t) for i := 0; i \u0026lt; v.NumMethod(); i++ { methType := v.Method(i).Type() fmt.Printf(\u0026#34;func (%s) %s%s\\n\u0026#34;, t, t.Method(i).Name, strings.TrimPrefix(methType.String(), \u0026#34;func\u0026#34;)) } } reflect.Type和reflect.Value都提供了一个Method方法。每次t.Method(i)调用将一个reflect.Method的实例，对应一个用于描述一个方法的名称和类型的结构体。每次v.Method(i)方法调用都返回一个reflect.Value以表示对应的值（§6.4），也就是一个方法是帮到它的接收者的。使用reflect.Value.Call方法（我们这里没有演示），将可以调用一个Func类型的Value，但是这个例子中只用到了它的类型。\n这是属于time.Duration和*strings.Replacer两个类型的方法：\nmethods.Print(time.Hour) // Output: // type time.Duration // func (time.Duration) Hours() float64 // func (time.Duration) Minutes() float64 // func (time.Duration) Nanoseconds() int64 // func (time.Duration) Seconds() float64 // func (time.Duration) String() string  methods.Print(new(strings.Replacer)) // Output: // type *strings.Replacer // func (*strings.Replacer) Replace(string) string // func (*strings.Replacer) WriteString(io.Writer, string) (int, error) "});index.add({'id':163,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.8.-Avoid-Mental-Mapping/','title':"2.8. 避免思维映射",'section':"2. 有意义的命名",'content':"2.8 避免思维映射 #  Readers shouldn’t have to mentally translate your names into other names they already know. This problem generally arises from a choice to use neither problem domain terms nor solution domain terms.\n 不应当让读者在脑中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。\n This is a problem with single-letter variable names. Certainly a loop counter may be named i or j or k (though never l!) if its scope is very small and no other names can conflict with it. This is because those single-letter names for loop counters are traditional. However, in most other contexts a single-letter name is a poor choice; it’s just a place holder that the reader must mentally map to the actual concept. There can be no worse reason for using the name c than because a and b were already taken.\n 单字母变量名就是个问题。在作用域较小、也没有名称冲突时，循环计数器自然有可能被命名为 i 或 j 或 k。（但千万别用字母 l！）这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择；读者必须在脑中将它映射为真实概念。仅仅是因为有了 a 和 b，就要取名为 c，实在并非像样的理由。\n In general programmers are pretty smart people. Smart people sometimes like to show off their smarts by demonstrating their mental juggling abilities. After all, if you can reliably remember that r is the lower-cased version of the url with the host and scheme removed, then you must clearly be very smart.\n 程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得 r 代表不包含主机名和图式（scheme）的小写字母版 url 的话，那你真是太聪明了。\n One difference between a smart programmer and a professional programmer is that the professional understands that clarity is king. Professionals use their powers for good and write code that others can understand.\n 聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。\n "});index.add({'id':164,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.8.-Deferred-Function-Calls/','title':"5.8. Deferred函数",'section':"5. 函数",'content':"5.8. Deferred函数 #  在findLinks的例子中，我们用http.Get的输出作为html.Parse的输入。只有url的内容的确是HTML格式的，html.Parse才可以正常工作，但实际上，url指向的内容很丰富，可能是图片，纯文本或是其他。将这些格式的内容传递给html.parse，会产生不良后果。\n下面的例子获取HTML页面并输出页面的标题。title函数会检查服务器返回的Content-Type字段，如果发现页面不是HTML，将终止函数运行，返回错误。\ngopl.io/ch5/title1\nfunc title(url string) error { resp, err := http.Get(url) if err != nil { return err } // Check Content-Type is HTML (e.g., \u0026#34;text/html;charset=utf-8\u0026#34;). \tct := resp.Header.Get(\u0026#34;Content-Type\u0026#34;) if ct != \u0026#34;text/html\u0026#34; \u0026amp;\u0026amp; !strings.HasPrefix(ct,\u0026#34;text/html;\u0026#34;) { resp.Body.Close() return fmt.Errorf(\u0026#34;%s has type %s, not text/html\u0026#34;,url, ct) } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return fmt.Errorf(\u0026#34;parsing %s as HTML: %v\u0026#34;, url,err) } visitNode := func(n *html.Node) { if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data == \u0026#34;title\u0026#34;\u0026amp;\u0026amp;n.FirstChild != nil { fmt.Println(n.FirstChild.Data) } } forEachNode(doc, visitNode, nil) return nil } 下面展示了运行效果：\n$ go build gopl.io/ch5/title1 $ ./title1 http://gopl.io The Go Programming Language $ ./title1 https://golang.org/doc/effective_go.html Effective Go - The Go Programming Language $ ./title1 https://golang.org/doc/gopher/frontpage.png title1: https://golang.org/doc/gopher/frontpage.png has type image/png, not text/html resp.Body.close调用了多次，这是为了确保title在所有执行路径下（即使函数运行失败）都关闭了网络连接。随着函数变得复杂，需要处理的错误也变多，维护清理逻辑变得越来越困难。而Go语言独有的defer机制可以让事情变得简单。\n你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。\ndefer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。在下面的代码中，一条defer语句替代了之前的所有resp.Body.Close\ngopl.io/ch5/title2\nfunc title(url string) error { resp, err := http.Get(url) if err != nil { return err } defer resp.Body.Close() ct := resp.Header.Get(\u0026#34;Content-Type\u0026#34;) if ct != \u0026#34;text/html\u0026#34; \u0026amp;\u0026amp; !strings.HasPrefix(ct,\u0026#34;text/html;\u0026#34;) { return fmt.Errorf(\u0026#34;%s has type %s, not text/html\u0026#34;,url, ct) } doc, err := html.Parse(resp.Body) if err != nil { return fmt.Errorf(\u0026#34;parsing %s as HTML: %v\u0026#34;, url,err) } // ...print doc\u0026#39;s title element… \treturn nil } 在处理其他资源时，也可以采用defer机制，比如对文件的操作：\nio/ioutil\npackage ioutil func ReadFile(filename string) ([]byte, error) { f, err := os.Open(filename) if err != nil { return nil, err } defer f.Close() return ReadAll(f) } 或是处理互斥锁（9.2章）\nvar mu sync.Mutex var m = make(map[string]int) func lookup(key string) int { mu.Lock() defer mu.Unlock() return m[key] } 调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。下例中的bigSlowOperation函数，直接调用trace记录函数的被调情况。bigSlowOperation被调时，trace会返回一个函数值，该函数值会在bigSlowOperation退出时被调用。通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，如例子中的start。需要注意一点：不要忘记defer语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。\ngopl.io/ch5/trace\nfunc bigSlowOperation() { defer trace(\u0026#34;bigSlowOperation\u0026#34;)() // don\u0026#39;t forget the extra parentheses \t// ...lots of work… \ttime.Sleep(10 * time.Second) // simulate slow operation by sleeping } func trace(msg string) func() { start := time.Now() log.Printf(\u0026#34;enter %s\u0026#34;, msg) return func() { log.Printf(\u0026#34;exit %s (%s)\u0026#34;, msg,time.Since(start)) } } 每一次bigSlowOperation被调用，程序都会记录函数的进入，退出，持续时间。（我们用time.Sleep模拟一个耗时的操作）\n$ go build gopl.io/ch5/trace $ ./trace 2015/11/18 09:53:26 enter bigSlowOperation 2015/11/18 09:53:36 exit bigSlowOperation (10.000589217s) 我们知道，defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。\n以double函数为例：\nfunc double(x int) int { return x + x } 我们只需要首先命名double的返回值，再增加defer语句，我们就可以在double每次被调用时，输出参数以及返回值。\nfunc double(x int) (result int) { defer func() { fmt.Printf(\u0026#34;double(%d) = %d\\n\u0026#34;, x,result) }() return x + x } _ = double(4) // Output: // \u0026#34;double(4) = 8\u0026#34; 可能double函数过于简单，看不出这个小技巧的作用，但对于有许多return语句的函数而言，这个技巧很有用。\n被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：\nfunc triple(x int) (result int) { defer func() { result += x }() return double(x) } fmt.Println(triple(4)) // \u0026#34;12\u0026#34; 在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。\nfor _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // NOTE: risky; could run out of file descriptors \t// ...process f… } 一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。\nfor _, filename := range filenames { if err := doFile(filename); err != nil { return err } } func doFile(filename string) error { f, err := os.Open(filename) if err != nil { return err } defer f.Close() // ...process f… } 下面的代码是fetch（1.5节）的改进版，我们将http响应信息写入本地文件而不是从标准输出流输出。我们通过path.Base提出url路径的最后一段作为文件名。\ngopl.io/ch5/fetch\n// Fetch downloads the URL and returns the // name and length of the local file. func fetch(url string) (filename string, n int64, err error) { resp, err := http.Get(url) if err != nil { return \u0026#34;\u0026#34;, 0, err } defer resp.Body.Close() local := path.Base(resp.Request.URL.Path) if local == \u0026#34;/\u0026#34; { local = \u0026#34;index.html\u0026#34; } f, err := os.Create(local) if err != nil { return \u0026#34;\u0026#34;, 0, err } n, err = io.Copy(f, resp.Body) // Close file, but prefer error from Copy, if any. \tif closeErr := f.Close(); err == nil { err = closeErr } return local, n, err } 对resp.Body.Close延迟调用我们已经见过了，在此不做解释。上例中，通过os.Create打开文件进行写入，在关闭文件时，我们没有对f.close采用defer机制，因为这会产生一些微妙的错误。许多文件系统，尤其是NFS，写入文件时发生的错误会被延迟到文件关闭时反馈。如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。如果io.Copy和f.close都失败了，我们倾向于将io.Copy的错误信息反馈给调用者，因为它先于f.close发生，更有可能接近问题的本质。\n**练习5.18：**不修改fetch的行为，重写fetch函数，要求使用defer机制关闭文件。\n"});index.add({'id':165,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/','title':"7. 接口",'section':"Go语言圣经",'content':"第七章　接口 #  接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。\n很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。\n在本章，我们会开始看到接口类型和值的一些基本技巧。顺着这种方式我们将学习几个来自标准库的重要接口。很多Go程序中都尽可能多的去使用标准库中的接口。最后，我们会在（§7.10）看到类型断言的知识，在（§7.13）看到类型开关的使用并且学到他们是怎样让不同的类型的概括成为可能。\n"});index.add({'id':166,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.8.-The-error-Interface/','title':"7.8. error接口",'section':"7. 接口",'content':"7.8. error接口 #  从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：\ntype error interface { Error() string } 创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。整个errors包仅只有4行：\npackage errors func New(text string) error { return \u0026amp;errorString{text} } type errorString struct { text string } func (e *errorString) Error() string { return e.text } 承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。并且因为是指针类型*errorString满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。\nfmt.Println(errors.New(\u0026#34;EOF\u0026#34;) == errors.New(\u0026#34;EOF\u0026#34;)) // \u0026#34;false\u0026#34; 调用errors.New函数是非常稀少的，因为有一个方便的封装函数fmt.Errorf，它还会处理字符串格式化。我们曾多次在第5章中用到它。\npackage fmt import \u0026#34;errors\u0026#34; func Errorf(format string, args ...interface{}) error { return errors.New(Sprintf(format, args...)) } 虽然*errorString可能是最简单的错误类型，但远非只有它一个。例如，syscall包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：\npackage syscall type Errno uintptr // operating system error code  var errors = [...]string{ 1: \u0026#34;operation not permitted\u0026#34;, // EPERM \t2: \u0026#34;no such file or directory\u0026#34;, // ENOENT \t3: \u0026#34;no such process\u0026#34;, // ESRCH \t// ... } func (e Errno) Error() string { if 0 \u0026lt;= int(e) \u0026amp;\u0026amp; int(e) \u0026lt; len(errors) { return errors[e] } return fmt.Sprintf(\u0026#34;errno %d\u0026#34;, e) } 下面的语句创建了一个持有Errno值为2的接口值，表示POSIX ENOENT状况：\nvar err error = syscall.Errno(2) fmt.Println(err.Error()) // \u0026#34;no such file or directory\u0026#34; fmt.Println(err) // \u0026#34;no such file or directory\u0026#34; err的值图形化的呈现在图7.6中。\n Errno是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。我们会在第7.11节了解到其它满足这个接口的类型。\n"});index.add({'id':167,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.8.-Example-Concurrent-Directory-Traversal/','title':"8.8. 示例: 并发的目录遍历",'section':"8. Goroutines和Channels",'content':"8.8. 示例: 并发的目录遍历 #  在本小节中，我们会创建一个程序来生成指定目录的硬盘使用情况报告，这个程序和Unix里的du工具比较相似。大多数工作用下面这个walkDir函数来完成，这个函数使用dirents函数来枚举一个目录下的所有入口。\ngopl.io/ch8/du1\n// walkDir recursively walks the file tree rooted at dir // and sends the size of each found file on fileSizes. func walkDir(dir string, fileSizes chan\u0026lt;- int64) { for _, entry := range dirents(dir) { if entry.IsDir() { subdir := filepath.Join(dir, entry.Name()) walkDir(subdir, fileSizes) } else { fileSizes \u0026lt;- entry.Size() } } } // dirents returns the entries of directory dir. func dirents(dir string) []os.FileInfo { entries, err := ioutil.ReadDir(dir) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;du1: %v\\n\u0026#34;, err) return nil } return entries } ioutil.ReadDir函数会返回一个os.FileInfo类型的slice，os.FileInfo类型也是os.Stat这个函数的返回值。对每一个子目录而言，walkDir会递归地调用其自身，同时也在递归里获取每一个文件的信息。walkDir函数会向fileSizes这个channel发送一条消息。这条消息包含了文件的字节大小。\n下面的主函数，用了两个goroutine。后台的goroutine调用walkDir来遍历命令行给出的每一个路径并最终关闭fileSizes这个channel。主goroutine会对其从channel中接收到的文件大小进行累加，并输出其和。\npackage main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { // Determine the initial directories. \tflag.Parse() roots := flag.Args() if len(roots) == 0 { roots = []string{\u0026#34;.\u0026#34;} } // Traverse the file tree. \tfileSizes := make(chan int64) go func() { for _, root := range roots { walkDir(root, fileSizes) } close(fileSizes) }() // Print the results. \tvar nfiles, nbytes int64 for size := range fileSizes { nfiles++ nbytes += size } printDiskUsage(nfiles, nbytes) } func printDiskUsage(nfiles, nbytes int64) { fmt.Printf(\u0026#34;%d files %.1f GB\\n\u0026#34;, nfiles, float64(nbytes)/1e9) } 这个程序会在打印其结果之前卡住很长时间。\n$ go build gopl.io/ch8/du1 $ ./du1 $HOME /usr /bin /etc 213201 files 62.7 GB 如果在运行的时候能够让我们知道处理进度的话想必更好。但是，如果简单地把printDiskUsage函数调用移动到循环里会导致其打印出成百上千的输出。\n下面这个du的变种会间歇打印内容，不过只有在调用时提供了-v的flag才会显示程序进度信息。在roots目录上循环的后台goroutine在这里保持不变。主goroutine现在使用了计时器来每500ms生成事件，然后用select语句来等待文件大小的消息来更新总大小数据，或者一个计时器的事件来打印当前的总大小数据。如果-v的flag在运行时没有传入的话，tick这个channel会保持为nil，这样在select里的case也就相当于被禁用了。\ngopl.io/ch8/du2\nvar verbose = flag.Bool(\u0026#34;v\u0026#34;, false, \u0026#34;show verbose progress messages\u0026#34;) func main() { // ...start background goroutine...  // Print the results periodically. \tvar tick \u0026lt;-chan time.Time if *verbose { tick = time.Tick(500 * time.Millisecond) } var nfiles, nbytes int64 loop: for { select { case size, ok := \u0026lt;-fileSizes: if !ok { break loop // fileSizes was closed \t} nfiles++ nbytes += size case \u0026lt;-tick: printDiskUsage(nfiles, nbytes) } } printDiskUsage(nfiles, nbytes) // final totals } 由于我们的程序不再使用range循环，第一个select的case必须显式地判断fileSizes的channel是不是已经被关闭了，这里可以用到channel接收的二值形式。如果channel已经被关闭了的话，程序会直接退出循环。这里的break语句用到了标签break，这样可以同时终结select和for两个循环；如果没有用标签就break的话只会退出内层的select循环，而外层的for循环会使之进入下一轮select循环。\n现在程序会悠闲地为我们打印更新流：\n$ go build gopl.io/ch8/du2 $ ./du2 -v $HOME /usr /bin /etc 28608 files 8.3 GB 54147 files 10.3 GB 93591 files 15.1 GB 127169 files 52.9 GB 175931 files 62.2 GB 213201 files 62.7 GB 然而这个程序还是会花上很长时间才会结束。完全可以并发调用walkDir，从而发挥磁盘系统的并行性能。下面这个第三个版本的du，会对每一个walkDir的调用创建一个新的goroutine。它使用sync.WaitGroup（§8.5）来对仍旧活跃的walkDir调用进行计数，另一个goroutine会在计数器减为零的时候将fileSizes这个channel关闭。\ngopl.io/ch8/du3\nfunc main() { // ...determine roots... \t// Traverse each root of the file tree in parallel. \tfileSizes := make(chan int64) var n sync.WaitGroup for _, root := range roots { n.Add(1) go walkDir(root, \u0026amp;n, fileSizes) } go func() { n.Wait() close(fileSizes) }() // ...select loop... } func walkDir(dir string, n *sync.WaitGroup, fileSizes chan\u0026lt;- int64) { defer n.Done() for _, entry := range dirents(dir) { if entry.IsDir() { n.Add(1) subdir := filepath.Join(dir, entry.Name()) go walkDir(subdir, n, fileSizes) } else { fileSizes \u0026lt;- entry.Size() } } } 由于这个程序在高峰期会创建成百上千的goroutine，我们需要修改dirents函数，用计数信号量来阻止他同时打开太多的文件，就像我们在8.7节中的并发爬虫一样：\n// sema is a counting semaphore for limiting concurrency in dirents. var sema = make(chan struct{}, 20) // dirents returns the entries of directory dir. func dirents(dir string) []os.FileInfo { sema \u0026lt;- struct{}{} // acquire token \tdefer func() { \u0026lt;-sema }() // release token \t// ... 这个版本比之前那个快了好几倍，尽管其具体效率还是和你的运行环境，机器配置相关。\n练习 8.9： 编写一个du工具，每隔一段时间将root目录下的目录大小计算并显示出来。\n"});index.add({'id':168,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/9.8.-Goroutines-and-Threads/','title':"9.8. Goroutines和线程",'section':"9. 基于共享变量的并发",'content':"9.8. Goroutines和线程 #  在上一章中我们说goroutine和操作系统的线程区别可以先忽略。尽管两者的区别实际上只是一个量的区别，但量变会引起质变的道理同样适用于goroutine和线程。现在正是我们来区分开两者的最佳时机。\n"});index.add({'id':169,'href':'/docs/Clean-Code/1.-Clean-Code/1.9.-Bibliography/','title':"1.9. 参考文献",'section':"1. 整洁代码",'content':"1.9 参考文献 #  [Beck07]: Implementation Patterns, Kent Beck, Addison-Wesley, 2007.\n[Knuth92]: Literate Programming, Donald E. Knuth, Center for the Study of Languageand Information, Leland Stanford Junior University, 1992.\n"});index.add({'id':170,'href':'/docs/The-Go-Programming-Language/12.-Reflection/12.9.-A-Word-of-Caution/','title':"12.9. 几点忠告",'section':"12. 反射",'content':"12.9. 几点忠告 #  虽然反射提供的API远多于我们讲到的，我们前面的例子主要是给出了一个方向，通过反射可以实现哪些功能。反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三。\n第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。\n以前面的readList函数（§12.6）为例，为了从输入读取字符串并填充int类型的变量而调用的reflect.Value.SetString方法可能导致panic异常。绝大多数使用反射的程序都有类似的风险，需要非常小心地检查每个reflect.Value的对应值的类型、是否可取地址，还有是否可以被修改等。\n避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码为例，当fmt.Printf收到一个非法的操作数时，它并不会抛出panic异常，而是打印相关的错误信息。程序虽然还有BUG，但是会更加容易诊断。\nfmt.Printf(\u0026#34;%d %s\\n\u0026#34;, \u0026#34;hello\u0026#34;, 42) // \u0026#34;%!d(string=hello) %!s(int=42)\u0026#34; 反射同样降低了程序的安全性，还影响了自动化重构和分析工具的准确性，因为它们无法识别运行时才能确认的类型信息。\n避免使用反射的第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受interface{}或reflect.Value类型参数的函数维护说明文档。\n第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。\n"});index.add({'id':171,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.9.-Class-Names/','title':"2.9. 类名",'section':"2. 有意义的命名",'content':"2.9 类名 #  Classes and objects should have noun or noun phrase names like Customer, WikiPage, Account, and AddressParser. Avoid words like Manager, Processor, Data, or Info in the name of a class. A class name should not be a verb.\n 类名和对象名应该是名词或名词短语，如 Customer、WikiPage、Account 和 AddressParser。避免使用 Manager、Processor、Data 或 Info 这样的类名。类名不应当是动词。\n "});index.add({'id':172,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.9.-Panic/','title':"5.9. Panic异常",'section':"5. 函数",'content':"5.9. Panic异常 #  Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。\n一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine（可以先理解成线程，在第8章会详细介绍）中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。\n不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：\nswitch s := suit(drawCard()); s { case \u0026#34;Spades\u0026#34;: // ... case \u0026#34;Hearts\u0026#34;: // ... case \u0026#34;Diamonds\u0026#34;: // ... case \u0026#34;Clubs\u0026#34;: // ... default: panic(fmt.Sprintf(\u0026#34;invalid suit %q\u0026#34;, s)) // Joker? } 断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码。\nfunc Reset(x *Buffer) { if x == nil { panic(\u0026#34;x is nil\u0026#34;) // unnecessary! \t} x.elements = nil } 虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。\n考虑regexp.Compile函数，该函数将正则表达式编译成有效的可匹配格式。当输入的正则表达式不合法时，该函数会返回一个错误。当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，就如前面的断言一样：当调用者输入了不应该出现的输入时，触发panic异常。\n在程序源码中，大多数正则表达式是字符串字面值（string literals），因此regexp包提供了包装函数regexp.MustCompile检查输入的合法性。\npackage regexp func Compile(expr string) (*Regexp, error) { /* ... */ } func MustCompile(expr string) *Regexp { re, err := Compile(expr) if err != nil { panic(err) } return re } 包装函数使得调用者可以便捷的用一个编译后的正则表达式为包级别的变量赋值：\nvar httpSchemeRE = regexp.MustCompile(`^https?:`) //\u0026#34;http:\u0026#34; or \u0026#34;https:\u0026#34; 显然，MustCompile不能接收不合法的输入。函数名中的Must前缀是一种针对此类函数的命名约定，比如template.Must（4.6节）\nfunc main() { f(3) } func f(x int) { fmt.Printf(\u0026#34;f(%d)\\n\u0026#34;, x+0/x) // panics if x == 0 \tdefer fmt.Printf(\u0026#34;defer %d\\n\u0026#34;, x) f(x - 1) } 上例中的运行输出如下：\nf(3) f(2) f(1) defer 1 defer 2 defer 3 当f(0)被调用时，发生panic异常，之前被延迟执行的3个fmt.Printf被调用。程序中断执行后，panic信息和堆栈信息会被输出（下面是简化的输出）：\npanic: runtime error: integer divide by zero main.f(0) src/gopl.io/ch5/defer1/defer.go:14 main.f(1) src/gopl.io/ch5/defer1/defer.go:16 main.f(2) src/gopl.io/ch5/defer1/defer.go:16 main.f(3) src/gopl.io/ch5/defer1/defer.go:16 main.main() src/gopl.io/ch5/defer1/defer.go:10 我们在下一节将看到，如何使程序从panic异常中恢复，阻止程序的崩溃。\n为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。\ngopl.io/ch5/defer2\nfunc main() { defer printStack() f(3) } func printStack() { var buf [4096]byte n := runtime.Stack(buf[:], false) os.Stdout.Write(buf[:n]) } printStack的简化输出如下（下面只是printStack的输出，不包括panic的日志信息）：\ngoroutine 1 [running]: main.printStack() src/gopl.io/ch5/defer2/defer.go:20 main.f(0) src/gopl.io/ch5/defer2/defer.go:27 main.f(1) src/gopl.io/ch5/defer2/defer.go:29 main.f(2) src/gopl.io/ch5/defer2/defer.go:29 main.f(3) src/gopl.io/ch5/defer2/defer.go:29 main.main() src/gopl.io/ch5/defer2/defer.go:15 将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。\n"});index.add({'id':173,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.9.-Example-Expression-Evaluator/','title':"7.9. 示例: 表达式求值",'section':"7. 接口",'content':"7.9. 示例: 表达式求值 #  在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口Expr来表示Go语言中任意的表达式。现在这个接口不需要有方法，但是我们后面会为它增加一些。\n// An Expr is an arithmetic expression. type Expr interface{} 我们的表达式语言由浮点数符号（小数点）；二元操作符+，-，*， 和/；一元操作符-x和+x；调用pow(x,y)，sin(x)，和sqrt(x)的函数；例如x和pi的变量；当然也有括号和标准的优先级运算符。所有的值都是float64类型。这下面是一些表达式的例子：\nsqrt(A / pi) pow(x, 3) + pow(y, 3) (F - 32) * 5 / 9 下面的五个具体类型表示了具体的表达式类型。Var类型表示对一个变量的引用。（我们很快会知道为什么它可以被输出。）literal类型表示一个浮点型常量。unary和binary类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。call类型表示对一个函数的调用；我们限制它的fn字段只能是pow，sin或者sqrt。\ngopl.io/ch7/eval\n// A Var identifies a variable, e.g., x. type Var string // A literal is a numeric constant, e.g., 3.141. type literal float64 // A unary represents a unary operator expression, e.g., -x. type unary struct { op rune // one of \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39; \tx Expr } // A binary represents a binary operator expression, e.g., x+y. type binary struct { op rune // one of \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;/\u0026#39; \tx, y Expr } // A call represents a function call expression, e.g., sin(x). type call struct { fn string // one of \u0026#34;pow\u0026#34;, \u0026#34;sin\u0026#34;, \u0026#34;sqrt\u0026#34; \targs []Expr } 为了计算一个包含变量的表达式，我们需要一个environment变量将变量的名字映射成对应的值：\ntype Env map[Var]float64 我们也需要每个表达式去定义一个Eval方法，这个方法会根据给定的environment变量返回表达式的值。因为每个表达式都必须提供这个方法，我们将它加入到Expr接口中。这个包只会对外公开Expr，Env，和Var类型。调用方不需要获取其它的表达式类型就可以使用这个求值器。\ntype Expr interface { // Eval returns the value of this Expr in the environment env. \tEval(env Env) float64 } 下面给大家展示一个具体的Eval方法。Var类型的这个方法对一个environment变量进行查找，如果这个变量没有在environment中定义过这个方法会返回一个零值，literal类型的这个方法简单的返回它真实的值。\nfunc (v Var) Eval(env Env) float64 { return env[v] } func (l literal) Eval(_ Env) float64 { return float64(l) } unary和binary的Eval方法会递归的计算它的运算对象，然后将运算符op作用到它们上。我们不将被零或无穷数除作为一个错误，因为它们都会产生一个固定的结果——无限。最后，call的这个方法会计算对于pow，sin，或者sqrt函数的参数值，然后调用对应在math包中的函数。\nfunc (u unary) Eval(env Env) float64 { switch u.op { case \u0026#39;+\u0026#39;: return +u.x.Eval(env) case \u0026#39;-\u0026#39;: return -u.x.Eval(env) } panic(fmt.Sprintf(\u0026#34;unsupported unary operator: %q\u0026#34;, u.op)) } func (b binary) Eval(env Env) float64 { switch b.op { case \u0026#39;+\u0026#39;: return b.x.Eval(env) + b.y.Eval(env) case \u0026#39;-\u0026#39;: return b.x.Eval(env) - b.y.Eval(env) case \u0026#39;*\u0026#39;: return b.x.Eval(env) * b.y.Eval(env) case \u0026#39;/\u0026#39;: return b.x.Eval(env) / b.y.Eval(env) } panic(fmt.Sprintf(\u0026#34;unsupported binary operator: %q\u0026#34;, b.op)) } func (c call) Eval(env Env) float64 { switch c.fn { case \u0026#34;pow\u0026#34;: return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env)) case \u0026#34;sin\u0026#34;: return math.Sin(c.args[0].Eval(env)) case \u0026#34;sqrt\u0026#34;: return math.Sqrt(c.args[0].Eval(env)) } panic(fmt.Sprintf(\u0026#34;unsupported function call: %s\u0026#34;, c.fn)) } 一些方法会失败。例如，一个call表达式可能有未知的函数或者错误的参数个数。用一个无效的运算符如!或者\u0026lt;去构建一个unary或者binary表达式也是可能会发生的（尽管下面提到的Parse函数不会这样做）。这些错误会让Eval方法panic。其它的错误，像计算一个没有在environment变量中出现过的Var，只会让Eval方法返回一个错误的结果。所有的这些错误都可以通过在计算前检查Expr来发现。这是我们接下来要讲的Check方法的工作，但是让我们先测试Eval方法。\n下面的TestEval函数是对evaluator的一个测试。它使用了我们会在第11章讲解的testing包，但是现在知道调用t.Errof会报告一个错误就足够了。这个函数循环遍历一个表格中的输入，这个表格中定义了三个表达式和针对每个表达式不同的环境变量。第一个表达式根据给定圆的面积A计算它的半径，第二个表达式通过两个变量x和y计算两个立方体的体积之和，第三个表达式将华氏温度F转换成摄氏度。\nfunc TestEval(t *testing.T) { tests := []struct { expr string env Env want string }{ {\u0026#34;sqrt(A / pi)\u0026#34;, Env{\u0026#34;A\u0026#34;: 87616, \u0026#34;pi\u0026#34;: math.Pi}, \u0026#34;167\u0026#34;}, {\u0026#34;pow(x, 3) + pow(y, 3)\u0026#34;, Env{\u0026#34;x\u0026#34;: 12, \u0026#34;y\u0026#34;: 1}, \u0026#34;1729\u0026#34;}, {\u0026#34;pow(x, 3) + pow(y, 3)\u0026#34;, Env{\u0026#34;x\u0026#34;: 9, \u0026#34;y\u0026#34;: 10}, \u0026#34;1729\u0026#34;}, {\u0026#34;5 / 9 * (F - 32)\u0026#34;, Env{\u0026#34;F\u0026#34;: -40}, \u0026#34;-40\u0026#34;}, {\u0026#34;5 / 9 * (F - 32)\u0026#34;, Env{\u0026#34;F\u0026#34;: 32}, \u0026#34;0\u0026#34;}, {\u0026#34;5 / 9 * (F - 32)\u0026#34;, Env{\u0026#34;F\u0026#34;: 212}, \u0026#34;100\u0026#34;}, } var prevExpr string for _, test := range tests { // Print expr only when it changes. \tif test.expr != prevExpr { fmt.Printf(\u0026#34;\\n%s\\n\u0026#34;, test.expr) prevExpr = test.expr } expr, err := Parse(test.expr) if err != nil { t.Error(err) // parse error \tcontinue } got := fmt.Sprintf(\u0026#34;%.6g\u0026#34;, expr.Eval(test.env)) fmt.Printf(\u0026#34;\\t%v =\u0026gt; %s\\n\u0026#34;, test.env, got) if got != test.want { t.Errorf(\u0026#34;%s.Eval() in %v = %q, want %q\\n\u0026#34;, test.expr, test.env, got, test.want) } } } 对于表格中的每一条记录，这个测试会解析它的表达式然后在环境变量中计算它，输出结果。这里我们没有空间来展示Parse函数，但是如果你使用go get下载这个包你就可以看到这个函数。\ngo test(§11.1) 命令会运行一个包的测试用例：\n$ go test -v gopl.io/ch7/eval 这个-v标识可以让我们看到测试用例打印的输出；正常情况下像这样一个成功的测试用例会阻止打印结果的输出。这里是测试用例里fmt.Printf语句的输出：\nsqrt(A / pi) map[A:87616 pi:3.141592653589793] =\u0026gt; 167 pow(x, 3) + pow(y, 3) map[x:12 y:1] =\u0026gt; 1729 map[x:9 y:10] =\u0026gt; 1729 5 / 9 * (F - 32) map[F:-40] =\u0026gt; -40 map[F:32] =\u0026gt; 0 map[F:212] =\u0026gt; 100 幸运的是目前为止所有的输入都是适合的格式，但是我们的运气不可能一直都有。甚至在解释型语言中，为了静态错误检查语法是非常常见的；静态错误就是不用运行程序就可以检测出来的错误。通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。\n让我们往Expr接口中增加另一个方法。Check方法对一个表达式语义树检查出静态错误。我们马上会说明它的vars参数。\ntype Expr interface { Eval(env Env) float64 // Check reports errors in this Expr and adds its Vars to the set. \tCheck(vars map[Var]bool) error } 具体的Check方法展示在下面。literal和Var类型的计算不可能失败，所以这些类型的Check方法会返回一个nil值。对于unary和binary的Check方法会首先检查操作符是否有效，然后递归的检查运算单元。相似地对于call的这个方法首先检查调用的函数是否已知并且有没有正确个数的参数，然后递归的检查每一个参数。\nfunc (v Var) Check(vars map[Var]bool) error { vars[v] = true return nil } func (literal) Check(vars map[Var]bool) error { return nil } func (u unary) Check(vars map[Var]bool) error { if !strings.ContainsRune(\u0026#34;+-\u0026#34;, u.op) { return fmt.Errorf(\u0026#34;unexpected unary op %q\u0026#34;, u.op) } return u.x.Check(vars) } func (b binary) Check(vars map[Var]bool) error { if !strings.ContainsRune(\u0026#34;+-*/\u0026#34;, b.op) { return fmt.Errorf(\u0026#34;unexpected binary op %q\u0026#34;, b.op) } if err := b.x.Check(vars); err != nil { return err } return b.y.Check(vars) } func (c call) Check(vars map[Var]bool) error { arity, ok := numParams[c.fn] if !ok { return fmt.Errorf(\u0026#34;unknown function %q\u0026#34;, c.fn) } if len(c.args) != arity { return fmt.Errorf(\u0026#34;call to %s has %d args, want %d\u0026#34;, c.fn, len(c.args), arity) } for _, arg := range c.args { if err := arg.Check(vars); err != nil { return err } } return nil } var numParams = map[string]int{\u0026#34;pow\u0026#34;: 2, \u0026#34;sin\u0026#34;: 1, \u0026#34;sqrt\u0026#34;: 1} 我们在两个组中有选择地列出有问题的输入和它们得出的错误。Parse函数（这里没有出现）会报出一个语法错误和Check函数会报出语义错误。\nx % 2 unexpected '%' math.Pi unexpected '.' !true unexpected '!' \u0026quot;hello\u0026quot; unexpected '\u0026quot;' log(10) unknown function \u0026quot;log\u0026quot; sqrt(1, 2) call to sqrt has 2 args, want 1 Check方法的参数是一个Var类型的集合，这个集合聚集从表达式中找到的变量名。为了保证成功的计算，这些变量中的每一个都必须出现在环境变量中。从逻辑上讲，这个集合就是调用Check方法返回的结果，但是因为这个方法是递归调用的，所以对于Check方法，填充结果到一个作为参数传入的集合中会更加的方便。调用方在初始调用时必须提供一个空的集合。\n在第3.2节中，我们绘制了一个在编译期才确定的函数f(x,y)。现在我们可以解析，检查和计算在字符串中的表达式，我们可以构建一个在运行时从客户端接收表达式的web应用并且它会绘制这个函数的表示的曲面。我们可以使用集合vars来检查表达式是否是一个只有两个变量x和y的函数——实际上是3个，因为我们为了方便会提供半径大小r。并且我们会在计算前使用Check方法拒绝有格式问题的表达式，这样我们就不会在下面函数的40000个计算过程（100x100个栅格，每一个有4个角）重复这些检查。\n这个ParseAndCheck函数混合了解析和检查步骤的过程：\ngopl.io/ch7/surface\nimport \u0026#34;gopl.io/ch7/eval\u0026#34; func parseAndCheck(s string) (eval.Expr, error) { if s == \u0026#34;\u0026#34; { return nil, fmt.Errorf(\u0026#34;empty expression\u0026#34;) } expr, err := eval.Parse(s) if err != nil { return nil, err } vars := make(map[eval.Var]bool) if err := expr.Check(vars); err != nil { return nil, err } for v := range vars { if v != \u0026#34;x\u0026#34; \u0026amp;\u0026amp; v != \u0026#34;y\u0026#34; \u0026amp;\u0026amp; v != \u0026#34;r\u0026#34; { return nil, fmt.Errorf(\u0026#34;undefined variable: %s\u0026#34;, v) } } return expr, nil } 为了编写这个web应用，所有我们需要做的就是下面这个plot函数，这个函数有和http.HandlerFunc相似的签名：\nfunc plot(w http.ResponseWriter, r *http.Request) { r.ParseForm() expr, err := parseAndCheck(r.Form.Get(\u0026#34;expr\u0026#34;)) if err != nil { http.Error(w, \u0026#34;bad expr: \u0026#34;+err.Error(), http.StatusBadRequest) return } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/svg+xml\u0026#34;) surface(w, func(x, y float64) float64 { r := math.Hypot(x, y) // distance from (0,0) \treturn expr.Eval(eval.Env{\u0026#34;x\u0026#34;: x, \u0026#34;y\u0026#34;: y, \u0026#34;r\u0026#34;: r}) }) }  这个plot函数解析和检查在HTTP请求中指定的表达式并且用它来创建一个两个变量的匿名函数。这个匿名函数和来自原来surface-plotting程序中的固定函数f有相同的签名，但是它计算一个用户提供的表达式。环境变量中定义了x，y和半径r。最后plot调用surface函数，它就是gopl.io/ch3/surface中的主要函数，修改后它可以接受plot中的函数和输出io.Writer作为参数，而不是使用固定的函数f和os.Stdout。图7.7中显示了通过程序产生的3个曲面。\n练习 7.13： 为Expr增加一个String方法来打印美观的语法树。当再一次解析的时候，检查它的结果是否生成相同的语法树。\n练习 7.14： 定义一个新的满足Expr接口的具体类型并且提供一个新的操作例如对它运算单元中的最小值的计算。因为Parse函数不会创建这个新类型的实例，为了使用它你可能需要直接构造一个语法树（或者继承parser接口）。\n练习 7.15： 编写一个从标准输入中读取一个单一表达式的程序，用户及时地提供对于任意变量的值，然后在结果环境变量中计算表达式的值。优雅的处理所有遇到的错误。\n练习 7.16： 编写一个基于web的计算器程序。\n"});index.add({'id':174,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/','title':"8. Goroutines和Channels",'section':"Go语言圣经",'content':"第八章　Goroutines和Channels #  并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。Web服务器会一次处理成千上万的请求。平板电脑和手机app在渲染用户画面同时还会后台执行各种计算任务和网络请求。即使是传统的批处理问题——读取数据、计算、写输出，现在也会用并发来隐藏掉I/O的操作延迟以充分利用现代计算机设备的多个核心。计算机的性能每年都在以非线性的速度增长。\nGo语言中的并发程序可以用两种手段来实现。本章讲解goroutine和channel，其支持“顺序通信进程”（communicating sequential processes）或被简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例（goroutine）中传递，尽管大多数情况下仍然是被限制在单一实例中。第9章覆盖更为传统的并发模型：多线程共享内存，如果你在其它的主流语言中写过并发程序的话可能会更熟悉一些。第9章也会深入介绍一些并发程序带来的风险和陷阱。\n尽管Go对并发的支持是众多强力特性之一，但跟踪调试并发程序还是很困难，在线性程序中形成的直觉往往还会使我们误入歧途。如果这是读者第一次接触并发，推荐稍微多花一些时间来思考这两个章节中的样例。\n"});index.add({'id':175,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.9.-Cancellation/','title':"8.9. 并发的退出",'section':"8. Goroutines和Channels",'content':"8.9. 并发的退出 #  有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。\nGo语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？\n一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。\n回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。\n只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，不需要向这个channel发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。\ngopl.io/ch8/du4\nvar done = make(chan struct{}) func cancelled() bool { select { case \u0026lt;-done: return true default: return false } } 下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到（比如用户按了回车键），这个goroutine就会把取消消息通过关闭done的channel广播出去。\n// Cancel traversal when input is detected. go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte \tclose(done) }() 现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候即会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。\nfor { select { case \u0026lt;-done: // Drain fileSizes to allow existing goroutines to finish. \tfor range fileSizes { // Do nothing. \t} return case size, ok := \u0026lt;-fileSizes: // ... \t} } walkDir这个goroutine一启动就会轮询取消状态，如果取消状态被设置的话会直接返回，并且不做额外的事情。这样我们将所有在取消事件之后创建的goroutine改变为无操作。\nfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan\u0026lt;- int64) { defer n.Done() if cancelled() { return } for _, entry := range dirents(dir) { // ... \t} } 在walkDir函数的循环中我们对取消状态进行轮询可以带来明显的益处，可以避免在取消事件发生时还去创建goroutine。取消本身是有一些代价的；想要快速的响应需要对程序逻辑进行侵入式的修改。确保在取消发生之后不要有代价太大的操作可能会需要修改你代码里的很多地方，但是在一些重要的地方去检查取消事件也确实能带来很大的好处。\n对这个程序的一个简单的性能分析可以揭示瓶颈在dirents函数中获取一个信号量。下面的select可以让这种操作可以被取消，并且可以将取消时的延迟从几百毫秒降低到几十毫秒。\nfunc dirents(dir string) []os.FileInfo { select { case sema \u0026lt;- struct{}{}: // acquire token \tcase \u0026lt;-done: return nil // cancelled \t} defer func() { \u0026lt;-sema }() // release token \t// ...read directory... } 现在当取消发生时，所有后台的goroutine都会迅速停止并且主函数会返回。当然，当主函数返回时，一个程序会退出，而我们又无法在主函数退出的时候确认其已经释放了所有的资源（译注：因为程序都退出了，你的代码都没法执行了）。这里有一个方便的窍门我们可以一用：取代掉直接从主函数返回，我们调用一个panic，然后runtime会把每一个goroutine的栈dump下来。如果main goroutine是唯一一个剩下的goroutine的话，他会清理掉自己的一切资源。但是如果还有其它的goroutine没有退出，他们可能没办法被正确地取消掉，也有可能被取消但是取消操作会很花时间；所以这里的一个调研还是很有必要的。我们用panic来获取到足够的信息来验证我们上面的判断，看看最终到底是什么样的情况。\n练习 8.10： HTTP请求可能会因http.Request结构体中Cancel channel的关闭而取消。修改8.6节中的web crawler来支持取消http请求。（提示：http.Get并没有提供方便地定制一个请求的方法。你可以用http.NewRequest来取而代之，设置它的Cancel字段，然后用http.DefaultClient.Do(req)来进行这个http请求。）\n练习 8.11： 紧接着8.4.4中的mirroredQuery流程，实现一个并发请求url的fetch的变种。当第一个请求返回时，直接取消其它的请求。\n"});index.add({'id':176,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.10.-Method-Names/','title':"2.10. 方法名",'section':"2. 有意义的命名",'content':"2.10 方法名 #  Methods should have verb or verb phrase names like postPayment, deletePage, or save. Accessors, mutators, and predicates should be named for their value and prefixed with get, set, and is according to the javabean standard.4\n 方法名应当是动词或动词短语，如 postPayment、deletePage 或 save。属性访问器、修改器和断言应该根据其值命名，并依 Javabean 标准加上 get、set 和 is 前缀。\n string name = employee.getName(); customer.setName(\u0026#34;mike\u0026#34;); if (paycheck.isPosted())… When constructors are overloaded, use static factory methods with names that describe the arguments. For example,\n 重载构造器时，使用描述了参数的静态工厂方法名。例如，\n Complex fulcrumPoint = Complex.FromRealNumber(23.0); is generally better than\n 通常好于\n Complex fulcrumPoint = new Complex(23.0); Consider enforcing their use by making the corresponding constructors private.\n 可以考虑将相应的构造器设置为 private，强制使用这种命名手段。\n "});index.add({'id':177,'href':'/docs/The-Go-Programming-Language/5.-Functions/5.10.-Recover/','title':"5.10. Recover捕获异常",'section':"5. 函数",'content':"5.10. Recover捕获异常 #  通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。\n如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。\n让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。\nfunc Parse(input string) (s *Syntax, err error) { defer func() { if p := recover(); p != nil { err = fmt.Errorf(\u0026#34;internal error: %v\u0026#34;, p) } }() // ...parser... } deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。\n不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。\n虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。\n有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。\n基于以上原因，安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。\n下面的例子是title函数的变形，如果HTML页面包含多个\u0026lt;title\u0026gt;，该函数会给调用者返回一个错误（error）。在soleTitle内部处理时，如果检测到有多个\u0026lt;title\u0026gt;，会调用panic，阻止函数继续递归，并将特殊类型bailout作为panic的参数。\n// soleTitle returns the text of the first non-empty title element // in doc, and an error if there was not exactly one. func soleTitle(doc *html.Node) (title string, err error) { type bailout struct{} defer func() { switch p := recover(); p { case nil: // no panic \tcase bailout{}: // \u0026#34;expected\u0026#34; panic \terr = fmt.Errorf(\u0026#34;multiple title elements\u0026#34;) default: panic(p) // unexpected panic; carry on panicking \t} }() // Bail out of recursion if we find more than one nonempty title. \tforEachNode(doc, func(n *html.Node) { if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data == \u0026#34;title\u0026#34; \u0026amp;\u0026amp; n.FirstChild != nil { if title != \u0026#34;\u0026#34; { panic(bailout{}) // multiple titleelements \t} title = n.FirstChild.Data } }, nil) if title == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;no title element\u0026#34;) } return title, nil } 在上例中，deferred函数调用recover，并检查panic value。当panic value是bailout{}类型时，deferred函数生成一个error返回给调用者。当panic value是其他non-nil值时，表示发生了未知的panic异常，deferred函数将调用panic函数并将当前的panic value作为参数传入；此时，等同于recover没有做任何操作。（请注意：在例子中，对可预期的错误采用了panic，这违反了之前的建议，我们在此只是想向读者演示这种机制。）\n有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。\n练习5.19： 使用panic和recover编写一个不包含return语句但能返回一个非零值的函数。\n"});index.add({'id':178,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.10.-Type-Assertions/','title':"7.10. 类型断言",'section':"7. 接口",'content':"7.10. 类型断言 #  类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。\n这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：\nvar w io.Writer w = os.Stdout f := w.(*os.File) // success: f == os.Stdout c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer 第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。\n在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型*os.File，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。\nvar w io.Writer w = os.Stdout rw := w.(io.ReadWriter) // success: *os.File has both Read and Write w = new(ByteCounter) rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method 如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。\nw = rw // io.ReadWriter is assignable to io.Writer w = rw.(io.Writer) // fails only if rw == nil 经常地，对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：\nvar w io.Writer = os.Stdout f, ok := w.(*os.File) // success: ok, f == os.Stdout b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil 第二个结果通常赋值给一个命名为ok的变量。如果这个操作失败了，那么ok就是false值，第一个结果等于被断言类型的零值，在这个例子中就是一个nil的*bytes.Buffer类型。\n这个ok结果经常立即用于决定程序下面做什么。if语句的扩展格式让这个变的很简洁：\nif f, ok := w.(*os.File); ok { // ...use f... } 当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖（理解：其实是声明了一个同名的新的本地变量，外层原来的w不会被改变），如下面这样：\nif w, ok := w.(*os.File); ok { // ...use w... } "});index.add({'id':179,'href':'/docs/The-Go-Programming-Language/8.-Goroutines-and-Channels/8.10.-Example-Chat-Server/','title':"8.10. 示例: 聊天服务",'section':"8. Goroutines和Channels",'content':"8.10. 示例: 聊天服务 #  我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goroutine。main和broadcaster各自是一个goroutine实例，每一个客户端的连接都会有一个handleConn和clientWriter的goroutine。broadcaster是select用法的不错的样例，因为它需要处理三种不同类型的消息。\n下面演示的main goroutine的工作，是listen和accept(译注：网络编程里的概念)从客户端过来的连接。对每一个连接，程序都会建立一个新的handleConn的goroutine，就像我们在本章开头的并发的echo服务器里所做的那样。\ngopl.io/ch8/chat\nfunc main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8000\u0026#34;) if err != nil { log.Fatal(err) } go broadcaster() for { conn, err := listener.Accept() if err != nil { log.Print(err) continue } go handleConn(conn) } } 然后是broadcaster的goroutine。他的内部变量clients会记录当前建立连接的客户端集合。其记录的内容是每一个客户端的消息发出channel的“资格”信息。\ntype client chan\u0026lt;- string // an outgoing message channel  var ( entering = make(chan client) leaving = make(chan client) messages = make(chan string) // all incoming client messages ) func broadcaster() { clients := make(map[client]bool) // all connected clients \tfor { select { case msg := \u0026lt;-messages: // Broadcast incoming message to all \t// clients\u0026#39; outgoing message channels. \tfor cli := range clients { cli \u0026lt;- msg } case cli := \u0026lt;-entering: clients[cli] = true case cli := \u0026lt;-leaving: delete(clients, cli) close(cli) } } } broadcaster监听来自全局的entering和leaving的channel来获知客户端的到来和离开事件。当其接收到其中的一个事件时，会更新clients集合，当该事件是离开行为时，它会关闭客户端的消息发送channel。broadcaster也会监听全局的消息channel，所有的客户端都会向这个channel中发送消息。当broadcaster接收到什么消息时，就会将其广播至所有连接到服务端的客户端。\n现在让我们看看每一个客户端的goroutine。handleConn函数会为它的客户端创建一个消息发送channel并通过entering channel来通知客户端的到来。然后它会读取客户端发来的每一行文本，并通过全局的消息channel来将这些文本发送出去，并为每条消息带上发送者的前缀来标明消息身份。当客户端发送完毕后，handleConn会通过leaving这个channel来通知客户端的离开并关闭连接。\nfunc handleConn(conn net.Conn) { ch := make(chan string) // outgoing client messages \tgo clientWriter(conn, ch) who := conn.RemoteAddr().String() ch \u0026lt;- \u0026#34;You are \u0026#34; + who messages \u0026lt;- who + \u0026#34; has arrived\u0026#34; entering \u0026lt;- ch input := bufio.NewScanner(conn) for input.Scan() { messages \u0026lt;- who + \u0026#34;: \u0026#34; + input.Text() } // NOTE: ignoring potential errors from input.Err()  leaving \u0026lt;- ch messages \u0026lt;- who + \u0026#34; has left\u0026#34; conn.Close() } func clientWriter(conn net.Conn, ch \u0026lt;-chan string) { for msg := range ch { fmt.Fprintln(conn, msg) // NOTE: ignoring network errors \t} } 另外，handleConn为每一个客户端创建了一个clientWriter的goroutine，用来接收向客户端发送消息的channel中的广播消息，并将它们写入到客户端的网络连接。客户端的读取循环会在broadcaster接收到leaving通知并关闭了channel后终止。\n下面演示的是当服务器有两个活动的客户端连接，并且在两个窗口中运行的情况，使用netcat来聊天：\n$ go build gopl.io/ch8/chat $ go build gopl.io/ch8/netcat3 $ ./chat \u0026amp; $ ./netcat3 You are 127.0.0.1:64208 $ ./netcat3 127.0.0.1:64211 has arrived You are 127.0.0.1:64211 Hi! 127.0.0.1:64208: Hi! 127.0.0.1:64208: Hi! Hi yourself. 127.0.0.1:64211: Hi yourself. 127.0.0.1:64211: Hi yourself. ^C 127.0.0.1:64208 has left $ ./netcat3 You are 127.0.0.1:64216 127.0.0.1:64216 has arrived Welcome. 127.0.0.1:64211: Welcome. 127.0.0.1:64211: Welcome. ^C 127.0.0.1:64211 has left” 当与n个客户端保持聊天session时，这个程序会有2n+2个并发的goroutine，然而这个程序却并不需要显式的锁（§9.2）。clients这个map被限制在了一个独立的goroutine中，broadcaster，所以它不能被并发地访问。多个goroutine共享的变量只有这些channel和net.Conn的实例，两个东西都是并发安全的。我们会在下一章中更多地讲解约束，并发安全以及goroutine中共享变量的含义。\n练习 8.12： 使broadcaster能够将arrival事件通知当前所有的客户端。这需要你在clients集合中，以及entering和leaving的channel中记录客户端的名字。\n练习 8.13： 使聊天服务器能够断开空闲的客户端连接，比如最近五分钟之后没有发送任何消息的那些客户端。提示：可以在其它goroutine中调用conn.Close()来解除Read调用，就像input.Scanner()所做的那样。\n练习 8.14： 修改聊天服务器的网络协议，这样每一个客户端就可以在entering时提供他们的名字。将消息前缀由之前的网络地址改为这个名字。\n练习 8.15： 如果一个客户端没有及时地读取数据可能会导致所有的客户端被阻塞。修改broadcaster来跳过一条消息，而不是等待这个客户端一直到其准备好读写。或者为每一个客户端的消息发送channel建立缓冲区，这样大部分的消息便不会被丢掉；broadcaster应该用一个非阻塞的send向这个channel中发消息。\n"});index.add({'id':180,'href':'/docs/The-Go-Programming-Language/9.-Concurrency-with-Shared-Variables/','title':"9. 基于共享变量的并发",'section':"Go语言圣经",'content':"第九章　基于共享变量的并发 #  前一章我们介绍了一些使用goroutine和channel这样直接而自然的方式来实现并发的方法。然而这样做我们实际上回避了在写并发代码时必须处理的一些重要而且细微的问题。\n在本章中，我们会细致地了解并发机制。尤其是在多goroutine之间的共享变量，并发问题的分析手段，以及解决这些问题的基本模式。最后我们会解释goroutine和操作系统线程之间的技术上的一些区别。\n"});index.add({'id':181,'href':'/docs/The-Go-Programming-Language/10.-Packages-and-the-Go-Tool/','title':"10. 包和工具",'section':"Go语言圣经",'content':"第十章　包和工具 #  现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的方式被重用。\nGo语言有超过100个的标准包（译注：可以用go list std | wc -l命令查看标准包的具体数目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 http://godoc.org 检索。在本章，我们将演示如何使用已有的包和创建新的包。\nGo还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。在本书开始的时候，我们已经见识过如何使用工具箱自带的工具来下载、构建和运行我们的演示程序了。在本章，我们将看看这些工具的基本设计理论和尝试更多的功能，例如打印工作区中包的文档和查询相关的元数据等。在下一章，我们将探讨testing包的单元测试用法。\n"});index.add({'id':182,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.11.-Dont-Be-Cute/','title':"2.11. 别扮可爱",'section':"2. 有意义的命名",'content':"2.11 别扮可爱 #  If names are too clever, they will be memorable only to people who share the author’s sense of humor, and only as long as these people remember the joke. Will they know what the function named HolyHandGrenade is supposed to do? Sure, it’s cute, but maybe in this case DeleteItems might be a better name. Choose clarity over entertainment value.\n 如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为 HolyHandGrenade 的函数是用来做什么的呢？没错，这名字挺伶俐，不过 DeleteItems 或许是更好的名称。宁可明确，毋为好玩。\n  Cuteness in code often appears in the form of colloquialisms or slang. For example, don’t use the name whack() to mean kill(). Don’t tell little culture-dependent jokes like eatMyShorts() to mean abort().\n 扮可爱的做法在代码中经常体现为使用俗话或俚语。例如，别用 whack() 来表示 kill( )。别用 eatMyShorts() 这类与文化紧密相关的笑话来表示 abort( )。\n Say what you mean. Mean what you say.\n 言到意到。意到言到。\n "});index.add({'id':183,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.11.-Discriminating-Errors-with-Type-Assertions/','title':"7.11. 基于类型断言区别错误类型",'section':"7. 接口",'content':"7.11. 基于类型断言区别错误类型 #  思考在os包中文件操作返回的错误集合。I/O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。os包中提供了三个帮助函数来对给定的错误值表示的失败进行分类：\npackage os func IsExist(err error) bool func IsNotExist(err error) bool func IsPermission(err error) bool 对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串，\nfunc IsNotExist(err error) bool { // NOTE: not robust! \treturn strings.Contains(err.Error(), \u0026#34;file does not exist\u0026#34;) } 但是处理I/O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。\n一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：\npackage os // PathError records an error and the operation and file path that caused it. type PathError struct { Op string Path string Err error } func (e *PathError) Error() string { return e.Op + \u0026#34; \u0026#34; + e.Path + \u0026#34;: \u0026#34; + e.Err.Error() } 大多数调用方都不知道PathError并且通过调用错误本身的Error方法来统一处理所有的错误。尽管PathError的Error方法简单地把这些字段连接起来生成错误消息，PathError的结构保护了内部的错误组件。调用方需要使用类型断言来检测错误的具体类型以便将一种失败和另一种区分开；具体的类型可以比字符串提供更多的细节。\n_, err := os.Open(\u0026#34;/no/such/file\u0026#34;) fmt.Println(err) // \u0026#34;open /no/such/file: No such file or directory\u0026#34; fmt.Printf(\u0026#34;%#v\\n\u0026#34;, err) // Output: // \u0026amp;os.PathError{Op:\u0026#34;open\u0026#34;, Path:\u0026#34;/no/such/file\u0026#34;, Err:0x2} 这就是三个帮助函数是怎么工作的。例如下面展示的IsNotExist，它会报出是否一个错误和syscall.ENOENT（§7.8）或者和有名的错误os.ErrNotExist相等（可以在§5.4.2中找到io.EOF）；或者是一个*PathError，它内部的错误是syscall.ENOENT和os.ErrNotExist其中之一。\nimport ( \u0026#34;errors\u0026#34; \u0026#34;syscall\u0026#34; ) var ErrNotExist = errors.New(\u0026#34;file does not exist\u0026#34;) // IsNotExist returns a boolean indicating whether the error is known to // report that a file or directory does not exist. It is satisfied by // ErrNotExist as well as some syscall errors. func IsNotExist(err error) bool { if pe, ok := err.(*PathError); ok { err = pe.Err } return err == syscall.ENOENT || err == ErrNotExist } 下面这里是它的实际使用：\n_, err := os.Open(\u0026#34;/no/such/file\u0026#34;) fmt.Println(os.IsNotExist(err)) // \u0026#34;true\u0026#34; 如果错误消息结合成一个更大的字符串，当然PathError的结构就不再为人所知，例如通过一个对fmt.Errorf函数的调用。区别错误通常必须在失败操作后，错误传回调用者前进行。\n"});index.add({'id':184,'href':'/docs/The-Go-Programming-Language/11.-Testing/','title':"11. 测试",'section':"Go语言圣经",'content':"第十一章　测试 #  Maurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memoirs of a Computer Pioneer）里，他回忆到：“忽然间有一种醍醐灌顶的感觉，我整个后半生的美好时光都将在寻找程序BUG中度过了”。肯定从那之后的大部分正常的码农都会同情Wilkes过分悲观的想法，虽然也许会有人困惑于他对软件开发的难度的天真看法。\n现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试，也就是本章的讨论主题。\n我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。\n软件测试是一个巨大的领域。测试的任务可能已经占据了一些程序员的部分时间和另一些程序员的全部时间。和软件测试技术相关的图书或博客文章有成千上万之多。对于每一种主流的编程语言，都会有一打的用于测试的软件包，同时也有大量的测试相关的理论，而且每种都吸引了大量技术先驱和追随者。这些都足以说服那些想要编写有效测试的程序员重新学习一套全新的技能。\nGo语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。\n在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。我们必须小心处理边界条件，思考合适的数据结构，推断合适的输入应该产生什么样的结果输出。编写测试代码和编写普通的Go代码过程是类似的；它并不需要学习新的符号、规则和工具。\n"});index.add({'id':185,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.12.-Pick-One-Word-per-Concept/','title':"2.12. 每个概念对应一个词",'section':"2. 有意义的命名",'content':"2.12 每个概念对应一个词 #  Pick one word for one abstract concept and stick with it. For instance, it’s confusing to have fetch, retrieve, and get as equivalent methods of different classes. How do you remember which method name goes with which class? Sadly, you often have to remember which company, group, or individual wrote the library or class in order to remember which term was used. Otherwise, you spend an awful lot of time browsing through headers and previous code samples.\n 给每个抽象概念选一个词，并且一以贯之。例如，使用 fetch、 retrieve 和 get 来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？很悲哀，你总得记住编写库或类的公司、机构或个人，才能想得起来用的是哪个术语。否则，就得耗费大把时间浏览各个文件头及前面的代码。\n Modern editing environments like Eclipse and IntelliJ provide context-sensitive clues, such as the list of methods you can call on a given object. But note that the list doesn’t usually give you the comments you wrote around your function names and parameter lists. You are lucky if it gives the parameter names from function declarations. The function names have to stand alone, and they have to be consistent in order for you to pick the correct method without any additional exploration.\n Eclipse 和 IntelliJ 之类现代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就找到正确的方法。\n Likewise, it’s confusing to have a controller and a manager and a driver in the same code base. What is the essential difference between a DeviceManager and a Protocol-Controller? Why are both not controllers or both not managers? Are they both Drivers really? The name leads you to expect two objects that have very different type as well as having different classes.\n 同样，在同一堆代码中有 controller，又有 manager，还有 driver，就会令人困惑。DeviceManager 和 Protocol-Controller 之间有何根本区别？为什么不全用 controllers 或 managers？他们都是 Drivers 吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。\n A consistent lexicon is a great boon to the programmers who must use your code.\n 对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。\n "});index.add({'id':186,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.12.-Querying-Behaviors-with-Interface-Type-Assertions/','title':"7.12. 通过类型断言询问行为",'section':"7. 接口",'content':"7.12. 通过类型断言询问行为 #  下面这段逻辑和net/http包中web服务器负责写入HTTP头字段（例如：\u0026ldquo;Content-type:text/html\u0026rdquo;）的部分相似。io.Writer接口类型的变量w代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。\nfunc writeHeader(w io.Writer, contentType string) error { if _, err := w.Write([]byte(\u0026#34;Content-Type: \u0026#34;)); err != nil { return err } if _, err := w.Write([]byte(contentType)); err != nil { return err } // ... } 因为Write方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用[]byte(\u0026hellip;)进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？\n这个io.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。如果我们回顾net/http包中的内幕，我们知道在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法；这个方法会避免去分配一个临时的拷贝。（这可能像在黑夜中射击一样，但是许多满足io.Writer接口的重要类型同时也有WriteString方法，包括*bytes.Buffer，*os.File和*bufio.Writer。）\n我们不能对任意io.Writer类型的变量w，假设它也拥有WriteString方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否w的动态类型满足这个新接口。\n// writeString writes s to w. // If w has a WriteString method, it is invoked instead of w.Write. func writeString(w io.Writer, s string) (n int, err error) { type stringWriter interface { WriteString(string) (n int, err error) } if sw, ok := w.(stringWriter); ok { return sw.WriteString(s) // avoid a copy \t} return w.Write([]byte(s)) // allocate temporary copy } func writeHeader(w io.Writer, contentType string) error { if _, err := writeString(w, \u0026#34;Content-Type: \u0026#34;); err != nil { return err } if _, err := writeString(w, contentType); err != nil { return err } // ... } 为了避免重复定义，我们将这个检查移入到一个实用工具函数writeString中，但是它太有用了以致于标准库将它作为io.WriteString函数提供。这是向一个io.Writer接口写入字符串的推荐方法。\n这个例子的神奇之处在于，没有定义了WriteString方法的标准接口，也没有指定它是一个所需行为的标准接口。一个具体类型只会通过它的方法决定它是否满足stringWriter接口，而不是任何它和这个接口类型所表达的关系。它的意思就是上面的技术依赖于一个假设，这个假设就是：如果一个类型满足下面的这个接口，然后WriteString(s)方法就必须和Write([]byte(s))有相同的效果。\ninterface { io.Writer WriteString(s string) (n int, err error) } 尽管io.WriteString实施了这个假设，但是调用它的函数极少可能会去实施类似的假设。定义一个特定类型的方法隐式地获取了对特定行为的协约。对于Go语言的新手，特别是那些来自有强类型语言使用背景的新手，可能会发现它缺乏显式的意图令人感到混乱，但是在实战的过程中这几乎不是一个问题。除了空接口interface{}，接口类型很少意外巧合地被实现。\n上面的writeString函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。这个技术可以被很好的使用，不论这个被询问的接口是一个标准如io.ReadWriter，或者用户定义的如stringWriter接口。\n这也是fmt.Fprintf函数怎么从其它所有值中区分满足error或者fmt.Stringer接口的值。在fmt.Fprintf内部，有一个将单个操作对象转换成一个字符串的步骤，像下面这样：\npackage fmt func formatOneValue(x interface{}) string { if err, ok := x.(error); ok { return err.Error() } if str, ok := x.(Stringer); ok { return str.String() } // ...all other types... } 如果x满足这两个接口类型中的一个，具体满足的接口决定对值的格式化方式。如果都不满足，默认的case或多或少会统一地使用反射来处理所有的其它类型；我们可以在第12章知道具体是怎么实现的。\n再一次的，它假设任何有String方法的类型都满足fmt.Stringer中约定的行为，这个行为会返回一个适合打印的字符串。\n"});index.add({'id':187,'href':'/docs/The-Go-Programming-Language/12.-Reflection/','title':"12. 反射",'section':"Go语言圣经",'content':"第十二章　反射 #  Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。\n在本章，我们将探讨Go语言的反射特性，看看它可以给语言增加哪些表达力，以及在两个至关重要的API是如何使用反射机制的：一个是fmt包提供的字符串格式化功能，另一个是类似encoding/json和encoding/xml提供的针对特定协议的编解码功能。对于我们在4.6节中看到过的text/template和html/template包，它们的实现也是依赖反射技术的。然后，反射是一个复杂的内省技术，不应该随意使用，因此，尽管上面这些包内部都是用反射技术实现的，但是它们自己的API都没有公开反射相关的接口。\n"});index.add({'id':188,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.13.-Dont-Pun/','title':"2.13. 别用双关语",'section':"2. 有意义的命名",'content':"2.13 别用双关语 #  Avoid using the same word for two purposes. Using the same term for two different ideas is essentially a pun.\n 避免将同一单词用于不同目的。同一术语用于不同概念，基本上就是双关语了。\n If you follow the “one word per concept” rule, you could end up with many classes that have, for example, an add method. As long as the parameter lists and return values of the various add methods are semantically equivalent, all is well.\n 如果遵循“一词一义”规则，可能在好多个类里面都会有 add 方法。只要这些 add 方法的参数列表和返回值在语义上等价，就一切顺利。\n However one might decide to use the word add for “consistency” when he or she is not in fact adding in the same sense. Let’s say we have many classes where add will create a new value by adding or concatenating two existing values. Now let’s say we are writing a new class that has a method that puts its single parameter into a collection. Should we call this method add? It might seem consistent because we have so many other add methods, but in this case, the semantics are different, so we should use a name like insert or append instead. To call the new method add would be a pun.\n 但是，可能会有人决定为“保持一致”而使用 add 这个词来命名，即便并非真的想表示这种意思。比如，在多个类中都有 add 方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做 add 吗？这样做貌似和其他 add 方法保持了一致，但实际上语义却不同，应该用 insert 或 append 之类词来命名才对。把该方法命名为 add，就是双关语了。\n Our goal, as authors, is to make our code as easy as possible to understand. We want our code to be a quick skim, not an intense study. We want to use the popular paperback model whereby the author is responsible for making himself clear and not the academic model where it is the scholar’s job to dig the meaning out of the paper.\n 代码作者应尽力写出易于理解的代码。我们想把代码写得让别人能一目尽览，而不必殚精竭虑地研究。我们想要那种大众化的作者尽责写清楚的平装书模式；我们不想要那种学者挖地三尺才能明白个中意义的学院派模式。\n "});index.add({'id':189,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.13.-Type-Switches/','title':"7.13. 类型分支",'section':"7. 接口",'content':"7.13. 类型分支 #  接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。\n第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。\n如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。\n和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：\nimport \u0026#34;database/sql\u0026#34; func listTracks(db sql.DB, artist string, minYear, maxYear int) { result, err := db.Exec( \u0026#34;SELECT * FROM tracks WHERE artist = ? AND ? \u0026lt;= year AND year \u0026lt;= ?\u0026#34;, artist, minYear, maxYear) // ... } Exec方法使用SQL字面量替换在查询字符串中的每个\u0026rsquo;?'；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。\nfunc sqlQuote(x interface{}) string { if x == nil { return \u0026#34;NULL\u0026#34; } else if _, ok := x.(int); ok { return fmt.Sprintf(\u0026#34;%d\u0026#34;, x) } else if _, ok := x.(uint); ok { return fmt.Sprintf(\u0026#34;%d\u0026#34;, x) } else if b, ok := x.(bool); ok { if b { return \u0026#34;TRUE\u0026#34; } return \u0026#34;FALSE\u0026#34; } else if s, ok := x.(string); ok { return sqlQuoteString(s) // (not shown) \t} else { panic(fmt.Sprintf(\u0026#34;unexpected type %T: %v\u0026#34;, x, x)) } } switch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。一个相似的type switch（类型分支）可以简化类型断言的if-else链。\n在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效。这个nil的case和if x == nil匹配，并且这个default的case和如果其它case都不匹配的情况匹配。一个对sqlQuote的类型分支可能会有这些case：\nswitch x.(type) { case nil: // ... case int, uint: // ... case bool: // ... case string: // ... default: // ... } 和（§1.8）中的普通switch语句一样，每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。default case相对其它case的位置是无所谓的。它不会允许落空发生。\n注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。\nswitch x := x.(type) { /* ... */ } 这里我们已经将新的变量也命名为x；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量x的定义不会和外面块中的x变量冲突。每一个case也会隐式的创建一个单独的词法块。\n使用类型分支的扩展形式来重写sqlQuote函数会让这个函数更加的清晰：\nfunc sqlQuote(x interface{}) string { switch x := x.(type) { case nil: return \u0026#34;NULL\u0026#34; case int, uint: return fmt.Sprintf(\u0026#34;%d\u0026#34;, x) // x has type interface{} here. \tcase bool: if x { return \u0026#34;TRUE\u0026#34; } return \u0026#34;FALSE\u0026#34; case string: return sqlQuoteString(x) // (not shown) \tdefault: panic(fmt.Sprintf(\u0026#34;unexpected type %T: %v\u0026#34;, x, x)) } } 在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。例如，变量x在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量x是switch运算对象的类型（接口）；在这个例子中运算对象是一个interface{}。当多个case需要相同的操作时，比如int和uint的情况，类型分支可以很容易的合并这些情况。\n尽管sqlQuote接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出“unexpected type”消息。虽然x的类型是interface{}，但是我们把它认为是一个int，uint，bool，string，和nil值的discriminated union（可识别联合）\n"});index.add({'id':190,'href':'/docs/The-Go-Programming-Language/13.-Low-Level-Programming/','title':"13. 底层编程",'section':"Go语言圣经",'content':"第十三章　底层编程 #  Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出错的用法。编译时类型检查可以发现大多数类型不匹配的操作，例如两个字符串做减法的错误。字符串、map、slice和chan等所有的内置类型，都有严格的类型转换规则。\n对于无法静态检测到的错误，例如数组访问越界或使用空指针，运行时动态检测可以保证程序在遇到问题的时候立即终止并打印相关的错误信息。自动内存管理（垃圾内存自动回收）可以消除大部分野指针和内存泄漏相关的问题。\nGo语言的实现刻意隐藏了很多底层细节。我们无法知道一个结构体真实的内存布局，也无法获取一个运行时函数对应的机器码，也无法知道当前的goroutine是运行在哪个操作系统线程之上。事实上，Go语言的调度器会自己决定是否需要将某个goroutine从一个操作系统线程转移到另一个操作系统线程。一个指向变量的指针也并没有展示变量真实的地址。因为垃圾回收器可能会根据需要移动变量的内存位置，当然变量对应的地址也会被自动更新。\n总的来说，Go语言的这些特性使得Go程序相比较低级的C语言来说更容易预测和理解，程序也不容易崩溃。通过隐藏底层的实现细节，也使得Go语言编写的程序具有高度的可移植性，因为语言的语义在很大程度上是独立于任何编译器实现、操作系统和CPU系统结构的（当然也不是完全绝对独立：例如int等类型就依赖于CPU机器字的大小，某些表达式求值的具体顺序，还有编译器实现的一些额外的限制等）。\n有时候我们可能会放弃使用部分语言特性而优先选择具有更好性能的方法，例如需要与其他语言编写的库进行互操作，或者用纯Go语言无法实现的某些函数。\n在本章，我们将展示如何使用unsafe包来摆脱Go语言规则带来的限制，讲述如何创建C语言函数库的绑定，以及如何进行系统调用。\n本章提供的方法不应该轻易使用（译注：属于黑魔法，虽然功能很强大，但是也容易误伤到自己）。如果没有处理好细节，它们可能导致各种不可预测的并且隐晦的错误，甚至连有经验的C语言程序员也无法理解这些错误。使用unsafe包的同时也放弃了Go语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的Go语言中很可能会被改变。\n要注意的是，unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布局相关的细节。将这些特性封装到一个独立的包中，是为在极少数情况下需要使用的时候，同时引起人们的注意（译注：因为看包的名字就知道使用unsafe包是不安全的）。此外，有一些环境因为安全的因素可能限制这个包的使用。\n不过unsafe包被广泛地用于比较低级的包，例如runtime、os、syscall还有net包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用unsafe包的。\n"});index.add({'id':191,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.14.-Use-Solution-Domain-Names/','title':"2.14. 使用解决方案领域名称",'section':"2. 有意义的命名",'content':"2.14 使用解决方案领域名称 #  Remember that the people who read your code will be programmers. So go ahead and use computer science (CS) terms, algorithm names, pattern names, math terms, and so forth. It is not wise to draw every name from the problem domain because we don’t want our coworkers to have to run back and forth to the customer asking what every name means when they already know the concept by a different name.\n 记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science，CS）术语、算法名、模式名、数学术语吧。依据问题所涉领域来命名可不算是聪明的做法，因为不该让协作者老是跑去问客户每个名称的含义，其实他们早该通过另一名称了解这个概念了。\n The name AccountVisitor means a great deal to a programmer who is familiar with the VISITOR pattern. What programmer would not know what a JobQueue was? There are lots of very technical things that programmers have to do. Choosing technical names for those things is usually the most appropriate course.\n 对于熟悉访问者（VISITOR）模式的程序来说，名称 AccountVisitor 富有意义。哪个程序员会不知道 JobQueue 的意思呢？程序员要做太多技术性工作。给这些事取个技术性的名称，通常是最靠谱的做法。\n "});index.add({'id':192,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.14.-Example-Token-Based-XML-Decoding/','title':"7.14. 示例: 基于标记的XML解码",'section':"7. 接口",'content':"7.14. 示例: 基于标记的XML解码 #  第4.5章节展示了如何使用encoding/json包中的Marshal和Unmarshal函数来将JSON文档转换成Go语言的数据结构。encoding/xml包提供了一个相似的API。当我们想构造一个文档树的表示时使用encoding/xml包会很方便，但是对于很多程序并不是必须的。encoding/xml包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－StartElement，EndElement，CharData，和Comment－每一个都是encoding/xml包中的具体类型。每一个对(*xml.Decoder).Token的调用都返回一个标记。\n这里显示的是和这个API相关的部分：\nencoding/xml\npackage xml type Name struct { Local string // e.g., \u0026#34;Title\u0026#34; or \u0026#34;id\u0026#34; } type Attr struct { // e.g., name=\u0026#34;value\u0026#34; \tName Name Value string } // A Token includes StartElement, EndElement, CharData, // and Comment, plus a few esoteric types (not shown). type Token interface{} type StartElement struct { // e.g., \u0026lt;name\u0026gt;  Name Name Attr []Attr } type EndElement struct { Name Name } // e.g., \u0026lt;/name\u0026gt; type CharData []byte // e.g., \u0026lt;p\u0026gt;CharData\u0026lt;/p\u0026gt; type Comment []byte // e.g., \u0026lt;!-- Comment --\u0026gt;  type Decoder struct{ /* ... */ } func NewDecoder(io.Reader) *Decoder func (*Decoder) Token() (Token, error) // returns next Token in sequence 这个没有方法的Token接口也是一个可识别联合的例子。传统的接口如io.Reader的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现：在这个实现中每个具体类型都被统一地对待。相反，满足可识别联合的具体类型的集合被设计为确定和暴露，而不是隐藏。可识别联合的类型几乎没有方法，操作它们的函数使用一个类型分支的case集合来进行表述，这个case集合中每一个case都有不同的逻辑。\n下面的xmlselect程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要实例化这个文档树。\ngopl.io/ch7/xmlselect\n// Xmlselect prints the text of selected elements of an XML document. package main import ( \u0026#34;encoding/xml\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { dec := xml.NewDecoder(os.Stdin) var stack []string // stack of element names \tfor { tok, err := dec.Token() if err == io.EOF { break } else if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;xmlselect: %v\\n\u0026#34;, err) os.Exit(1) } switch tok := tok.(type) { case xml.StartElement: stack = append(stack, tok.Name.Local) // push \tcase xml.EndElement: stack = stack[:len(stack)-1] // pop \tcase xml.CharData: if containsAll(stack, os.Args[1:]) { fmt.Printf(\u0026#34;%s: %s\\n\u0026#34;, strings.Join(stack, \u0026#34; \u0026#34;), tok) } } } } // containsAll reports whether x contains the elements of y, in order. func containsAll(x, y []string) bool { for len(y) \u0026lt;= len(x) { if len(y) == 0 { return true } if x[0] == y[0] { y = y[1:] } x = x[1:] } return false } main函数中的循环每遇到一个StartElement时，它把这个元素的名称压到一个栈里，并且每次遇到EndElement时，它将名称从这个栈中推出。这个API保证了StartElement和EndElement的序列可以被完全的匹配，甚至在一个糟糕的文档格式中。注释会被忽略。当xmlselect遇到一个CharData时，只有当栈中有序地包含所有通过命令行参数传入的元素名称时，它才会输出相应的文本。\n下面的命令打印出任意出现在两层div元素下的h2元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。\n$ go build gopl.io/ch1/fetch $ ./fetch http://www.w3.org/TR/2006/REC-xml11-20060816 | ./xmlselect div div h2 html body div div h2: 1 Introduction html body div div h2: 2 Documents html body div div h2: 3 Logical Structures html body div div h2: 4 Physical Structures html body div div h2: 5 Conformance html body div div h2: 6 Notation html body div div h2: A References html body div div h2: B Definitions for Character Normalization ... 练习 7.17： 扩展xmlselect程序以便让元素不仅可以通过名称选择，也可以通过它们CSS风格的属性进行选择。例如一个像这样\n\u0026lt;div id=\u0026#34;page\u0026#34; class=\u0026#34;wide\u0026#34;\u0026gt; 的元素可以通过匹配id或者class，同时还有它的名称来进行选择。\n练习 7.18： 使用基于标记的解码API，编写一个可以读取任意XML文档并构造这个文档所代表的通用节点树的程序。节点有两种类型：CharData节点表示文本字符串，和 Element节点表示被命名的元素和它们的属性。每一个元素节点有一个子节点的切片。\n你可能发现下面的定义会对你有帮助。\nimport \u0026#34;encoding/xml\u0026#34; type Node interface{} // CharData or *Element  type CharData string type Element struct { Type xml.Name Attr []xml.Attr Children []Node } "});index.add({'id':193,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.15.-Use-Problem-Domain-Names/','title':"2.15. 使用源自所涉问题领域的名称",'section':"2. 有意义的命名",'content':"2.15 使用源自所涉问题领域的名称 #  When there is no “programmer-eese” for what you’re doing, use the name from the problem domain. At least the programmer who maintains your code can ask a domain expert what it means.\n 如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。\n Separating solution and problem domain concepts is part of the job of a good programmer and designer. The code that has more to do with problem domain concepts should have names drawn from the problem domain.\n 优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。与所涉问题领域更为贴近的代码，应当采用源自问题领域的名称。\n "});index.add({'id':194,'href':'/docs/The-Go-Programming-Language/7.-Interfaces/7.15.-A-Few-Words-of-Advice/','title':"7.15. 一些建议",'section':"7. 接口",'content':"7.15. 一些建议 #  当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制（§6.6）来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。\n当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。\n因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）\n我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像input.Scan这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如fmt.Printf。\n"});index.add({'id':195,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.16.-Add-Meaningful-Context/','title':"2.16. 添加有意义的语境",'section':"2. 有意义的命名",'content':"2.16 添加有意义的语境 #  There are a few names which are meaningful in and of themselves—most are not. Instead, you need to place names in context for your reader by enclosing them in well-named classes, functions, or namespaces. When all else fails, then prefixing the name may be necessary as a last resort.\n 很少有名称是能自我说明的——多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。\n Imagine that you have variables named firstName, lastName, street, houseNumber, city, state, and zipcode. Taken together it’s pretty clear that they form an address. But what if you just saw the state variable being used alone in a method? Would you automatically infer that it was part of an address?\n 设想你有名为 firstName、lastName、street、houseNumber、city、state 和 zipcode 的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零一个 state 变量呢？你会理所当然推断那是某个地址的一部分吗？\n You can add context by using prefixes: addrFirstName, addrLastName, addrState, and so on. At least readers will understand that these variables are part of a larger structure. Of course, a better solution is to create a class named Address. Then, even the compiler knows that the variables belong to a bigger concept.\n 可以添加前缀 addrFirstName、addrLastName、addrState 等，以此提供语境。至少，读者会明白这些变量是某个更大结构的一部分。当然，更好的方案是创建名为 Address 的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。\n Consider the method in Listing 2-1. Do the variables need a more meaningful context? The function name provides only part of the context; the algorithm provides the rest. Once you read through the function, you see that the three variables, number, verb, and pluralModifier, are part of the “guess statistics” message. Unfortunately, the context must be inferred. When you first look at the method, the meanings of the variables are opaque.\n 看看代码清单 2-1 中的方法。以下变量是否需要更有意义的语境呢？函数名仅给出了部分语境；算法提供了剩下的部分。遍览函数后，你会知道 number、verb 和 pluralModifier 这三个变量是“测估”信息的一部分。不幸的是这语境得靠读者推断出来。第一眼看到这个方法时，这些变量的含义完全不清楚。\n Listing 2-1 Variables with unclear context.\n 代码清单 2-1 语境不明确的变量\n private void printGuessStatistics(char candidate, int count) { String number; String verb; String pluralModifier; if (count == 0) { number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } else if (count == 1) { number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } else { number = Integer.toString(count); verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } String guessMessage = String.format( \u0026#34;There %s %s %s%s\u0026#34;, verb, number, candidate, pluralModifier ); print(guessMessage); } The function is a bit too long and the variables are used throughout. To split the function into smaller pieces we need to create a GuessStatisticsMessage class and make the three variables fields of this class. This provides a clear context for the three variables. They are definitively part of the GuessStatisticsMessage. The improvement of context also allows the algorithm to be made much cleaner by breaking it into many smaller functions. (See Listing 2-2.)\n 上列函数有点儿过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为 GuessStatisticsMessage 的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了 GuessStatisticsMessage 的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。\n Listing 2-2 Variables have a context.\n （如代码清单 2-2 所示。）代码清单\n public class GuessStatisticsMessage { private String number; private String verb; private String pluralModifier; public String make(char candidate, int count) { createPluralDependentMessageParts(count); return String.format( \u0026#34;There %s %s %s%s\u0026#34;, verb, number, candidate, pluralModifier); } private void createPluralDependentMessageParts(int count) { if (count == 0) { thereAreNoLetters(); } else if (count == 1) { thereIsOneLetter(); } else { thereAreManyLetters(count); } } private void thereAreManyLetters(int count) { number = Integer.toString(count); verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } private void thereIsOneLetter() { number = \u0026#34;1\u0026#34;; verb = \u0026#34;is\u0026#34;; pluralModifier = \u0026#34;\u0026#34;; } private void thereAreNoLetters() { number = \u0026#34;no\u0026#34;; verb = \u0026#34;are\u0026#34;; pluralModifier = \u0026#34;s\u0026#34;; } } "});index.add({'id':196,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.17.-Dont-Add-Gratuitous-Context/','title':"2.17. 不要添加没用的语境",'section':"2. 有意义的命名",'content':"2.17 不要添加没用的语境 #  In an imaginary application called “Gas Station Deluxe,” it is a bad idea to prefix every class with GSD. Frankly, you are working against your tools. You type G and press the completion key and are rewarded with a mile-long list of every class in the system. Is that wise? Why make it hard for the IDE to help you?\n 设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加 GSD 前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入 G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得 IDE 没法帮助你？\n Likewise, say you invented a MailingAddress class in GSD’s accounting module, and you named it GSDAccountAddress. Later, you need a mailing address for your customer contact application. Do you use GSDAccountAddress? Does it sound like the right name? Ten of 17 characters are redundant or irrelevant.\n 再比如，你在 GSD 应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为 GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用 GSDAccountAddress 吗？这名字听起来没问题吗？在这 17 个字母里面，有 10 个字母纯属多余和与当前语境毫无关联。\n Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary.\n 只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。\n The names accountAddress and customerAddress are fine names for instances of the class Address but could be poor names for classes. Address is a fine name for a class. If I need to differentiate between MAC addresses, port addresses, and Web addresses, I might consider PostalAddress, MAC, and URI. The resulting names are more precise, which is the point of all naming.\n 对于 Address 类的实体来说，accountAddress 和 customerAddress 都是不错的名称，不过用在类名上就不太好了。Address 是个好类名。如果需要与 MAC 地址、端口地址和 Web 地址相区别，我会考虑使用 PostalAddress、MAC 和 URI。这样的名称更为精确，而精确正是命名的要点。\n "});index.add({'id':197,'href':'/docs/Clean-Code/2.-Meaningful-Names/2.18.-Final-Words/','title':"2.18. 最后的话",'section':"2. 有意义的命名",'content':"2.18 最后的话 #  The hardest thing about choosing good names is that it requires good descriptive skills and a shared cultural background. This is a teaching issue rather than a technical, business, or management issue. As a result many people in this field don’t learn to do it very well.\n 取好名字最难的地方在于需要良好的描述技巧和共有文化背景。与其说这是一种技术、商业或管理问题，还不如说是一种教学问题。其结果是，这个领域内的许多人都没能学会做得很好。\n People are also afraid of renaming things for fear that some other developers will object. We do not share that fear and find that we are actually grateful when names change (for the better). Most of the time we don’t really memorize the names of classes and methods. We use the modern tools to deal with details like that so we can focus on whether the code reads like paragraphs and sentences, or at least like tables and data structure (a sentence isn’t always the best way to display data). You will probably end up surprising someone when you rename, just like you might with any other code improvement. Don’t let it stop you in your tracks.\n 我们有时会怕其他开发者反对重命名。如果讨论一下就知道，如果名称改得更好，那大家真的会感激你。多数时候我们并不记忆类名和方法名。我们使用现代工具对付这些细节，好让自己集中精力于把代码写得就像词句篇章、至少像是表和数据结构（词句并非总是呈现数据的最佳手段）。改名可能会让某人吃惊，就像你做到其他代码改善工作一样。别让这种事阻碍你的前进步伐。\n Follow some of these rules and see whether you don’t improve the readability of your code. If you are maintaining someone else’s code, use refactoring tools to help resolve these problems. It will pay off in the short term and continue to pay in the long run.\n 不妨试试上面这些规则，看你的代码可读性是否有所提升。如果你是在维护别人写的代码，使用重构工具来解决问题。效果立竿见影，而且会持续下去。\n "});index.add({'id':198,'href':'/docs/Clean-Code/10.-Classes/ch10/','title':"Ch10",'section':"Go语言圣经",'content':"第 10 章 Classes 类 #  with Jeff Langr\n So far in this book we have focused on how to write lines and blocks of code well. We have delved into proper composition of functions and how they interrelate. But for all the attention to the expressiveness of code statements and the functions they comprise, we still don’t have clean code until we’ve paid attention to higher levels of code organization. Let’s talk about clean classes.\n 本书到目前为止一直在讨论如何编写良好的代码行和代码块。我们深入研究了函数的恰当构成，以及函数之间如何互相关联。不过，尽管讨论了这么多关于代码语句及由代码语句构成的函数的表达力，除非我们将注意力放到代码组织的更高层面，就始终不能得到整洁的代码。\n 10.1 CLASS ORGANIZATION 类的组织 #  Following the standard Java convention, a class should begin with a list of variables. Public static constants, if any, should come first. Then private static variables, followed by private instance variables. There is seldom a good reason to have a public variable.\n 遵循标准的 Java 约定，类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。\n Public functions should follow the list of variables. We like to put the private utilities called by a public function right after the public function itself. This follows the stepdown rule and helps the program read like a newspaper article.\n 公共函数应跟在变量列表之后。我们喜欢把由某个公共函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则，让程序读起来就像一篇报纸文章。\n Encapsulation\n 封装\n We like to keep our variables and utility functions private, but we’re not fanatic about it. Sometimes we need to make a variable or utility function protected so that it can be accessed by a test. For us, tests rule. If a test in the same package needs to call a function or access a variable, we’ll make it protected or package scope. However, we’ll first look for a way to maintain privacy. Loosening encapsulation is always a last resort.\n 我们喜欢保持变量和工具函数的私有性，但并不执着于此。有时，我们也需要用到受护（protected）变量或工具函数，好让测试可以访问到。对我们来说，测试说了算。若同一程序包内的某个测试需要调用一个函数或变量，我们就会将该函数或变量置为受护或在整个程序包内可访问。然而，我们首先会想办法使之保有隐私。放松封装总是下策。\n 10.2 CLASSES SHOULD BE SMALL! 类应该短小 #  The first rule of classes is that they should be small. The second rule of classes is that they should be smaller than that. No, we’re not going to repeat the exact same text from the Functions chapter. But as with functions, smaller is the primary rule when it comes to designing classes. As with functions, our immediate question is always “How small?”\n 关于类的第一条规则是类应该短小。第二条规则是还要更短小。不，我们并不是要重弹“函数”一章的论调。就像函数一样，在设计类时，首要规条就是要更短小。和函数一样，马上有个问题出现，那就是“多小合适呢？”\n With functions we measured size by counting physical lines. With classes we use a different measure. We count responsibilities.\n 对于函数，我们通过计算代码行数衡量大小。对于类，我们采用不同的衡量方法，计算权责（responsibility）。\n Listing 10-1 outlines a class, SuperDashboard, that exposes about 70 public methods. Most developers would agree that it’s a bit too super in size. Some developers might refer to SuperDashboard as a “God class.”\n 代码清单 10-1 给出了某个类的轮廓。SuperDashboard 类曝露大概 70 个公共方法。大多数开发者都会同意，这实在是太长了。有些开发者或许会将 SuperDashboard 类指为“神的类”。\n Listing 10-1 Too Many Responsibilities\npublic class SuperDashboard extends JFrame implements MetaDataUser { public String getCustomizerLanguagePath() { } public void setSystemConfigPath(String systemConfigPath) { } public String getSystemConfigDocument() { } public void setSystemConfigDocument(String systemConfigDocument) { } public boolean getGuruState() { } public boolean getNoviceState() { } public boolean getOpenSourceState() { } public void showObject(MetaObject object) { } public void showProgress(String s) { } public boolean isMetadataDirty() { } public void setIsMetadataDirty(boolean isMetadataDirty) { } public Component getLastFocusedComponent() { } public void setLastFocused(Component lastFocused) { } public void setMouseSelectState(boolean isMouseSelected) { } public boolean isMouseSelected() { } public LanguageManager getLanguageManager() { } public Project getProject() { } public Project getFirstProject() { } public Project getLastProject() { } public String getNewProjectName() { } public void setComponentSizes(Dimension dim) { } public String getCurrentDir() { } public void setCurrentDir(String newDir) { } public void updateStatus(int dotPos, int markPos) { } public Class[] getDataBaseClasses() { } public MetadataFeeder getMetadataFeeder() { } public void addProject(Project project) { } public boolean setCurrentProject(Project project) { } public boolean removeProject(Project project) { } public MetaProjectHeader getProgramMetadata() { } public void resetDashboard() { } public Project loadProject(String fileName, String projectName) { } public void setCanSaveMetadata(boolean canSave) { } public MetaObject getSelectedObject() { } public void deselectObjects() { } public void setProject(Project project) { } public void editorAction(String actionName, ActionEvent event) { } public void setMode(int mode) { } public FileManager getFileManager() { } public void setFileManager(FileManager fileManager) { } public ConfigManager getConfigManager() { } public void setConfigManager(ConfigManager configManager) { } public ClassLoader getClassLoader() { } public void setClassLoader(ClassLoader classLoader) { } public Properties getProps() { } public String getUserHome() { } public String getBaseDir() { } public int getMajorVersionNumber() { } public int getMinorVersionNumber() { } public int getBuildNumber() { } public MetaObject pasting( MetaObject target, MetaObject pasted, MetaProject project) { } public void processMenuItems(MetaObject metaObject) { } public void processMenuSeparators(MetaObject metaObject) { } public void processTabPages(MetaObject metaObject) { } public void processPlacement(MetaObject object) { } public void processCreateLayout(MetaObject object) { } public void updateDisplayLayer(MetaObject object, int layerIndex) { } public void propertyEditedRepaint(MetaObject object) { } public void processDeleteObject(MetaObject object) { } public boolean getAttachedToDesigner() { } public void processProjectChangedState(boolean hasProjectChanged) { } public void processObjectNameChanged(MetaObject object) { } public void runProject() { } public void setAçowDragging(boolean allowDragging) { } public boolean allowDragging() { } public boolean isCustomizing() { } public void setTitle(String title) { } public IdeMenuBar getIdeMenuBar() { } public void showHelper(MetaObject metaObject, String propertyName) { } // … many non-public methods follow … } But what if SuperDashboard contained only the methods shown in Listing 10-2?\n 如果 SuperDashboard 类只包括代码清单 10-2 中的方法呢？\n Listing 10-2 Small Enough?\n 代码清单 10-2 足够短小了吗？\n public class SuperDashboard extends JFrame implements MetaDataUser { public Component getLastFocusedComponent() { } public void setLastFocused(Component lastFocused) { } public int getMajorVersionNumber() { } public int getMinorVersionNumber() { } public int getBuildNumber() { } } Five methods isn’t too much, is it? In this case it is because despite its small number of methods, SuperDashboard has too many responsibilities.\n 5 个方法不算多，在这里，虽然方法数量较少，可 SuperDashboard 还是拥有太多权责。\n The name of a class should describe what responsibilities it fulfills. In fact, naming is probably the first way of helping determine class size. If we cannot derive a concise name for a class, then it’s likely too large. The more ambiguous the class name, the more likely it has too many responsibilities. For example, class names including weasel words like Processor or Manager or Super often hint at unfortunate aggregation of responsibilities.\n 类的名称应当描述其权责。实际上，命名正是帮助判断类的长度的第一个手段。如果无法为某个类命以精确的名称，这个类大概就太长了。类名越含混，该类越有可能拥有过多权责。例如，如果类名中包括含义模糊的词，如 Processor 或 Manager 或 Super，这种现象往往说明有不恰当的权责聚集情况存在。\n We should also be able to write a brief description of the class in about 25 words, without using the words “if,” “and,” “or,” or “but.” How would we describe the SuperDashboard? “The SuperDashboard provides access to the component that last held the focus, and it also allows us to track the version and build numbers.” The first “and” is a hint that SuperDashboard has too many responsibilities.\n 我们也应该能够用大概 25 个单词简要描述一个类，且不用“若（if）”、“与（and）”、“或（or）”或者“但（but）”等词汇。我们该如何描述 SuperDashboard 类呢？“SuperDashboard 类提供了对最后拥有焦点的组件的访问能力，我们还能通过它跟踪版本号和构建序列号。”“还能”二字正好提示了 SuperDashboard 类有太多权责。\n 10.2.1 The Single Responsibility Principle 单一权责原则 #  The Single Responsibility Principle (SRP)2 states that a class or module should have one, and only one, reason to change. This principle gives us both a definition of responsibility, and a guidelines for class size. Classes should have one responsibility—one reason to change.\n 单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。该原则既给出了权责的定义，又是关于类的长度的指导方针。类只应有一个权责——只有一条修改的理由。\n The seemingly small SuperDashboard class in Listing 10-2 has two reasons to change. First, it tracks version information that would seemingly need to be updated every time the software gets shipped. Second, it manages Java Swing components (it is a derivative of JFrame, the Swing representation of a top-level GUI window). No doubt we’ll want to update the version number if we change any of the Swing code, but the converse isn’t necessarily true: We might change the version information based on changes to other code in the system.\n 代码清单 10-2 中貌似很小的 SuperDashboard 类有两条加以修改的理由。首先，它跟踪大概会随软件每次发布而更新的版本信息。第二，它管理 Java Swing 组件（派生自 JFrame，顶层 GUI 窗口的 Swing 表现形态）。每次修改 Swing 代码时，无疑都要更新版本号，但反之未必可行：也可能依据系统中其他代码的修改而更新版本信息。\n Trying to identify responsibilities (reasons to change) often helps us recognize and create better abstractions in our code. We can easily extract all three SuperDashboard methods that deal with version information into a separate class named Version. (See Listing 10-3.) The Version class is a construct that has a high potential for reuse in other applications!\n 鉴别权责（修改的理由）常常帮助我们在代码中认识到并创建出更好的抽象。可以轻易地将全部三个处理版本信息的 SuperDashboard 方法拆解到名为 Version 的类中（如代码清单 10-3 所示）。Version 类是个极有可能在其他应用程序中得到复用的构造！\n Listing 10-3 A single-responsibility class\n 代码清单 10-3 单一权责类\n public class Version { public int getMajorVersionNumber() { } public int getMinorVersionNumber() { } public int getBuildNumber() { } } SRP is one of the more important concept in OO design. It’s also one of the simpler concepts to understand and adhere to. Yet oddly, SRP is often the most abused class design principle. We regularly encounter classes that do far too many things. Why?\n SRP 是 OO 设计中最为重要的概念之一，也是较为容易理解和遵循的概念之一。奇怪的是 SRP 往往也是最容易被破坏的类设计原则。经常会遇到做太多事的类。为什么呢？\n Getting software to work and making software clean are two very different activities. Most of us have limited room in our heads, so we focus on getting our code to work more than organization and cleanliness. This is wholly appropriate. Maintaining a separation of concerns is just as important in our programming activities as it is in our programs.\n 让软件能工作和让软件保持整洁，是两种截然不同的工作。我们中的大多数人脑力有限，只能更多地把精力放在让代码能工作上，而不是放在保持代码有组织和整洁上。这全然正确。分而治之，其在编程行为中的重要程度等同于在程序中的重要程度。\n The problem is that too many of us think that we are done once the program works. We fail to switch to the other concern of organization and cleanliness. We move on to the next problem rather than going back and breaking the overstuffed classes into decoupled units with single responsibilities.\n 问题是太多人在程序能工作时就以为万事大吉了。我们没能把思维转向有关代码组织和整洁的部分。我们直接转向下一个问题，而不是回头将臃肿的类切分为只有单一权责的去耦式单元。\n At the same time, many developers fear that a large number of small, single-purpose classes makes it more difficult to understand the bigger picture. They are concerned that they must navigate from class to class in order to figure out how a larger piece of work gets accomplished.\n 与此同时，许多开发者害怕数量巨大的短小单一目的类会导致难以一目了然抓住全局。他们认为，要搞清楚一件较大工作如何完成，就得在类与类之间找来找去。\n However, a system with many small classes has no more moving parts than a system with a few large classes. There is just as much to learn in the system with a few large classes. So the question is: Do you want your tools organized into toolboxes with many small drawers each containing well-defined and well-labeled components? Or do you want a few drawers that you just toss everything into?\n 然而，有大量短小类的系统并不比有少量庞大类的系统拥有更多移动部件，其数量大致相等。问题是：你是想把工具归置到有许多抽屉、每个抽屉中装有定义和标记良好的组件的工具箱中呢，还是想要少数几个能随便把所有东西扔进去的抽屉？\n Every sizable system will contain a large amount of logic and complexity. The primary goal in managing such complexity is to organize it so that a developer knows where to look to find things and need only understand the directly affected complexity at any given time. In contrast, a system with larger, multipurpose classes always hampers us by insisting we wade through lots of things we don’t need to know right now.\n 每个达到一定规模的系统都会包括大量逻辑和复杂性。管理这种复杂性的首要目标就是加以组织，以便开发者知道到哪儿能找到东西，并且在某个特定时间只需要理解直接有关的复杂性。反之，拥有巨大、多目的类的系统，总是让我们在目前并不需要了解的一大堆东西中艰难跋涉。\n To restate the former points for emphasis: We want our systems to be composed of many small classes, not a few large ones. Each small class encapsulates a single responsibility, has a single reason to change, and collaborates with a few others to achieve the desired system behaviors.\n 再强调一下：系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。\n 10.2.2 Cohesion 内聚 #  Classes should have a small number of instance variables. Each of the methods of a class should manipulate one or more of those variables. In general the more variables a method manipulates the more cohesive that method is to its class. A class in which each variable is used by each method is maximally cohesive.\n 类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。\n In general it is neither advisable nor possible to create such maximally cohesive classes; on the other hand, we would like cohesion to be high. When cohesion is high, it means that the methods and variables of the class are co-dependent and hang together as a logical whole.\n 一般来说，创建这种极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。\n Consider the implementation of a Stack in Listing 10-4. This is a very cohesive class. Of the three methods only size() fails to use both the variables.\n 看看代码清单 10-4 中一个 Stack 类的实现方式。这个类非常内聚。在三个方法中，只有 size( )方法没有使用所有两个变量。\n Listing 10-4 Stack.java A cohesive class.\n 代码清单 10-4 Stack.java（一个内聚类）\n public class Stack { private int topOfStack = 0; List\u0026lt;Integer\u0026gt; elements = new LinkedList\u0026lt;Integer\u0026gt;(); public int size() { return topOfStack; } public void push(int element) { topOfStack++; elements.add(element); } public int pop() throws PoppedWhenEmpty { if (topOfStack == 0) throw new PoppedWhenEmpty(); int element = elements.get(--topOfStack); elements.remove(topOfStack); return element; } } The strategy of keeping functions small and keeping parameter lists short can sometimes lead to a proliferation of instance variables that are used by a subset of methods. When this happens, it almost always means that there is at least one other class trying to get out of the larger class. You should try to separate the variables and methods into two or more classes such that the new classes are more cohesive.\n 保持函数和参数列表短小的策略，有时会导致为一组子集方法所用的实体变量数量增加。出现这种情况时，往往意味着至少有一个类要从大类中挣扎出来。你应当尝试将这些变量和方法分拆到两个或多个类中，让新的类更为内聚。\n 10.2.3 Maintaining Cohesion Results in Many Small Classes 保持内聚性就会得到许多短小的类 #  Just the act of breaking large functions into smaller functions causes a proliferation of classes. Consider a large function with many variables declared within it. Let’s say you want to extract one small part of that function into a separate function. However, the code you want to extract uses four of the variables declared in the function. Must you pass all four of those variables into the new function as arguments?\n 仅仅是将较大的函数切割为小函数，就将导致更多的类出现。想想看一个有许多变量的大函数。你想把该函数中某一小部分拆解成单独的函数。不过，你想要拆出来的代码使用了该函数中声明的 4 个变量。是否必须将这 4 个变量都作为参数传递到新函数中去呢？\n Not at all! If we promoted those four variables to instance variables of the class, then we could extract the code without passing any variables at all. It would be easy to break the function up into small pieces.\n 完全没必要！只要将 4 个变量提升为类的实体变量，完全无需传递任何变量就能拆解代码了。应该很容易将函数拆分为小块。\n Unfortunately, this also means that our classes lose cohesion because they accumulate more and more instance variables that exist solely to allow a few functions to share them. But wait! If there are a few functions that want to share certain variables, doesn’t that make them a class in their own right? Of course it does. When classes lose cohesion, split them!\n 可惜这也意味着类丧失了内聚性，因为堆积了越来越多只为允许少量函数共享而存在的实体变量。等一下！如果有些函数想要共享某些变量，为什么不让它们拥有自己的类呢？当类丧失了内聚性，就拆分它！\n So breaking a large function into many smaller functions often gives us the opportunity to split several smaller classes out as well. This gives our program a much better organization and a more transparent structure.\n 所以，将大函数拆为许多小函数，往往也是将类拆分为多个小类的时机。程序会更加有组织，也会拥有更为透明的结构。\n As a demonstration of what I mean, let’s use a time-honored example taken from Knuth’s wonderful book Literate Programming.3 Listing 10-5 shows a translation into Java of Knuth’s PrintPrimes program. To be fair to Knuth, this is not the program as he wrote it but rather as it was output by his WEB tool. I’m using it because it makes a great starting place for breaking up a big function into many smaller functions and classes.\n 可惜这也意味着类丧失了内聚性，因为堆积了越来越多只为允许少量函数共享而存在的实体变量。等一下！如果有些函数想要共享某些变量，为什么不让它们拥有自己的类呢？当类丧失了内聚性，就拆分它！所以，将大函数拆为许多小函数，往往也是将类拆分为多个小类的时机。程序会更加有组织，也会拥有更为透明的结构。\n Listing 10-5 PrintPrimes.java\n 代码清单 10-5 PrintPrimes.java\n package literatePrimes; public class PrintPrimes { public static void main(String[] args) { final int M = 1000; final int RR = 50; final int CC = 4; final int WW = 10; final int ORDMAX = 30; int P[] = new int[M + 1]; int PAGENUMBER; int PAGEOFFSET; int ROWOFFSET; int C; int J; int K; boolean JPRIME; int ORD; int SQUARE; int N; int MULT[] = new int[ORDMAX + 1]; J = 1; K = 1; P[1] = 2; ORD = 2; SQUARE = 9; while (K \u0026lt; M) { do { J = J + 2; if (J == SQUARE) { ORD = ORD + 1; SQUARE = P[ORD] * P[ORD]; MULT[ORD - 1] = J; } N = 2; JPRIME = true; while (N \u0026lt; ORD \u0026amp;\u0026amp; JPRIME) { while (MULT[N] \u0026lt; J) MULT[N] = MULT[N] + P[N] + P[N]; if (MULT[N] == J) JPRIME = false; N = N + 1; } } while (!JPRIME); K = K + 1; P[K] = J; } { PAGENUMBER = 1; PAGEOFFSET = 1; while (PAGEOFFSET \u0026lt;= M) { System.out.println(\u0026#34;The First \u0026#34; + M + \u0026#34;Prime Numbers ---Page \u0026#34;+PAGENUMBER); System.out.println(\u0026#34;\u0026#34;); for (ROWOFFSET = PAGEOFFSET; ROWOFFSET \u0026lt; PAGEOFFSET + RR; ROWOFFSET++) { for (C = 0; C \u0026lt; CC; C++) if (ROWOFFSET + C * RR \u0026lt;= M) System.out.format(\u0026#34; % 10d\u0026#34;,P[ROWOFFSET + C * RR]); System.out.println(\u0026#34;\u0026#34;); } System.out.println(\u0026#34;\\f\u0026#34;); PAGENUMBER = PAGENUMBER + 1; PAGEOFFSET = PAGEOFFSET + RR * CC; } } } } This program, written as a single function, is a mess. It has a deeply indented structure, a plethora of odd variables, and a tightly coupled structure. At the very least, the one big function should be split up into a few smaller functions.\n 该程序只有一个大函数，简直一团糟。它拥有很深的缩进结构，冗 余的变量和紧密耦合的结构。至少应该将其拆分为数个较小的函数。\n Listing 10-6 through Listing 10-8 show the result of splitting the code in Listing 10-5 into smaller classes and functions, and choosing meaningful names for those classes, functions, and variables.\n 从代码清单 10-6 到代码清单 10-8，展示了将代码清单 10-5 中的代码拆分为较小的类和函数，并为这些类、函数和变量取个好名字后的结果。\n Listing 10-6 PrimePrinter.java (refactored)\n 代码清单 10-6 PrimePrinter.java（重构后）\n package literatePrimes; public class PrimePrinter { public static void main(String[] args) { final int NUMBER_OF_PRIMES = 1000; int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES); final int ROWS_PER_PAGE = 50; final int COLUMNS_PER_PAGE = 4; RowColumnPagePrinter tablePrinter = new RowColumnPagePrinter(ROWS_PER_PAGE, COLUMNS_PER_PAGE, \u0026#34;The First \u0026#34; + NUMBER_OF_PRIMES + \u0026#34; Prime Numbers\u0026#34;); tablePrinter.print(primes); } } Listing 10-7 RowColumnPagePrinter.java\n 代码清单 10-7 RowColumnPagePrinter.java\n package literatePrimes; import java.io.PrintStream; public class RowColumnPagePrinter { private int rowsPerPage; private int columnsPerPage; private int numbersPerPage; private String pageHeader; private PrintStream printStream; public RowColumnPagePrinter(int rowsPerPage, int columnsPerPage, String pageHeader) { this.rowsPerPage = rowsPerPage; this.columnsPerPage = columnsPerPage; this.pageHeader = pageHeader; numbersPerPage = rowsPerPage * columnsPerPage; printStream = System.out; } public void print(int data[]) { int pageNumber = 1; for (int firstIndexOnPage = 0; firstIndexOnPage \u0026lt; data.length; firstIndexOnPage += numbersPerPage) { int lastIndexOnPage = Math.min(firstIndexOnPage + numbersPerPage - 1, data.length - 1); printPageHeader(pageHeader, pageNumber); printPage(firstIndexOnPage, lastIndexOnPage, data); printStream.println(\u0026#34;\\f\u0026#34;); pageNumber++; } } private void printPage(int firstIndexOnPage, int lastIndexOnPage, int[] data) { int firstIndexOfLastRowOnPage = firstIndexOnPage + rowsPerPage - 1; for (int firstIndexInRow = firstIndexOnPage; firstIndexInRow \u0026lt;= firstIndexOfLastRowOnPage; firstIndexInRow++) { printRow(firstIndexInRow, lastIndexOnPage, data); printStream.println(\u0026#34;\u0026#34;); } } private void printRow(int firstIndexInRow, int lastIndexOnPage, int[] data) { for (int column = 0; column \u0026lt; columnsPerPage; column++) { int index = firstIndexInRow + column * rowsPerPage; if (index \u0026lt;= lastIndexOnPage) printStream.format(\u0026#34;%10d\u0026#34;, data[index]); } } private void printPageHeader(String pageHeader, int pageNumber) { printStream.println(pageHeader + \u0026#34; --- Page \u0026#34; + pageNumber); printStream.println(\u0026#34;\u0026#34;); } public void setOutput(PrintStream printStream) { this.printStream = printStream; } } Listing 10-8 PrimeGenerator.java\n 代码清单 10-8 PrimeGenerator.java\n package literatePrimes; import java.util.ArrayList; public class PrimeGenerator { private static int[] primes; private static ArrayList\u0026lt;Integer\u0026gt; multiplesOfPrimeFactors; protected static int[] generate(int n) { primes = new int[n]; multiplesOfPrimeFactors = new ArrayList\u0026lt;Integer\u0026gt;(); set2AsFirstPrime(); checkOddNumbersForSubsequentPrimes(); return primes; } private static void set2AsFirstPrime() { primes[0] = 2; multiplesOfPrimeFactors.add(2); } private static void checkOddNumbersForSubsequentPrimes() { int primeIndex = 1; for (int candidate = 3; primeIndex \u0026lt; primes.length; candidate += 2) { if (isPrime(candidate)) primes[primeIndex++] = candidate; } } private static boolean isPrime(int candidate) { if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) { multiplesOfPrimeFactors.add(candidate); return false; } return isNotMultipleOfAnyPreviousPrimeFactor(candidate); } private static boolean isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) { int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()]; int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor; return candidate == leastRelevantMultiple; } private static boolean isNotMultipleOfAnyPreviousPrimeFactor(int candidate) { for (int n = 1; n \u0026lt; multiplesOfPrimeFactors.size(); n++) { if (isMultipleOfNthPrimeFactor(candidate, n)) return false; } return true; } private static boolean isMultipleOfNthPrimeFactor(int candidate, int n) { return candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n); } private static int smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) { int multiple = multiplesOfPrimeFactors.get(n); while (multiple \u0026lt; candidate) multiple += 2 * primes[n]; multiplesOfPrimeFactors.set(n, multiple); return multiple; } } The first thing you might notice is that the program got a lot longer. It went from a little over one page to nearly three pages in length. There are several reasons for this growth. First, the refactored program uses longer, more descriptive variable names. Second, the refactored program uses function and class declarations as a way to add commentary to the code. Third, we used whitespace and formatting techniques to keep the program readable.\n 你可能注意到的第一件事就是程序比原来长了许多，从 1 页多增加到了将近 3 页。这有几个原因。其一，重构后的程序采用了更长、更有描述性的变量名。其二，重构后的程序将函数和类声明当作是给代码添加注释的一种手段。其三，我们采用了空格和格式技巧让程序更可读。\n Notice how the program has been split into three main responsibilities. The main program is contained in the PrimePrinter class all by itself. Its responsibility is to handle the execution environment. It will change if the method of invocation changes. For example, if this program were converted to a SOAP service, this is the class that would be affected.\n 留意程序是如何被拆分为 3 个主要权责的。PrimePrinter 类中只有主程序。主程序的权责是处理执行环境。如果调用方式改变，它也会随之改变。例如，如果程序被转换为 SOAP 服务，则该类也会被影响到。\n The RowColumnPagePrinter knows all about how to format a list of numbers into pages with a certain number of rows and columns. If the formatting of the output needed changing, then this is the class that would be affected.\n RowColumnPagePrinter 类懂得如何将数字列表格式化到有着固定行、列数的页面上。若输出格式需要改动，则该类也会被影响到。\n The PrimeGenerator class knows how to generate a list prime numbers. Notice that it is not meant to be instantiated as an object. The class is just a useful scope in which its variables can be declared and kept hidden. This class will change if the algorithm for computing prime numbers changes.\n PrimeGenerator 类懂得如何生成素数列表。注意，这并不意味着要实体化为对象。该类就是个有用的作用域，在其中声明并隐藏变量。如果计算素数的算法发生改动，则该类也会改动。\n This was not a rewrite! We did not start over from scratch and write the program over again. Indeed, if you look closely at the two different programs, you’ll see that they use the same algorithm and mechanics to get their work done.\n 这并不算是重写！我们没从头开始写一遍程序。实际上，如果你仔细看上述两个不同的程序，就会发现它们采用了同样的算法和机制来完成工作。\n The change was made by writing a test suite that verified the precise behavior of the first program. Then a myriad of tiny little changes were made, one at a time. After each change the program was executed to ensure that the behavior had not changed. One tiny step after another, the first program was cleaned up and transformed into the second.\n 我们通过编写验证第一个程序的精确行为的用例来实现修改。然后，我们做了许多小改动，每次改动一处。每改动一次，就执行一次，确保程序的行为没有变化。一小步接着一小步，第一个程序被逐渐清理和转换为第二个程序。\n 10.3 ORGANIZING FOR CHANGE 为了修改而组织 #  For most systems, change is continual. Every change subjects us to the risk that the remainder of the system no longer works as intended. In a clean system we organize our classes so as to reduce the risk of change.\n 对于多数系统，修改将一直持续。每处修改都让我们冒着系统其他部分不能如期望般工作的风险。在整洁的系统中，我们对类加以组织，以降低修改的风险。\n The Sql class in Listing 10-9 is used to generate properly formed SQL strings given appropriate metadata. It’s a work in progress and, as such, doesn’t yet support SQL functionality like update statements. When the time comes for the Sql class to support an update statement, we’ll have to “open up” this class to make modifications. The problem with opening a class is that it introduces risk. Any modifications to the class have the potential of breaking other code in the class. It must be fully retested.\n 代码清单 10-9 中的 Sql 类用来生成提供恰当元数据的 SQL 格式化字符串。这个类还没写完，所以暂时不支持 update 语句等 SQL 功能。当需要 Sql 类支持 update 语句时，我们就得“打开”这个类进行修改。打开类带来的问题是风险随之而来。对类的任何修改都有可能破坏类中的其他代码。必须全面重新测试。\n Listing 10-9 A class that must be opened for change\n 代码清单 10-9 一个必须打开修改的类\n public class Sql { public Sql(String table, Column[] columns) { } public String create() { } public String insert(Object[] fields) { } public String selectAll() { } public String findByKey(String keyColumn, String keyValue) { } public String select(Column column, String pattern) { } public String select(Criteria criteria) { } public String preparedInsert() { } private String columnList(Column[] columns) { } private String valuesList(Object[] fields, final Column[] columns) { } private String selectWithCriteria(String criteria) { } private String placeholderList(Column[] columns) { } } The Sql class must change when we add a new type of statement. It also must change when we alter the details of a single statement type—for example, if we need to modify the select functionality to support subselects. These two reasons to change mean that the Sql class violates the SRP.\n 当增加一种新语句类型时，就要修改 Sql 类。改动单个语句类型时，也要进行修改，比如打算让 select 功能支持子查询。存在两个修改的理由，说明 Sql 违反了 SRP 原则。\n We can spot this SRP violation from a simple organizational standpoint. The method outline of Sql shows that there are private methods, such as selectWithCriteria, that appear to relate only to select statements.\n 可以从一条简单的组织性观点发现对 SRP 的违反。Sql 的方法大纲显示，存在类似 selectWithCriteria 等只与 select 语句有关的私有方法。\n Private method behavior that applies only to a small subset of a class can be a useful heuristic for spotting potential areas for improvement. However, the primary spur for taking action should be system change itself. If the Sql class is deemed logically complete, then we need not worry about separating the responsibilities. If we won’t need update functionality for the foreseeable future, then we should leave Sql alone. But as soon as we find ourselves opening up a class, we should consider fixing our design.\n 出现了只与类的一小部分有关的私有方法行为，意味着存在改进空间。然而，展开行动的基本动因却应该是系统的变动。若我们认为 Sql 类在逻辑上已具足，则无需担心对权责的拆分。如果在可预见的未来无需增加 update 功能，就该不去动 Sql 类。不过，一旦打开了类，就应当修正设计方案。\n What if we considered a solution like that in Listing 10-10? Each public interface method defined in the previous Sql from Listing 10-9 is refactored out to its own derivative of the Sql class. Note that the private methods, such as valuesList, move directly where they are needed. The common private behavior is isolated to a pair of utility classes, Where and ColumnList.\n 代码清单 10-10 中的解决方式如何呢？代码清单 10-9 中 Sql 类的每个接口方法都重构到从 Sql 类派生出来的类中了。注意那些私有方法，如 valuesList，直接移到了需要用它们的地方。公共私有行为被划分到独立的两个工具类 Where 和 ColumnList 中。\n Listing 10-10 A set of closed classes\n 代码清单 10-10 一组封闭类\n abstract public class Sql { public Sql(String table, Column[] columns) { } abstract public String generate(); } public class CreateSql extends Sql { public CreateSql(String table, Column[] columns) { } @Override public String generate() { } } public class SelectSql extends Sql { public SelectSql(String table, Column[] columns) { } @Override public String generate() { } } public class InsertSql extends Sql { public InsertSql(String table, Column[] columns, Object[] fields) { } @Override public String generate() { } private String valuesList(Object[] fields, final Column[] columns) { } } public class SelectWithCriteriaSql extends Sql { public SelectWithCriteriaSql(String table, Column[] columns, Criteria criteria) { } @Override public String generate() { } } public class SelectWithMatchSql extends Sql { public SelectWithMatchSql( String table, Column[] columns, Column column, String pattern) { } @Override public String generate() { } } public class FindByKeySql extends Sql { public FindByKeySql(String table, Column[] columns, String keyColumn, String keyValue) { } @Override public String generate() { } } public class PreparedInsertSql extends Sql { public PreparedInsertSql(String table, Column[] columns) { } @Override public String generate() { private String placeholderList (Column[]columns){ } } public class Where { public Where(String criteria) { } public String generate() { } } public class ColumnList { public ColumnList(Column[] columns) { } public String generate() { } } } The code in each class becomes excruciatingly simple. Our required comprehension time to understand any class decreases to almost nothing. The risk that one function could break another becomes vanishingly small. From a test standpoint, it becomes an easier task to prove all bits of logic in this solution, as the classes are all isolated from one another.\n 每个类中的代码都变得极为简单。理解每个类花费的时间缩减到近乎为零。函数对其他函数造成毁坏的风险也变得几近于无。从测试的角度看，验证方案中每一处逻辑都成了极为简单的任务，因为类与类之间相互隔离了。\n Equally important, when it’s time to add the update statements, none of the existing classes need change! We code the logic to build update statements in a new subclass of Sql named UpdateSql. No other code in the system will break because of this change.\n 当需要增加 update 语句时，现存类无需做任何修改，这也同等重要！我们在 Sql 类的新子类 UpdateSql 中构建 update 语句的逻辑。系统中的其他代码都不会因为这个修改而被破坏。\n Our restructured Sql logic represents the best of all worlds. It supports the SRP. It also supports another key OO class design principle known as the Open-Closed Principle, or OCP:4 Classes should be open for extension but closed for modification. Our restructured Sql class is open to allow new functionality via subclassing, but we can make this change while keeping every other class closed. We simply drop our UpdateSql class in place.\n 重新架构的 Sql 逻辑百利而无一弊。它支持 SRP。它也支持其他面向对象设计的关键原则，如开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。通过子类化手段，重新架构的 Sql 类对添加新功能是开放的，而且可以同时不触及其他类。只要将 UpdateSql 类放置到位就行了。\n We want to structure our systems so that we muck with as little as possible when we update them with new or changed features. In an ideal system, we incorporate new features by extending the system, not by making modifications to existing code.\n 我们希望将系统打造成在添加或修改特性时尽可能少惹麻烦的架子。在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。\n Isolating from Change\n 隔离修改\n Needs will change, therefore code will change. We learned in OO 101 that there are concrete classes, which contain implementation details (code), and abstract classes, which represent concepts only. A client class depending upon concrete details is at risk when those details change. We can introduce interfaces and abstract classes to help isolate the impact of those details.\n 需求会改变，所以代码也会改变。在 OO 101 中，我们学习到，具体类包含实现细节（代码），而抽象类则只呈现概念。依赖于具体细节的客户类，当细节改变时，就会有风险。我们可以借助接口和抽象类来隔离这些细节带来的影响。\n Dependencies upon concrete details create challenges for testing our system. If we’re building a Portfolio class and it depends upon an external TokyoStockExchange API to derive the portfolio’s value, our test cases are impacted by the volatility of such a lookup. It’s hard to write a test when we get a different answer every five minutes!\n 对具体细节的依赖给对系统的测试带来了挑战。如果我们构建一个依赖于外部 TokyoStockExchange API 的 Portfolio 类，代表投资组合的价值，则测试用例就会受到价值查询的连带影响。如果每 5 分钟就有新说法，就很难写出测试来。\n Instead of designing Portfolio so that it directly depends upon TokyoStockExchange, we create an interface, StockExchange, that declares a single method:\n 与其设计直接依赖于 TokyoStockExchange 的 Portfolio 类，不如创建 StockExchange 接口，其中只声明一个方法：\n public interface StockExchange { Money currentPrice(String symbol); } We design TokyoStockExchange to implement this interface. We also make sure that the constructor of Portfolio takes a StockExchange reference as an argument:\n 我们设计 TokyoStockExchange 类来实现这个接口。我们还要确保 Portfolio 的构造器接受作为参数的 StockExchange 引用：\n public Portfolio { private StockExchange exchange; public Portfolio(StockExchange exchange) { this.exchange = exchange; } // … } Now our test can create a testable implementation of the StockExchange interface that emulates the TokyoStockExchange. This test implementation will fix the current value for any symbol we use in testing. If our test demonstrates purchasing five shares of Microsoft for our portfolio, we code the test implementation to always return $100 per share of Microsoft. Our test implementation of the StockExchange interface reduces to a simple table lookup. We can then write a test that expects $500 for our overall portfolio value.\n 现在就可以为 StockExchange 接口创建可测试的尝试性实现了。该尝试性实现将返回固定的现值。如果测试中购买了 5 股微软股票，则尝试性实现总是返回每股 100 美元的现值。对于 StockExchange 接口的尝试性实现简化为简单的表格查找。然后再编写一个总投资价值为 500 美元的测试。\n public class PortfolioTest { private FixedStockExchangeStub exchange; private Portfolio portfolio; @Before protected void setUp() throws Exception { exchange = new FixedStockExchangeStub(); exchange.fix(\u0026#34;MSFT\u0026#34;, 100); portfolio = new Portfolio(exchange); } @Test public void GivenFiveMSFTTotalShouldBe500() throws Exception { portfolio.add(5, \u0026#34;MSFT\u0026#34;); Assert.assertEquals(500, portfolio.value()); } } If a system is decoupled enough to be tested in this way, it will also be more flexible and promote more reuse. The lack of coupling means that the elements of our system are better isolated from each other and from change. This isolation makes it easier to understand each element of the system.\n 如果系统解耦到足以这样测试的程度，也就更加灵活，更加可复用。部件之间的解耦代表着系统中的元素互相隔离得很好。隔离也让对系统每个元素的理解变得更加容易。\n By minimizing coupling in this way, our classes adhere to another class design principle known as the Dependency Inversion Principle (DIP).5 In essence, the DIP says that our classes should depend upon abstractions, not on concrete details.\n 通过降低连接度，我们的类就遵循了另一条类设计原则，依赖倒置原则（Dependency Inversion Principle，DIP）。本质而言，DIP 认为类应当依赖于抽象而不是依赖于具体细节。\n Instead of being dependent upon the implementation details of the TokyoStock-Exchange class, our Portfolio class is now dependent upon the StockExchange interface. The StockExchange interface represents the abstract concept of asking for the current price of a symbol. This abstraction isolates all of the specific details of obtaining such a price, including from where that price is obtained.\n 我们的 Portfolio 类不再依赖于 TokyoStockExchange 类的实现细节，而是依赖于 StockExchange 接口。StockExchange 接口呈现的是有关询问某只股票价格的抽象概念。这种抽象隔离了所有询价的特定细节，包括价格数据来自何处之类。\n "});index.add({'id':199,'href':'/docs/Clean-Code/11.-Systems/ch11/','title':"Ch11",'section':"Go语言圣经",'content':"第 11 章 Systems 系统 #  by Dr. Kevin Dean Wampler\n “Complexity kills. It sucks the life out of developers, it makes products difficult to plan, build, and test.”\n—Ray Ozzie, CTO, Microsoft Corporation\n “复杂要人命。它消磨开发者的生命，让产品难以规划、构建和测试。”\n——Ray Ozzie，微软公司首席技术官\n 11.1 HOW WOULD YOU BUILD A CITY? 如何建造一个城市 #  Could you manage all the details yourself? Probably not. Even managing an existing city is too much for one person. Yet, cities work (most of the time). They work because cities have teams of people who manage particular parts of the city, the water systems, power systems, traffic, law enforcement, building codes, and so forth. Some of those people are responsible for the big picture, while others focus on the details.\n 你能自己掌管一切细节吗？大概不行。即便是管理一个既存的城市，也是一个人无法做到的。不过，城市还是在运转（多数时候）。因为每个城市都有一组组人管理不同的部分，供水系统、供电系统、交通、执法、立法，诸如此类。有些人负责全局，其他人负责细节。\n Cities also work because they have evolved appropriate levels of abstraction and modularity that make it possible for individuals and the “components” they manage to work effectively, even without understanding the big picture.\n 城市能运转，还因为它演化出恰当的抽象等级和模块，好让个人和他们所管理的“组件”即便在不了解全局时也能有效地运转。\n Although software teams are often organized like that too, the systems they work on often don’t have the same separation of concerns and levels of abstraction. Clean code helps us achieve this at the lower levels of abstraction. In this chapter let us consider how to stay clean at higher levels of abstraction, the system level.\n 尽管软件团队往往也是这样组织起来，但他们所致力的工作却常常没有同样的关注面切分及抽象层级。整洁的代码帮助我们在较低层的抽象层级上达成这一目标。本章将讨论如何在较高的抽象层级——系统层级——上保持整洁。\n 11.2 SEPARATE CONSTRUCTING A SYSTEM FROM USING IT 将系统的构造与使用分开 #  First, consider that construction is a very different process from use. As I write this, there is a new hotel under construction that I see out my window in Chicago. Today it is a bare concrete box with a construction crane and elevator bolted to the outside. The busy people there all wear hard hats and work clothes. In a year or so the hotel will be finished. The crane and elevator will be gone. The building will be clean, encased in glass window walls and attractive paint. The people working and staying there will look a lot different too.\n 首先，构造与使用是非常不一样的过程。当我走笔至此，投目窗外的芝加哥，看到有一间酒店正在建设。今天，那只是个框架结构，起重机和升降机附着在外面。忙碌的人们身穿工作服，头戴安全帽。大概一年之后，酒店就将建成。起重机和升降机都会消失无踪。建筑物变得整洁，覆盖着玻璃幕墙和漂亮的漆色。在其中工作和住宿的人，会看到完全不同的景象。\n Software systems should separate the startup process, when the application objects are constructed and the dependencies are “wired” together, from the runtime logic that takes over after startup.\n 软件系统应将启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系。\n The startup process is a concern that any application must address. It is the first concern that we will examine in this chapter. The separation of concerns is one of the oldest and most important design techniques in our craft.\n 每个应用程序都该留意启始过程。那也是本章中我们首先要考虑的问题。将关注的方面分离开，是软件技艺中最古老也最重要的设计技巧。\n Unfortunately, most applications don’t separate this concern. The code for the startup process is ad hoc and it is mixed in with the runtime logic. Here is a typical example:\n 不幸的是，多数应用程序都没有做分离处理。启始过程代码很特殊，被混杂到运行时逻辑中。下例就是典型的情形：\n public Service getService() { if (service == null) service = new MyServiceImpl(…); // Good enough default for most cases?  return service; } This is the LAZY INITIALIZATION/EVALUATION idiom, and it has several merits. We don’t incur the overhead of construction unless we actually use the object, and our startup times can be faster as a result. We also ensure that null is never returned.\n 这就是所谓延迟初始化/赋值，也有一些好处。在真正用到对象之前，无需操心这种架空构造，启始时间也会更短，而且还能保证永远不会返回 null 值。\n However, we now have a hard-coded dependency on MyServiceImpl and everything its constructor requires (which I have elided). We can’t compile without resolving these dependencies, even if we never actually use an object of this type at runtime!\n 然而，我们也得到了 MyServiceImpl 及其构造器所需一切（我省略了那些代码）的硬编码依赖。不分解这些依赖关系就无法编译，即便在运行时永不使用这种类型的对象！\n Testing can be a problem. If MyServiceImpl is a heavyweight object, we will need to make sure that an appropriate TEST DOUBLE1 or MOCK OBJECT gets assigned to the service field before this method is called during unit testing. Because we have construction logic mixed in with normal runtime processing, we should test all execution paths (for example, the null test and its block). Having both of these responsibilities means that the method is doing more than one thing, so we are breaking the Single Responsibility Principle in a small way.\n 如果 MyServiceImpl 是个重型对象，则测试也会是个问题。我们必须确保在单元测试调用该方法之前，就给 service 指派恰当的测试替身（TEST DOUBLE）[1]或仿制对象（MOCK OBJECT）。由于构造逻辑与运行过程相混杂，我们必须测试所有的执行路径（例如，null 值测试及其代码块）。有了这些权责，说明方法做了不止一件事，这样就略微违反了单一权责原则。\n Perhaps worst of all, we do not know whether MyServiceImpl is the right object in all cases. I implied as much in the comment. Why does the class with this method have to know the global context? Can we ever really know the right object to use here? Is it even possible for one type to be right for all possible contexts?\n 最糟糕的大概是我们不知道 MyServiceImpl 在所有情形中是否都是正确的对象。我在代码注释中做了暗示。为什么该方法所属类必须知道全局情景？我们是否真能知道在这里要用到的正确对象？是否真有可能存在一种放之四海而皆准的类型？\n One occurrence of LAZY-INITIALIZATION isn’t a serious problem, of course. However, there are normally many instances of little setup idioms like this in applications. Hence, the global setup strategy (if there is one) is scattered across the application, with little modularity and often significant duplication.\n 当然，仅出现一次的延迟初始化不算是严重问题。不过，在应用程序中往往有许多种类似的情况出现。于是，全局设置策略（如果有的话）在应用程序中四散分布，缺乏模块组织性，通常也会有许多重复代码。\n If we are diligent about building well-formed and robust systems, we should never let little, convenient idioms lead to modularity breakdown. The startup process of object construction and wiring is no exception. We should modularize this process separately from the normal runtime logic and we should make sure that we have a global, consistent strategy for resolving our major dependencies.\n 如果我们勤于打造有着良好格式并且强固的系统，就不该让这类就手小技巧破坏模块组织性。对象构造的启始和设置过程也不例外。应当将这个过程从正常的运行时逻辑中分离出来，确保拥有解决主要依赖问题的全局性一贯策略。\n 11.2.1 Separation of Main 分解 main #  One way to separate construction from use is simply to move all aspects of construction to main, or modules called by main, and to design the rest of the system assuming that all objects have been constructed and wired up appropriately. (See Figure 11-1.)\n 将构造与使用分开的方法之一是将全部构造过程搬迁到 main 或被称之为 main 的模块中，设计系统的其余部分时，假设所有对象都已正确构造和设置（如图 11-1 所示）。\n The flow of control is easy to follow. The main function builds the objects necessary for the system, then passes them to the application, which simply uses them. Notice the direction of the dependency arrows crossing the barrier between main and the application. They all go one direction, pointing away from main. This means that the application has no knowledge of main or of the construction process. It simply expects that everything has been built properly.\n 控制流程很容易理解。main 函数创建系统所需的对象，再传递给应用程序，应用程序只管使用。注意看横贯 main 与应用程序之间隔篱的依赖箭头的方向。它们都从 main 函数向外走。这表示应用程序对 main 或者构造过程一无所知。它只是简单地指望一切已齐备。\n 11.2.2 Factories 工厂 #  Sometimes, of course, we need to make the application responsible for when an object gets created. For example, in an order processing system the application must create the\nFigure 11-1 Separating construction in main()\n LineItem instances to add to an Order. In this case we can use the ABSTRACT FACTORY2 pattern to give the application control of when to build the LineItems, but keep the details of that construction separate from the application code. (See Figure 11-2.)\n 当然，有时应用程序也要负责确定何时创建对象。比如，在某个订单处理系统中，应用程序必须创建 LineItem 实体，添加到 Order 对象。在这种情况下，我们可以使用抽象工厂模式让应用自行控制何时创建 LineItems，但构造的细节却隔离于应用程序代码之外。\n Figure 11-2 Separation construction with factory\n Again notice that all the dependencies point from main toward the OrderProcessing application. This means that the application is decoupled from the details of how to build a LineItem. That capability is held in the LineItemFactoryImplementation, which is on the main side of the line. And yet the application is in complete control of when the LineItem instances get built and can even provide application-specific constructor arguments.\n 再留意一下，所有依赖都是从 main 指向 OrderProcessing 应用程序。这代表应用程序与如何构建 LineItem 的细节是分离开来的。构建能力由 LineItemFactoryImplementation 持有，而 LineItemFactoryImplementation 又是在 main 这一边的。但应用程序能完全控制 LineItem 实体何时构建，甚至能传递应用特定的构造器参数。\n 11.2.3 Dependency Injection 依赖注入 #  A powerful mechanism for separating construction from use is Dependency Injection (DI), the application of Inversion of Control (IoC) to dependency management.3 Inversion of Control moves secondary responsibilities from an object to other objects that are dedicated to the purpose, thereby supporting the Single Responsibility Principle. In the context of dependency management, an object should not take responsibility for instantiating dependencies itself. Instead, it should pass this responsibility to another “authoritative” mechanism, thereby inverting the control. Because setup is a global concern, this authoritative mechanism will usually be either the “main” routine or a special-purpose container.\n 有一种强大的机制可以实现分离构造与使用，那就是依赖注入（Dependency Injection，DI），控制反转（Inversion of Control，IoC）在依赖管理中的一种应用手段。控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循了单一权责原则。在依赖管理情景中，对象不应负责实体化对自身的依赖。反之，它应当将这份权责移交给其他“有权力”的机制，从而实现控制的反转。因为初始设置是一种全局问题，这种授权机制通常要么是 main 例程，要么是有特定目的的容器。\n JNDI lookups are a “partial” implementation of DI, where an object asks a directory server to provide a “service” matching a particular name.\n JNDI 查找是 DI 的一种“部分”实现。在 JNDI 中，对象请求目录服务器提供一种符合某个特定名称的“服务”。\n MyService myService = (MyService) (jndiContext.lookup(\u0026#34;NameOfMyService\u0026#34;)); The invoking object doesn’t control what kind of object is actually returned (as long it implements the appropriate interface, of course), but the invoking object still actively resolves the dependency.\n 调用对象并不控制真正返回对象的类别（当然前提是它实现了恰当的接口），但调用对象仍然主动分解了依赖。\n True Dependency Injection goes one step further. The class takes no direct steps to resolve its dependencies; it is completely passive. Instead, it provides setter methods or constructor arguments (or both) that are used to inject the dependencies. During the construction process, the DI container instantiates the required objects (usually on demand) and uses the constructor arguments or setter methods provided to wire together the dependencies. Which dependent objects are actually used is specified through a configuration file or programmatically in a special-purpose construction module.\n 真正的依赖注入还要更进一步。类并不直接分解其依赖，而是完全被动的。它提供可用于注入依赖的赋值器方法或构造器参数（或二者皆有）。在构造过程中，DI 容器实体化需要的对象（通常按需创建），并使用构造器参数或赋值器方法将依赖连接到一起。至于哪个依赖对象真正得到使用，是通过配置文件或在一个有特殊目的的构造模块中编程决定。\n The Spring Framework provides the best known DI container for Java.4 You define which objects to wire together in an XML configuration file, then you ask for particular objects by name in Java code. We will look at an example shortly.\n Spring 框架提供了最有名的 Java DI 容器。用户在 XML 配置文件中定义互相关联的对象，然后用 Java 代码请求特定的对象。稍后我们就会看到例子。\n But what about the virtues of LAZY-INITIALIZATION? This idiom is still sometimes useful with DI. First, most DI containers won’t construct an object until needed. Second, many of these containers provide mechanisms for invoking factories or for constructing proxies, which could be used for LAZY-EVALUATION and similar optimizations.\n 但延后初始化的好处是什么呢？这种手段在 DI 中也有其作用。首先，多数 DI 容器在需要对象之前并不构造对象。其次，许多这类容器提供调用工厂或构造代理的机制，而这种机制可为延迟赋值或类似的优化处理所用。\n 11.3 SCALING UP 扩容 #  Cities grow from towns, which grow from settlements. At first the roads are narrow and practically nonexistent, then they are paved, then widened over time. Small buildings and empty plots are filled with larger buildings, some of which will eventually be replaced with skyscrapers.\n 城市由城镇而来，城镇由聚居而来。一开始，道路狭窄，几乎无人涉足，随后逐渐拓宽。小型建筑和空地渐渐被更大的建筑所取代，一些地方最终矗立起摩天大楼。\n At first there are no services like power, water, sewage, and the Internet (gasp!). These services are also added as the population and building densities increase.\n 一开始，供电、供水、下水、互联网（哇！）等服务全部欠奉。随着人口和建筑密度的增加，这些服务也开始出现。\n This growth is not without pain. How many times have you driven, bumper to bumper through a road “improvement” project and asked yourself, “Why didn’t they build it wide enough the first time!?”\n 这种成长并非全无阵痛。你有多少次开着车，艰难穿行过一个“道路改善”工程，问自己，“他们为什么不一开始就修条够宽的路呢？！”\n But it couldn’t have happened any other way. Who can justify the expense of a six-lane highway through the middle of a small town that anticipates growth? Who would want such a road through their town?\n 不过那无论如何不可能实现。谁敢打包票说在一个小镇修建一条六车道的公路并不浪费呢？谁会想要这么一条穿过他们小镇的路呢？\n It is a myth that we can get systems “right the first time.” Instead, we should implement only today’s stories, then refactor and expand the system to implement new stories tomorrow. This is the essence of iterative and incremental agility. Test-driven development, refactoring, and the clean code they produce make this work at the code level.\n “一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现。\n But what about at the system level? Doesn’t the system architecture require preplanning? Certainly, it can’t grow incrementally from simple to complex, can it?\n 但在系统层面又如何？难道系统架构不需要预先做好计划吗？系统理所当然不可能从简单递增到复杂，它能行吗？\n Software systems are unique compared to physical systems. Their architectures can grow incrementally, ifwe maintain the proper separation of concerns.\n 软件系统与物理系统可以类比。它们的架构都可以递增式地增长，只要我们持续将关注面恰当地切分。\n The ephemeral nature of software systems makes this possible, as we will see. Let us first consider a counterexample of an architecture that doesn’t separate concerns adequately.\n 如我们将见到的那样，软件系统短生命周期本质使这一切变得可行。我们先来看一个没有充分隔离关注问题的架构反例。\n The original EJB1 and EJB2 architectures did not separate concerns appropriately and thereby imposed unnecessary barriers to organic growth. Consider an Entity Bean for a persistent Bank class. An entity bean is an in-memory representation of relational data, in other words, a table row.\n 初始的 EJB1 和 EJB2 架构没有恰当地切分关注面，从而给有机增长压上了不必要的负担。比如一个持久 Bank 类的 Entity Bean。Entity bean 是关系数据在内存中的体现，换言之，是表格的一行。\n First, you had to define a local (in process) or remote (separate JVM) interface, which clients would use. Listing 11-1 shows a possible local interface:\n 首先，你要定义一个本地（进程内）或远程（分离的 JVM）接口，供客户代码使用。\n Listing 11-1 An EJB2 local interface for a Bank EJB\n 代码清单 11-1 就是一种可能的本地接口：代码清单 11-1 Bank EJB 的 EJB2 本地接口\n package com.example.banking; import java.util.Collections; import javax.ejb.*; public interface BankLocal extends java.ejb.EJBLocalObject { String getStreetAddr1() throws EJBException; String getStreetAddr2() throws EJBException; String getCity() throws EJBException; String getState() throws EJBException; String getZipCode() throws EJBException; void setStreetAddr1(String street1) throws EJBException; void setStreetAddr2(String street2) throws EJBException; void setCity(String city) throws EJBException; void setState(String state) throws EJBException; void setZipCode(String zip) throws EJBException; Collection getAccounts() throws EJBException; void setAccounts(Collection accounts) throws EJBException; void addAccount(AccountDTO accountDTO) throws EJBException; } I have shown several attributes for the Bank’s address and a collection of accounts that the bank owns, each of which would have its data handled by a separate Account EJB. Listing 11-2 shows the corresponding implementation class for the Bank bean.\n 面列出了银行地址的几个属性，和一组该银行拥有的账户，其中每个账户的数据都由单独的 Account EJB 所持有。代码清单 11-2 展示了 Bank bean 的相应实现类。\n Listing 11-2 The corresponding EJB2 Entity Bean Implementation\n 代码清单 11-2 相应的 EJB2 Entity Bean 实现\n package com.example.banking; import java.util.Collections; import javax.ejb.*; public abstract class Bank implements javax.ejb.EntityBean { // Business logic…  public abstract String getStreetAddr1(); public abstract String getStreetAddr2(); public abstract String getCity(); public abstract String getState(); public abstract String getZipCode(); public abstract void setStreetAddr1(String street1); public abstract void setStreetAddr2(String street2); public abstract void setCity(String city); public abstract void setState(String state); public abstract void setZipCode(String zip); public abstract Collection getAccounts(); public abstract void setAccounts(Collection accounts); public void addAccount(AccountDTO accountDTO) { InitialContext context = new InitialContext(); AccountHomeLocal accountHome = context.lookup(”AccountHomeLocal”); AccountLocal account = accountHome.create(accountDTO); Collection accounts = getAccounts(); accounts.add(account); } // EJB container logic  public abstract void setId(Integer id); public abstract Integer getId(); public Integer ejbCreate(Integer id) { …} public void ejbPostCreate(Integer id) { …} // The rest had to be implemented but were usually empty:  public void setEntityContext(EntityContext ctx) { } public void unsetEntityContext() { } public void ejbActivate() { } public void ejbPassivate() { } public void ejbLoad() { } public void ejbStore() { } public void ejbRemove() { } } I haven’t shown the corresponding LocalHome interface, essentially a factory used to create objects, nor any of the possible Bank finder (query) methods you might add.\n 我没有列出对应的 LocalHome 接口，该接口基本上是用来创建对象的，也没有列出你可能添加的 Bank 查找器（查询）。\n Finally, you had to write one or more XML deployment descriptors that specify the object-relational mapping details to a persistence store, the desired transactional behavior, security constraints, and so on.\n 最后，你要编写一个或多个 XML 部署说明，将对象相关映射细节指定给某个持久化存储空间，说明期望的事物行为、安全约束等。\n The business logic is tightly coupled to the EJB2 application “container.” You must subclass container types and you must provide many lifecycle methods that are required by the container.\n 业务逻辑与 EJB2 应用“容器”紧密耦合。你必须子类化容器类型，必须提供许多个该容器所需要的生命周期方法。\n Because of this coupling to the heavyweight container, isolated unit testing is difficult. It is necessary to mock out the container, which is hard, or waste a lot of time deploying EJBs and tests to a real server. Reuse outside of the EJB2 architecture is effectively impossible, due to the tight coupling.\n 由于存在这种与重量级容器的紧耦合，隔离单元测试就很困难。有必要模拟出容器（这很难），或者花费大量时间在真实服务器上部署 EJB 和测试。也由于耦合的存在，在 EJB2 架构之外的复用实际上变得不可能。\n Finally, even object-oriented programming is undermined. One bean cannot inherit from another bean. Notice the logic for adding a new account. It is common in EJB2 beans to define “data transfer objects” (DTOs) that are essentially “structs” with no behavior. This usually leads to redundant types holding essentially the same data, and it requires boilerplate code to copy data from one object to another.\n 最终，连面向对象编程本身也被侵蚀。bean 不能继承自另一个 bean。留意添加新账号的逻辑。在 EJB2 bean 中，定义一种本质上是无行为 struct 的“数据传输对象”（DTO）很常见。这往往会导致拥有同样数据的冗余类型出现，而且也需要在对象之间复制数据的八股式代码。\n Cross-Cutting Concerns\n 横贯式关注面\n The EJB2 architecture comes close to true separation of concerns in some areas. For example, the desired transactional, security, and some of the persistence behaviors are declared in the deployment descriptors, independently of the source code.\n 在某些领域，EBJ2 架构已经很接近于真正的关注面切分。例如，在与源代码分离的部署描述中声明了期待的事务、安全及部分持久化行为。\n Note that concerns like persistence tend to cut across the natural object boundaries of a domain. You want to persist all your objects using generally the same strategy, for example, using a particular DBMS6 versus flat files, following certain naming conventions for tables and columns, using consistent transactional semantics, and so on.\n 注意，持久化之类关注面倾向于横贯某个领域的天然对象边界。你会想用同样的策略来持久化所有对象，例如，使用 DBMS 而非平面文件，表名和列名遵循某种命名约定，采用一致的事务语义，等等。\n In principle, you can reason about your persistence strategy in a modular, encapsulated way. Yet, in practice, you have to spread essentially the same code that implements the persistence strategy across many objects. We use the term cross-cutting concerns for concerns like these. Again, the persistence framework might be modular and our domain logic, in isolation, might be modular. The problem is the fine-grained intersection of these domains.\n 原则上，你可以从模块、封装的角度推理持久化策略。但在实践上，你却不得不将实现了持久化策略的代码铺展到许多对象中。我们用术语“横贯式关注面”来形容这类情况。同样，持久化框架和领域逻辑，孤立地看也可以是模块化的。问题在于横贯这些领域的情形。\n In fact, the way the EJB architecture handled persistence, security, and transactions, “anticipated” aspect-oriented programming (AOP),7 which is a general-purpose approach to restoring modularity for cross-cutting concerns.\n 实际上，EJB 架构处理持久化、安全和事务的方法是“预期”面向方面编程（aspect-oriented programming，AOP），而 AOP 是一种恢复横贯式关注面模块化的普适手段。\n In AOP, modular constructs called aspects specify which points in the system should have their behavior modified in some consistent way to support a particular concern. This specification is done using a succinct declarative or programmatic mechanism.\n 在 AOP 中，被称为方面（aspect）的模块构造指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。这种说明是用某种简洁的声明或编程机制来实现的。\n Using persistence as an example, you would declare which objects and attributes (or patterns thereof) should be persisted and then delegate the persistence tasks to your persistence framework. The behavior modifications are made noninvasively8 to the target code by the AOP framework. Let us look at three aspects or aspect-like mechanisms in Java.\n 以持久化为例，可以声明哪些对象和属性（或其模式）应当被持久化，然后将持久化任务委托给持久化框架。行为的修改由 AOP 框架以无损方式在目标代码中进行。下面来看看 Java 中的三种方面或类似方面的机制。\n 11.4 JAVA PROXIES Java 代理 #  Java proxies are suitable for simple situations, such as wrapping method calls in individual objects or classes. However, the dynamic proxies provided in the JDK only work with interfaces. To proxy classes, you have to use a byte-code manipulation library, such as CGLIB, ASM, or Javassist.\n Java 代理适用于简单的情况，例如在单独的对象或类中包装方法调用。然而，JDK 提供的动态代理仅能与接口协同工作。对于代理类，你得使用字节码操作库，比如 CGLIB、ASM 或 Javassist。\n Listing 11-3 shows the skeleton for a JDK proxy to provide persistence support for our Bank application, covering only the methods for getting and setting the list of accounts.\n 代码清单 11-3 展示了为我们的 Bank 应用程序提供持久化支持的 JDK 代理，代码仅覆盖设置和取得账号列表的方法。\n Listing 11-3 JDK Proxy Example\n 代码清单 11-3 JDK 代理范例\n // Bank.java (suppressing package names…) import java.utils.*; // The abstraction of a bank. public interface Bank { Collection\u0026lt;Account\u0026gt; getAccounts(); void setAccounts(Collection\u0026lt;Account\u0026gt; accounts); } // BankImpl.java import java.utils.*; // The “Plain Old Java Object\u0026#34; (POJO) implementing the abstraction. public class BankImpl implements Bank { private List\u0026lt;Account\u0026gt; accounts; public Collection\u0026lt;Account\u0026gt; getAccounts() { return accounts; } public void setAccounts(Collection\u0026lt;Account\u0026gt; accounts) { this.accounts = new ArrayList\u0026lt;Account\u0026gt;(); for (Account account: accounts) { this.accounts.add(account); } } } // BankProxyHandler.java import java.lang.reflect.*; import java.util.*; // “InvocationHandler\u0026#34; required by the proxy API. public class BankProxyHandler implements InvocationHandler { private Bank bank; public BankHandler (Bank bank) { this.bank = bank; } // Method defined in InvocationHandler  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String methodName = method.getName(); if (methodName.equals(\u0026#34;getAccounts\u0026#34;)) { bank.setAccounts(getAccountsFromDatabase()); return bank.getAccounts(); } else if (methodName.equals(\u0026#34;setAccounts\u0026#34;)) { bank.setAccounts((Collection\u0026lt;Account\u0026gt;) args[0]); setAccountsToDatabase(bank.getAccounts()); return null; } else { … } } // Lots of details here:  protected Collection\u0026lt;Account\u0026gt; getAccountsFromDatabase() { … } protected void setAccountsToDatabase(Collection\u0026lt;Account\u0026gt; accounts) { … } } // Somewhere else…  Bank bank = (Bank) Proxy.newProxyInstance( Bank.class.getClassLoader(), new Class[] { Bank.class }, new BankProxyHandler(new BankImpl())); We defined an interface Bank, which will be wrapped by the proxy, and a Plain-Old Java Object (POJO), BankImpl, that implements the business logic. (We will revisit POJOs shortly.)\n 我们定义了将被代理包装起来的接口 Bank，还有旧式的 Java 对象（Plain-Old Java Object，POJO）BankImpl，该对象实现业务逻辑（稍后再来看 POJO）。\n The Proxy API requires an InvocationHandler object that it calls to implement any Bank method calls made to the proxy. Our BankProxyHandler uses the Java reflection API to map the generic method invocations to the corresponding methods in BankImpl, and so on.\n Proxy API 需要一个 InvocationHandler 对象，用来实现对代理的全部 Bank 方法调用。BankProxyHandler 使用 Java 反射 API 将一般方法调用映射到 BankImpl 中的对应方法，以此类推。\n There is a lot of code here and it is relatively complicated, even for this simple case.10 Using one of the byte-manipulation libraries is similarly challenging. This code “volume” and complexity are two of the drawbacks of proxies. They make it hard to create clean code! Also, proxies don’t provide a mechanism for specifying system-wide execution “points” of interest, which is needed for a true AOP solution.\n 即便对于这样简单的例子，也有许多相对复杂的代码。使用那些字节操作类库也同样具有挑战性。代码量和复杂度是代理的两大弱点，创建整洁代码变得很难！另外，代理也没有提供在系统范围内指定执行点的机制，而那正是真正的 AOP 解决方案所必须的。\n 11.5 PURE JAVA AOP FRAMEWORKS 纯 Java AOP 框架 #  Fortunately, most of the proxy boilerplate can be handled automatically by tools. Proxies are used internally in several Java frameworks, for example, Spring AOP and JBoss AOP, to implement aspects in pure Java.12 In Spring, you write your business logic as Plain-Old Java Objects. POJOs are purely focused on their domain. They have no dependencies on enterprise frameworks (or any other domains). Hence, they are conceptually simpler and easier to test drive. The relative simplicity makes it easier to ensure that you are implementing the corresponding user stories correctly and to maintain and evolve the code for future stories.\n 幸运的是，编程工具能自动处理大多数代理模板代码。在数个 Java 框架中，代理都是内嵌的，如 Spring AOP 和 JBoss AOP 等，从而能够以纯 Java 代码实现面向方面编程。在 Spring 中，你将业务逻辑编码为旧式 Java 对象。POJO 自扫门前雪，并不依赖于企业框架（或其他域）。因此，它在概念上更简单、更易于测试驱动。相对简单性也较易于保证正确地实现相应的用户故事，并为未来的用户故事维护和改进代码。\n You incorporate the required application infrastructure, including cross-cutting concerns like persistence, transactions, security, caching, failover, and so on, using declarative configuration files or APIs. In many cases, you are actually specifying Spring or JBoss library aspects, where the framework handles the mechanics of using Java proxies or byte-code libraries transparently to the user. These declarations drive the dependency injection (DI) container, which instantiates the major objects and wires them together on demand.\n 使用描述性配置文件或 API，你把需要的应用程序构架组合起来，包括持久化、事务、安全、缓存、恢复等横贯性问题。在许多情况下，你实际上只是指定 Spring 或 Jboss 类库，框架以对用户透明的方式处理使用 Java 代理或字节代码库的机制。这些声明驱动了依赖注入（DI）容器，DI 容器再实体化主要对象，并按需将对象连接起来。\n Listing 11-4 shows a typical fragment of a Spring V2.5 configuration file, app.xml13:\n 代码清单 11-4 展示了 Spring V2.5 配置文件 app.xml 的典型片段。\n Listing 11-4 Spring 2.X configuration file\n 代码清单 11-4 Spring 2.x 的配置文件\n \u0026lt;beans\u0026gt; … \u0026lt;bean id=\u0026#34;appDataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34; p:driverClassName=\u0026#34;com.mysql.jdbc.Driver\u0026#34; p:url=\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34; p:username=\u0026#34;me\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;bankDataAccessObject\u0026#34; class=\u0026#34;com.example.banking.persistence.BankDataAccessObject\u0026#34; p:dataSource-ref=\u0026#34;appDataSource\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;bank\u0026#34; class=\u0026#34;com.example.banking.model.Bank\u0026#34; p:dataAccessObject-ref=\u0026#34;bankDataAccessObject\u0026#34; /\u0026gt; … \u0026lt;/beans\u0026gt; Each “bean” is like one part of a nested “Russian doll,” with a domain object for a Bank proxied (wrapped) by a data accessor object (DAO), which is itself proxied by a JDBC driver data source. (See Figure 11-3.)\n 每个 bean 就像是嵌套“俄罗斯套娃”中的一个，每个由数据存取器对象（DAO）代理（包装）的 Bank 都有个域对象，而 bean 本身又是由 JDBC 驱动程序数据源代理（如图 11-3 所示）。\n Figure 11-3 The “Russian doll” of decorators\n The client believes it is invoking getAccounts() on a Bank object, but it is actually talking to the outermost of a set of nested DECORATOR14 objects that extend the basic behavior of the Bank POJO. We could add other decorators for transactions, caching, and so forth.\n 客户代码以为调用的是 Bank 对象的 getAccount( )方法，其实它是在与一组扩展 Bank POJO 基础行为的油漆工（DECORATOR）对象中最外面的那个沟通。\n In the application, a few lines are needed to ask the DI container for the top-level objects in the system, as specified in the XML file.\n 在应用程序中，只添加了少数几行代码，用来向 DI 容器请求系统中的顶层对象，如 XML 文件中所定义的那样。\n XmlBeanFactory bf = new XmlBeanFactory(new ClassPathResource(\u0026#34;app.xml\u0026#34;, getClass())); Bank bank = (Bank) bf.getBean(\u0026#34;bank\u0026#34;); Because so few lines of Spring-specific Java code are required, the application is almost completely decoupled from Spring, eliminating all the tight-coupling problems of systems like EJB2.\n 只有区区几行与 Spring 相关的 Java 代码，应用程序几乎完全与 Spring 分离，消除了 EJB2 之类系统中那种紧耦合问题。\n Although XML can be verbose and hard to read,15 the “policy” specified in these configuration files is simpler than the complicated proxy and aspect logic that is hidden from view and created automatically. This type of architecture is so compelling that frameworks like Spring led to a complete overhaul of the EJB standard for version 3. EJB3 largely follows the Spring model of declaratively supporting cross-cutting concerns using XML configuration files and/or Java 5 annotations.\n 尽管 XML 可能会冗长且难以阅读，配置文件中定义的“策略”还是要比那种隐藏在幕后自动创建的复杂的代理和方面逻辑来得简单。这种类型的架构是如此引人注目，Spring 之类的框架最终导致了 EJB 标准在第 3 版的彻底变化。使用 XML 配置文件和/或 Java 5 annotation，EJB3 很大程度上遵循了 Spring 通过描述性手段支持横贯式关注面的模型。代码清单 11-5 展示了用 EJB3 重写的 Bank 对象。\n Listing 11-5 shows our Bank object rewritten in EJB3.\n 代码清单 11-5 展示了用 EJB3 重写的 Bank 对象。\n Listing 11-5 An EBJ3 Bank EJB\n 代码清单 11-5 EJB3 版本的 Bank\n package com.example.banking.model; import javax.persistence.*; import java.util.ArrayList; import java.util.Collection; @Entity @Table(name = \u0026#34;ANKS\u0026#34;) public class Bank implements java.io.Serializable { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int id; @Embeddable // An object “inlined\u0026#34; in Bank’s DB row  public class Address { protected String streetAddr1; protected String streetAddr2; protected String city; protected String state; protected String zipCode; } @Embedded private Address address; @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy = \u0026#34;bank\u0026#34;) private Collection\u0026lt;Account\u0026gt; accounts = new ArrayList\u0026lt;Account\u0026gt;(); public int getId() { return id; } public void setId(int id) { this.id = id; } public void addAccount(Account account) { account.setBank(this); accounts.add(account); } public Collection\u0026lt;Account\u0026gt; getAccounts() { return accounts; } public void setAccounts(Collection\u0026lt;Account\u0026gt; accounts) { this.accounts = accounts; } } This code is much cleaner than the original EJB2 code. Some of the entity details are still here, contained in the annotations. However, because none of that information is outside of the annotations, the code is clean, clear, and hence easy to test drive, maintain, and so on.\n 上列代码要比原本的 EJB2 代码整洁多了。有些实体细节仍然在 annotation 中存在。不过，因为没有任何信息超出 annotation 之外，代码依然整洁、清晰，也因此而易于测试驱动、易于维护。\n Some or all of the persistence information in the annotations can be moved to XML deployment descriptors, if desired, leaving a truly pure POJO. If the persistence mapping details won’t change frequently, many teams may choose to keep the annotations, but with far fewer harmful drawbacks compared to the EJB2 invasiveness.\n 如果愿意的话，annotation 中有些或全部持久化信息可以转移到 XML 部署描述中，只留下真正的纯 POJO。如果持久化映射细节不会频繁改动，许多团队可能会选择保留 annotation，但与 EJB2 那种侵害性相比还是少了很多问题。\n 11.6 ASPECTJ ASPECTS AspectJ 的方面 #  Finally, the most full-featured tool for separating concerns through aspects is the AspectJ language,17 an extension of Java that provides “first-class” support for aspects as modularity constructs. The pure Java approaches provided by Spring AOP and JBoss AOP are sufficient for 80–90 percent of the cases where aspects are most useful. However, AspectJ provides a very rich and powerful tool set for separating concerns. The drawback of AspectJ is the need to adopt several new tools and to learn new language constructs and usage idioms.\n 通过方面来实现关注面切分的功能最全的工具是 AspectJ 语言，一种提供“一流的”将方面作为模块构造处理支持的 Java 扩展。在 80%~90%用到方面特性的情况下，Spring AOP 和 JBoss AOP 提供的纯 Java 实现手段足够使用。然而，AspectJ 却提供了一套用以切分关注面的丰富而强有力的工具。AspectJ 的弱势在于，需要采用几种新工具，学习新语言构造和使用方式。\n The adoption issues have been partially mitigated by a recently introduced “annotation form” of AspectJ, where Java 5 annotations are used to define aspects using pure Java code. Also, the Spring Framework has a number of features that make incorporation of annotation-based aspects much easier for a team with limited AspectJ experience.\n 藉由 AspectJ 近期引入的“annotation form”（使用 Java 5 annotation 定义纯 Java 代码的方面），新工具采用的问题大大减少。另外，Spring Framework 也有一些让拥有较少 AspectJ 经验的团队更容易组合基于 annotation 的方面的特性。\n A full discussion of AspectJ is beyond the scope of this book. See [AspectJ], [Colyer], and [Spring] for more information.\n 关于 AspectJ 的全面探讨已经超出本书范围。更多信息可参见[AspectJ]、[Colyer]和[Spring]。\n 11.7 TEST DRIVE THE SYSTEM ARCHITECTURE 测试驱动系统架构 #  The power of separating concerns through aspect-like approaches can’t be overstated. If you can write your application’s domain logic using POJOs, decoupled from any architecture concerns at the code level, then it is possible to truly test drive your architecture. You can evolve it from simple to sophisticated, as needed, by adopting new technologies on demand. It is not necessary to do a Big Design Up Front18 (BDUF). In fact, BDUF is even harmful because it inhibits adapting to change, due to the psychological resistance to discarding prior effort and because of the way architecture choices influence subsequent thinking about the design.\n 通过方面式的手段切分关注面的威力不可低估。假使你能用 POJO 编写应用程序的领域逻辑，在代码层面与架构关注面分离开，就有可能真正地用测试来驱动架构。采用一些新技术，就能将架构按需从简单演化到精细。没必要先做大设计（Big Design Up Front，BDUF）。实际上，BDUF 甚至是有害的，它阻碍改进，因为心理上会抵制丢弃既成之事，也因为架构上的方案选择影响到后续的设计思路。\n Building architects have to do BDUF because it is not feasible to make radical architectural changes to a large physical structure once construction is well underway.19 Although software has its own physics,20 it is economically feasible to make radical change, if the structure of the software separates its concerns effectively.\n 建筑设计师不得不做 BDUF，因为一旦建造过程开始，就不可能对大型物理建筑的结构做根本性改动。尽管软件也有物理的一面，只要软件的构架有效切分了各个关注面，还是有可能做根本性改动的。\n This means we can start a software project with a “naively simple” but nicely decoupled architecture, delivering working user stories quickly, then adding more infrastructure as we scale up. Some of the world’s largest Web sites have achieved very high availability and performance, using sophisticated data caching, security, virtualization, and so forth, all done efficiently and flexibly because the minimally coupled designs are appropriately simple at each level of abstraction and scope.\n 这意味着我们可以从“简单自然”但切分良好的架构开始做软件项目，快速交付可工作的用户故事，随着规模的增长添加更多基础架构。有些世界上最大的网站采用了精密的数据缓存、安全、虚拟化等技术，获得了极高的可用性和性能，在每个抽象层和范围之内，那些最小化耦合的设计都简单到位，效率和灵活性也随之而来。\n Of course, this does not mean that we go into a project “rudderless.” We have some expectations of the general scope, goals, and schedule for the project, as well as the general structure of the resulting system. However, we must maintain the ability to change course in response to evolving circumstances.\n 当然，这不是说要毫无准备地进入一个项目。对于总的覆盖范围、目标、项目进度和最终系统的总体构架，我们会有所预期。不过，我们必须有能力随机应变。\n The early EJB architecture is but one of many well-known APIs that are over-engineered and that compromise separation of concerns. Even well-designed APIs can be overkill when they aren’t really needed. A good API should largely disappear from view most of the time, so the team expends the majority of its creative efforts focused on the user stories being implemented. If not, then the architectural constraints will inhibit the efficient delivery of optimal value to the customer.\n EJB 早期架构就是一种著名的过度工程化而没能有效切分关注面的 API。在没能真正得到使用时，设计得再好的 API 也等于是杀鸡用牛刀。优秀的 API 在大多数时间都该在视线之外，这样团队才能将创造力集中在要实现的用户故事上。否则，架构上的约束就会妨碍向客户交付优化价值的软件。\n To recap this long discussion, An optimal system architecture consists of modularized domains of concern, each of which is implemented with Plain Old Java (or other) Objects. The different domains are integrated together with minimally invasive Aspects or Aspect-like tools. This architecture can be test-driven, just like the code.\n 概言之，最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯 Java（或其他语言）对象实现。不同的领域之间用最不具有侵害性的方面或类方面工具整合起来。这种架构能测试驱动，就像代码一样。\n 11.8 OPTIMIZE DECISION MAKING 优化决策 #  Modularity and separation of concerns make decentralized management and decision making possible. In a sufficiently large system, whether it is a city or a software project, no one person can make all the decisions.\n 模块化和关注面切分成就了分散化管理和决策。在巨大的系统中，不管是一座城市或一个软件项目，无人能做所有决策。\n We all know it is best to give responsibilities to the most qualified persons. We often forget that it is also best to postpone decisions until the last possible moment. This isn’t lazy or irresponsible; it lets us make informed choices with the best possible information. A premature decision is a decision made with suboptimal knowledge. We will have that much less customer feedback, mental reflection on the project, and experience with our implementation choices if we decide too soon.\n 众所周知，最好是授权给最有资格的人。但我们常常忘记了，延迟决策至最后一刻也是好手段。这不是懒惰或不负责；它让我们能够基于最有可能的信息做出选择。提前决策是一种预备知识不足的决策。如果决策太早，就会缺少太多客户反馈、关于项目的思考和实施经验。\n The agility provided by a POJO system with modularized concerns allows us to make optimal, just-in-time decisions, based on the most recent knowledge. The complexity of these decisions is also reduced.\n 拥有模块化关注面的 POJO 系统提供的敏捷能力，允许我们基于最新的知识做出优化的、时机刚好的决策。决策的复杂性也降低了。\n 11.9 USE STANDARDS WISELY, WHEN THEY ADD DEMONSTRABLE VALUE 明智使用添加了可论证价值的标准 #  Building construction is a marvel to watch because of the pace at which new buildings are built (even in the dead of winter) and because of the extraordinary designs that are possible with today’s technology. Construction is a mature industry with highly optimized parts, methods, and standards that have evolved under pressure for centuries.\n 建筑构造大有可观，既因为新建筑的构建过程（即便是在隆冬季节），也因为那些现今科技所能实现的超凡设计。建筑业是一个成熟行业，有着高度优化的部件、方法和久经岁月历练的标准。\n Many teams used the EJB2 architecture because it was a standard, even when lighter-weight and more straightforward designs would have been sufficient. I have seen teams become obsessed with various strongly hyped standards and lose focus on implementing value for their customers.\n 即便是轻量级和更直截了当的设计已足敷使用，许多团队还是采用了 EJB2 架构，只因为 EJB2 是个标准。我见过一些团队，纠缠于这个或那个名声大噪的标准，却丧失了对为客户实现价值的关注。有了标准，就更易复用想法和组件、雇用拥有相关经验的人才、封装好点子，以及将组件连接起来。不过，创立标准的过程有时却漫长到行业等不及的程度，有些标准没能与它要服务的采用者的真实需求相结合。\n Standards make it easier to reuse ideas and components, recruit people with relevant experience, encapsulate good ideas, and wire components together. However, the process of creating standards can sometimes take too long for industry to wait, and some standards lose touch with the real needs of the adopters they are intended to serve.\n11.10 SYSTEMS NEED DOMAIN-SPECIFIC LANGUAGES 系统需要领域特定语言 #  Building construction, like most domains, has developed a rich language with a vocabulary, idioms, and patterns21 that convey essential information clearly and concisely. In software, there has been renewed interest recently in creating Domain-Specific Languages (DSLs),22 which are separate, small scripting languages or APIs in standard languages that permit code to be written so that it reads like a structured form of prose that a domain expert might write.\n 建筑，与大多数其他领域一样，发展出一套丰富的语言，有词汇、熟语和清晰而简洁地表达基础信息的句式。在软件领域，领域特定语言（Domain-Specific Language，DSL）最近重受关注。DSL 是一种单独的小型脚本语言或以标准语言写就的 API，领域专家可以用它编写读起来像是组织严谨的散文一般的代码。\n A good DSL minimizes the “communication gap” between a domain concept and the code that implements it, just as agile practices optimize the communications within a team and with the project’s stakeholders. If you are implementing domain logic in the same language that a domain expert uses, there is less risk that you will incorrectly translate the domain into the implementation.\n 优秀的 DSL 填平了领域概念和实现领域概念的代码之间的“壕沟”，就像敏捷实践优化了开发团队和甲方之间的沟通一样。如果你用与领域专家使用的同一种语言来实现领域逻辑，就会降低不正确地将领域翻译为实现的风险。\n DSLs, when used effectively, raise the abstraction level above code idioms and design patterns. They allow the developer to reveal the intent of the code at the appropriate level of abstraction.\n DSL 在有效使用时能提升代码惯用法和设计模式之上的抽象层次。它允许开发者在恰当的抽象层级上直指代码的初衷。\n Domain-Specific Languages allow all levels of abstraction and all domains in the application to be expressed as POJOs, from high-level policy to low-level details.\n 领域特定语言允许所有抽象层级和应用程序中的所有领域，从高级策略到底层细节，使用 POJO 来表达。\n 11.11 CONCLUSION 小结 #  Systems must be clean too. An invasive architecture overwhelms the domain logic and impacts agility. When the domain logic is obscured, quality suffers because bugs find it easier to hide and stories become harder to implement. If agility is compromised, productivity suffers and the benefits of TDD are lost.\n 系统也应该是整洁的。侵害性架构会湮灭领域逻辑，冲击敏捷能力。当领域逻辑受到困扰，质量也就堪忧，因为缺陷更易隐藏，用户故事更难实现。当敏捷能力受到损害时，生产力也会降低，TDD 的好处遗失殆尽。\n At all levels of abstraction, the intent should be clear. This will only happen if you write POJOs and you use aspect-like mechanisms to incorporate other implementation concerns noninvasively.\n 在所有的抽象层级上，意图都应该清晰可辨。只有在编写 POJO 并使用类方面的机制来无损地组合其他关注面时，这种事情才会发生。\n Whether you are designing systems or individual modules, never forget to use the simplest thing that can possibly work.\n 无论是设计系统或单独的模块，别忘了使用大概可工作的最简单方案。\n "});index.add({'id':200,'href':'/docs/Clean-Code/12.-Emergence/ch12/','title':"Ch12",'section':"Go语言圣经",'content':"第 12 章 Emergence 迭进 #  by Jeff Langr\n 12.1 GETTING CLEAN VIA EMERGENT DESIGN 通过迭进设计达到整洁目的 #  What if there were four simple rules that you could follow that would help you create good designs as you worked? What if by following these rules you gained insights into the structure and design of your code, making it easier to apply principles such as SRP and DIP? What if these four rules facilitated the emergence of good designs?\n 假使有 4 条简单的规矩，跟着做就能帮助你创建优良的设计，会如何？假使遵循这些规矩你就能洞见代码的结构和设计，更轻易地应用 SRP 和 DIP 之类原则，又会如何？\n Many of us feel that Kent Beck’s four rules of Simple Design1 are of significant help in creating well-designed software.\n 我们中的许多人认为，Kent Beck 关于简单设计的四条规则，对于创建具有良好设计的软件有着莫大的帮助。\n According to Kent, a design is “simple” if it follows these rules:\n 据 Kent 所述，只要遵循以下规则，设计就能变得“简单”：\n  Runs all the tests Contains no duplication Expresses the intent of the programmer Minimizes the number of classes and methods     运行所有测试； 不可重复； 表达了程序员的意图； 尽可能减少类和方法的数量；   The rules are given in order of importance.\n 以上规则按其重要程度排列。\n 12.2 SIMPLE DESIGN RULE 1: RUNS ALL THE TESTS 简单设计规则 1：运行所有测试 #  First and foremost, a design must produce a system that acts as intended. A system might have a perfect design on paper, but if there is no simple way to verify that the system actually works as intended, then all the paper effort is questionable.\n 设计必须制造出如预期一般工作的系统，这是首要因素。系统也许有一套绝佳设计，但如果缺乏验证系统是否真按预期那样工作的简单方法，那就无异于纸上谈兵。\n A system that is comprehensively tested and passes all of its tests all of the time is a testable system. That’s an obvious statement, but an important one. Systems that aren’t testable aren’t verifiable. Arguably, a system that cannot be verified should never be deployed.\n 全面测试并持续通过所有测试的系统，就是可测试的系统。看似浅显，但却重要。不可测试的系统同样不可验证。不可验证的系统，绝不应部署。\n Fortunately, making our systems testable pushes us toward a design where our classes are small and single purpose. It’s just easier to test classes that conform to the SRP. The more tests we write, the more we’ll continue to push toward things that are simpler to test. So making sure our system is fully testable helps us create better designs.\n 幸运的是，只要系统可测试，就会导向保持类短小且目的单一的设计方案。遵循 SRP 的类，测试起来较为简单。测试编写得越多，就越能持续走向编写较易测试的代码。所以，确保系统完全可测试能帮助我们创建更好的设计。\n Tight coupling makes it difficult to write tests. So, similarly, the more tests we write, the more we use principles like DIP and tools like dependency injection, interfaces, and abstraction to minimize coupling. Our designs improve even more.\n 紧耦合的代码难以编写测试。同样，编写测试越多，就越会遵循 DIP 之类规则，使用依赖注入、接口和抽象等工具尽可能减少耦合。如此一来，设计就有长足进步。\n Remarkably, following a simple and obvious rule that says we need to have tests and run them continuously impacts our system’s adherence to the primary OO goals of low coupling and high cohesion. Writing tests leads to better designs.\n 遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近 OO 低耦合度、高内聚度的目标。编写测试引致更好的设计。\n 12.3 SIMPLE DESIGN RULES 2–4: REFACTORING 简单设计规则 2 ～ 4：重构 #  Once we have tests, we are empowered to keep our code and classes clean. We do this by incrementally refactoring the code. For each few lines of code we add, we pause and reflect on the new design. Did we just degrade it? If so, we clean it up and run our tests to demonstrate that we haven’t broken anything. The fact that we have these tests eliminates the fear that cleaning up the code will break it!\n 有了测试，就能保持代码和类的整洁，方法就是递增式地重构代码。添加了几行代码后，就要暂停，琢磨一下变化了的设计。设计退步了吗？如果是，就要清理它，并且运行测试，保证没有破坏任何东西。测试消除了对清理代码就会破坏代码的恐惧。\n During this refactoring step, we can apply anything from the entire body of knowledge about good software design. We can increase cohesion, decrease coupling, separate concerns, modularize system concerns, shrink our functions and classes, choose better names, and so on. This is also where we apply the final three rules of simple design: Eliminate duplication, ensure expressiveness, and minimize the number of classes and methods.\n 在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称，如此等等。这也是应用简单设计后三条规则的地方：消除重复，保证表达力，尽可能减少类和方法的数量。\n 12.4 NO DUPLICATION 不可重复 #  Duplication is the primary enemy of a well-designed system. It represents additional work, additional risk, and additional unnecessary complexity. Duplication manifests itself in many forms. Lines of code that look exactly alike are, of course, duplication. Lines of code that are similar can often be massaged to look even more alike so that they can be more easily refactored. And duplication can exist in other forms such as duplication of implementation. For example, we might have two methods in a collection class:\n 重复是拥有良好设计系统的大敌。它代表着额外的工作、额外的风险和额外且不必要的复杂度。重复有多种表现。极其雷同的代码行当然是重复。类似的代码往往可以调整得更相似，这样就能更容易地进行重构。重复也有实现上的重复等其他一些形态。例如，在某个群集类中可能会有两个方法：\n int size() {} boolean isEmpty() {} We could have separate implementations for each method. The isEmpty method could track a boolean, while size could track a counter. Or, we can eliminate this duplication by tying isEmpty to the definition of size:\n 这两个方法可以分别实现。isEmpty 方法跟踪一个布尔值，而 size 方法则跟踪一个计数器。或者，也可以通过在 isEmpty 中使用 size 方法来消除重复：\n boolean isEmpty() { return 0 == size(); } Creating a clean system requires the will to eliminate duplication, even in just a few lines of code. For example, consider the following code:\n 要想创建整洁的系统，需要有消除重复的意愿，即便对于短短几行也是如此。例如以下代码：\n public void scaleToOneDimension( float desiredDimension, float imageDimension) { if (Math.abs(desiredDimension - imageDimension) \u0026lt; errorThreshold) return; float scalingFactor = desiredDimension / imageDimension; scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f); RenderedOp newImage = ImageUtilities.getScaledImage( image, scalingFactor, scalingFactor); image.dispose(); System.gc(); image = newImage; } public synchronized void rotate(int degrees) { RenderedOp newImage = ImageUtilities.getRotatedImage( image, degrees); image.dispose(); System.gc(); image = newImage; } To keep this system clean, we should eliminate the small amount of duplication between the scaleToOneDimension and rotate methods:\n 要保持系统整洁，应该消除 scaleToOneDimension 和 rotate 方法里面的少量重复：\n public void scaleToOneDimension( float desiredDimension, float imageDimension) { if (Math.abs(desiredDimension - imageDimension) \u0026lt; errorThreshold) return; float scalingFactor = desiredDimension / imageDimension; scalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f); replaceImage(ImageUtilities.getScaledImage( image, scalingFactor, scalingFactor)); } public synchronized void rotate(int degrees) { replaceImage(ImageUtilities.getRotatedImage(image, degrees)); } privatex void replaceImage(RenderedOp newImage) { image.dispose(); System.gc(); image = newImage; } As we extract commonality at this very tiny level, we start to recognize violations of SRP. So we might move a newly extracted method to another class. That elevates its visibility. Someone else on the team may recognize the opportunity to further abstract the new method and reuse it in a different context. This “reuse in the small” can cause system complexity to shrink dramatically. Understanding how to achieve reuse in the small is essential to achieving reuse in the large.\n 做了一点点共性抽取后，我们意识到已经违反了 SRP 原则。所以，可以把一个新方法分解到另外的类中，从而提升其可见性。团队中的其他成员也许会发现进一步抽象新方法的机会，并且在其他场景中复用之。“小规模复用”可大量降低系统复杂性。要想实现大规模复用，必须理解如何实现小规模复用。\n The TEMPLATE METHOD2 pattern is a common technique for removing higher-level duplication. For example:\n 模板方法模式是一种移除高层级重复的通用技巧。例如：\n public class VacationPolicy { public void accrueUSDivisionVacation() { // code to calculate vacation based on hours worked to date  // …  // code to ensure vacation meets US minimums  // …  // code to apply vaction to payroll record  // …  } public void accrueEUDivisionVacation() { // code to calculate vacation based on hours worked to date  // …  // code to ensure vacation meets EU minimums  // …  // code to apply vaction to payroll record  // …  } } The code across accrueUSDivisionVacation and accrueEuropeanDivisionVacation is largely the same, with the exception of calculating legal minimums. That bit of the algorithm changes based on the employee type.\n 除了计算法定最少数量假期的部分，accrueUSDivisionVacation 和 accrueEuropeanDivision Vacation 中有大量代码雷同。那部分的算法，依据员工类型而变。\n We can eliminate the obvious duplication by applying the TEMPLATE METHOD pattern.\n 可以通过应用模板方法模式来消除明显的重复。\n abstract public class VacationPolicy { public void accrueVacation() { calculateBaseVacationHours(); alterForLegalMinimums(); applyToPayroll(); } private void calculateBaseVacationHours() { /* … */ }; abstract protected void alterForLegalMinimums(); private void applyToPayroll() { /* … */ }; } public class USVacationPolicy extends VacationPolicy { @Override protected void alterForLegalMinimums() { // US specific logic  } } public class EUVacationPolicy extends VacationPolicy { @Override protected void alterForLegalMinimums() { // EU specific logic  } } The subclasses fill in the “hole” in the accrueVacation algorithm, supplying the only bits of information that are not duplicated.\n 子类填充了 accrueVacation 算法中的“空洞”，提供不重复的信息。\n 12.5 EXPRESSIVE 表达力 #  Most of us have had the experience of working on convoluted code. Many of us have produced some convoluted code ourselves. It’s easy to write code that we understand, because at the time we write it we’re deep in an understanding of the problem we’re trying to solve. Other maintainers of the code aren’t going to have so deep an understanding.\n 我们中的大多数人都经历过费解代码的纠缠。我们中的许多人自己就编写过费解的代码。写出自己能理解的代码很容易，因为在写这些代码时，我们正深入于要解决的问题中。代码的其他维护者不会那么深入，也就不易理解代码。\n The majority of the cost of a software project is in long-term maintenance. In order to minimize the potential for defects as we introduce change, it’s critical for us to be able to understand what a system does. As systems become more complex, they take more and more time for a developer to understand, and there is an ever greater opportunity for a misunderstanding. Therefore, code should clearly express the intent of its author. The clearer the author can make the code, the less time others will have to spend understanding it. This will reduce defects and shrink the cost of maintenance.\n 软件项目的主要成本在于长期维护。为了在修改时尽量降低出现缺陷的可能性，很有必要理解系统是做什么的。当系统变得越来越复杂，开发者就需要越来越多的时间来理解它，而且也极有可能误解。所以，代码应当清晰地表达其作者的意图。作者把代码写得越清晰，其他人花在理解代码上的时间也就越少，从而减少缺陷，缩减维护成本。\n You can express yourself by choosing good names. We want to be able to hear a class or function name and not be surprised when we discover its responsibilities.\n 可以通过选用好名称来表达。我们想要听到好类名和好函数名，而且在查看其权责时不会大吃一惊。\n You can also express yourself by keeping your functions and classes small. Small classes and functions are usually easy to name, easy to write, and easy to understand.\n 也可以通过保持函数和类尺寸短小来表达。短小的类和函数通常易于命名，易于编写，易于理解。\n You can also express yourself by using standard nomenclature. Design patterns, for example, are largely about communication and expressiveness. By using the standard pattern names, such as COMMAND or VISITOR, in the names of the classes that implement those patterns, you can succinctly describe your design to other developers.\n 还可以通过采用标准命名法来表达。例如，设计模式很大程度上就关乎沟通和表达。通过在实现这些模式的类的名称中采用标准模式名，例如 COMMAND 或 VISITOR，就能充分地向其他开发者描述你的设计。\n Well-written unit tests are also expressive. A primary goal of tests is to act as documentation by example. Someone reading our tests should be able to get a quick understanding of what a class is all about.\n 编写良好的单元测试也具有表达性。测试的主要目的之一就是通过实例起到文档的作用。读到测试的人应该能很快理解某个类是做什么的。\n But the most important way to be expressive is to try. All too often we get our code working and then move on to the next problem without giving sufficient thought to making that code easy for the next person to read. Remember, the most likely next person to read the code will be you.\n 不过，做到有表达力的最重要方式却是尝试。有太多时候，我们写出能工作的代码，就转移到下一个问题上，没有下足功夫调整代码，让后来者易于阅读。记住，下一位读代码的人最有可能是你自己。\n So take a little pride in your workmanship. Spend a little time with each of your functions and classes. Choose better names, split large functions into smaller functions, and generally just take care of what you’ve created. Care is a precious resource.\n 所以，多少尊重一下你的手艺吧。花一点点时间在每个函数和类上。选用较好的名称，将大函数切分为小函数，时时照拂自己创建的东西。用心是最珍贵的资源。\n 12.6 MINIMAL CLASSES AND METHODS 尽可能少的类和方法 #  Even concepts as fundamental as elimination of duplication, code expressiveness, and the SRP can be taken too far. In an effort to make our classes and methods small, we might create too many tiny classes and methods. So this rule suggests that we also keep our function and class counts low.\n 即便是消除重复、代码表达力和 SRP 等最基础的概念也会被过度使用。为了保持类和函数短小，我们可能会造出太多的细小类和方法。所以这条规则也主张函数和类的数量要少。\n High class and method counts are sometimes the result of pointless dogmatism. Consider, for example, a coding standard that insists on creating an interface for each and every class. Or consider developers who insist that fields and behavior must always be separated into data classes and behavior classes. Such dogma should be resisted and a more pragmatic approach adopted.\n 类和方法的数量太多，有时是由毫无意义的教条主义导致的。例如，某个编码标准就坚称应当为每个类创建接口。也有开发者认为，字段和行为必须切分到数据类和行为类中。应该抵制这类教条，采用更实用的手段。\n Our goal is to keep our overall system small while we are also keeping our functions and classes small. Remember, however, that this rule is the lowest priority of the four rules of Simple Design. So, although it’s important to keep class and function count low, it’s more important to have tests, eliminate duplication, and express yourself.\n 我们的目标是在保持函数和类短小的同时，保持整个系统短小精悍。不过要记住，这在关于简单设计的四条规则里面是优先级最低的一条。所以，尽管使类和函数的数量尽量少是很重要的，但更重要的却是测试、消除重复和表达力。\n 12.7 CONCLUSION 小结 #  Is there a set of simple practices that can replace experience? Clearly not. On the other hand, the practices described in this chapter and in this book are a crystallized form of the many decades of experience enjoyed by the authors. Following the practice of simple design can and does encourage and enable developers to adhere to good principles and patterns that otherwise take years to learn.\n 有没有能替代经验的一套简单实践手段呢？当然不会有。另一方面，本章中写到的实践来自于本书作者数十年经验的精练总结。遵循简单设计的实践手段，开发者不必经年学习就能掌握好的原则和模式。\n "});index.add({'id':201,'href':'/docs/Clean-Code/13.-Concurrency/ch13/','title':"Ch13",'section':"Go语言圣经",'content':"第 13 章 Concurrency 并发编程 #  by Brett L. Schuchert\n “Objects are abstractions of processing. Threads are abstractions of schedule.”\n—James O. Coplien1\n “对象是过程的抽象。线程是调度的抽象。”\n——James O\n Writing clean concurrent programs is hard—very hard. It is much easier to write code that executes in a single thread. It is also easy to write multithreaded code that looks fine on the surface but is broken at a deeper level. Such code works fine until the system is placed under stress.\n Coplien 编写整洁的并发程序很难——非常难。编写在单线程中执行的代码简单得多。编写表面上看来不错、深入进去却支离破碎的多线程代码也简单。系统一旦遭受压力，这种代码就扛不住了。\n In this chapter we discuss the need for concurrent programming, and the difficulties it presents. We then present several recommendations for dealing with those difficulties, and writing clean concurrent code. Finally, we conclude with issues related to testing concurrent code.\n 本章将讨论并发编程的需求及其困难之处，并给出一些对付这些难点、编写整洁的并发代码的建议。最后，我们将讨论与测试并发代码有关的问题。\n Clean Concurrency is a complex topic, worthy of a book by itself. Our strategy in this book is to present an overview here and provide a more detailed tutorial in “Concurrency II” on page 317. If you are just curious about concurrency, then this chapter will suffice for you now. If you have a need to understand concurrency at a deeper level, then you should read through the tutorial as well.\n 整洁的并发编程是个复杂话题，值得用一整本书来讨论。本书只做概览，并在“并发编程 II”一章中提供更详细的指引。如果你只是对并发好奇，阅读本章就足够了。如果你需要更深入地理解并发，就应读完整个指引章节。\n 13.1 WHY CONCURRENCY? 为什么要并发 #  Concurrency is a decoupling strategy. It helps us decouple what gets done from when it gets done. In single-threaded applications what and when are so strongly coupled that the state of the entire application can often be determined by looking at the stack backtrace. A programmer who debugs such a system can set a breakpoint, or a sequence of breakpoints, and know the state of the system by which breakpoints are hit.\n 并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。在单线程应用中，目的与时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序的状态。调试这种系统的程序员可以设定断点或者断点序列，通过查看到达哪个断点来了解系统状态。\n Decoupling what from when can dramatically improve both the throughput and structures of an application. From a structural point of view the application looks like many little collaborating computers rather than one big main loop. This can make the system easier to understand and offers some powerful ways to separate concerns.\n 解耦目的与时机能明显地改进应用程序的吞吐量和结构。从结构的角度来看，应用程序看起来更像是许多台协同工作的计算机，而不是一个大循环。系统因此会更易于被理解，给出了许多切分关注面的有力手段。\n Consider, for example, the standard “Servlet” model of Web applications. These systems run under the umbrella of a Web or EJB container that partially manages concurrency for you. The servlets are executed asynchronously whenever Web requests come in. The servlet programmer does not have to manage all the incoming requests. In principle, each servlet execution lives in its own little world and is decoupled from all the other servlet executions.\n 例如，Web 应用的 Servlet 标准模式。这类系统运行于 Web 或 EJB 容器的保护伞之下，Web 或 EJB 为你部分地处理并发问题。当有 Web 请求时，servlet 就会异步执行。Servlet 程序员无需管理所有的请求。原则上，每次 servlet 是在自己的小世界中执行，与其他 servlet 的执行是分离的。\n Of course if it were that easy, this chapter wouldn’t be necessary. In fact, the decoupling provided by Web containers is far less than perfect. Servlet programmers have to be very aware, and very careful, to make sure their concurrent programs are correct. Still, the structural benefits of the servlet model are significant.\n 当然，如果只是那么简单，也就没必要写这一章了。实际上，Web 容器提供的解耦手段离完美还差得远。Servlet 程序员得非常警惕、非常小心地保证并发程序不出错。同样，servlet 模式的结构性好处还是很明显。\n But structure is not the only motive for adopting concurrency. Some systems have response time and throughput constraints that require hand-coded concurrent solutions. For example, consider a single-threaded information aggregator that acquires information from many different Web sites and merges that information into a daily summary. Because this system is single threaded, it hits each Web site in turn, always finishing one before starting the next. The daily run needs to execute in less than 24 hours. However, as more and more Web sites are added, the time grows until it takes more than 24 hours to gather all the data. The single-thread involves a lot of waiting at Web sockets for I/O to complete. We could improve the performance by using a multithreaded algorithm that hits more than one Web site at a time.\n 但结构并非采用并发的唯一动机。有些系统对响应时间和吞吐量有要求，需要手工编写并发解决方案。例如，考虑一个单线程信息聚合程序，它从许多 Web 站点获取信息，再合并写入日志中。因为该系统是单线程的，它会逐个访问 Web 站点，在开始下一个之前等待当前站点访问完毕。每天的执行时间必须少于 24 个小时。然而，随着要访问的站点越来越多，采集所有数据花费的时间也越来越多，最终超过了 24 个小时的限制。单线程程序许多时间花在等待 Web 套接字 I/O 结束上面。通过采用同时访问多个站点的多线程算法，就能改进性能。\n Or consider a system that handles one user at a time and requires only one second of time per user. This system is fairly responsive for a few users, but as the number of users increases, the system’s response time increases. No user wants to get in line behind 150 others! We could improve the response time of this system by handling many users concurrently.\n 或者，考虑某个每次花费 1 秒钟处理一个用户请求的系统。该系统在用户量较少的时候响应及时，但随着用户数增加，系统的响应时间也增加了。没人想排在 150 个人后面！通过并发处理多个用户请求，就能改进系统响应时间。\n Or consider a system that interprets large data sets but can only give a complete solution after processing all of them. Perhaps each data set could be processed on a different computer, so that many data sets are being processed in parallel.\n 再或者，考虑某个解释大量数据集、但只在处理完全部数据后给出一个完整解决方案的系统。或许可以在独立的计算机上处理每个数据集，那样的话许多数据集就能并行地得到处理。\n Myths and Misconceptions\n 迷思与误解\n And so there are compelling reasons to adopt concurrency. However, as we said before, concurrency is hard. If you aren’t very careful, you can create some very nasty situations. Consider these common myths and misconceptions:\n 看来有足够的理由采用并发方案。然而，如前文所述，并发编程很难。如果你不那么细心，就会搞出不堪入目的东西来。看看以下常见的迷思和误解：\n  Concurrency always improves performance. Concurrency can sometimes improve performance, but only when there is a lot of wait time that can be shared between multiple threads or multiple processors. Neither situation is trivial. Design does not change when writing concurrent programs. In fact, the design of a concurrent algorithm can be remarkably different from the design of a single-threaded system. The decoupling of what from when usually has a huge effect on the structure of the system. Understanding concurrency issues is not important when working with a container such as a Web or EJB container. In fact, you’d better know just what your container is doing and how to guard against the issues of concurrent update and deadlock described later in this chapter.    （1）并发总能改进性能。并发有时能改进性能，但只在多个线程或处理器之间能分享大量等待时间的时候管用。事情没那么简单。 （2）编写并发程序无需修改设计。事实上，并发算法的设计有可能与单线程系统的设计极不相同。目的与时机的解耦往往对系统结构产生巨大影响。 （3）在采用 Web 或 EJB 容器的时候，理解并发问题并不重要。实际上，你最好了解容器在做什么，了解如何对付本章后文将提到的并发更新、死锁等问题。  Here are a few more balanced sound bites regarding writing concurrent software:\n 下面是一些有关编写并发软件的中肯说法：\n  Concurrency incurs some overhead, both in performance as well as writing additional code. Correct concurrency is complex, even for simple problems. Concurrency bugs aren’t usually repeatable, so they are often ignored as one-offs2 instead of the true defects they are. Concurrency often requires a fundamental change in design strategy.    并发会在性能和编写额外代码上增加一些开销； 正确的并发是复杂的，即便对于简单的问题也是如此； 并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待； 并发常常需要对设计策略的根本性修改。   13.2 CHALLENGES 挑战 #  What makes concurrent programming so difficult? Consider the following trivial class:\n 并发编程为何如此之难？来看看下面这个小型类：\n public class X { private int lastIdUsed; public int getNextId() { return ++lastIdUsed; } } Let’s say we create an instance of X, set the lastIdUsed field to 42, and then share the instance between two threads. Now suppose that both of those threads call the method getNextId(); there are three possible outcomes:\n 比如，创建 x 的一个实体，将 lastIdUsed 设置为 42，在两个线程中共享这个实体。假设这两个线程都调用 getNextId() 方法，结果可能有三种输出：\n  Thread one gets the value 43, thread two gets the value 44, lastIdUsed is 44. Thread one gets the value 44, thread two gets the value 43, lastIdUsed is 44. Thread one gets the value 43, thread two gets the value 43, lastIdUsed is 43.     线程一得到值 43，线程二得到值 44，lastIdUsed 为 44； 线程一得到值 44，线程二得到值 43，lastIdUsed 为 44； 线程一得到值 43，线程二得到值 43，lastIdUsed 为 43。   The surprising third result3 occurs when the two threads step on each other. This happens because there are many possible paths that the two threads can take through that one line of Java code, and some of those paths generate incorrect results. How many different paths are there? To really answer that question, we need to understand what the Just-In-Time Compiler does with the generated byte-code, and understand what the Java memory model considers to be atomic.\n 第三种结果令人惊异，当两个线程相互影响时就会出现这种情况。这是因为线程在执行那行 Java 代码时有许多可能路径可行，有些路径会产生错误的结果。有多少种不同路径呢？要真正回答这个问题，需要理解 Just-In-Time 编译器如何对待生成的字节码，还要理解 Java 内存模型认为什么东西具有原子性。\n A quick answer, working with just the generated byte-code, is that there are 12,870 different possible execution paths4 for those two threads executing within the getNextId method. If the type of lastIdUsed is changed from int to long, the number of possible paths increases to 2,704,156. Of course most of those paths generate valid results. The problem is that some of them don’t.\n 简答一下，就生成的字节码而言，对于在 getNextId 方法中执行的那两个线程，有 12870 种不同的可能执行路径。如果 lastIdUsed 的类型从 int 变为 long，则可能路径的数量将增至 2704156 种。当然，多数路径都得到正确结果。问题是其中一些不能得到正确结果。\n 13.3 CONCURRENCY DEFENSE PRINCIPLES 并发防御原则 #  What follows is a series of principles and techniques for defending your systems from the problems of concurrent code.\n 下面给出一系列防御并发代码问题的原则和技巧。\n 13.3.1 Single Responsibility Principle 单一权责原则 #  The SRP5 states that a given method/class/component should have a single reason to change. Concurrency design is complex enough to be a reason to change in it’s own right and therefore deserves to be separated from the rest of the code. Unfortunately, it is all too common for concurrency implementation details to be embedded directly into other production code. Here are a few things to consider:\n 单一权责原则（SRP）认为，方法/类/组件应当只有一个修改的理由。并发设计自身足够复杂到成为修改的理由，所以也该从其他代码中分离出来。不幸的是，并发实现细节常常直接嵌入到其他生产代码中。下面是要考虑的一些问题：\n  Concurrency-related code has its own life cycle of development, change, and tuning. Concurrency-related code has its own challenges, which are different from and often more difficult than nonconcurrency-related code. The number of ways in which miswritten concurrency-based code can fail makes it challenging enough without the added burden of surrounding application code.     并发相关代码有自己的开发、修改和调优生命周期； 开发相关代码有自己要对付的挑战，和非并发相关代码不同，而且往往更为困难； 即便没有周边应用程序增加的负担，写得不好的并发代码可能的出错方式数量也已经足具挑战性。   Recommendation: Keep your concurrency-related code separate from other code.6\n 建议：分离并发相关代码与其他代码。\n 13.3.2 Corollary: Limit the Scope of Data 推论：限制数据作用域 #  As we saw, two threads modifying the same field of a shared object can interfere with each other, causing unexpected behavior. One solution is to use the synchronized keyword to protect a critical section in the code that uses the shared object. It is important to restrict the number of such critical sections. The more places shared data can get updated, the more likely:\n 如我们所见，两个线程修改共享对象的同一字段时，可能互相干扰，导致未预期的行为。解决方案之一是采用 synchronized 关键字在代码中保护一块使用共享对象的临界区（critical section）。限制临界区的数量很重要。更新共享数据的地方越多，就越可能：\n  You will forget to protect one or more of those places—effectively breaking all code that modifies that shared data. There will be duplication of effort required to make sure everything is effectively guarded (violation of DRY7). It will be difficult to determine the source of failures, which are already hard enough to find.     你会忘记保护一个或多个临界区——破坏了修改共享数据的代码； 得多花力气保证一切都受到有效防护（破坏了 DRY 原则）； 很难找到错误源，也很难判断错误源。   Recommendation: Take data encapsulation to heart; severely limit the access of any data that may be shared.\n 建议：谨记数据封装；严格限制对可能被共享的数据的访问。\n 13.3.3 Corollary: Use Copies of Data 推论：使用数据复本 #  A good way to avoid shared data is to avoid sharing the data in the first place. In some situations it is possible to copy objects and treat them as read-only. In other cases it might be possible to copy objects, collect results from multiple threads in these copies and then merge the results in a single thread.\n 避免共享数据的好方法之一就是一开始就避免共享数据。在某些情形下，有可能复制对象并以只读方式对待。在另外的情况下，有可能复制对象，从多个线程收集所有复本的结果，并在单个线程中合并这些结果。\n If there is an easy way to avoid sharing objects, the resulting code will be far less likely to cause problems. You might be concerned about the cost of all the extra object creation. It is worth experimenting to find out if this is in fact a problem. However, if using copies of objects allows the code to avoid synchronizing, the savings in avoiding the intrinsic lock will likely make up for the additional creation and garbage collection overhead.\n 如果有避免共享数据的简易手段，结果代码就会大大减少导致错误的可能。你可能会关心创建额外对象的成本。值得试验一下看看那是否真是个问题。然而，假使使用对象复本能避免代码同步执行，则因避免了锁定而省下的价值有可能补偿得上额外的创建成本和垃圾收集开销。\n 13.3.4 Corollary: Threads Should Be as Independent as Possible 推论：线程应尽可能地独立 #  Consider writing your threaded code such that each thread exists in its own world, sharing no data with any other thread. Each thread processes one client request, with all of its required data coming from an unshared source and stored as local variables. This makes each of those threads behave as if it were the only thread in the world and there were no synchronization requirements.\n 让每个线程在自己的世界中存在，不与其他线程共享数据。每个线程处理一个客户端请求，从不共享的源头接纳所有请求数据，存储为本地变量。这样一来，每个线程都像是世界中的唯一线程，没有同步需要。\n For example, classes that subclass from HttpServlet receive all of their information as parameters passed in to the doGet and doPost methods. This makes each Servlet act as if it has its own machine. So long as the code in the Servlet uses only local variables, there is no chance that the Servlet will cause synchronization problems. Of course, most applications using Servlets eventually run into shared resources such as database connections.\n 例如，HttpServlet 的子类接收所有以参数形式传递给 doGet 和 doPost 方法的信息。每个 Servlet 都像拥有独立虚拟机一般运行。只要 Servlet 中的代码只使用本地变量，Servlet 就不会导致同步问题。当然，多数使用 Servlet 的应用程序最终都还是会用到类似数据库连接之类的共享资源。\n Recommendation: Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors.\n 建议：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。\n 13.4 KNOW YOUR LIBRARY 了解 Java 库 #  Java 5 offers many improvements for concurrent development over previous versions. There are several things to consider when writing threaded code in Java 5:\n 相对于之前的版本，Java 5 提供了许多并发开发方面的改进。在用 Java 5 编写线程代码时，要注意以下几点：\n  Use the provided thread-safe collections. Use the executor framework for executing unrelated tasks. Use nonblocking solutions when possible. Several library classes are not thread safe.     使用类库提供的线程安全群集； 使用 executor 框架（executor framework）执行无关任务； 尽可能使用非锁定解决方案； 有几个类并不是线程安全的。   Thread-Safe Collections 线程安全群集 When Java was young, Doug Lea wrote the seminal book8 Concurrent Programming in Java. Along with the book he developed several thread-safe collections, which later became part of the JDK in the java.util.concurrent package. The collections in that package are safe for multithreaded situations and they perform well. In fact, the ConcurrentHashMap implementation performs better than HashMap in nearly all situations. It also allows for simultaneous concurrent reads and writes, and it has methods supporting common composite operations that are otherwise not thread safe. If Java 5 is the deployment environment, start with ConcurrentHashMap.\n 当 Java 还年轻时，Doug Lea 编写了 Concurrent Programming in Java（中译版《Java 并发编程》）教程，同时开发了几个线程安全群集，这些代码后来成为 JDK 中 java.util.concurrent 包的一部分。该代码包中的群集对于多线程解决方案是安全的，执行良好。实际上，在几乎所有情况下，ConcurrentHashMap 实现都比 HashMap 表现得好。它还支持同步并发读写，也拥有支持非线程安全的合成操作的方法。如果部署环境是 Java 5，可以采用 ConcurrentHashMap。\n There are several other kinds of classes added to support advanced concurrency design. Here are a few examples:\n 还有几个支持高级并发设计的类。以下是其中一小部分，如表 13-1 所示。\n  Recommendation: Review the classes available to you. In the case of Java, become familiar with java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks.\n 建议：检读可用的类。对于 Java，掌握 java.util.concurrent、 java.util.concurrent.atomic 和 java.util.concurrent.locks。\n 13.5 KNOW YOUR EXECUTION MODELS 了解执行模型 #  There are several different ways to partition behavior in a concurrent application. To discuss them we need to understand some basic definitions.\n 有几种在并发应用中切分行为的途径。要讨论这些途径，我们需要理解一些基础定义，如表 13-2 所示。\n  Given these definitions, we can now discuss the various execution models used in concurrent programming.\n 有了这些定义，我们就能讨论在并发编程中用到的几种执行模型了。\n 13.5.1 Producer-Consumer 生产者-消费者模型 #  One or more producer threads create some work and place it in a buffer or queue. One or more consumer threads acquire that work from the queue and complete it. The queue between the producers and consumers is a bound resource. This means producers must wait for free space in the queue before writing and consumers must wait until there is something in the queue to consume. Coordination between the producers and consumers via the queue involves producers and consumers signaling each other. The producers write to the queue and signal that the queue is no longer empty. Consumers read from the queue and signal that the queue is no longer full. Both potentially wait to be notified when they can continue.\n 一个或多个生产者线程创建某些工作，并置于缓存或队列中。一个或多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。\n 13.5.2 Readers-Writers 读者-作者模型 #  When you have a shared resource that primarily serves as a source of information for readers, but which is occasionally updated by writers, throughput is an issue. Emphasizing throughput can cause starvation and the accumulation of stale information. Allowing updates can impact throughput. Coordinating readers so they do not read something a writer is updating and vice versa is a tough balancing act. Writers tend to block many readers for a long period of time, thus causing throughput issues.\n 当存在一个主要为读者线程提供信息源，但只偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的累积。更新会影响吞吐量。协调读者线程，不去读作者线程正在更新的信息（反之亦然），这是一种辛苦的平衡工作。作者线程倾向于长期锁定许多读者线程，从而导致吞吐量问题。\n The challenge is to balance the needs of both readers and writers to satisfy correct operation, provide reasonable throughput and avoiding starvation. A simple strategy makes writers wait until there are no readers before allowing the writer to perform an update. If there are continuous readers, however, the writers will be starved. On the other hand, if there are frequent writers and they are given priority, throughput will suffer. Finding that balance and avoiding concurrent update issues is what the problem addresses.\n 挑战之处在于平衡读者线程和作者线程的需求，实现正确操作，提供合理的吞吐量，避免线程饥饿。\n 13.5.3 Dining Philosophers 宴席哲学家 #  Imagine a number of philosophers sitting around a circular table. A fork is placed to the left of each philosopher. There is a big bowl of spaghetti in the center of the table. The philosophers spend their time thinking unless they get hungry. Once hungry, they pick up the forks on either side of them and eat. A philosopher cannot eat unless he is holding two forks. If the philosopher to his right or left is already using one of the forks he needs, he must wait until that philosopher finishes eating and puts the forks back down. Once a philosopher eats, he puts both his forks back down on the table and waits until he is hungry again.\n 想象一下，一群哲学家环坐在圆桌旁。每个哲学家的左手边放了一把叉子。桌面中央摆着一大碗意大利面。哲学家们思索良久，直至肚子饿了。每个人都要拿起叉子吃饭。但除非手上有两把叉子，否则就没法进食。如果左边或右边的哲学家已经取用一把叉子，中间这位就得等到别人吃完、放回叉子。每位哲学家吃完后，就将两把叉子放回桌面，直到肚子再饿。\n Replace philosophers with threads and forks with resources and this problem is similar to many enterprise applications in which processes compete for resources. Unless carefully designed, systems that compete in this way can experience deadlock, livelock, throughput, and efficiency degradation.\n 用线程代替哲学家，用资源代替叉子，就变成了许多企业级应用中进程竞争资源的情形。如果没有用心设计，这种竞争式系统就会遭遇死锁、活锁、吞吐量和效率降低等问题。\n Most concurrent problems you will likely encounter will be some variation of these three problems. Study these algorithms and write solutions using them on your own so that when you come across concurrent problems, you’ll be more prepared to solve the problem.\n 你可能遇到的并发问题，大多数都是这三个问题的变种。请研究并使用这些算法，这样，遇到并发问题时你就能有解决问题的准备了。\n Recommendation: Learn these basic algorithms and understand their solutions.\n 建议：学习这些基础算法，理解其解决方案。\n 13.6 BEWARE DEPENDENCIES BETWEEN SYNCHRONIZED METHODS 警惕同步方法之间的依赖 #  Dependencies between synchronized methods cause subtle bugs in concurrent code. The Java language has the notion of synchronized, which protects an individual method. However, if there is more than one synchronized method on the same shared class, then your system may be written incorrectly.12\n 同步方法之间的依赖会导致并发代码中的狡猾缺陷。Java 语言有 synchronized 概念，可以用来保护单个方法。然而，如果在同一共享类中有多个同步方法，系统就可能写得不太正确了。\n Recommendation: Avoid using more than one method on a shared object.\n 建议：避免使用一个共享对象的多个方法。\n There will be times when you must use more than one method on a shared object. When this is the case, there are three ways to make the code correct:\n 有时必须使用一个共享对象的多个方法。在这种情况发生时，有 3 种写对代码的手段：\n  Client-Based Locking—Have the client lock the server before calling the first method and make sure the lock’s extent includes code calling the last method. Server-Based Locking—Within the server create a method that locks the server, calls all the methods, and then unlocks. Have the client call the new method. Adapted Server—create an intermediary that performs the locking. This is an example of server-based locking, where the original server cannot be changed.     基于客户端的锁定——客户端代码在调用第一个方法前锁定服务端，确保锁的范围覆盖了调用最后一个方法的代码； 基于服务端的锁定——在服务端内创建锁定服务端的方法，调用所有方法，然后解锁。让客户端代码调用新方法； 适配服务端——创建执行锁定的中间层。这是一种基于服务端的锁定的例子，但不修改原始服务端代码。   13.7 KEEP SYNCHRONIZED SECTIONS SMALL 保持同步区域微小 #  The synchronized keyword introduces a lock. All sections of code guarded by the same lock are guaranteed to have only one thread executing through them at any given time. Locks are expensive because they create delays and add overhead. So we don’t want to litter our code with synchronized statements. On the other hand, critical sections13 must be guarded. So we want to design our code with as few critical sections as possible.\n 关键字 synchronized 制造了锁。同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行。锁是昂贵的，因为它们带来了延迟和额外开销。所以我们不愿将代码扔给 synchronized 语句了事。另一方面，临界区应该被保护起来。所以，应该尽可能少地设计临界区。\n Some naive programmers try to achieve this by making their critical sections very large. However, extending synchronization beyond the minimal critical section increases contention and degrades performance.\n 有些天真的程序员想通过扩大临界区面积达到这个目的。然而，将同步延展到最小临界区范围之外，会增加资源争用、降低执行效率。\n Recommendation: Keep your synchronized sections as small as possible.\n 建议：尽可能减小同步区域。\n 13.8 WRITING CORRECT SHUT-DOWN CODE IS HARD 很难编写正确的关闭代码 #  Writing a system that is meant to stay live and run forever is different from writing something that works for awhile and then shuts down gracefully.\n 编写永远运行的系统，与编写运行一段时间后平静地关闭的系统是两码事。\n Graceful shutdown can be hard to get correct. Common problems involve deadlock,15 with threads waiting for a signal to continue that never comes.\n 平静关闭很难做到。常见问题与死锁有关，线程一直等待永远不会到来的信号。\n For example, imagine a system with a parent thread that spawns several child threads and then waits for them all to finish before it releases its resources and shuts down. What if one of the spawned threads is deadlocked? The parent will wait forever, and the system will never shut down.\n 例如，想象一个系统中有个父线程分裂出数个子线程，父线程等待所有子线程结束，然后释放资源并关闭。如果其中一个子线程发生死锁会怎样？父线程将一直等待下去，而系统就永远不能关闭。\n Or consider a similar system that has been instructed to shut down. The parent tells all the spawned children to abandon their tasks and finish. But what if two of the children were operating as a producer/consumer pair. Suppose the producer receives the signal from the parent and quickly shuts down. The consumer might have been expecting a message from the producer and be blocked in a state where it cannot receive the shutdown signal. It could get stuck waiting for the producer and never finish, preventing the parent from finishing as well.\n 或者，考虑一个被指示关闭的类似系统。父线程告知全体子线程放弃任务并结束。如果其中两个子线程正以生产者/消费者模型操作会怎样呢？假设生产者线程从父线程处接收到信号，并迅速关闭。消费者线程可能还在等待生产者线程发来消息，于是就被锁定在无法接收到关闭信号的状态中。它会死等生产者线程，永不结束，从而导致父线程也无法结束。\n Situations like this are not at all uncommon. So if you must write concurrent code that involves shutting down gracefully, expect to spend much of your time getting the shutdown to happen correctly.\n 这类情形并非那么不常见。如果你要编写涉及平静关闭的并发代码，请多预留一些时间搞对关闭过程。\n Recommendation: Think about shut-down early and get it working early. It’s going to take longer than you expect. Review existing algorithms because this is probably harder than you think.\n 建议：尽早考虑关闭问题，尽早令其工作正常。这会花费比你预期更多的时间。检视既有算法，因为这可能会比想象中难得多。\n 13.9 TESTING THREADED CODE 测试线程代码 #  Proving that code is correct is impractical. Testing does not guarantee correctness. However, good testing can minimize risk. This is all true in a single-threaded solution. As soon as there are two or more threads using the same code and working with shared data, things get substantially more complex.\n 证明代码的正确性不切实际。测试并不能确保正确性。然而，好的测试却能尽量降低风险。这对于所有单线程解决方案都是对的。当有两个或多个线程使用同一代码段和共享数据，事情就变得非常复杂了。\n Recommendation: Write tests that have the potential to expose problems and then run them frequently, with different programatic configurations and system configurations and load. If tests ever fail, track down the failure. Don’t ignore a failure just because the tests pass on a subsequent run.\n 建议：编写有潜力曝露问题的测试，在不同的编程配置、系统配置和负载条件下频繁运行。如果测试失败，跟踪错误。别因为后来测试通过了后来的运行就忽略失败。\n That is a whole lot to take into consideration. Here are a few more fine-grained recommendations:\n 有一大堆问题要考虑。下面是一些精练的建议：\n  Treat spurious failures as candidate threading issues. Get your nonthreaded code working first. Make your threaded code pluggable. Make your threaded code tunable. Run with more threads than processors. Run on different platforms. Instrument your code to try and force failures.     将伪失败看作可能的线程问题； 先使非线程代码可工作； 编写可插拔的线程代码； 编写可调整的线程代码； 运行多于处理器数量的线程； 在不同平台上运行； 调整代码并强迫错误发生。   13.9.1 Treat Spurious Failures as Candidate Threading Issues 将伪失败看作可能的线程问题 #  Threaded code causes things to fail that “simply cannot fail.” Most developers do not have an intuitive feel for how threading interacts with other code (authors included). Bugs in threaded code might exhibit their symptoms once in a thousand, or a million, executions. Attempts to repeat the systems can be frustratingly. This often leads developers to write off the failure as a cosmic ray, a hardware glitch, or some other kind of “one-off.” It is best to assume that one-offs do not exist. The longer these “one-offs” are ignored, the more code is built on top of a potentially faulty approach.\n 线程代码导致“不可能失败的”失败。多数开发者缺乏有关线程如何与其他代码（可能由其他作者编写）互动的直觉。线程代码中的缺陷可能在一千或一百万次执行中才会显现一次。重复执行想要复现问题令人沮丧。所以开发者常常会将失败归咎于宇宙射线、硬件错误或其他“偶发事件”。最好假设这种偶发事件根本不存在。“偶发事件”被忽略得越久，代码就越有可能搭建于不完善的基础之上。\n Recommendation: Do not ignore system failures as one-offs.\n 建议：不要将系统错误归咎于偶发事件。\n 13.9.2 Get Your Nonthreaded Code Working First 先使非线程代码可工作 #  This may seem obvious, but it doesn’t hurt to reinforce it. Make sure code works outside of its use in threads. Generally, this means creating POJOs that are called by your threads. The POJOs are not thread aware, and can therefore be tested outside of the threaded environment. The more of your system you can place in such POJOs, the better.\n 这看起来太浅显，但强调一下不无益处。确保线程之外的代码可工作。通常，这意味着创建由线程调用的 POJO。POJO 与线程无涉，所以可在线程环境之外测试。能放进 POJO 中的代码越多越好。\n Recommendation: Do not try to chase down nonthreading bugs and threading bugs at the same time. Make sure your code works outside of threads.\n 建议：不要同时追踪非线程缺陷和线程缺陷。确保代码在线程之外可工作。\n 13.9.3 Make Your Threaded Code Pluggable 编写可插拔的线程代码 #  Write the concurrency-supporting code such that it can be run in several configurations:\n 编写可在数个配置环境下运行的线程代码：\n  One thread, several threads, varied as it executes Threaded code interacts with something that can be both real or a test double. Execute with test doubles that run quickly, slowly, variable. Configure tests so they can run for a number of iterations.    单线程与多个线程在执行时不同的情况； 线程代码与实物或测试替身互动； 用运行快速、缓慢和有变动的测试替身执行； 将测试配置为能运行一定数量的迭代。   Recommendation: Make your thread-based code especially pluggable so that you can run it in various configurations.\n 建议：编写可插拔的线程代码，这样就能在不同的配置环境下运行。\n 13.9.4 Make Your Threaded Code Tunable 编写可调整的线程代码 #  Getting the right balance of threads typically requires trial an error. Early on, find ways to time the performance of your system under different configurations. Allow the number of threads to be easily tuned. Consider allowing it to change while the system is running. Consider allowing self-tuning based on throughput and system utilization.\n 要获得良好的线程平衡，常常需要试错。一开始，在不同的配置环境下监测系统性能。要允许线程数量可调整。在系统运行时允许线程发生变动。允许线程依据吞吐量和系统使用率自我调整。\n 13.9.5 Run with More Threads Than Processors 运行多于处理器数量的线程 #  Things happen when the system switches between tasks. To encourage task swapping, run with more threads than processors or cores. The more frequently your tasks swap, the more likely you’ll encounter code that is missing a critical section or causes deadlock.\n 系统在切换任务时会发生一些事。为了促使任务交换的发生，运行多于处理器或处理器核心数量的线程。任务交换越频繁，越有可能找到错过临界区或导致死锁的代码。\n 13.9.6 Run on Different Platforms 在不同平台上运行 #  In the middle of 2007 we developed a course on concurrent programming. The course development ensued primarily under OS X. The class was presented using Windows XP running under a VM. Tests written to demonstrate failure conditions did not fail as frequently in an XP environment as they did running on OS X.\n 2007 年，我们做了一套关于并发编程的课程。该课程主要在 OS X 下开发，在运行于虚拟机的 Windows XP 上展示。用于演示的测试失败条件，在 OS X 上要比在 XP 上失败得更频繁。\n In all cases the code under test was known to be incorrect. This just reinforced the fact that different operating systems have different threading policies, each of which impacts the code’s execution. Multithreaded code behaves differently in different environments.16 You should run your tests in every potential deployment environment.\n 被测试的代码已知是不正确的。这正强调了不同操作系统有着不同线程策略的事实，不同的线程策略影响了代码的执行。在不同环境中，多线程代码的行为也不一样。应该在所有可能部署的环境中运行测试。\n Recommendation: Run your threaded code on all target platforms early and often.\n 建议：尽早并经常地在所有目标平台上运行线程代码。\n 13.9.7 Instrument Your Code to Try and Force Failures 装置试错代码 #  It is normal for flaws in concurrent code to hide. Simple tests often don’t expose them. Indeed, they often hide during normal processing. They might show up once every few hours, or days, or weeks!\n 并发代码中藏有缺陷，这并不罕见。简单的测试往往无法曝露这些缺陷。实际上，缺陷经常隐藏于一般处理过程中。可能好几个小时、好几天甚至好几个星期才会跳出来一次！\n The reason that threading bugs can be infrequent, sporadic, and hard to repeat, is that only a very few pathways out of the many thousands of possible pathways through a vulnerable section actually fail. So the probability that a failing pathway is taken can be star-tlingly low. This makes detection and debugging very difficult.\n 线程中的缺陷之所以如此不频繁、偶发、难以重现，是因为在几千个穿过脆弱区域的可能路径当中，只有少数路径会真的导致失败。经过会导致失败的路径的可能性惊人地低。所以，侦测与调试也非常之难。\n How might you increase your chances of catching such rare occurrences? You can instrument your code and force it to run in different orderings by adding calls to methods like Object.wait(), Object.sleep(), Object.yield() and Object.priority().\n 怎么才能增加捕捉住如此罕见之物的机会？可以装置代码，增加对 Object.wait( )、Object.sleep( )、Object.yield( )和 Object.priority( )等方法的调用，改变代码执行顺序。\n Each of these methods can affect the order of execution, thereby increasing the odds of detecting a flaw. It’s better when broken code fails as early and as often as possible.\n 这些方法都会影响执行顺序，从而增加了侦测到缺陷的可能性。有问题的代码，最好尽早、尽可能多地通不过测试。\n There are two options for code instrumentation:\n 有两种装置代码的方法：\n  Hand-coded Automated     硬编码； 自动化。   13.9.8 Hand-Coded 硬编码 #  You can insert calls to wait(), sleep(), yield(), and priority() in your code by hand. It might be just the thing to do when you’re testing a particularly thorny piece of code.\n 你可以手工向代码中插入 wait()、sleep()、yield() 和 priority() 的调用。在测试某段棘手的代码时，正当如此操作。\n Here is an example of doing just that:\n 下面是个例子：\n public synchronized String nextUrlOrNull() { if(hasNext()) { String url = urlGenerator.next(); Thread.yield(); // inserted for testing.  updateHasNext(); return url; } return null; } The inserted call to yield() will change the execution pathways taken by the code and possibly cause the code to fail where it did not fail before. If the code does break, it was not because you added a call to yield().17 Rather, your code was broken and this simply made the failure evident.\n 插入对 yield() 的调用，将改变代码的执行路径，由此而可能导致代码在以前未失败过的地方失败。如果代码的确出错，那并非是因为你插入了 yield() 方法调用。代码出错了，这便是失败的原因。\n There are many problems with this approach:\n 这种手法有许多毛病：\n  You have to manually find appropriate places to do this. How do you know where to put the call and what kind of call to use? Leaving such code in a production environment unnecessarily slows the code down. It’s a shotgun approach. You may or may not find flaws. Indeed, the odds aren’t with you.     你得手工找到合适的地方来插入方法调用；你怎么知道在哪里插入调用、插入什么调用？ 不必要地在产品环境中留下这类代码，将拖慢代码执行速度； 这是种无的放矢的手段。你可能找不到缺陷。实际上，这不在你把握之中。   What we need is a way to do this during testing but not in production. We also need to easily mix up configurations between different runs, which results in increased chances of finding errors in the aggregate.\n 我们所需要的，是一种在测试中但不在生产中实现的手段。我们还需要为多次运行轻易地调整配置，从而增加总的发现错误机会。\n Clearly, if we divide our system up into POJOs that know nothing of threading and classes that control the threading, it will be easier to find appropriate places to instrument the code. Moreover, we could create many different test jigs that invoke the POJOs under different regimes of calls to sleep, yield, and so on.\n 无疑，如果将系统分解为对线程及控制线程的类一无所知的 POJO，就能更容易地找到装置代码的位置。而且，还能创建许多个以不同方式调用 sleep、yield 等方法的 POJO 测试。\n 13.9.9 Automated 自动化 #  You could use tools like an Aspect-Oriented Framework, CGLIB, or ASM to programmatically instrument your code. For example, you could use a class with a single method:\n 可以使用 Aspect-Oriented Framework、CGLIB 或 ASM 之类工具通过编程来装置代码。例如，可以使用有单个方法的类：\n public class ThreadJigglePoint { public static void jiggle() { } } You can add calls to this in various places within your code:\n 可以在代码的不同位置调用这个方法：\n public synchronized String nextUrlOrNull() { if(hasNext()) { ThreadJiglePoint.jiggle(); String url = urlGenerator.next(); ThreadJiglePoint.jiggle(); updateHasNext(); ThreadJiglePoint.jiggle(); return url; } return null; } Now you use a simple aspect that randomly selects among doing nothing, sleeping, or yielding.\n 如此，你就得到了一个随机选择无所作为、睡眠或让步的方面。\n Or imagine that the ThreadJigglePoint class has two implementations. The first implements jiggle to do nothing and is used in production. The second generates a random number to choose between sleeping, yielding, or just falling through. If you run your tests a thousand times with random jiggling, you may root out some flaws. If the tests pass, at least you can say you’ve done due diligence. Though a bit simplistic, this could be a reasonable option in lieu of a more sophisticated tool.\n 或者，想象 ThreadJigglePoint 类有两种实现。第一种实现 jiggle 什么都不做，在生产环境中使用。第二种实现生成一个随机数，在睡眠、让步或径直执行间做选择。如果上千次地做这种随机测试，大概就能找到一些缺陷的根源。假如测试都通过了，至少你可以说自己已谨慎对待。这种方法看似有点过于简单，但确是替代复杂工具的一种可选方案。\n There is a tool called ConTest,18 developed by IBM that does something similar, but it does so with quite a bit more sophistication.\n 有一种叫做 ConTest 的工具，由 IBM 开发，能做类似的事情，但做法却稍微复杂些。\n The point is to jiggle the code so that threads run in different orderings at different times. The combination of well-written tests and jiggling can dramatically increase the chance finding errors.\n 要点是让代码“异动”，从而使线程以不同次序执行。编写良好的测试与“异动”相组合，能有效地增加发现错误的机会。\n Recommendation: Use jiggling strategies to ferret out errors.\n 建议：使用异动策略搜出错误。\n 13.10 CONCLUSION 小结 #  Concurrent code is difficult to get right. Code that is simple to follow can become nightmarish when multiple threads and shared data get into the mix. If you are faced with writing concurrent code, you need to write clean code with rigor or else face subtle and infrequent failures.\n 并发代码很难写正确。加入多线程和共享数据后，简单的代码也会变成噩梦。要编写并发代码，就得严格地编写整洁的代码，否则将面临微细和不频繁发生的失败。\n First and foremost, follow the Single Responsibility Principle. Break your system into POJOs that separate thread-aware code from thread-ignorant code. Make sure when you are testing your thread-aware code, you are only testing it and nothing else. This suggests that your thread-aware code should be small and focused.\n 第一要诀是遵循单一权责原则。将系统切分为分离了线程相关代码和线程无关代码的 POJO。确保在测试线程相关代码时只是在测试，没有做其他事情。线程相关代码应该保持短小和目的集中。\n Know the possible sources of concurrency issues: multiple threads operating on shared data, or using a common resource pool. Boundary cases, such as shutting down cleanly or finishing the iteration of a loop, can be especially thorny.\n 了解并发问题的可能原因：对共享数据的多线程操作，或使用了公共资源池。类似平静关闭或停止循环之类边界情况尤其棘手。\n Learn your library and know the fundamental algorithms. Understand how some of the features offered by the library support solving problems similar to the fundamental algorithms.\n 学习类库，了解基本算法。理解类库提供的与基础算法类似的解决问题的特性。\n Learn how to find regions of code that must be locked and lock them. Do not lock regions of code that do not need to be locked. Avoid calling one locked section from another. This requires a deep understanding of whether something is or is not shared. Keep the amount of shared objects and the scope of the sharing as narrow as possible. Change designs of the objects with shared data to accommodate clients rather than forcing clients to manage shared state.\n 学习如何找到必须锁定的代码区域并锁定之。不要锁定不必锁定的代码。避免从锁定区域中调用其他锁定区域。这需要深刻理解某物是否已共享。尽可能减少共享对象和共享范围。修改对象的设计，向客户代码提供共享数据，而不是迫使客户代码管理共享状态。\n Issues will crop up. The ones that do not crop up early are often written off as a onetime occurrence. These so-called one-offs typically only happen under load or at seemingly random times. Therefore, you need to be able to run your thread-related code in many configurations on many platforms repeatedly and continuously. Testability, which comes naturally from following the Three Laws of TDD, implies some level of plug-ability, which offers the support necessary to run code in a wider range of configurations.\n 问题会跳出来。那种在早期没跳出来的问题往往是偶发的。这种所谓偶发问题，通常仅在高负载下出现或者偶然出现。所以，你要能在不同平台上、以不同配置持续重复运行线程代码。跟随 TDD 三要则而来的可测试性意味着某种程度的可插拔性，从而提供了在大量不同配置下运行代码的必要支持。\n You will greatly improve your chances of finding erroneous code if you take the time to instrument your code. You can either do so by hand or using some kind of automated technology. Invest in this early. You want to be running your thread-based code as long as possible before you put it into production.\n 如果花点时间装置代码，就能极大地提升发现错误代码的机会。可以手工做，也可以使用某种自动化技术。尽早这么做。在将线程代码投入生产环境前，就要尽可能多地运行它。\n If you take a clean approach, your chances of getting it right increase drastically.\n 只要采用了整洁的做法，做对的可能性就有翻天覆地的提高。\n "});index.add({'id':202,'href':'/docs/Clean-Code/14.-Successive-Refinement/ch14/','title':"Ch14",'section':"Go语言圣经",'content':"第 14 章 Successive Refinement 逐步改进 #  Case Study of a Command-Line Argument Parser\n This chapter is a case study in successive refinement. You will see a module that started well but did not scale. Then you will see how the module was refactored and cleaned.\n 本章研究一个逐步改进的案例。你将看到一个开始还不错，规模扩大后即出问题的模块。你还将看到这个模块是如何被重构得整洁起来的。\n Most of us have had to parse command-line arguments from time to time. If we don’t have a convenient utility, then we simply walk the array of strings that is passed into the main function. There are several good utilities available from various sources, but none of them do exactly what I want. So, of course, I decided to write my own. I call it: Args.\n 我们中的大多数人都会遇到解析命令行参数的情况。如果没有就手的工具，就得遍历传入 main 函数的字符串数组。有一些不同来源的好工具，但没有一个是最符合要求的。所以，我当然要自己写一个。我把它叫做 Args。\n Args is very simple to use. You simply construct the Args class with the input arguments and a format string, and then query the Args instance for the values of the arguments. Consider the following simple example:\n Args 非常易于使用。你只要简单地用输入参数和格式化字符串构造 Args 类，再向 Args 实体询问参数值即可。看看下面的简单例子：\n Listing 14-1 Simple use of Args\n 代码清单 14-1 Args 的简单用法\n public static void main(String[] args) { try { Args arg = new Args(“l,p#,d*”, args); boolean logging = arg.getBoolean(’l’); int port = arg.getInt(’p’); String directory = arg.getString(’d’); executeApplication(logging, port, directory); } catch (ArgsException e) { System.out.printf(“Argument error: %s\\n”, e.errorMessage()); } } You can see how simple this is. We just create an instance of the Args class with two parameters. The first parameter is the format, or schema, string: “l,p#,d*.” It defines three command-line arguments. The first, -l, is a boolean argument. The second, -p, is an integer argument. The third, -d, is a string argument. The second parameter to the Args constructor is simply the array of command-line argument passed into main.\n 可以看到这有多简单。我们只是用两个参数创建了 Args 类的一个实体。第一个参数是格式字符串，或范式字符串：l,p#,d*。它定义了三个命令行参数。第一个，-l，是一个布尔值参数。第二个，-p，是一个整数参数。第三个，-d，是一个字符串参数。向 Args 构造器传入的第二个参数就是向 main 传入的命令行参数数组。\n If the constructor returns without throwing an ArgsException, then the incoming command-line was parsed, and the Args instance is ready to be queried. Methods like getBoolean, getInteger, and getString allow us to access the values of the arguments by their names.\n 如果构造器正常返回，没有抛出 ArgsException 异常，则命令行参数已传入，Args 实体随时待命。使用 getBoolean、getInteger 和 getString 等方法，可以用参数名称获得参数值。\n If there is a problem, either in the format string or in the command-line arguments themselves, an ArgsException will be thrown. A convenient description of what went wrong can be retrieved from the errorMessage method of the exception.\n 不管是格式化字符串或命令行参数出现问题，就会抛出一个 ArgsException 异常。可以从该异常的 errorMessage 中获得关于错误的描述。\n 14.1 ARGS IMPLEMENTATION Args 的实现 #  Listing 14-2 is the implementation of the Args class. Please read it very carefully. I worked hard on the style and structure and hope it is worth emulating.\n 代码清单 14-2 是 Args 类的实现。请仔细阅读。我在代码风格和结构上花了大力气，使之值得仿效。\n Listing 14-2 Args.java\n 代码清单 14-2 Args.java\n package com.objectmentor.utilities.args; import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; import java.util.*; public class Args { private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers; private Set\u0026lt;Character\u0026gt; argsFound; private ListIterator\u0026lt;String\u0026gt; currentArgument; public Args(String schema, String[] args) throws ArgsException { marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); argsFound = new HashSet\u0026lt;Character\u0026gt;(); parseSchema(schema); parseArgumentStrings(Arrays.asList(args)); } private void parseSchema(String schema) throws ArgsException { for (String element : schema.split(\u0026#34;,\u0026#34;)) if (element.length() \u0026gt; 0) parseSchemaElement(element.trim()); } private void parseSchemaElement(String element) throws ArgsException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (elementTail.length() == 0) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (elementTail.equals(\u0026#34;*\u0026#34;)) marshalers.put(elementId, new StringArgumentMarshaler()); else if (elementTail.equals(\u0026#34;#\u0026#34;)) marshalers.put(elementId, new IntegerArgumentMarshaler()); else if (elementTail.equals(\u0026#34;##\u0026#34;)) marshalers.put(elementId, new DoubleArgumentMarshaler()); else if (elementTail.equals(\u0026#34;[*]\u0026#34;)) marshalers.put(elementId, new StringArrayArgumentMarshaler()); else throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail); } private void validateSchemaElementId(char elementId) throws ArgsException { if (!Character.isLetter(elementId)) throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null); } private void parseArgumentStrings(List\u0026lt;String\u0026gt; argsList) throws ArgsException { for (currentArgument = argsList.listIterator(); currentArgument.hasNext(); ) { String argString = currentArgument.next(); if (argString.startsWith(\u0026#34;-\u0026#34;)) { parseArgumentCharacters(argString.substring(1)); } else { currentArgument.previous(); break; } } } private void parseArgumentCharacters(String argChars) throws ArgsException { for (int i = 0; i \u0026lt; argChars.length(); i++) parseArgumentCharacter(argChars.charAt(i)); } private void parseArgumentCharacter(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) { throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null); } else { argsFound.add(argChar); try { m.set(currentArgument); } catch (ArgsException e) { e.setErrorArgumentId(argChar); throw e; } } } public boolean has(char arg) { return argsFound.contains(arg); } public int nextArgument() { return currentArgument.nextIndex(); } public boolean getBoolean(char arg) { return BooleanArgumentMarshaler.getValue(marshalers.get(arg)); } public String getString(char arg) { return StringArgumentMarshaler.getValue(marshalers.get(arg)); } public int getInt(char arg) { return IntegerArgumentMarshaler.getValue(marshalers.get(arg)); } public double getDouble(char arg) { return DoubleArgumentMarshaler.getValue(marshalers.get(arg)); } public String[] getStringArray(char arg) { return StringArrayArgumentMarshaler.getValue(marshalers.get(arg)); } } Notice that you can read this code from the top to the bottom without a lot of jumping around or looking ahead. The one thing you may have had to look ahead for is the definition of ArgumentMarshaler, which I left out intentionally. Having read this code carefully, you should understand what the ArgumentMarshaler interface is and what its derivatives do. I’ll show a few of them to you now (Listing 14-3 through Listing 14-6).\n 注意，你可以从上到下阅读这些代码，不用跳来跳去，也不用先看后面的部分。唯一需要先看的是 ArgumentMarshaler 的定义，这部分我有意省略了。仔细看这段代码，你应该能理解 ArgumentMarshaler 接口是什么，其派生类做什么。下面我将向你展示一部分（如代码清单 14-3 ～ 14-6 所示）。\n Listing 14-3 ArgumentMarshaler.java\n 代码清单 14-3 ArgumentMarshaler.java\n public interface ArgumentMarshaler { void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException; } Listing 14-4 BooleanArgumentMarshaler.java\npublic class BooleanArgumentMarshaler implements ArgumentMarshaler { private boolean booleanValue = false; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { booleanValue = true; } public static boolean getValue(ArgumentMarshaler am) { if (am != null \u0026amp;\u0026amp; am instanceof BooleanArgumentMarshaler) return ((BooleanArgumentMarshaler) am).booleanValue; else return false; } } Listing 14-5 StringArgumentMarshaler.java\n 代码清单 14-5 StringArgumentMarshaler.java\n import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; public class StringArgumentMarshaler implements ArgumentMarshaler { private String stringValue = public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { try { stringValue = currentArgument.next(); } catch (NoSuchElementException e) { throw new ArgsException(MISSING_STRING); } } public static String getValue(ArgumentMarshaler am) { if (am != null \u0026amp;\u0026amp; am instanceof StringArgumentMarshaler) return ((StringArgumentMarshaler) am).stringValue; else return \u0026#34;\u0026#34;; } } The other ArgumentMarshaler derivatives simply replicate this pattern for doubles and String arrays and would serve to clutter this chapter. I’ll leave them to you as an exercise.\n ArgumentMarshaler 的其他派生类以同样的模式处理 double 和 String 数组，一一列出反而阻碍行文。你可以练习自己实现它们。\n One other bit of information might be troubling you: the definition of the error code constants. They are in the ArgsException class (Listing 14-7).\n 还有些信息可能会困扰你：错误码常量的定义。这些是在 ArgsException 类（代码清单 14-7）中定义的。\n Listing 14-6 IntegerArgumentMarshaler.java\n 代码清单 14-6 IntegerArgumentMarshaler.java\n import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; public class IntegerArgumentMarshaler implements ArgumentMarshaler { private int intValue = 0; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); intValue = Integer.parseInt(parameter); } catch (NoSuchElementException e) { throw new ArgsException(MISSING_INTEGER); } catch (NumberFormatException e) { throw new ArgsException(INVALID_INTEGER, parameter); } } public static int getValue(ArgumentMarshaler am) { if (am != null \u0026amp;\u0026amp; am instanceof IntegerArgumentMarshaler) return ((IntegerArgumentMarshaler) am).intValue; else return 0; } } Listing 14-7 ArgsException.java\n 代码清单 14-7 ArgsException.java\n import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*; public class ArgsException extends Exception { private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = null; private ErrorCode errorCode = OK; public ArgsException() { } public ArgsException(String message) { super(message); } public ArgsException(ErrorCode errorCode) { this.errorCode = errorCode; } public ArgsException(ErrorCode errorCode, String errorParameter) { this.errorCode = errorCode; this.errorParameter = errorParameter; } public ArgsException(ErrorCode errorCode, char errorArgumentId, String errorParameter) { this.errorCode = errorCode; this.errorParameter = errorParameter; this.errorArgumentId = errorArgumentId; } public char getErrorArgumentId() { return errorArgumentId; } public void setErrorArgumentId(char errorArgumentId) { this.errorArgumentId = errorArgumentId; } public String getErrorParameter() { return errorParameter; } public void setErrorParameter(String errorParameter) { this.errorParameter = errorParameter; } public ErrorCode getErrorCode() { return errorCode; } public void setErrorCode(ErrorCode errorCode) { this.errorCode = errorCode; } public String errorMessage() { switch (errorCode) { case OK: return \u0026#34;TILT: Should not get here.\u0026#34;; case UNEXPECTED_ARGUMENT: return String.format(\u0026#34;Argument -%c unexpected.\u0026#34;, errorArgumentId); case MISSING_STRING: return String.format(\u0026#34;Could not find string parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_INTEGER: return String.format(\u0026#34;Argument -%c expects an integer but was \u0026#39;%s\u0026#39;.\u0026#34;, errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\u0026#34;Could not find integer parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_DOUBLE: return String.format(\u0026#34;Argument -%c expects a double but was \u0026#39;%s\u0026#39;.\u0026#34;, errorArgumentId, errorParameter); case MISSING_DOUBLE: return String.format(\u0026#34;Could not find double parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_ARGUMENT_NAME: return String.format(\u0026#34;\u0026#39;%c\u0026#39; is not a valid argument name.\u0026#34;, errorArgumentId); case INVALID_ARGUMENT_FORMAT: return String.format(\u0026#34;\u0026#39;%s\u0026#39; is not a valid argument format.\u0026#34;, errorParameter); } return \u0026#34;\u0026#34;; } public enum ErrorCode { OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, MISSING_DOUBLE, INVALID_DOUBLE } } It’s remarkable how much code is required to flesh out the details of this simple concept. One of the reasons for this is that we are using a particularly wordy language. Java, being a statically typed language, requires a lot of words in order to satisfy the type system. In a language like Ruby, Python, or Smalltalk, this program is much smaller.1\n 为了充实这么一个简单概念的细节，需要如此多代码，这很值得注意。原因之一是我们使用了 Java 这种唠叨型语言。作为一种静态类型语言，需要大量语句才能满足类型系统的要求。在 Ruby、Python 或 Smalltalk 等语言中，程序会短很多[1]。\n Please read the code over one more time. Pay special attention to the way things are named, the size of the functions, and the formatting of the code. If you are an experienced programmer, you may have some quibbles here and there with various parts of the style or structure. Overall, however, I hope you conclude that this program is nicely written and has a clean structure.\n 请再次阅读这段代码。特别留意命名方式、函数大小和代码格式。如果你是经验丰富的程序员，可能会对风格或结构有着这样或那样的不同观点。不过，希望你认为这段程序总体上编写良好，有着整洁的结构。\n For example, it should be obvious how you would add a new argument type, such as a date argument or a complex number argument, and that such an addition would require a trivial amount of effort. In short, it would simply require a new derivative of Argument-Marshaler, a new getXXX function, and a new case statement in the parseSchemaElement function. There would also probably be a new ArgsException.ErrorCode and a new error message.\n 例如，如何增加新参数类型，如日期或复杂数字参数。其实现手段很清楚，而且只需要花一点点力气即可。简言之，只需要从 ArgumentMarshaler 派生一个新类，写一个新的 getXXX 函数，在 parseSchemaElement 函数中添加一个新的 case 语句。可能还需要添加新的 ArgsException.Errorcode 和新错误信息。\n How Did I Do This?\n 我怎么做的？\n Let me set your mind at rest. I did not simply write this program from beginning to end in its current form. More importantly, I am not expecting you to be able to write clean and elegant programs in one pass. If we have learned anything over the last couple of decades, it is that programming is a craft more than it is a science. To write clean code, you must first write dirty code and then clean it.\n 先放松一下神经。这段程序并非从一开始就写成现在的样子。更重要的是，我也没指望你能够一次过写出整洁、漂亮的程序。如果说我们从过去几十年里面学到什么东西的话，那就是编程是一种技艺甚于科学的东西。要编写整洁代码，必须先写肮脏代码，然后再清理它。\n This should not be a surprise to you. We learned this truth in grade school when our teachers tried (usually in vain) to get us to write rough drafts of our compositions. The process, they told us, was that we should write a rough draft, then a second draft, then several subsequent drafts until we had our final version. Writing clean compositions, they tried to tell us, is a matter of successive refinement.\n 你应该不会对此感到惊讶。我们在小学就学过这条真理了。那时，老师（通常是徒劳地）努力让我们写作文草稿。他们告诉我们，我们应该先写草稿，再写二稿，一次又一次地草撰，直至写出终稿。他们尽力告诉我们，写出好作文是一个逐步改进的过程。\n Most freshman programmers (like most grade-schoolers) don’t follow this advice particularly well. They believe that the primary goal is to get the program working. Once it’s “working,” they move on to the next task, leaving the “working” program in whatever state they finally got it to “work.” Most seasoned programmers know that this is professional suicide.\n 多数新手程序员（就像多数小学生一样）没有特别认真地遵循这个建议。他们相信，首要任务是写出能工作的程序。只要程序“能工作”，就转移到下一个任务上，而那个“能工作”的程序就留在了最后那个所谓“能工作”的状态。多数老手程序员都知道，这是一种自毁行为。\n 4.2 ARGS: THE ROUGH DRAFT Args：草稿 #  Listing 14-8 shows an earlier version of the Args class. It “works.” And it’s messy.\n 代码清单 14-8 展示了 Args 类的一个早期版本。它“能工作”，但却很烂。\n Listing 14-8 Args.java (first draft)\n 代码清单 14-8 Args.java（初稿）\n import java.text.ParseException; import java.util.*; public class Args { private String schema; private String[] args; private boolean valid = true; private Set\u0026lt;Character\u0026gt; unexpectedArguments = new TreeSet\u0026lt;Character\u0026gt;(); private Map\u0026lt;Character, Boolean\u0026gt; booleanArgs = new HashMap \u0026lt;Character, Boolean\u0026gt;(); private Map\u0026lt;Character, String\u0026gt; stringArgs = new HashMap \u0026lt;Character, String\u0026gt;(); private Map\u0026lt;Character, Integer\u0026gt; intArgs = new HashMap\u0026lt;Character, Integer\u0026gt;(); private Set\u0026lt;Character\u0026gt; argsFound = new HashSet\u0026lt;Character\u0026gt;(); private int currentArgument; private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = \u0026#34;TILT\u0026#34;; private ErrorCode errorCode = ErrorCode.OK; private enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT } public Args(String schema, String[] args) throws ParseException { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws ParseException { if (schema.length() == 0 \u0026amp;\u0026amp; args.length == 0) return true; parseSchema(); try { parseArguments(); } catch (ArgsException e) { } return valid; } private boolean parseSchema() throws ParseException { for (String element : schema.split(\u0026#34;,\u0026#34;)) { if (element.length() \u0026gt; 0) { String trimmedElement = element.trim(); parseSchemaElement(trimmedElement); } } return true; } private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (isBooleanSchemaElement(elementTail)) parseBooleanSchemaElement(elementId); else if (isStringSchemaElement(elementTail)) parseStringSchemaElement(elementId); else if (isIntegerSchemaElement(elementTail)) { parseIntegerSchemaElement(elementId); } else { throw new ParseException( String.format(\u0026#34;Argument: %c has invalid format: %s.\u0026#34;, elementId, elementTail), 0); } } private void validateSchemaElementId(char elementId) throws ParseException { if (!Character.isLetter(elementId)) { throw new ParseException( \u0026#34;Bad character:\u0026#34; + elementId + \u0026#34;in Args format: \u0026#34; + schema, 0); } } private void parseBooleanSchemaElement(char elementId) { booleanArgs.put(elementId, false); } private void parseIntegerSchemaElement(char elementId) { intArgs.put(elementId, 0); } private void parseStringSchemaElement(char elementId) { stringArgs.put(elementId, \u0026#34;\u0026#34;); } private boolean isStringSchemaElement(String elementTail) { return elementTail.equals(\u0026#34;*\u0026#34;); } private boolean isBooleanSchemaElement(String elementTail) { return elementTail.length() == 0; } private boolean isIntegerSchemaElement(String elementTail) { return elementTail.equals(\u0026#34;#\u0026#34;); } private boolean parseArguments() throws ArgsException { for (currentArgument = 0; currentArgument \u0026lt; args.length; currentArgument++) { String arg = args[currentArgument]; parseArgument(arg); } return true; } private void parseArgument(String arg) throws ArgsException { if (arg.startsWith(\u0026#34;-\u0026#34;)) parseElements(arg); } private void parseElements(String arg) throws ArgsException { for (int i = 1; i \u0026lt; arg.length(); i++) parseElement(arg.charAt(i)); } private void parseElement(char argChar) throws ArgsException { if (setArgument(argChar)) argsFound.add(argChar); else { unexpectedArguments.add(argChar); errorCode = ErrorCode.UNEXPECTED_ARGUMENT; valid = false; } } private boolean setArgument(char argChar) throws ArgsException { if (isBooleanArg(argChar)) setBooleanArg(argChar, true); else if (isStringArg(argChar)) setStringArg(argChar); else if (isIntArg(argChar)) setIntArg(argChar); else return false; return true; } private boolean isIntArg(char argChar) { return intArgs.containsKey(argChar); } private void setIntArg(char argChar) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; intArgs.put(argChar, new Integer(parameter)); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (NumberFormatException e) { valid = false; errorArgumentId = argChar; errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } private void setStringArg(char argChar) throws ArgsException { currentArgument++; try { stringArgs.put(argChar, args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } private boolean isStringArg(char argChar) { return stringArgs.containsKey(argChar); } private void setBooleanArg(char argChar, boolean value) { booleanArgs.put(argChar, value); } private boolean isBooleanArg(char argChar) { return booleanArgs.containsKey(argChar); } public int cardinality() { return argsFound.size(); } public String usage() { if (schema.length() \u0026gt; 0) return \u0026#34;-[\u0026#34; + schema + \u0026#34;]\u0026#34;; else return \u0026#34;\u0026#34;; } public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(\u0026#34;TILT: Should not get here.\u0026#34;); case UNEXPECTED_ARGUMENT: return unexpectedArgumentMessage(); case MISSING_STRING: return String.format(\u0026#34;Could not find string parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_INTEGER: return String.format(\u0026#34;Argument -%c expects an integer but was \u0026#39;%s\u0026#39;.\u0026#34;, errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\u0026#34;Could not find integer parameter for -%c.\u0026#34;, errorArgumentId); } return \u0026#34;\u0026#34;; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(\u0026#34;Argument(s) -\u0026#34;); for (char c : unexpectedArguments) { message.append(c); } message.append(\u0026#34; unexpected.\u0026#34;); return message.toString(); } private boolean falseIfNull(Boolean b) { return b != null \u0026amp;\u0026amp; b; } private int zeroIfNull(Integer i) { return i == null ? 0 : i; } private String blankIfNull(String s) { return s == null ? \u0026#34;\u0026#34; : s; } public String getString(char arg) { return blankIfNull(stringArgs.get(arg)); } public int getInt(char arg) { return zeroIfNull(intArgs.get(arg)); } public boolean getBoolean(char arg) { return falseIfNull(booleanArgs.get(arg)); } public boolean has(char arg) { return argsFound.contains(arg); } public boolean isValid() { return valid; } private class ArgsException extends Exception { } } I hope your initial reaction to this mass of code is “I’m certainly glad he didn’t leave it like that!” If you feel like this, then remember that’s how other people are going to feel about code that you leave in rough-draft form.\n 希望你看到这段乱七八糟的代码时，第一反应是“他没就此罢手，真令人高兴！”如果你这么想，不如想想其他人对你留置在草稿形态的代码的想法吧。\n Actually “rough draft” is probably the kindest thing you can say about this code. It’s clearly a work in progress. The sheer number of instance variables is daunting. The odd strings like “TILT,” the HashSets and TreeSets, and the try-catch-catch blocks all add up to a festering pile.\n 实际上，“草稿”大概会是你对这段代码的最高评价。它显然还需打磨。实体变量的数量多到吓人。诸如 TILT 之类奇怪的字符串，HashSet 和 TreeSets，还有那些 try-catch-catch 代码块，组成了一个烂摊子。\n I had not wanted to write a festering pile. Indeed, I was trying to keep things reasonably well organized. You can probably tell that from my choice of function and variable names and the fact that there is a crude structure to the program. But, clearly, I had let the problem get away from me.\n 我不想写出一个烂摊子。我也一直想保持一切有序。从函数和变量命名，以及程序的粗略架构中，你可以看出这一点。不过，显然我没能做到。\n The mess built gradually. Earlier versions had not been nearly so nasty. For example, Listing 14-9 shows an earlier version in which only Boolean arguments were working.\n 混乱是逐渐产生的。更早的版本并不如此肮脏。例如，代码清单 14-9 展示了一个早期版本代码，那时只支持 Boolean 参数。\n Listing 14-9 Args.java (Boolean only)\n 代码清单 14-9 Args.java（只支持 Boolean）\n package com.objectmentor.utilities.getopts; import java.util.*; public class Args { private String schema; private String[] args; private boolean valid; private Set\u0026lt;Character\u0026gt; unexpectedArguments = new TreeSet\u0026lt;Character\u0026gt;(); private Map\u0026lt;Character, Boolean\u0026gt; booleanArgs = new HashMap\u0026lt;Character, Boolean\u0026gt;(); private int numberOfArguments = 0; public Args(String schema, String[] args) { this.schema = schema; this.args = args; valid = parse(); } public boolean isValid() { return valid; } private boolean parse() { if (schema.length() == 0 \u0026amp;\u0026amp; args.length == 0) return true; parseSchema(); parseArguments(); return unexpectedArguments.size() == 0; } private boolean parseSchema() { for (String element : schema.split(\u0026#34;,\u0026#34;)) { parseSchemaElement(element); } return true; } private void parseSchemaElement(String element) { if (element.length() == 1) { parseBooleanSchemaElement(element); } } private void parseBooleanSchemaElement(String element) { char c = element.charAt(0); if (Character.isLetter(c)) { booleanArgs.put(c, false); } } private boolean parseArguments() { for (String arg : args) parseArgument(arg); return true; } private void parseArgument(String arg) { if (arg.startsWith(\u0026#34;-\u0026#34;)) parseElements(arg); } private void parseElements(String arg) { for (int i = 1; i \u0026lt; arg.length(); i++) parseElement(arg.charAt(i)); } private void parseElement(char argChar) { if (isBoolean(argChar)) { numberOfArguments++; setBooleanArg(argChar, true); } else unexpectedArguments.add(argChar); } private void setBooleanArg(char argChar, boolean value) { booleanArgs.put(argChar, value); } private boolean isBoolean(char argChar) { return booleanArgs.containsKey(argChar); } public int cardinality() { return numberOfArguments; } public String usage() { if (schema.length() \u0026gt; 0) return \u0026#34;-[\u0026#34; + schema + \u0026#34;]\u0026#34;; else return \u0026#34;\u0026#34;; } public String errorMessage() { if (unexpectedArguments.size() \u0026gt; 0) { return unexpectedArgumentMessage(); } else return \u0026#34;\u0026#34;; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(\u0026#34;Argument(s) -\u0026#34;); for (char c : unexpectedArguments) { message.append(c); } message.append(\u0026#34; unexpected.\u0026#34;); return message.toString(); } public boolean getBoolean(char arg) { return booleanArgs.get(arg); } } Although you can find plenty to complain about in this code, it’s really not that bad. It’s compact and simple and easy to understand. However, within this code it is easy to see the seeds of the later festering pile. It’s quite clear how this grew into the latter mess.\n 尽管你可能对这段代码很不满意，其实它并非如此之烂。它精练、简单，易于理解。然而，在这段代码中很容易找到后面烂摊子的根源。很清楚能看到小问题如何变成大混乱的。\n Notice that the latter mess has only two more argument types than this: String and integer. The addition of just two more argument types had a massively negative impact on the code. It converted it from something that would have been reasonably maintainable into something that I would expect to become riddled with bugs and warts.\n 注意，后来的混乱代码只比这个版本多支持两种参数类型：String 和 integer。只增加两种参数类型支持，就对代码产生了如此巨大的负面影响。它从某种可维护之物变成了满是缺陷的东西。\n I added the two argument types incrementally. First, I added the String argument, which yielded this:\n 我逐步添加了对这两种参数类型的支持。首先，我添加对 String 参数的支持，就像这样：\n Listing 14-10 Args.java (Boolean and String)\n 代码清单 14-10 Args.java（Boolean 和 String）\n package com.objectmentor.utilities.getopts; import java.text.ParseException; import java.util.*; public class Args { private String schema; private String[] args; private boolean valid = true; private Set\u0026lt;Character\u0026gt; unexpectedArguments = new TreeSet\u0026lt;Character\u0026gt;(); private Map\u0026lt;Character, Boolean\u0026gt; booleanArgs = new HashMap\u0026lt;Character, Boolean\u0026gt;(); private Map\u0026lt;Character, String\u0026gt; stringArgs = new HashMap\u0026lt;Character, String\u0026gt;(); private Set\u0026lt;Character\u0026gt; argsFound = new HashSet\u0026lt;Character\u0026gt;(); private int currentArgument; private char errorArgument = \u0026#39;\\0\u0026#39;; enum ErrorCode { OK, MISSING_STRING } private ErrorCode errorCode = ErrorCode.OK; public Args(String schema, String[] args) throws ParseException { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws ParseException { if (schema.length() == 0 \u0026amp;\u0026amp; args.length == 0) return true; parseSchema(); parseArguments(); return valid; } private boolean parseSchema() throws ParseException { for (String element : schema.split(\u0026#34;,\u0026#34;)) { if (element.length() \u0026gt; 0) { String trimmedElement = element.trim(); parseSchemaElement(trimmedElement); } } return true; } private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (isBooleanSchemaElement(elementTail)) parseBooleanSchemaElement(elementId); else if (isStringSchemaElement(elementTail)) parseStringSchemaElement(elementId); } private void validateSchemaElementId(char elementId) throws ParseException { if (!Character.isLetter(elementId)) { throw new ParseException( \u0026#34;Bad character:\u0026#34; + elementId + \u0026#34;in Args format: \u0026#34; + schema, 0); } } private void parseStringSchemaElement(char elementId) { stringArgs.put(elementId, \u0026#34; \u0026#34;); } private boolean isStringSchemaElement(String elementTail) { return elementTail.equals(\u0026#34;*\u0026#34;); } private boolean isBooleanSchemaElement(String elementTail) { return elementTail.length() == 0; } private void parseBooleanSchemaElement(char elementId) { booleanArgs.put(elementId, false); } private boolean parseArguments() { for (currentArgument = 0; currentArgument \u0026lt; args.length; currentArgument++) { String arg = args[currentArgument]; parseArgument(arg); } return true; } private void parseArgument(String arg) { if (arg.startsWith(\u0026#34;-\u0026#34;)) parseElements(arg); } private void parseElements(String arg) { for (int i = 1; i \u0026lt; arg.length(); i++) parseElement(arg.charAt(i)); } private void parseElement(char argChar) { if (setArgument(argChar)) argsFound.add(argChar); else { unexpectedArguments.add(argChar); valid = false; } } private boolean setArgument(char argChar) { boolean set = true; if (isBoolean(argChar)) setBooleanArg(argChar, true); else if (isString(argChar)) setStringArg(argChar, \u0026#34; \u0026#34;); else set = false; return set; } private void setStringArg(char argChar, String s) { currentArgument++; try { stringArgs.put(argChar, args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgument = argChar; errorCode = ErrorCode.MISSING_STRING; } } private boolean isString(char argChar) { return stringArgs.containsKey(argChar); } private void setBooleanArg(char argChar, boolean value) { booleanArgs.put(argChar, value); } private boolean isBoolean(char argChar) { return booleanArgs.containsKey(argChar); } public int cardinality() { return argsFound.size(); } public String usage() { if (schema.length() \u0026gt; 0) return \u0026#34;-[\u0026#34; + schema + \u0026#34;]\u0026#34;; else return \u0026#34; \u0026#34;; } public String errorMessage() throws Exception { if (unexpectedArguments.size() \u0026gt; 0) { return unexpectedArgumentMessage(); } else switch (errorCode) { case MISSING_STRING: return String.format(\u0026#34;Could not find string parameter for -%c.\u0026#34;, errorArgument); case OK: throw new Exception(\u0026#34;TILT: Should not get here.\u0026#34;); } return \u0026#34; \u0026#34;; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(\u0026#34;Argument(s) -\u0026#34;); for (char c : unexpectedArguments) { message.append(c); } message.append(\u0026#34; unexpected.\u0026#34;); return message.toString(); } public boolean getBoolean(char arg) { return falseIfNull(booleanArgs.get(arg)); } private boolean falseIfNull(Boolean b) { return b == null ? false : b; } public String getString(char arg) { return blankIfNull(stringArgs.get(arg)); } private String blankIfNull(String s) { return s == null ? \u0026#34; \u0026#34; : s; } public boolean has(char arg) { return argsFound.contains(arg); } public boolean isValid() { return valid; } } You can see that this is starting to get out of hand. It’s still not horrible, but the mess is certainly starting to grow. It’s a pile, but it’s not festering quite yet. It took the addition of the integer argument type to get this pile really fermenting and festering.\n 你可以看到，代码开始失去控制。还算不上可怕，但混乱已经开始生长。已经出现了一堆东西，不过还没烂掉。增加对整数参数类型的支持后，那堆东西就真的变质腐烂了。\n 14.2.1 So I Stopped 所以我暂停了 #  I had at least two more argument types to add, and I could tell that they would make things much worse. If I bulldozed my way forward, I could probably get them to work, but I’d leave behind a mess that was too large to fix. If the structure of this code was ever going to be maintainable, now was the time to fix it.\n 还有至少两种参数类型要添加，而且情形一定会更加糟糕。如果一味蛮干，大概也能让它工作，不过就会留下一大堆要调整的混乱。如果希望代码结构一直可维护，现在就是调整的时机了。\n So I stopped adding features and started refactoring. Having just added the String and integer arguments, I knew that each argument type required new code in three major places. First, each argument type required some way to parse its schema element in order to select the HashMap for that type. Next, each argument type needed to be parsed in the command-line strings and converted to its true type. Finally, each argument type needed a getXXX method so that it could be returned to the caller as its true type.\n 所以我暂停添加特性，开始重构。由于刚添加了 String 和 integer 参数，我知道每种参数类型都需要在三个主要位置增加新代码。首先，每种参数类型都要有解析其范式元素、从而为该种类型选择 HashMap 的方法。其次，每种参数类型都需要在命令行字符串中解析，然后再转换为真实类型。最后，每种参数类型都需要一个 getXXX 方法，按照其真实类型向调用者返回参数值。\n Many different types, all with similar methods—that sounds like a class to me. And so the ArgumentMarshaler concept was born.\n 许多种不同类型，类似的方法 ——听起来像是个类。ArgumentMarshaler 的概念就是这样产生的。\n 14.2.2 On Incrementalism 渐进 #  One of the best ways to ruin a program is to make massive changes to its structure in the name of improvement. Some programs never recover from such “improvements.” The problem is that it’s very hard to get the program working the same way it worked before the “improvement.”\n 毁坏程序的最好方法之一就是以改进之名大动其结构。有些程序永远不能从这种所谓“改进”中恢复过来。问题在于，很难让程序以“改进”之前的方式工作。\n ARGS: THE ROUGH DRAFT To avoid this, I use the discipline of Test-Driven Development (TDD). One of the central doctrines of this approach is to keep the system running at all times. In other words, using TDD, I am not allowed to make a change to the system that breaks that system. Every change I make must keep the system working as it worked before.\n 为了避免这种状况发生，我采用了测试驱动开发的规程。这种手法的核心原则之一是保持系统始终能运行。换言之，采用 TDD，我不会允许做出破坏系统的修改。每次修改都必须保证系统能像以前一样工作。\n To achieve this, I need a suite of automated tests that I can run on a whim and that verifies that the behavior of the system is unchanged. For the Args class I had created a suite of unit and acceptance tests while I was building the festering pile. The unit tests were written in Java and administered by JUnit. The acceptance tests were written as wiki pages in FitNesse. I could run these tests any time I wanted, and if they passed, I was confident that the system was working as I specified.\n 我需要一套能随需运行、确保系统行为不会改动的自动化测试。在我搞出那个烂摊子的同时，也为 Args 类创建了一套单元测试和验收测试。单元测试用 Java 写成，采用 JUnit 管理。验收测试用 FitNesse 以 wiki 页形式写成。我可以随时运行这些测试，如果测试通过，就能打包票说系统以我期望的方式工作。\n So I proceeded to make a large number of very tiny changes. Each change moved the structure of the system toward the ArgumentMarshaler concept. And yet each change kept the system working. The first change I made was to add the skeleton of the ArgumentMarshaller to the end of the festering pile (Listing 14-11).\n 于是我开始做出大量小规模修改。每次修改都将系统结构向 ArgumentMarshaler 概念的方向推动。而且每次修改后，系统都要能工作。第一个修改是在烂摊子末尾添加 ArgumentMarshaler 的轮廓。\n Listing 14-11 ArgumentMarshaller appended to Args.java\n 代码清单 14-11 向 Args.java 添加 ArgumentMarshaler\n private class ArgumentMarshaler { private boolean booleanValue = false; public void setBoolean(boolean value) { booleanValue = value; } public boolean getBoolean() { return booleanValue; } } private class BooleanArgumentMarshaler extends ArgumentMarshaler { } private class StringArgumentMarshaler extends ArgumentMarshaler { } private class IntegerArgumentMarshaler extends ArgumentMarshaler { } Clearly, this wasn’t going to break anything. So then I made the simplest modification I could, one that would break as little as possible. I changed the HashMap for the Boolean arguments to take an ArgumentMarshaler.\n 显然，这什么也不会破坏。于是我做了一点最简单的、破坏性尽可能小的修改。我修改了 HashMap，采用 ArgumentMarshaler，使之支持 Boolean 参数。\n private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; booleanArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); This broke a few statements, which I quickly fixed.\n 这个修改影响到少数语句，我很快就修正了。\n … private void parseBooleanSchemaElement(char elementId) { booleanArgs.put(elementId, new BooleanArgumentMarshaler()); } … private void setBooleanArg(char argChar, boolean value) { booleanArgs.get(argChar).setBoolean(value); } … public boolean getBoolean(char arg) { return falseIfNull(booleanArgs.get(arg).getBoolean()); } Notice how these changes are in exactly the areas that I mentioned before: the parse, set, and get for the argument type. Unfortunately, small as this change was, some of the tests started failing. If you look carefully at getBoolean, you’ll see that if you call it with \u0026lsquo;y,\u0026rsquo; but there is no y argument, then booleanArgs.get(\u0026lsquo;y\u0026rsquo;) will return null, and the function will throw a NullPointerException. The falseIfNull function had been used to protect against this, but the change I made caused that function to become irrelevant.\n 注意，这些修改正是在我之前提到的那些区域之内所做的：参数类型的 parse、set 和 get 操作。不幸的是，即便修改如此细微，有些测试还是会失败。仔细看 getBoolean，可以看到如果用 y 去调用、而并没有 y 这个参数，则 booleanArgs.get(\u0026lsquo;y\u0026rsquo;)就会返回 null 值，函数将抛出一个 NullPointerException 异常。函数 falseIfNull 用以防止这种状况发生，但我做出的修改却导致该函数无所作为。\n Incrementalism demanded that I get this working quickly before making any other changes. Indeed, the fix was not too difficult. I just had to move the check for null. It was no longer the boolean being null that I needed to check; it was the ArgumentMarshaller.\n 渐进主义要求我在做其他修改之前迅速修正这个问题。修正并不费劲。我只是把对 null 值的检查移了个位置。再也不用检测 bollean 是否为 null，而是检查 ArgumentMarshaler 是否为 null。\n First, I removed the falseIfNull call in the getBoolean function. It was useless now, so I also eliminated the function itself. The tests still failed in the same way, so I was confident that I hadn’t introduced any new errors.\n 首先，我移除了 getBoolean 函数中的 falseIfNull 调用。现在它没什么用了，所以我也删去了这个函数。测试还是以同样的方式失败，所以我确定没有引入新的错误。\n public boolean getBoolean(char arg) { return booleanArgs.get(arg).getBoolean(); } Next, I split the function into two lines and put the ArgumentMarshaller into its own variable named argumentMarshaller. I didn’t care for the long variable name; it was badly redundant and cluttered up the function. So I shortened it to am [N5].\n 下一步，我把函数拆解为两行，并把 ArgumentMarshaler 放到它自己的名为 argumentMarshaler 的变量中[2]。我不在意变量名太长，但它却有点啰嗦，把函数搞得支离破碎。所以我把变量名缩短为 am[N5]。\n public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); return am.getBoolean(); } And then I put in the null detection logic.\n 然后再放入检测 null 值的逻辑。\n public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); return am != null \u0026amp;\u0026amp; am.getBoolean(); } 14.3 STRING ARGUMENTS 字符串参数 #  Addin_g String arguments was very similar to adding boolean arguments. I had to change the HashMap and get the parse, set, and get functions working. There shouldn’t be any surprises in what follows except, perhaps, that I seem to be putting all the marshalling implementation in the ArgumentMarshaller base class instead of distributing it to the derivatives.\n 添加 String 参数和添加 boolean 参数非常像。我要修改 HashMap，让 parse、set 和 get 函数能工作。跟着就是按部就班，但我似乎该把所有的 marshalling（编组）实现放到 ArgumentMarshaler 基类而不是派生类中。\n private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; stringArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); … private void parseStringSchemaElement(char elementId) { stringArgs.put(elementId, new StringArgumentMarshaler()); } … private void setStringArg(char argChar) throws ArgsException { currentArgument++; try { stringArgs.get(argChar).setString(args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } … public String getString(char arg) { Args.ArgumentMarshaler am = stringArgs.get(arg); return am == null ? “ ” : am.getString(); } … private class ArgumentMarshaler { private boolean booleanValue = false; private String stringValue; public void setBoolean(boolean value) { booleanValue = value; } public boolean getBoolean() { return booleanValue; } public void setString(String s) { stringValue = s; } public String getString() { return stringValue == null ? “ ” : stringValue; } } Again, these changes were made one at a time and in such a way that the tests kept running, if not passing. When a test broke, I made sure to get it passing again before continuing with the next change.\n 同样，也是每次修改一个地方，持续运行测试。如果测试出错，在做下一个修改前确保通过。\n By now you should be able to see my intent. Once I get all the current marshalling behavior into the ArgumentMarshaler base class, I’m going to start pushing that behavior down into the derivatives. This will allow me to keep everything running while I gradually change the shape of this program.\n 现在你应该明白我的意图了。一旦我将当前的编组行为放到 ArgumentMarshaler 基类中，就会开始往派生类推入该行为。这样，在我逐渐修改程序的形状时，还能保持一切正常。\n The obvious next step was to move the int argument functionality into the ArgumentMarshaler. Again, there weren’t any surprises.\n 下一步显而易见，把 int 参数的相关功能放到 ArgumentMarshaler 里面。同样，也是照方抓药。\n private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; intArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); … private void parseIntegerSchemaElement(char elementId) { intArgs.put(elementId, new IntegerArgumentMarshaler()); } … private void setIntArg(char argChar) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; intArgs.get(argChar).setInteger(Integer.parseInt(parameter)); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (NumberFormatException e) { valid = false; errorArgumentId = argChar; errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } … public int getInt(char arg) { Args.ArgumentMarshaler am = intArgs.get(arg); return am == null ? 0 : am.getInteger(); } … private class ArgumentMarshaler { private boolean booleanValue = false; private String stringValue; private int integerValue; public void setBoolean(boolean value) { booleanValue = value; } public boolean getBoolean() { return booleanValue; } public void setString(String s) { stringValue = s; } public String getString() { return stringValue == null ? “ ”: stringValue; } public void setInteger(int i) { integerValue = i; } public int getInteger() { return integerValue; } } With all the marshalling moved to the ArgumentMarshaler, I started pushing functionality into the derivatives. The first step was to move the setBoolean function into the BooleanArgumentMarshaller and make sure it got called correctly. So I created an abstract set method.\n 当所有的编组操作都放到了 ArgumentMarshaler 中，我开始向派生类移植功能。第一步是把 setBoolean 函数放到 BooleanArgumentMarshaler 中，确保它能正确调用。所以我创建了一个抽象的 set 方法。\n private abstract class ArgumentMarshaler { protected boolean booleanValue = false; private String stringValue; private int integerValue; public void setBoolean(boolean value) { booleanValue = value; } public boolean getBoolean() { return booleanValue; } public void setString(String s) { stringValue = s; } public String getString() { return stringValue == null ? \u0026#34; \u0026#34; : stringValue; } public void setInteger(int i) { integerValue = i; } public int getInteger() { return integerValue; } public abstract void set(String s); } Then I implemented the set method in BooleanArgumentMarshaller.\n 然后在 BooleanArgumentMarshaler 中实现 set 方法。\n private class BooleanArgumentMarshaler extends ArgumentMarshaler { public void set(String s) { booleanValue = true; } } And finally I replaced the call to setBoolean with a call to set.\n 最后，通过调用 set，替换对 setBoolean 的调用。\n private void setBooleanArg(char argChar, boolean value) { booleanArgs.get(argChar) .set(“true”); } The tests all still passed. Because this change caused set to be deployed to the Boolean-ArgumentMarshaler, I removed the setBoolean method from the ArgumentMarshaler base class.\n 测试仍然全部通过。因为这次修改导致 set 函数放到了 BooleanArgumentMarshaler 里面，我就从 ArgumentMarshaler 基类删除了 setBoolean 方法。\n Notice that the abstract set function takes a String argument, but the implementation in the BooleanArgumentMarshaller does not use it. I put that argument in there because I knew that the StringArgumentMarshaller and IntegerArgumentMarshaller would use it.\n 注意，抽象函数 set 有一个 String 参数，但其在 BooleanArgumentMarshaler 中的实现却没有使用这个参数。之所以在这里放个参数，是因为我知道 StringArgumentMarshaler 和 IntegerArgumentMarshaler 可能会使用它。\n Next, I wanted to deploy the get method into BooleanArgumentMarshaler. Deploying get functions is always ugly because the return type has to be Object, and in this case needs to be cast to a Boolean.\n 跟着，我打算把 get 方法放到 BooleanArgumentMarshaler 中。这有点难看，因为返回类型必须是 Object，且在这里需要转换为 Boolean 值。\n public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); return am != null \u0026amp;\u0026amp; (Boolean)am.get(); } Just to get this to compile, I added the get function to the ArgumentMarshaler.\n 为了编译通过，我把 get 函数加到 ArgumentMarshaler 中。\n private abstract class ArgumentMarshaler { … public Object get() { return null; } } This compiled and obviously failed the tests. Getting the tests working again was simply a matter of making get abstract and implementing it in BooleanAgumentMarshaler.\n 这样一来，虽然可以编译，但却无法通过测试。只要将 get 修改为抽象方法，并在 BooleanArgumentMarshaler 中实现，就能重新通过测试。\n private abstract class ArgumentMarshaler { protected boolean booleanValue = false; … public abstract Object get(); } private class BooleanArgumentMarshaler extends ArgumentMarshaler { public void set(String s) { booleanValue = true; } public Object get() { return booleanValue; } } Once again the tests passed. So both get and set deploy to the BooleanArgumentMarshaler! This allowed me to remove the old getBoolean function from ArgumentMarshaler, move the protected booleanValue variable down to BooleanArgumentMarshaler, and make it private.\n 测试又通过了。get 和 set 方法都已部署到 BooleanArgumentMarshaler 中！这样我就可以从 ArgumentMarshaler 里面移除旧的 getBoolean 函数，把受保护的 booleanValue 变量向下移动到 BooleanArgumentMarshaler，并将其设置为 private。\n I did the same pattern of changes for Strings. I deployed both set and get, deleted the unused functions, and moved the variables.\n 对于 String 也照此办理。我修改了 set 和 get 的部署方式，删除无用的函数，并移动了变量。\n private void setStringArg(char argChar) throws ArgsException { currentArgument++; try { stringArgs.get(argChar).set(args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } … public String getString(char arg) { Args.ArgumentMarshaler am = stringArgs.get(arg); return am == null ? \u0026#34; \u0026#34; : (String) am.get(); } … private abstract class ArgumentMarshaler { private int integerValue; public void setInteger(int i) { integerValue = i; } public int getInteger() { return integerValue; } public abstract void set(String s); public abstract Object get(); } private class BooleanArgumentMarshaler extends ArgumentMarshaler { private boolean booleanValue = false; public void set(String s) { booleanValue = true; } public Object get() { return booleanValue; } } private class StringArgumentMarshaler extends ArgumentMarshaler { private String stringValue = \u0026#34; \u0026#34;; public void set(String s) { stringValue = s; } public Object get() { return stringValue; } } private class IntegerArgumentMarshaler extends ArgumentMarshaler { public void set(String s) { } public Object get() { return null; } } Finally, I repeated the process for integers. This was just a little more complicated because integers needed to be parsed, and the parse operation can throw an exception. But the result is better because the whole concept of NumberFormatException got buried in the IntegerArgumentMarshaler.\n 最后，我为 integer 类型参数重复这个过程。这稍稍复杂一点，因为 integer 需要解析，而 parse 操作会抛出异常。不过结果会更好，因为 NumberFormatException 的概念在 IntegerArgumentMarshaler 中隐藏了。\n private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);} private void setIntArg(char argChar) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; intArgs.get(argChar).set(parameter); } catch (ArrayIndexOutOfBoundsException e) { valid = false; errorArgumentId = argChar; errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (ArgsException e) { valid = false; errorArgumentId = argChar; errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw e; } } … private void setBooleanArg(char argChar) { try { booleanArgs.get(argChar).set(“true”); } catch (ArgsException e) { } } … public int getInt(char arg) { Args.ArgumentMarshaler am = intArgs.get(arg); return am == null ? 0 : (Integer) am.get(); } … private abstract class ArgumentMarshaler { public abstract void set(String s) throws ArgsException; public abstract Object get(); } … private class IntegerArgumentMarshaler extends ArgumentMarshaler { private int intValue = 0; public void set(String s) throws ArgsException { try { intValue = Integer.parseInt(s); } catch (NumberFormatException e) { throw new ArgsException(); } } public Object get() { return intValue; } } Of course, the tests continued to pass. Next, I got rid of the three different maps up at the top of the algorithm. This made the whole system much more generic. However, I couldn’t get rid of them just by deleting them because that would break the system. Instead, I added a new Map for the ArgumentMarshaler and then one by one changed the methods to use it instead of the three original maps.\n 测试当然继续通过。下一步，我要删掉算法顶端的三种不同 Map。这样，整个系统就变得更通用了。不过，只是删除它们却无法达到目的，因为那样会破坏系统。反之，我为 ArgumentMarshaler 添加一个新的 Map，然后再逐个修改那些方法，让方法调用这个新 Map。\n public class Args { … private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; booleanArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; stringArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; intArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); … private void parseBooleanSchemaElement(char elementId) { ArgumentMarshaler m = new BooleanArgumentMarshaler(); booleanArgs.put(elementId, m); marshalers.put(elementId, m); } private void parseIntegerSchemaElement(char elementId) { ArgumentMarshaler m = new IntegerArgumentMarshaler(); intArgs.put(elementId, m); marshalers.put(elementId, m); } private void parseStringSchemaElement(char elementId) { ArgumentMarshaler m = new StringArgumentMarshaler(); stringArgs.put(elementId, m); marshalers.put(elementId, m); } } Of course the tests all still passed. Next, I changed isBooleanArg from this:\n 当然，测试还是通过了。接着，我把 isBooleanArg：\n private boolean isBooleanArg(char argChar) { return booleanArgs.containsKey(argChar); } to this:\n 修改成这样：\n private boolean isBooleanArg(char argChar) { ArgumentMarshaler m = marshalers.get(argChar); return m instanceof BooleanArgumentMarshaler; } The tests still passed. So I made the same change to isIntArg and isStringArg.\n 测试仍然通过。于是我修改了一下 isIntArg 和 isStringArg。\n private boolean isIntArg(char argChar) { ArgumentMarshaler m = marshalers.get(argChar); return m instanceof IntegerArgumentMarshaler; } private boolean isStringArg(char argChar) { ArgumentMarshaler m = marshalers.get(argChar); return m instanceof StringArgumentMarshaler; } The tests still passed. So I eliminated all the duplicate calls to marshalers.get as follows:\n 测试继续通过。我跟着消除了对 marshaler.get 的重复调用：\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (isBooleanArg(m)) setBooleanArg(argChar); else if (isStringArg(m)) setStringArg(argChar); else if (isIntArg(m)) setIntArg(argChar); else return false; return true; } private boolean isIntArg(ArgumentMarshaler m) { return m instanceof IntegerArgumentMarshaler; } private boolean isStringArg(ArgumentMarshaler m) { return m instanceof StringArgumentMarshaler; } private boolean isBooleanArg(ArgumentMarshaler m) { return m instanceof BooleanArgumentMarshaler; } This left no good reason for the three isxxxArg methods. So I inlined them:\n 存在三个 isxxxArg 方法毫无道理。所以我做了内联修改：\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m instanceof BooleanArgumentMarshaler) setBooleanArg(argChar); else if (m instanceof StringArgumentMarshaler) setStringArg(argChar); else if (m instanceof IntegerArgumentMarshaler) setIntArg(argChar); else return false; return true; } Next, I started using the marshalers map in the set functions, breaking the use of the other three maps. I started with the booleans.\n 下一步，我开始在 set 函数中使用 marshaler 映射，停止使用另外三个映射映射。从 boolean 开始：\n public class Args { private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m instanceof BooleanArgumentMarshaler) setBooleanArg(m); else if (m instanceof StringArgumentMarshaler) setStringArg(argChar); else if (m instanceof IntegerArgumentMarshaler) setIntArg(argChar); else return false; return true; } … private void setBooleanArg(ArgumentMarshaler m) { try { m.set(\u0026#34;true\u0026#34;); // was: booleanArgs.get(argChar).set(\u0026#34;true\u0026#34;);  } catch (ArgsException e) { } } } The tests still passed, so I did the same with Strings and Integers. This allowed me to integrate some of the ugly exception management code into the setArgument function.\n 测试通过，于是我如法炮制 String 和 Integer 参数。这样我就能把有些丑陋的异常管理代码整合到 setArgument 函数中。\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); try { if (m instanceof BooleanArgumentMarshaler) setBooleanArg(m); else if (m instanceof StringArgumentMarshaler) setStringArg(m); else if (m instanceof IntegerArgumentMarshaler) setIntArg(m); else return false; } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } return true; } private void setIntArg(ArgumentMarshaler m) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; m.set(parameter); } catch (ArrayIndexOutOfBoundsException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (ArgsException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw e; } } private void setStringArg(ArgumentMarshaler m) throws ArgsException { currentArgument++; try { m.set(args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } I was close to being able to remove the three old maps. First, I needed to change the getBoolean function from this:\n 离彻底删除那 3 个旧映射的时机越来越近了。首先，我需要修改 getBoolean 函数：\n public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = booleanArgs.get(arg); return am != null \u0026amp;\u0026amp; (Boolean) am.get(); } to this:\n 修改成这样：\n public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null \u0026amp;\u0026amp; (Boolean) am.get(); } catch (ClassCastException e) { b = false; } return b; } This last change might have been a surprise. Why did I suddenly decide to deal with the ClassCastException? The reason is that I have a set of unit tests and a separate set of acceptance tests written in FitNesse. It turns out that the FitNesse tests made sure that if you called getBoolean on a nonboolean argument, you got a false. The unit tests did not. Up to this point I had only been running the unit tests.2\n 最后这个修改可能令人吃惊。为什么我会突然决定对付 ClassCastException？原因是我有一组单元测试，还有用 FitNesse 编写的一组验收测试。FitNesse 测试确认，如果用非布尔值参数调用 getBoolean，应该返回 false。可单元测试的结果不是这样。而到此时为止，我一直只调用单元测试[3]。\n This last change allowed me to pull out another use of the boolean map:\n 这次修改把另一个对 boolean 映射的使用抽离了：\n private void parseBooleanSchemaElement(char elementId) { ArgumentMarshaler m = new BooleanArgumentMarshaler(); booleanArgs.put(elementId, m); marshalers.put(elementId, m); } And now we can delete the boolean map.\n 如此我们就能删除 boolean 映射。\n public class Args { … private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; booleanArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; stringArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; intArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); … } Next, I migrated the String and Integer arguments in the same manner and did a little cleanup with the booleans.\n 接下来，我用同样的手法处理 String 和 Integer 参数，对 boolean 参数做了一点清理工作。\n private void parseBooleanSchemaElement(char elementId) { marshalers.put(elementId, new BooleanArgumentMarshaler()); } private void parseIntegerSchemaElement(char elementId) { marshalers.put(elementId, new IntegerArgumentMarshaler()); } private void parseStringSchemaElement(char elementId) { marshalers.put(elementId, new StringArgumentMarshaler()); } … public String getString(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? “ ” : (String) am.get(); } catch (ClassCastException e) { return “ ”; } } public int getInt(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? 0 : (Integer) am.get(); } catch (Exception e) { return 0; } } … public class Args { … private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; stringArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; intArgs = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); … Next, I inlined the three parse methods because they didn’t do much anymore:\n 接着，由于那些 parse 方法没有太多事可做，我对它们进行了内联修改：\n private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (isBooleanSchemaElement(elementTail)) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (isStringSchemaElement(elementTail)) marshalers.put(elementId, new StringArgumentMarshaler()); else if (isIntegerSchemaElement(elementTail)) { marshalers.put(elementId, new IntegerArgumentMarshaler()); } else { throw new ParseException(String.format( \u0026#34;Argument: %c has invalid format: %s.\u0026#34;, elementId, elementTail), 0); } } Okay, so now let’s look at the whole picture again. Listing 14-12 shows the current form of the Args class.\n 行了，下面来看看全景吧。代码清单 14-12 展示了 Args 类的现状。\n Listing 14-12 Args.java (After first refactoring)\n 代码清单 14-12 Args.java（首次重构后）\n package com.objectmentor.utilities.getopts; import java.text.ParseException; import java.util.*; public class Args { private String schema; private String[] args; private boolean valid = true; private Set\u0026lt;Character\u0026gt; unexpectedArguments = new TreeSet\u0026lt;Character\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Set\u0026lt;Character\u0026gt; argsFound = new HashSet\u0026lt;Character\u0026gt;(); private int currentArgument; private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = \u0026#34;TILT\u0026#34;; private ErrorCode errorCode = ErrorCode.OK; private enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT } public Args(String schema, String[] args) throws ParseException { this.schema = schema; this.args = args; valid = parse(); } private boolean parse() throws ParseException { if (schema.length() == 0 \u0026amp;\u0026amp; args.length == 0) return true; parseSchema(); try { parseArguments(); } catch (ArgsException e) { } return valid; } private boolean parseSchema() throws ParseException { for (String element : schema.split(\u0026#34;,\u0026#34;)) { if (element.length() \u0026gt; 0) { String trimmedElement = element.trim(); parseSchemaElement(trimmedElement); } } return true; } private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (isBooleanSchemaElement(elementTail)) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (isStringSchemaElement(elementTail)) marshalers.put(elementId, new StringArgumentMarshaler()); else if (isIntegerSchemaElement(elementTail)) { marshalers.put(elementId, new IntegerArgumentMarshaler()); } else { throw new ParseException(String.format( \u0026#34;Argument: %c has invalid format: %s.\u0026#34;, elementId, elementTail), 0); } } private void validateSchemaElementId(char elementId) throws ParseException { if (!Character.isLetter(elementId)) { throw new ParseException( \u0026#34;Bad character:\u0026#34; + elementId + \u0026#34;in Args format: \u0026#34; + schema, 0); } } private boolean isStringSchemaElement(String elementTail) { return elementTail.equals(\u0026#34;*\u0026#34;); } private boolean isBooleanSchemaElement(String elementTail) { return elementTail.length() == 0; } private boolean isIntegerSchemaElement(String elementTail) { return elementTail.equals(\u0026#34;-\u0026#34;); } private boolean parseArguments() throws ArgsException { for (currentArgument = 0; currentArgument \u0026lt; args.length; currentArgument++) { String arg = args[currentArgument]; parseArgument(arg); } return true; } private void parseArgument(String arg) throws ArgsException { if (arg.startsWith(\u0026#34;-\u0026#34;)) parseElements(arg); } private void parseElements(String arg) throws ArgsException { for (int i = 1; i \u0026lt; arg.length(); i++) parseElement(arg.charAt(i)); } private void parseElement(char argChar) throws ArgsException { if (setArgument(argChar)) argsFound.add(argChar); else { unexpectedArguments.add(argChar); errorCode = ErrorCode.UNEXPECTED_ARGUMENT; valid = false; } } private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); try { if (m instanceof BooleanArgumentMarshaler) setBooleanArg(m); else if (m instanceof StringArgumentMarshaler) setStringArg(m); else if (m instanceof IntegerArgumentMarshaler) setIntArg(m); else return false; } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } return true; } private void setIntArg(ArgumentMarshaler m) throws ArgsException { currentArgument++; String parameter = null; try { parameter = args[currentArgument]; m.set(parameter); } catch (ArrayIndexOutOfBoundsException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (ArgsException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw e; } } private void setStringArg(ArgumentMarshaler m) throws ArgsException { currentArgument++; try { m.set(args[currentArgument]); } catch (ArrayIndexOutOfBoundsException e) { errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } private void setBooleanArg(ArgumentMarshaler m) { try { m.set(\u0026#34;true\u0026#34;); } catch (ArgsException e) { } } public int cardinality() { return argsFound.size(); } public String usage() { if (schema.length() \u0026gt; 0) return \u0026#34;-[\u0026#34; + schema + \u0026#34;]\u0026#34;; else return \u0026#34; \u0026#34;; } public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(\u0026#34;TILT: Should not get here.\u0026#34;); case UNEXPECTED_ARGUMENT: return unexpectedArgumentMessage(); case MISSING_STRING: return String.format(\u0026#34;Could not find string parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_INTEGER: return String.format(\u0026#34;Argument -%c expects an integer but was \u0026#39;%s\u0026#39;.\u0026#34;, errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\u0026#34;Could not find integer parameter for -%c.\u0026#34;, errorArgumentId); } return \u0026#34; \u0026#34;; } private String unexpectedArgumentMessage() { StringBuffer message = new StringBuffer(\u0026#34;Argument(s) -\u0026#34;); for (char c : unexpectedArguments) { message.append(c); } message.append(\u0026#34; unexpected.\u0026#34;); return message.toString(); } public boolean getBoolean(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null \u0026amp;\u0026amp; (Boolean) am.get(); } catch (ClassCastException e) { b = false; } return b; } public String getString(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? \u0026#34; \u0026#34; : (String) am.get(); } catch (ClassCastException e) { return \u0026#34; \u0026#34;; } } public int getInt(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? 0 : (Integer) am.get(); } catch (Exception e) { return 0; } } public boolean has(char arg) { return argsFound.contains(arg); } public boolean isValid() { return valid; } private class ArgsException extends Exception { } private abstract class ArgumentMarshaler { public abstract void set(String s) throws ArgsException; public abstract Object get(); } private class BooleanArgumentMarshaler extends ArgumentMarshaler { private boolean booleanValue = false; public void set(String s) { booleanValue = true; } public Object get() { return booleanValue; } } private class StringArgumentMarshaler extends ArgumentMarshaler { private String stringValue = \u0026#34; \u0026#34;; public void set(String s) { stringValue = s; } public Object get() { return stringValue; } } private class IntegerArgumentMarshaler extends ArgumentMarshaler { private int intValue = 0; public void set(String s) throws ArgsException { try { intValue = Integer.parseInt(s); } catch (NumberFormatException e) { throw new ArgsException(); } } public Object get() { return intValue; } } } After all that work, this is a bit disappointing. The structure is a bit better, but we still have all those variables up at the top; there’s still a horrible type-case in setArgument; and all those set functions are really ugly. Not to mention all the error processing. We still have a lot of work ahead of us.\n 功夫费尽，还是有点失望。程序结构好了一点，但在代码顶端还是有那一堆变量；在 setArgument 里面还是有那么恐怖的类型转换操作；而且那些 set 函数真的很丑陋。就别提那些错误处理操作了。前头要做的事还很多。\n I’d really like to get rid of that type-case up in setArgument [G23]. What I’d like in setArgument is a single call to ArgumentMarshaler.set. This means I need to push setIntArg, setStringArg, and setBooleanArg down into the appropriate ArgumentMarshaler derivatives. But there is a problem.\n 我真是想删掉 setArgument 里面那些类型转换操作[G23]。我想要 setArgument 只简单地调用 ArgumentMarshaler.set。这意味着我需要将 setIntArg、setStringArg 和 setBooleanArg 推到合适的 ArgumentMarshaler 派生类里面。不过这有个问题。\n If you look closely at setIntArg, you’ll notice that it uses two instance variables: args and currentArg. To move setIntArg down into BooleanArgumentMarshaler, I’ll have to pass both args and currentArgs as function arguments. That’s dirty [F1]. I’d rather pass one argument instead of two. Fortunately, there is a simple solution. We can convert the args array into a list and pass an Iterator down to the set functions. The following took me ten steps, passing all the tests after each. But I’ll just show you the result. You should be able to figure out what most of the tiny little steps were.\n 仔细看 setIntArg，你会发现，它使用了两个实体变量：args 和 currentArg。为了把 setIntArg 移到 BooleanARgumentMarshaler 里面，我得把这两个变量都作为函数参数传递过去。那种做法太烂了[F1]。我只想传递一个参数。幸运的是，有个简单的解决方法。可以把 args 数组转换为一个 list，并向 set 函数传递一个 Iterator。这花了我 10 步功夫，每次都通过了测试。不过我只向你展示结果。你应该能看出每个小修改步骤。\n public class Args { private String schema; private String[] args; private boolean valid = true; private Set\u0026lt;Character\u0026gt; unexpectedArguments = new TreeSet\u0026lt;Character\u0026gt;(); private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Set\u0026lt;Character\u0026gt; argsFound = new HashSet\u0026lt;Character\u0026gt;(); private Iterator\u0026lt;String\u0026gt; currentArgument; private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = \u0026#34;TILT\u0026#34;; private ErrorCode errorCode = ErrorCode.OK; private List\u0026lt;String\u0026gt; argsList; private enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT } public Args(String schema, String[] args) throws ParseException { this.schema = schema; argsList = Arrays.asList(args); valid = parse(); } private boolean parse() throws ParseException { if (schema.length() == 0 \u0026amp;\u0026amp; argsList.size() == 0) return true; parseSchema(); try { parseArguments(); } catch (ArgsException e) { } return valid; } } --- private boolean parseArguments() throws ArgsException { for (currentArgument = argsList.iterator(); currentArgument.hasNext(); ) { String arg = currentArgument.next(); parseArgument(arg); } return true; } --- private void setIntArg(ArgumentMarshaler m) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); m.set(parameter); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (ArgsException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw e; } } private void setStringArg(ArgumentMarshaler m) throws ArgsException { try { m.set(currentArgument.next()); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } These were simple changes that kept all the tests passing. Now we can start moving the set functions down into the appropriate derivatives. First, I need to make the following change in setArgument:\n 是这些简单的修改让测试保持通过。现在我们可以开始把 set 函数移植到合适的派生类中了。第一步，我要在 setArgument 中做以下修改：\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) return false; try { if (m instanceof BooleanArgumentMarshaler) setBooleanArg(m); else if (m instanceof StringArgumentMarshaler) setStringArg(m); else if (m instanceof IntegerArgumentMarshaler) setIntArg(m); else return false; } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } return true; } This change is important because we want to completely eliminate the if-else chain. Therefore, we needed to get the error condition out of it.\n 这个修改很重要，因为我们想要彻底删除那条 if-else 链。所以，需要把错误条件抽离。\n Now we can start to move the set functions. The setBooleanArg function is trivial, so we’ll prepare that one first. Our goal is to change the setBooleanArg function to simply forward to the BooleanArgumentMarshaler.\n 现在可以开始移动 set 函数了。setBooleanArg 函数很小，就从它开始。目标是让 setBooleanArg 函数只与 BooleanArgumentMarshaler 有关。\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) return false; try { if (m instanceof BooleanArgumentMarshaler) setBooleanArg(m, currentArgument); else if (m instanceof StringArgumentMarshaler) setStringArg(m); else if (m instanceof IntegerArgumentMarshaler) setIntArg(m); } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } return true; } --- private void setBooleanArg(ArgumentMarshaler m, Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { try { m.set(\u0026#34;true\u0026#34;); } catch (ArgsException e) { } } Didn’t we just put that exception processing in? Putting things in so you can take them out again is pretty common in refactoring. The smallness of the steps and the need to keep the tests running means that you move things around a lot. Refactoring is a lot like solving a Rubik’s cube. There are lots of little steps required to achieve a large goal. Each step enables the next.\n 我们不是刚把那个异常处理放进去吗？放进拿出是重构过程中常见的事。小步幅和保持测试通过，意味着你会不断移动各种东西。重构有点像是解魔方。需要经过许多小步骤，才能达到较大目标。每一步都是下一步的基础。\n Why did we pass that iterator when setBooleanArg certainly doesn’t need it? Because setIntArg and setStringArg will! And because I want to deploy all three of these functions through an abstract method in ArgumentMarshaller, I need to pass it to setBooleanArg.\n 为什么要在 setBooleanArg 根本不需要的情况下向其传递 iterator 呢？因为 setIntArg 和 setStringArg 需要！还因为我打算通过 ArgumentMarshaler 中的抽象方法部署这三个函数，需要将其传递给 setBooleanArg。\n So now setBooleanArg is useless. If there were a set function in ArgumentMarshaler, we could call it directly. So it’s time to make that function! The first step is to add the new abstract method to ArgumentMarshaler.\n 现在 setBooleanArg 没用了。如果 ArgumentMarshaler 中有个 set 函数，我们可以直接调用它。是时候打造那个函数了！第一步，在 ArgumentMarshaler 中添加抽象方法。\n private abstract class ArgumentMarshaler { public abstract void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException; public abstract void set(String s) throws ArgsException; public abstract Object get(); } Of course this breaks all the derivatives. So let’s implement the new method in each.\n 当然，这会影响到所有派生类。所以，要逐个实现新方法。\n private class BooleanArgumentMarshaler extends ArgumentMarshaler { private boolean booleanValue = false; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { booleanValue = true; } public void set(String s) { booleanValue = true; } public Object get() { return booleanValue; } } private class StringArgumentMarshaler extends ArgumentMarshaler { private String stringValue = \u0026#34;\u0026#34;; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { } public void set(String s) { stringValue = s; } public Object get() { return stringValue; } } private class IntegerArgumentMarshaler extends ArgumentMarshaler { private int intValue = 0; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { } public void set(String s) throws ArgsException { try { intValue = Integer.parseInt(s); } catch (NumberFormatException e) { throw new ArgsException(); } } public Object get() { return intValue; } } And now we can eliminate setBooleanArg!\n 现在可以删除 setBooleanArg 了！\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) return false; try { if (m instanceof BooleanArgumentMarshaler) m.set(currentArgument); else if (m instanceof StringArgumentMarshaler) setStringArg(m); else if (m instanceof IntegerArgumentMarshaler) setIntArg(m); } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } return true; } The tests all pass, and the set function is deploying to BooleanArgumentMarshaler! Now we can do the same for Strings and Integers.\n 测试全都通过，而且 set 函数也部署到 BooleanArgumentMarshaler 里面了！现在就能对 String 和 Integer 参数的处理做同样的修改。\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) return false; try { if (m instanceof BooleanArgumentMarshaler) m.set(currentArgument); else if (m instanceof StringArgumentMarshaler) m.set(currentArgument); else if (m instanceof IntegerArgumentMarshaler) m.set(currentArgument); } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } return true; } --- private class StringArgumentMarshaler extends ArgumentMarshaler { private String stringValue = \u0026#34;\u0026#34;; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { try { stringValue = currentArgument.next(); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_STRING; throw new ArgsException(); } } public void set(String s) { } public Object get() { return stringValue; } } private class IntegerArgumentMarshaler extends ArgumentMarshaler { private int intValue = 0; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); set(parameter); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (ArgsException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw e; } } public void set(String s) throws ArgsException { try { intValue = Integer.parseInt(s); } catch (NumberFormatException e) { throw new ArgsException(); } } public Object get() { return intValue; } } And so the coup de grace: The type-case can be removed! Touche!\n 最后一击：可以移除类型转换了！看招！\n private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) return false; try { m.set(currentArgument); return true; } catch (ArgsException e) { valid = false; errorArgumentId = argChar; throw e; } } Now we can get rid of some crufty functions in IntegerArgumentMarshaler and clean it up a bit.\n 现在可以删掉 IntegerArgumentMarshaler 中那些过时的函数，做一下清理了。\n private class IntegerArgumentMarshaler extends ArgumentMarshaler { private int intValue = 0 public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); intValue = Integer.parseInt(parameter); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (NumberFormatException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } public Object get() { return intValue; } } We can also turn ArgumentMarshaler into an interface.\n 还可以把 ArgumentMarshaler 修改为接口。\n private interface ArgumentMarshaler { void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException; Object get(); } So now let’s see how easy it is to add a new argument type to our structure. It should require very few changes, and those changes should be isolated. First, we begin by adding a new test case to check that the double argument works correctly.\n 现在来看看往这个结构中添加新的参数类型有多容易。只需要做少量修改，而且修改是被隔离的。首先，增加一个新的测试用例，检测 double 参数是否正常工作。\n public void testSimpleDoublePresent() throws Exception { Args args = new Args(\u0026#34;x##\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;42.3\u0026#34;}); assertTrue(args.isValid()); assertEquals(1, args.cardinality()); assertTrue(args.has(\u0026#39;x\u0026#39;)); assertEquals(42.3, args.getDouble(\u0026#39;x\u0026#39;), .001); } Now we clean up the schema parsing code and add the ## detection for the double argument type.\n 然后清理范式解析代码，为 double 参数类型添加 ## 监测。\n private void parseSchemaElement(String element) throws ParseException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (elementTail.length() == 0) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (elementTail.equals(\u0026#34;*\u0026#34;)) marshalers.put(elementId, new StringArgumentMarshaler()); else if (elementTail.equals(\u0026#34;#\u0026#34;)) marshalers.put(elementId, new IntegerArgumentMarshaler()); else if (elementTail.equals(\u0026#34;##\u0026#34;)) marshalers.put(elementId, new DoubleArgumentMarshaler()); else throw new ParseException(String.format( \u0026#34;Argument: %c has invalid format: %s.\u0026#34;, elementId, elementTail), 0); } Next, we write the DoubleArgumentMarshaler class.\n 下一步，编写 DoubleArgumentMarshaler 类。\n private class DoubleArgumentMarshaler implements ArgumentMarshaler { private double doubleValue = 0; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); doubleValue = Double.parseDouble(parameter); } catch (NoSuchElementException e) { errorCode = ErrorCode.MISSING_DOUBLE; throw new ArgsException(); } catch (NumberFormatException e) { errorParameter = parameter; errorCode = ErrorCode.INVALID_DOUBLE; throw new ArgsException(); } } public Object get() { return doubleValue; } } This forces us to add a new ErrorCode.\n 然后就得添加一个新的 ErrorCode：\n private enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT, MISSING_DOUBLE, INVALID_DOUBLE } And we need a getDouble function.\n 还需要一个 getDouble 函数：\n public double getDouble(char arg) { Args.ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? 0 : (Double) am.get(); } catch (Exception e) { return 0.0; } } And all the tests pass! That was pretty painless. So now let’s make sure all the error processing works correctly. The next test case checks that an error is declared if an unparseable string is fed to a ## argument.\n 全部测试都通过了！完全无痛。再来确保全部错误处理代码正确工作。下一个测试用例用来检测在向 ## 参数传递一个不可解析的字符串时是否会返回错误。\n public void testInvalidDouble() throws Exception { Args args = new Args(\u0026#34;x##\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;Forty two\u0026#34;}); assertFalse(args.isValid()); assertEquals(0, args.cardinality()); assertFalse(args.has(\u0026#39;x\u0026#39;)); assertEquals(0, args.getInt(\u0026#39;x\u0026#39;)); assertEquals(\u0026#34;Argument -x expects a double but was ‘Forty two\u0026#39;.\u0026#34;, args.errorMessage()); } --- public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(\u0026#34;TILT: Should not get here.\u0026#34;); case UNEXPECTED_ARGUMENT: return unexpectedArgumentMessage(); case MISSING_STRING: return String.format(\u0026#34;Could not find string parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_INTEGER: return String.format(\u0026#34;Argument -%c expects an integer but was ‘%s’.\u0026#34;, errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\u0026#34;Could not find integer parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_DOUBLE: return String.format(\u0026#34;Argument -%c expects a double but was ‘%s’.\u0026#34;, errorArgumentId, errorParameter); case MISSING_DOUBLE: return String.format(\u0026#34;Could not find double parameter for -%c.\u0026#34;, errorArgumentId); } return \u0026#34;\u0026#34;; } And the tests pass. The next test makes sure we detect a missing double argument properly.\n 测试通过。下一个测试确保我们正确检测到遗漏的 double 参数。\n public void testMissingDouble() throws Exception { Args args = new Args(\u0026#34;x##\u0026#34;, new String[]{\u0026#34;-x\u0026#34;}); assertFalse(args.isValid()); assertEquals(0, args.cardinality()); assertFalse(args.has(\u0026#39;x\u0026#39;)); assertEquals(0.0, args.getDouble(\u0026#39;x\u0026#39;), 0.01); assertEquals(\u0026#34;Could not find double parameter for -x.\u0026#34;, args.errorMessage()); } This passes as expected. We wrote it simply for completeness.\n 测试如期通过。我们只是为了保持一切完整而编写这个测试。\n The exception code is pretty ugly and doesn’t really belong in the Args class. We are also throwing out ParseException, which doesn’t really belong to us. So let’s merge all the exceptions into a single ArgsException class and move it into its own module.\n 异常代码很丑陋，不该在 Args 类中存在。我们也抛出 ParseException，但那并不真的属于我们自己。那就把所有异常都塞到 ArgsException 类中，并将其移到它自己的模块里面。\n public class ArgsException extends Exception { private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = \u0026#34;TILT\u0026#34;; private ErrorCode errorCode = ErrorCode.OK; public ArgsException() { } public ArgsException(String message) { super(message); } public enum ErrorCode { OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT, MISSING_DOUBLE, INVALID_DOUBLE } } --- public class Args { … private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = \u0026#34;TILT\u0026#34;; private ArgsException.ErrorCode errorCode = ArgsException.ErrorCode.OK; private List\u0026lt;String\u0026gt; argsList; public Args(String schema, String[] args) throws ArgsException { this.schema = schema; argsList = Arrays.asList(args); valid = parse(); } private boolean parse() throws ArgsException { if (schema.length() == 0 \u0026amp;\u0026amp; argsList.size() == 0) return true; parseSchema(); try { parseArguments(); } catch (ArgsException e) { } return valid; } private boolean parseSchema() throws ArgsException { … } private void parseSchemaElement(String element) throws ArgsException { … else throw new ArgsException( String.format(\u0026#34;Argument: %c has invalid format: %s.\u0026#34;, elementId, elementTail)); } private void validateSchemaElementId(char elementId) throws ArgsException { if (!Character.isLetter(elementId)) { throw new ArgsException( \u0026#34;Bad character:\u0026#34; + elementId + \u0026#34;in Args format: \u0026#34; + schema); } } … private void parseElement(char argChar) throws ArgsException { if (setArgument(argChar)) argsFound.add(argChar); else { unexpectedArguments.add(argChar); errorCode = ArgsException.ErrorCode.UNEXPECTED_ARGUMENT; valid = false; } } … private class StringArgumentMarshaler implements ArgumentMarshaler { private String stringValue = \u0026#34;\u0026#34;; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { try { stringValue = currentArgument.next(); } catch (NoSuchElementException e) { errorCode = ArgsException.ErrorCode.MISSING_STRING; throw new ArgsException(); } } public Object get() { return stringValue; } } private class IntegerArgumentMarshaler implements ArgumentMarshaler { private int intValue = 0; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); intValue = Integer.parseInt(parameter); } catch (NoSuchElementException e) { errorCode = ArgsException.ErrorCode.MISSING_INTEGER; throw new ArgsException(); } catch (NumberFormatException e) { errorParameter = parameter; errorCode = ArgsException.ErrorCode.INVALID_INTEGER; throw new ArgsException(); } } public Object get() { return intValue; } } private class DoubleArgumentMarshaler implements ArgumentMarshaler { private double doubleValue = 0; public void set(Iterator\u0026lt;String\u0026gt; currentArgument) throws ArgsException { String parameter = null; try { parameter = currentArgument.next(); doubleValue = Double.parseDouble(parameter); } catch (NoSuchElementException e) { errorCode = ArgsException.ErrorCode.MISSING_DOUBLE; throw new ArgsException(); } catch (NumberFormatException e) { errorParameter = parameter; errorCode = ArgsException.ErrorCode.INVALID_DOUBLE; throw new ArgsException(); } } public Object get() { return doubleValue; } } } This is nice. Now the only exception thrown by Args is ArgsException. Moving ArgsException into its own module means that we can move a lot of the miscellaneous error support code into that module and out of the Args module. It provides a natural and obvious place to put all that code and will really help us clean up the Args module going forward.\n 很好。现在，Args 抛出的唯一一个异常是 ArgsException。把 ArgsException 移到它自己的模块中，意味着我们能把大量杂七杂八的错误支持代码从 Args 模块转移到这个模块。\n So now we have completely separated the exception and error code from the Args module. (See Listing 14-13 through Listing 14-16.) This was achieved through a series of about 30 tiny steps, keeping the tests passing between each step.\n 现在我们完全把异常和错误代码从 Args 模块中隔离出来了。（如代码清单 14-13 ～ 16 所示。）为达到这一目标，大概做了 30 次小修改，每次修改都保持测试通过。\n Listing 14-13 ArgsTest.java\n 代码清单 14-13 ArgsTest.java\n package com.objectmentor.utilities.args; import junit.framework.TestCase; public class ArgsTest extends TestCase { public void testCreateWithNoSchemaOrArguments() throws Exception { Args args = new Args(\u0026#34;\u0026#34;, new String[0]); assertEquals(0, args.cardinality()); } public void testWithNoSchemaButWithOneArgument() throws Exception { try { new Args(\u0026#34;\u0026#34;, new String[]{\u0026#34;-x\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); } } public void testWithNoSchemaButWithMultipleArguments() throws Exception { try { new Args(\u0026#34;\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;-y\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); } } public void testNonLetterSchema() throws Exception { try { new Args(\u0026#34;*\u0026#34;, new String[]{}); fail(\u0026#34;Args constructor should have thrown exception\u0026#34;); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME, e.getErrorCode()); assertEquals(\u0026#39;*\u0026#39;, e.getErrorArgumentId()); } } public void testInvalidArgumentFormat() throws Exception { try { new Args(\u0026#34;f~\u0026#34;, new String[]{}); fail(\u0026#34;Args constructor should have throws exception\u0026#34;); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode()); assertEquals(\u0026#39;f\u0026#39;, e.getErrorArgumentId()); } } public void testSimpleBooleanPresent() throws Exception { Args args = new Args(\u0026#34;x\u0026#34;, new String[]{\u0026#34;-x\u0026#34;}); assertEquals(1, args.cardinality()); assertEquals(true, args.getBoolean(\u0026#39;x\u0026#39;)); } public void testSimpleStringPresent() throws Exception { Args args = new Args(\u0026#34;x*\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;param\u0026#34;}); assertEquals(1, args.cardinality()); assertTrue(args.has(\u0026#39;x\u0026#39;)); assertEquals(\u0026#34;param\u0026#34;, args.getString(\u0026#39;x\u0026#39;)); } public void testMissingStringArgument() throws Exception { try { new Args(\u0026#34;x*\u0026#34;, new String[]{\u0026#34;-x\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); } } public void testSpacesInFormat() throws Exception { Args args = new Args(\u0026#34;x, y\u0026#34;, new String[]{\u0026#34;-xy\u0026#34;}); assertEquals(2, args.cardinality()); assertTrue(args.has(\u0026#39;x\u0026#39;)); assertTrue(args.has(\u0026#39;y\u0026#39;)); } public void testSimpleIntPresent() throws Exception { Args args = new Args(\u0026#34;x#\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;42\u0026#34;}); assertEquals(1, args.cardinality()); assertTrue(args.has(\u0026#39;x\u0026#39;)); assertEquals(42, args.getInt(\u0026#39;x\u0026#39;)); } public void testInvalidInteger() throws Exception { try { new Args(\u0026#34;x#\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;Forty two\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); assertEquals(\u0026#34;Forty two\u0026#34;, e.getErrorParameter()); } } public void testMissingInteger() throws Exception { try { new Args(\u0026#34;x#\u0026#34;, new String[]{\u0026#34;-x\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); } } public void testSimpleDoublePresent() throws Exception { Args args = new Args(\u0026#34;x##\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;42.3\u0026#34;}); assertEquals(1, args.cardinality()); assertTrue(args.has(\u0026#39;x\u0026#39;)); assertEquals(42.3, args.getDouble(\u0026#39;x\u0026#39;), .001); } public void testInvalidDouble() throws Exception { try { new Args(\u0026#34;x##\u0026#34;, new String[]{\u0026#34;-x\u0026#34;, \u0026#34;Forty two\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); assertEquals(\u0026#34;Forty two\u0026#34;, e.getErrorParameter()); } } public void testMissingDouble() throws Exception { try { new Args(\u0026#34;x##\u0026#34;, new String[]{\u0026#34;-x\u0026#34;}); fail(); } catch (ArgsException e) { assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode()); assertEquals(\u0026#39;x\u0026#39;, e.getErrorArgumentId()); } } } Listing 14-14 ArgsExceptionTest.java\n 代码清单 14-14 ArgsExceptionTest.java\n public class ArgsExceptionTest extends TestCase { public void testUnexpectedMessage() throws Exception { ArgsException e = new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT, \u0026#39;x\u0026#39;, null); assertEquals(\u0026#34;Argument -x unexpected.\u0026#34;, e.errorMessage()); } public void testMissingStringMessage() throws Exception { ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING, \u0026#39;x\u0026#39;, null); assertEquals(\u0026#34;Could not find string parameter for -x.\u0026#34;, e.errorMessage()); } public void testInvalidIntegerMessage() throws Exception { ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER, \u0026#39;x\u0026#39;, \u0026#34;Forty two\u0026#34;); assertEquals(\u0026#34;Argument -x expects an integer but was \u0026#39;Forty two\u0026#39;.\u0026#34;, e.errorMessage()); } public void testMissingIntegerMessage() throws Exception { ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, \u0026#39;x\u0026#39;, null); assertEquals(\u0026#34;Could not find integer parameter for -x.\u0026#34;, e.errorMessage()); } public void testInvalidDoubleMessage() throws Exception { ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE, \u0026#39;x\u0026#39;, \u0026#34;Forty two\u0026#34;); assertEquals(\u0026#34;Argument -x expects a double but was \u0026#39;Forty two\u0026#39;.\u0026#34;, e.errorMessage()); } public void testMissingDoubleMessage() throws Exception { ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE, \u0026#39;x\u0026#39;, null); assertEquals(\u0026#34;Could not find double parameter for -x.\u0026#34;, e.errorMessage()); } } Listing 14-15 ArgsException.java\n 代码清单 14-15 ArgsException.java\n public class ArgsException extends Exception { private char errorArgumentId = \u0026#39;\\0\u0026#39;; private String errorParameter = \u0026#34;TILT\u0026#34;; private ErrorCode errorCode = ErrorCode.OK; public ArgsException() { } public ArgsException(String message) { super(message); } public ArgsException(ErrorCode errorCode) { this.errorCode = errorCode; } public ArgsException(ErrorCode errorCode, String errorParameter) { this.errorCode = errorCode; this.errorParameter = errorParameter; } public ArgsException(ErrorCode errorCode, char errorArgumentId, String errorParameter) { this.errorCode = errorCode; this.errorParameter = errorParameter; this.errorArgumentId = errorArgumentId; } public char getErrorArgumentId() { return errorArgumentId; } public void setErrorArgumentId(char errorArgumentId) { this.errorArgumentId = errorArgumentId; } public String getErrorParameter() { return errorParameter; } public void setErrorParameter(String errorParameter) { this.errorParameter = errorParameter; } public ErrorCode getErrorCode() { return errorCode; } public void setErrorCode(ErrorCode errorCode) { this.errorCode = errorCode; } public String errorMessage() throws Exception { switch (errorCode) { case OK: throw new Exception(\u0026#34;TILT: Should not get here.\u0026#34;); case UNEXPECTED_ARGUMENT: return String.format(\u0026#34;Argument -%c unexpected.\u0026#34;, errorArgumentId); case MISSING_STRING: return String.format(\u0026#34;Could not find string parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_INTEGER: return String.format(\u0026#34;Argument -%c expects an integer but was \u0026#39;%s\u0026#39;.\u0026#34;, errorArgumentId, errorParameter); case MISSING_INTEGER: return String.format(\u0026#34;Could not find integer parameter for -%c.\u0026#34;, errorArgumentId); case INVALID_DOUBLE: return String.format(\u0026#34;Argument -%c expects a double but was \u0026#39;%s\u0026#39;.\u0026#34;, errorArgumentId, errorParameter); case MISSING_DOUBLE: return String.format(\u0026#34;Could not find double parameter for -%c.\u0026#34;, errorArgumentId); } return \u0026#34;\u0026#34;; } public enum ErrorCode { OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, MISSING_DOUBLE, INVALID_DOUBLE } } Listing 14-16 Args.java\n 代码清单 14-16 Args.java\n public class Args { private String schema; private Map\u0026lt;Character, ArgumentMarshaler\u0026gt; marshalers = new HashMap\u0026lt;Character, ArgumentMarshaler\u0026gt;(); private Set\u0026lt;Character\u0026gt; argsFound = new HashSet\u0026lt;Character\u0026gt;(); private Iterator\u0026lt;String\u0026gt; currentArgument; private List\u0026lt;String\u0026gt; argsList; public Args(String schema, String[] args) throws ArgsException { this.schema = schema; argsList = Arrays.asList(args); parse(); } private void parse() throws ArgsException { parseSchema(); parseArguments(); } private boolean parseSchema() throws ArgsException { for (String element : schema.split(\u0026#34;,\u0026#34;)) { if (element.length() \u0026gt; 0) { parseSchemaElement(element.trim()); } } return true; } private void parseSchemaElement(String element) throws ArgsException { char elementId = element.charAt(0); String elementTail = element.substring(1); validateSchemaElementId(elementId); if (elementTail.length() == 0) marshalers.put(elementId, new BooleanArgumentMarshaler()); else if (elementTail.equals(\u0026#34;*\u0026#34;)) marshalers.put(elementId, new StringArgumentMarshaler()); else if (elementTail.equals(\u0026#34;#\u0026#34;)) marshalers.put(elementId, new IntegerArgumentMarshaler()); else if (elementTail.equals(\u0026#34;##\u0026#34;)) marshalers.put(elementId, new DoubleArgumentMarshaler()); else throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT, elementId, elementTail); } private void validateSchemaElementId(char elementId) throws ArgsException { if (!Character.isLetter(elementId)) { throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME, elementId, null); } } private void parseArguments() throws ArgsException { for (currentArgument = argsList.iterator(); currentArgument.hasNext(); ) { String arg = currentArgument.next(); parseArgument(arg); } } private void parseArgument(String arg) throws ArgsException { if (arg.startsWith(\u0026#34;-\u0026#34;)) parseElements(arg); } private void parseElements(String arg) throws ArgsException { for (int i = 1; i \u0026lt; arg.length(); i++) parseElement(arg.charAt(i)); } private void parseElement(char argChar) throws ArgsException { if (setArgument(argChar)) argsFound.add(argChar); else { throw new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT, argChar, null); } } private boolean setArgument(char argChar) throws ArgsException { ArgumentMarshaler m = marshalers.get(argChar); if (m == null) return false; try { m.set(currentArgument); return true; } catch (ArgsException e) { e.setErrorArgumentId(argChar); throw e; } } public int cardinality() { return argsFound.size(); } public String usage() { if (schema.length() \u0026gt; 0) return \u0026#34;-[\u0026#34; + schema + \u0026#34;]\u0026#34;; else return \u0026#34;\u0026#34;; } public boolean getBoolean(char arg) { ArgumentMarshaler am = marshalers.get(arg); boolean b = false; try { b = am != null \u0026amp;\u0026amp; (Boolean) am.get(); } catch (ClassCastException e) { b = false; } return b; } public String getString(char arg) { ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? \u0026#34;\u0026#34; : (String) am.get(); } catch (ClassCastException e) { return \u0026#34;\u0026#34;; } } public int getInt(char arg) { ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? 0 : (Integer) am.get(); } catch (Exception e) { return 0; } } public double getDouble(char arg) { ArgumentMarshaler am = marshalers.get(arg); try { return am == null ? 0 : (Double) am.get(); } catch (Exception e) { return 0.0; } } public boolean has(char arg) { return argsFound.contains(arg); } } The majority of the changes to the Args class were deletions. A lot of code just got moved out of Args and put into ArgsException. Nice. We also moved all the ArgumentMarshaller s into their own files. Nicer!\n 对 Args 类所做的最主要的修改是在监测部分。从 Args 里面取出了大量代码，放到 ArgsException 中。很好。我们还把全部 ArgumentMarshaler 转移到了它们自己的文件中。更好！\n Much of good software design is simply about partitioning—creating appropriate places to put different kinds of code. This separation of concerns makes the code much simpler to understand and maintain.\n 优秀的软件设计，大都关乎分隔——创建合适的空间放置不同种类的代码。对关注面的分隔让代码更易于理解和维护。\n Of special interest is the errorMessage method of ArgsException. Clearly it was a violation of the SRP to put the error message formatting into Args. Args should be about the processing of arguments, not about the format of the error messages. However, does it really make sense to put the error message formatting code into ArgsException?\n 特别有意思的是 ArgsException 中的 errorMessage 方法。显然，把错误信息格式化操作放在 Args 里面，违反了 SRP 原则。Args 应该只处理参数，不该去管错误信息的格式。然而，把错误信息格式化代码放到 ArgsException 中是否有道理呢？\n Frankly, it’s a compromise. Users who don’t like the error messages supplied by ArgsException will have to write their own. But the convenience of having canned error messages already prepared for you is not insignificant.\n 实话说，这是种折衷做法。不打算用 ArgsException 提供的错误信息的用户会想自己写错误信息。但如果有备好的错误信息，其方便之处也并非鲜见。\n By now it should be clear that we are within striking distance of the final solution that appeared at the start of this chapter. I’ll leave the final transformations to you as an exercise.\n 现在，显然我们已经非常接近本章开始处所展示的最终解决方案了。最后的工作留给你来练习完成。\n 14.4 CONCLUSION 小结 #  It is not enough for code to work. Code that works is often badly broken. Programmers who satisfy themselves with merely working code are behaving unprofessionally. They may fear that they don’t have time to improve the structure and design of their code, but I disagree. Nothing has a more profound and long-term degrading effect upon a development project than bad code. Bad schedules can be redone, bad requirements can be redefined. Bad team dynamics can be repaired. But bad code rots and ferments, becoming an inexorable weight that drags the team down. Time and time again I have seen teams grind to a crawl because, in their haste, they created a malignant morass of code that forever thereafter dominated their destiny.\n 代码能工作还不够。能工作的代码经常会严重崩溃。满足于仅仅让代码能工作的程序员不够专业。他们会害怕没时间改进代码的结构和设计，我不敢苟同。没什么能比糟糕的代码给开发项目带来更深远和长期的损害了。进度可以重订，需求可以重新定义，团队动态可以修正。但糟糕的代码只是一直腐败发酵，无情地拖着团队的后腿。我无数次看到开发团队蹒跚前行，只因为他们匆匆搞出一片代码沼泽，从此之后命运再也不受自己控制。\n Of course bad code can be cleaned up. But it’s very expensive. As code rots, the modules insinuate themselves into each other, creating lots of hidden and tangled dependencies. Finding and breaking old dependencies is a long and arduous task. On the other hand, keeping code clean is relatively easy. If you made a mess in a module in the morning, it is easy to clean it up in the afternoon. Better yet, if you made a mess five minutes ago, it’s very easy to clean it up right now.\n 当然，糟糕的代码可以清理。不过成本高昂。随着代码腐败下去，模块之间互相渗透，出现大量隐藏纠结的依赖关系。找到和破除陈旧的依赖关系又费时间又费劲。另一方面，保持代码整洁却相对容易。早晨在模块中制造出一堆混乱，下午就能轻易清理掉。更好的情况是，5 分钟之前制造出混乱，马上就能很容易地清理掉。\n So the solution is to continuously keep your code as clean and simple as it can be. Never let the rot get started.\n 所以，解决之道就是保持代码持续整洁和简单。永不让腐坏有机会开始。\n "});index.add({'id':203,'href':'/docs/Clean-Code/15.-JUnit-Internals/ch15/','title':"Ch15",'section':"Go语言圣经",'content':"第 15 章 JUnit Internals JUnit 内幕 #   JUnit is one of the most famous of all Java frameworks. As frameworks go, it is simple in conception, precise in definition, and elegant in implementation. But what does the code look like? In this chapter we’ll critique an example drawn from the JUnit framework.\n JUnit 是最有名的 Java 框架之一。就像别的框架一样，它概念简单，定义精确，实现优雅。但它的代码是怎样的呢？本章将研判来自 JUnit 框架的一个代码例子。\n 15.1THE JUNIT FRAMEWORK JUnit 框架 #  JUnit has had many authors, but it began with Kent Beck and Eric Gamma together on a plane to Atlanta. Kent wanted to learn Java, and Eric wanted to learn about Kent’s Smalltalk testing framework. “What could be more natural to a couple of geeks in cramped quarters than to pull out our laptops and start coding?”1 After three hours of high-altitude work, they had written the basics of JUnit.\n JUnit 有很多位作者，但它始于 Kent Beck 和 Eric Gamma 一次去亚特兰大的飞行旅程。Kent 想学 Java，而 Eric 则打算学习 Kent 的 Smalltalk 测试框架。“对于两个身处狭窄空间的奇客，还有什么会比拿出笔记本电脑开始编码来得更自然呢？”经过 3 小时高海拔工作，他们写出了 JUnit 的基础代码。\n The module we’ll look at is the clever bit of code that helps identify string comparison errors. This module is called ComparisonCompactor. Given two strings that differ, such as ABCDE and ABXDE, it will expose the difference by generating a string such as \u0026lt;…B[X]D…\u0026gt;.\n 我们要查看的模块，是用来帮忙鉴别字符串比较错误的一段聪明代码。该模块被命名为 ComparisonCompactor。对于两个不同的字符串，例如 ABCDE 和 ABXDE，它将用形如\u0026lt;…B[X]D…\u0026gt;的字符串来曝露两者的不同之处。\n I could explain it further, but the test cases do a better job. So take a look at Listing 15-1 and you will understand the requirements of this module in depth. While you are at it, critique the structure of the tests. Could they be simpler or more obvious?\n 我可以做进一步解释，但测试用例会更有说服力。看看代码清单 15-1，你将深入了解到该模块满足的需求。边看代码，边研究该测试的结构。它们能变得更简洁或更明确吗？\n Listing 15-1 ComparisonCompactorTest.java\n 代码清单 15-1 ComparisonCompactorTest.java\n package junit.tests.framework; import junit.framework.ComparisonCompactor; import junit.framework.TestCase; public class ComparisonCompactorTest extends TestCase { public void testMessage() { String failure = new ComparisonCompactor(0, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;).compact(\u0026#34;a\u0026#34;); assertTrue(\u0026#34;a expected:\u0026lt;[b]\u0026gt; but was:\u0026lt;[c]\u0026gt;\u0026#34;.equals(failure)); } public void testStartSame() { String failure = new ComparisonCompactor(1, \u0026#34;ba\u0026#34;, \u0026#34;bc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;b[a]\u0026gt; but was:\u0026lt;b[c]\u0026gt;\u0026#34;, failure); } public void testEndSame() { String failure = new ComparisonCompactor(1, \u0026#34;ab\u0026#34;, \u0026#34;cb\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;[a]b\u0026gt; but was:\u0026lt;[c]b\u0026gt;\u0026#34;, failure); } public void testSame() { String failure = new ComparisonCompactor(1, \u0026#34;ab\u0026#34;, \u0026#34;ab\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;ab\u0026gt; but was:\u0026lt;ab\u0026gt;\u0026#34;, failure); } public void testNoContextStartAndEndSame() { String failure = new ComparisonCompactor(0, \u0026#34;abc\u0026#34;, \u0026#34;adc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;…[b]…\u0026gt; but was:\u0026lt;…[d]…\u0026gt;\u0026#34;, failure); } public void testStartAndEndContext() { String failure = new ComparisonCompactor(1, \u0026#34;abc\u0026#34;, \u0026#34;adc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;a[b]c\u0026gt; but was:\u0026lt;a[d]c\u0026gt;\u0026#34;, failure); } public void testStartAndEndContextWithEllipses() { String failure = new ComparisonCompactor(1, \u0026#34;abcde\u0026#34;, \u0026#34;abfde\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;…b[c]d…\u0026gt; but was:\u0026lt;…b[f]d…\u0026gt;\u0026#34;, failure); } public void testComparisonErrorStartSameComplete() { String failure = new ComparisonCompactor(2, \u0026#34;ab\u0026#34;, \u0026#34;abc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;ab[]\u0026gt; but was:\u0026lt;ab[c]\u0026gt;\u0026#34;, failure); } public void testComparisonErrorEndSameComplete() { String failure = new ComparisonCompactor(0, \u0026#34;bc\u0026#34;, \u0026#34;abc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;[]…\u0026gt; but was:\u0026lt;[a]…\u0026gt;\u0026#34;, failure); } public void testComparisonErrorEndSameCompleteContext() { String failure = new ComparisonCompactor(2, \u0026#34;bc\u0026#34;, \u0026#34;abc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;[]bc\u0026gt; but was:\u0026lt;[a]bc\u0026gt;\u0026#34;, failure); } public void testComparisonErrorOverlapingMatches() { String failure = new ComparisonCompactor(0, \u0026#34;abc\u0026#34;, \u0026#34;abbc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;…[]…\u0026gt; but was:\u0026lt;…[b]…\u0026gt;\u0026#34;, failure); } public void testComparisonErrorOverlapingMatchesContext() { String failure = new ComparisonCompactor(2, \u0026#34;abc\u0026#34;, \u0026#34;abbc\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;ab[]c\u0026gt; but was:\u0026lt;ab[b]c\u0026gt;\u0026#34;, failure); } public void testComparisonErrorOverlapingMatches2() { String failure = new ComparisonCompactor(0, \u0026#34;abcdde\u0026#34;, \u0026#34;abcde\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;…[d]…\u0026gt; but was:\u0026lt;…[]…\u0026gt;\u0026#34;, failure); } public void testComparisonErrorOverlapingMatches2Context() { String failure = new ComparisonCompactor(2, \u0026#34;abcdde\u0026#34;, \u0026#34;abcde\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;…cd[d]e\u0026gt; but was:\u0026lt;…cd[]e\u0026gt;\u0026#34;, failure); } public void testComparisonErrorWithActualNull() { String failure = new ComparisonCompactor(0, \u0026#34;a\u0026#34;, null).compact(null); assertEquals(\u0026#34;expected:\u0026lt;a\u0026gt; but was:\u0026lt;null\u0026gt;\u0026#34;, failure); } public void testComparisonErrorWithActualNullContext() { String failure = new ComparisonCompactor(2, \u0026#34;a\u0026#34;, null).compact(null); assertEquals(\u0026#34;expected:\u0026lt;a\u0026gt; but was:\u0026lt;null\u0026gt;\u0026#34;, failure); } public void testComparisonErrorWithExpectedNull() { String failure = new ComparisonCompactor(0, null, \u0026#34;a\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;null\u0026gt; but was:\u0026lt;a\u0026gt;\u0026#34;, failure); } public void testComparisonErrorWithExpectedNullContext() { String failure = new ComparisonCompactor(2, null, \u0026#34;a\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;null\u0026gt; but was:\u0026lt;a\u0026gt;\u0026#34;, failure); } public void testBug609972() { String failure = new ComparisonCompactor(10, \u0026#34;S\u0026amp;P500\u0026#34;, \u0026#34;0\u0026#34;).compact(null); assertEquals(\u0026#34;expected:\u0026lt;[S\u0026amp;P50]0\u0026gt; but was:\u0026lt;[]0\u0026gt;\u0026#34;, failure); } } I ran a code coverage analysis on the ComparisonCompactor using these tests. The code is 100 percent covered. Every line of code, every if statement and for loop, is executed by the tests. This gives me a high degree of confidence that the code works and a high degree of respect for the craftsmanship of the authors.\n 我对用到这些测试的 ComparisonCompactor 进行了代码覆盖分析。代码被 100%覆盖了。每行代码、每个 if 语句和 for 循环都被测试执行了。于是我对代码的工作能力有了极高的信心，也对代码作者们的技艺产生了极高的尊敬。\n The code for ComparisonCompactor is in Listing 15-2. Take a moment to look over this code. I think you’ll find it to be nicely partitioned, reasonably expressive, and simple in structure. Once you are done, then we’ll pick the nits together.\n ComparisonCompactor 的代码如代码清单 15-2 所示。\n Listing 15-2 ComparisonCompactor.java (Original)\n 代码清单 15-2 ComparisonCompactor.java（原始版本）\n package junit.framework; public class ComparisonCompactor { private static final String ELLIPSIS = \u0026#34;…\u0026#34;; private static final String DELTA_END = \u0026#34;]\u0026#34;; private static final String DELTA_START = \u0026#34;[\u0026#34;; private int fContextLength; private String fExpected; private String fActual; private int fPrefix; private int fSuffix; public ComparisonCompactor(int contextLength, String expected, String actual) { fContextLength = contextLength; fExpected = expected; fActual = actual; } public String compact(String message) { if (fExpected == null || fActual == null || areStringsEqual()) return Assert.format(message, fExpected, fActual); findCommonPrefix(); findCommonSuffix(); String expected = compactString(fExpected); String actual = compactString(fActual); return Assert.format(message, expected, actual); } private String compactString(String source) { String result = DELTA_START + source.substring(fPrefix, source.length() - fSuffix + 1) + DELTA_END; if (fPrefix \u0026gt; 0) result = computeCommonPrefix() + result; if (fSuffix \u0026gt; 0) result = result + computeCommonSuffix(); return result; } private void findCommonPrefix() { fPrefix = 0; int end = Math.min(fExpected.length(), fActual.length()); for (; fPrefix \u0026lt; end; fPrefix++) { if (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix)) break; } } private void findCommonSuffix() { int expectedSuffix = fExpected.length() - 1; int actualSuffix = fActual.length() - 1; for (; actualSuffix \u0026gt;= fPrefix \u0026amp;\u0026amp; expectedSuffix \u0026gt;= fPrefix; actualSuffix--, expectedSuffix--) { if (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix)) break; } fSuffix = fExpected.length() - expectedSuffix; } private String computeCommonPrefix() { return (fPrefix \u0026gt; fContextLength ? ELLIPSIS : \u0026#34;\u0026#34;) + fExpected.substring(Math.max(0, fPrefix - fContextLength), fPrefix); } private String computeCommonSuffix() { int end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength, fExpected.length()); return fExpected.substring(fExpected.length() - fSuffix + 1, end) + (fExpected.length() - fSuffix + 1 \u0026lt; fExpected.length() - fContextLength ? ELLIPSIS : \u0026#34;\u0026#34;); } private boolean areStringsEqual() { return fExpected.equals(fActual); } } You might have a few complaints about this module. There are some long expressions and some strange +1s and so forth. But overall this module is pretty good. After all, it might have looked like Listing 15-3.\n 你可能会对这个模块有所抱怨。里面有些长表达式，有些奇怪的+1 操作，如此等等。不过，总的来说，这个模块很不错。毕竟它原本可能被写成如代码清单 15-3 中的样子。\n Listing 15-3 ComparisonCompator.java (defactored)\n 代码清单 15-3 ComparisonCompator.java（背离版本）\n package junit.framework; public class ComparisonCompactor { private int ctxt; private String s1; private String s2; private int pfx; private int sfx; public ComparisonCompactor(int ctxt, String s1, String s2) { this.ctxt = ctxt; this.s1 = s1; this.s2 = s2; } public String compact(String msg) { if (s1 == null || s2 == null || s1.equals(s2)) return Assert.format(msg, s1, s2); pfx = 0; for (; pfx \u0026lt; Math.min(s1.length(), s2.length()); pfx++) { if (s1.charAt(pfx) != s2.charAt(pfx)) break; } int sfx1 = s1.length() - 1; int sfx2 = s2.length() - 1; for (; sfx2 \u0026gt;= pfx \u0026amp;\u0026amp; sfx1 \u0026gt;= pfx; sfx2--, sfx1--) { if (s1.charAt(sfx1) != s2.charAt(sfx2)) break; } sfx = s1.length() - sfx1; String cmp1 = compactString(s1); String cmp2 = compactString(s2); return Assert.format(msg, cmp1, cmp2); } private String compactString(String s) { String result = \u0026#34;[\u0026#34; + s.substring(pfx, s.length() - sfx + 1) + \u0026#34;]\u0026#34;; if (pfx \u0026gt; 0) result = (pfx \u0026gt; ctxt ? \u0026#34;…\u0026#34; : \u0026#34;\u0026#34;) + s1.substring(Math.max(0, pfx - ctxt), pfx) + result; if (sfx \u0026gt; 0) { int end = Math.min(s1.length() - sfx + 1 + ctxt, s1.length()); result = result + (s1.substring(s1.length() - sfx + 1, end) + (s1.length() - sfx + 1 \u0026lt; s1.length() - ctxt ? \u0026#34;…\u0026#34; : \u0026#34;\u0026#34;)); } return result; } } Even though the authors left this module in very good shape, the Boy Scout Rule2 tells us we should leave it cleaner than we found it. So, how can we improve on the original code in Listing 15-2?\n 即便作者们把这个模块写得已经很棒，但童子军军规却告诉我们，离时要比来时整洁。所以，我们怎样才能改进代码清单 15-2 中的原始代码呢？\n The first thing I don’t care for is the f prefix for the member variables [N6]. Today’s environments make this kind of scope encoding redundant. So let’s eliminate all the f’s.\n 我首先看到的是成员变量的 f 前缀[N6]。在现今的运行环境中，这类范围性编码纯属多余。所以，先删除所有的 f 前缀。\n private int contextLength; private String expected; private String actual; private int prefix; private int suffix; Next, we have an unencapsulated conditional at the beginning of the compact function [G28].\n 下一步，在 compact 函数开始处，有一个未封装的条件判断[G28]。\n public String compact(String message) { if (expected == null || actual == null || areStringsEqual()) return Assert.format(message, expected, actual); findCommonPrefix(); findCommonSuffix(); String expected = compactString(this.expected); String actual = compactString(this.actual); return Assert.format(message, expected, actual); } This conditional should be encapsulated to make our intent clear. So let’s extract a method that explains it.\n 这个条件判断应当封装起来，从而更清晰地表达代码的意图。我们拆解出一个方法，解释这个条件判断。\n public String compact(String message) { if (shouldNotCompact()) return Assert.format(message, expected, actual); findCommonPrefix(); findCommonSuffix(); String expected = compactString(this.expected); String actual = compactString(this.actual); return Assert.format(message, expected, actual); } private boolean shouldNotCompact() { return expected == null || actual == null || areStringsEqual(); } I don’t much care for the this.expected and this.actual notation in the compact function. This happened when we changed the name of fExpected to expected. Why are there variables in this function that have the same names as the member variables? Don’t they represent something else [N4]? We should make the names unambiguous.\n 我也不太喜欢 compact 函数中的 this.expected 和 this.actual 符号。这个是我们把 fExpected 改为 expected 时发生的。为什么函数中的变量会与成员变量同名呢？它们不是该表示其他意思吗[N4]？我们应该区分这些名称。\n String compactExpected = compactString(expected); String compactActual = compactString(actual); Negatives are slightly harder to understand than positives [G29]. So let’s turn that if statement on its head and invert the sense of the conditional.\n 否定式稍微比肯定式难理解一些[G29]。我们把 if 语句放到上头，调转条件判断。\n public String compact(String message) { if (canBeCompacted()) { findCommonPrefix(); findCommonSuffix(); String compactExpected = compactString(expected); String compactActual = compactString(actual); return Assert.format(message, compactExpected, compactActual); } else { return Assert.format(message, expected, actual); } } private boolean canBeCompacted() { return expected != null \u0026amp;\u0026amp; actual != null \u0026amp;\u0026amp; ! areStringsEqual(); } The name of the function is strange [N7]. Although it does compact the strings, it actually might not compact the strings if canBeCompacted returns false. So naming this function compact hides the side effect of the error check. Notice also that the function returns a formatted message, not just the compacted strings. So the name of the function should really be formatCompactedComparison. That makes it read a lot better when taken with the function argument:\n 函数名很奇怪[N7]。尽管它的确会压缩字符串，但如果 canBeCompact 为 false，它实际上就不会压缩字符串。用 compact 来命名，隐藏了错误检查的副作用。注意，该函数返回一条格式化后的消息，而不仅仅只是压缩后的字符串。所以，函数名其实应该是 formatCompacted Comparison。在用以下参数调用时，读起来会好很 多：\n public String formatCompactedComparison(String message) { The body of the if statement is where the true compacting of the expected and actual strings is done. We should extract that as a method named compactExpectedAndActual. However, we want the formatCompactedComparison function to do all the formatting. The compact… function should do nothing but compacting [G30]. So let’s split it up as follows:\n 两个字符串是在 if 语句体中压缩的。我们应当拆分出一个名为 compactExpectedAndActual 的方法。然而，我们希望 formatCompactComparison 函数完成所有的格式化工作。而 compact…函数除了压缩之外什么都不做[G30]。所以，做如下拆分：\n … private String compactExpected; private String compactActual; … public String formatCompactedComparison(String message) { if (canBeCompacted()) { compactExpectedAndActual(); return Assert.format(message, compactExpected, compactActual); } else { return Assert.format(message, expected, actual); } } private void compactExpectedAndActual() { findCommonPrefix(); findCommonSuffix(); compactExpected = compactString(expected); compactActual = compactString(actual); } Notice that this required us to promote compactExpected and compactActual to member variables. I don’t like the way that the last two lines of the new function return variables, but the first two don’t. They aren’t using consistent conventions [G11]. So we should change findCommonPrefix and findCommonSuffix to return the prefix and suffix values.\n 注意，这要求我们向成员变量举荐 compactExpected 和 compactActual。我不喜欢新函数最后两行返回变量的方式，但前两个可不是这样。它们没采用一以贯之的约定[G11]。我们应该修改 findCommonPrefix 和 findCommonSuffix，返回前缀和后缀值。\n private void compactExpectedAndActual() { prefixIndex = findCommonPrefix(); suffixIndex = findCommonSuffix(); compactExpected = compactString(expected); compactActual = compactString(actual); } private int findCommonPrefix() { int prefixIndex = 0; int end = Math.min(expected.length(), actual.length()); for (; prefixIndex \u0026lt; end; prefixIndex++) { if (expected.charAt(prefixIndex) != actual.charAt(prefixIndex)) break; } return prefixIndex; } private int findCommonSuffix() { int expectedSuffix = expected.length() - 1; int actualSuffix = actual.length() - 1; for (; actualSuffix \u0026gt;= prefixIndex \u0026amp;\u0026amp; expectedSuffix \u0026gt;= prefixIndex; actualSuffix--, expectedSuffix--) { if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) break; } return expected.length() - expectedSuffix; } We should also change the names of the member variables to be a little more accurate [N1]; after all, they are both indices.\n 我们还应该修改成员变量的名称，使之更准确一点[N1]；毕竟它们都是索引。\n Careful inspection of findCommonSuffix exposes a hidden temporal coupling [G31]; it depends on the fact that prefixIndex is calculated by findCommonPrefix. If these two functions were called out of order, there would be a difficult debugging session ahead. So, to expose this temporal coupling, let’s have findCommonSuffix take the prefixIndex as an argument.\n 仔细检查 findCommonSuffix，其中藏了个时序性耦合[G31]；它依赖于 prefixIndex 是由 findCommonSuffix 计算得来的事实。如果这两个方法不是按这样的顺序调用，调试就会变得困难。为了暴露这个时序性耦合，我们将 prefixIndex 做成 find 的参数。\n private void compactExpectedAndActual() { prefixIndex = findCommonPrefix(); suffixIndex = findCommonSuffix(prefixIndex); compactExpected = compactString(expected); compactActual = compactString(actual); } private int findCommonSuffix(int prefixIndex) { int expectedSuffix = expected.length() - 1; int actualSuffix = actual.length() - 1; for (; actualSuffix \u0026gt;= prefixIndex \u0026amp;\u0026amp; expectedSuffix \u0026gt;= prefixIndex; actualSuffix--, expectedSuffix--) { if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) break; } return expected.length() - expectedSuffix; } I’m not really happy with this. The passing of the prefixIndex argument is a bit arbitrary [G32]. It works to establish the ordering but does nothing to explain the need for that ordering. Another programmer might undo what we have done because there’s no indication that the parameter is really needed. So let’s take a different tack.\n 我对这样的方式不太满意。传递 prefixIndex 参数有些随意[G32]。它成功维持了执行次序，但对于解释排序的需要却毫无作用。其他程序员可能会抹杀我们刚完成的工作，因为并没有迹象说明该参数确属必要。还是采取别的做法吧。\n private void compactExpectedAndActual() { findCommonPrefixAndSuffix(); compactExpected = compactString(expected); compactActual = compactString(actual); } private void findCommonPrefixAndSuffix() { findCommonPrefix(); int expectedSuffix = expected.length() - 1; int actualSuffix = actual.length() - 1; for (; actualSuffix \u0026gt;= prefixIndex \u0026amp;\u0026amp; expectedSuffix \u0026gt;= prefixIndex; actualSuffix--, expectedSuffix-- ) { if (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix)) break; } suffixIndex = expected.length() - expectedSuffix; } private void findCommonPrefix() { prefixIndex = 0; int end = Math.min(expected.length(), actual.length()); for (; prefixIndex \u0026lt; end; prefixIndex++) if (expected.charAt(prefixIndex) != actual.charAt(prefixIndex)) break; } We put findCommonPrefix and findCommonSuffix back the way they were, changing the name of findCommonSuffix to findCommonPrefixAnd Suffix and having it call findCommon-Prefix before doing anything else. That establishes the temporal nature of the two functions in a much more dramatic way than the previous solution. It also points out how ugly findCommonPrefixAndSuffix is. Let’s clean it up now.\n 我们恢复 findCommonPreffix 和 findCommonSuffix 的原样，把 findCommonSuffix 的名称改为 findCommonPrefixAndSuffix，让它在执行其他操作之前，先调用 findCommonPrefix。这样一来，就以一种相比前种手段更为有效的方式建立了两个函数之间的时序关系。\n private void findCommonPrefixAndSuffix() { findCommonPrefix(); int suffixLength = 1; for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) { if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)) break; } suffixIndex = suffixLength; } private char charFromEnd(String s, int i) { return s.charAt(s.length() - i); } private boolean suffixOverlapsPrefix(int suffixLength) { return actual.length() - suffixLength \u0026lt; prefixLength || expected.length() - suffixLength \u0026lt; prefixLength; } This is much better. It exposes that the suffixIndex is really the length of the suffix and is not well named. The same is true of the prefixIndex, though in that case “index” and “length” are synonymous. Even so, it is more consistent to use “length.” The problem is that the suffixIndex variable is not zero based; it is 1 based and so is not a true length. This is also the reason that there are all those +1s in computeCommonSuffix [G33]. So let’s fix that. The result is in Listing 15-4.\n 这样就好多了。它暴露出 suffixIndex 其实是后缀的长度，而且名字没取好。对于 prefix 也是如此。虽然在那样一种情形下 index 和 length 是同义的，但使用 length 一词却更有一贯性。问题在于，suffixIndex 变量并不从 0 开始，它从 1 开始，所以并非真正的长度。这也是 computeCommonSuffix 中那些+1 存在的原因[G33]。来修正它们吧。结果就是代码清单 15-4。\n Listing 15-4 ComparisonCompactor.java (interim)\n 代码清单 15-4 ComparisonCompactor.java（过渡版本）\n public class ComparisonCompactor { // …  private int suffixLength; // …  private void findCommonPrefixAndSuffix() { findCommonPrefix(); suffixLength = 0; for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) { if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength)) break; } } private char charFromEnd(String s, int i) { return s.charAt(s.length() - i - 1); } private boolean suffixOverlapsPrefix(int suffixLength) { return actual.length() - suffixLength \u0026lt;= prefixLength || expected.length() - suffixLength \u0026lt;= prefixLength; } // …  private String compactString(String source) { String result = DELTA_START + source.substring(prefixLength, source.length() - suffixLength) + DELTA_END; if (prefixLength \u0026gt; 0) result = computeCommonPrefix() + result; if (suffixLength \u0026gt; 0) result = result + computeCommonSuffix(); return result; } // …  private String computeCommonSuffix() { int end = Math.min(expected.length() - suffixLength + contextLength, expected.length() ); return expected.substring(expected.length() - suffixLength, end) + (expected.length() - suffixLength \u0026lt; expected.length() - contextLength ? ELLIPSIS : \u0026#34;\u0026#34;); } } We replaced the +1s in computeCommonSuffix with a -1 in charFromEnd, where it makes perfect sense, and two \u0026lt;= operators in suffixOverlapsPrefix, where they also make perfect sense. This allowed us to change the name of suffixIndex to suffixLength, greatly enhancing the readability of the code.\n 我们用 charFromEnd 中的那个-1 替代了 computeCommonSuffix 中的一堆+1，前者更为合情合理，suffixOverlapsPrefix 中的两个“\u0026lt;=”操作符也同理。这样我们就能修改 suffixIndex 和 suffixLength 的名称，极大地提升了代码的可读性。\n There is a problem however. As I was eliminating the +1s, I noticed the following line in compactString:\n 不过还有一个问题。在消灭那些+1 时，我注意到 compactString 中的以下代码：\n if (suffixLength \u0026gt; 0) Take a look at it in Listing 15-4. By rights, because suffixLength is now one less than it used to be, I should change the \u0026gt; operator to a \u0026gt;= operator. But that makes no sense. It makes sense now! This means that it didn’t use to make sense and was probably a bug. Well, not quite a bug. Upon further analysis we see that the if statement now prevents a zero length suffix from being appended. Before we made the change, the if statement was nonfunctional because suffixIndex could never be less than one!\n 看看代码清单 15-4 中的这行代码。因为 suffixLength 现在要比原本少 1，我应该把“\u0026gt;”操作符改为“\u0026gt;=”操作符。那本无道理，不过现在却有意义！这表示这么做没道理，而且可能是个缺陷。嗯，也不算是个缺陷。从之前的分析中我们可以看到，if 语句现在会放置添加长度为零的后缀。在作出修改之前，if 语句没有作用，因为 suffixIndex 永不会小于 1。\n This calls into question both if statements in compactString! It looks as though they could both be eliminated. So let’s comment them out and run the tests. They passed! So let’s restructure compactString to eliminate the extraneous if statements and make the function much simpler [G9].\n 这说明 compactString 中的两个 if 语句都有问题！看起来它们都该删除。所以，我们将其注释掉，运行测试。测试通过了！那就重新构架 compactString，删除没用的 if 语句，将函数改得更加简洁[G9]。\n private String compactString(String source) { return computeCommonPrefix() + DELTA_START + source.substring(prefixLength, source.length() - suffixLength) + DELTA_END + computeCommonSuffix(); } This is much better! Now we see that the compactString function is simply composing the fragments together. We can probably make this even clearer. Indeed, there are lots of little cleanups we could do. But rather than drag you through the rest of the changes, I’ll just show you the result in Listing 15-5.\n 这样就好多了！现在我们看到，compactString 函数只是把片段组合起来。我们甚至可以让它更清晰。有许多细微的整理工作可做。与其拖着你遍历剩下的那些修改，我更愿意直接展示代码清单 15-5 中的结果。\n Listing 15-5 ComparisonCompactor.java (final)\n 代码清单 15-5 ComparisonCompactor.java（最终版）\n package junit.framework; public class ComparisonCompactor { private static final String ELLIPSIS = \u0026#34;…\u0026#34;; private static final String DELTA_END = \u0026#34;]\u0026#34;; private static final String DELTA_START = \u0026#34;[\u0026#34;; private int contextLength; private String expected; private String actual; private int prefixLength; private int suffixLength; public ComparisonCompactor( int contextLength, String expected, String actual ) { this.contextLength = contextLength; this.expected = expected; this.actual = actual; } public String formatCompactedComparison(String message) { String compactExpected = expected; String compactActual = actual; if (shouldBeCompacted()) { findCommonPrefixAndSuffix(); compactExpected = compact(expected); compactActual = compact(actual); } return Assert.format(message, compactExpected, compactActual); } private boolean shouldBeCompacted() { return !shouldNotBeCompacted(); } private boolean shouldNotBeCompacted() { return expected == null || actual == null || expected.equals(actual); } private void findCommonPrefixAndSuffix() { findCommonPrefix(); suffixLength = 0; for (; !suffixOverlapsPrefix(); suffixLength++) { if (charFromEnd(expected, suffixLength) != charFromEnd(actual, suffixLength) ) break; } } private char charFromEnd(String s, int i) { return s.charAt(s.length() - i - 1); } private boolean suffixOverlapsPrefix() { return actual.length() - suffixLength \u0026lt;= prefixLength || expected.length() - suffixLength \u0026lt;= prefixLength; } private void findCommonPrefix() { prefixLength = 0; int end = Math.min(expected.length(), actual.length()); for (; prefixLength \u0026lt; end; prefixLength++) if (expected.charAt(prefixLength) != actual.charAt(prefixLength)) break; } private String compact(String s) { return new StringBuilder() .append(startingEllipsis()) .append(startingContext()) .append(DELTA_START) .append(delta(s)) .append(DELTA_END) .append(endingContext()) .append(endingEllipsis()) .toString(); } private String startingEllipsis() { return prefixLength \u0026gt; contextLength ? ELLIPSIS : \u0026#34;\u0026#34;; } private String startingContext() { int contextStart = Math.max(0, prefixLength - contextLength); int contextEnd = prefixLength; return expected.substring(contextStart, contextEnd); } private String delta(String s) { int deltaStart = prefixLength; int deltaEnd = s.length() - suffixLength; return s.substring(deltaStart, deltaEnd); } private String endingContext() { int contextStart = expected.length() - suffixLength; int contextEnd = Math.min(contextStart + contextLength, expected.length()); return expected.substring(contextStart, contextEnd); } private String endingEllipsis() { return (suffixLength \u0026gt; contextLength ? ELLIPSIS : \u0026#34;\u0026#34;); } } This is actually quite pretty. The module is separated into a group of analysis functions and another group of synthesis functions. They are topologically sorted so that the definition of each function appears just after it is used. All the analysis functions appear first, and all the synthesis functions appear last.\n 这的确很漂亮。模块分解成了一组分析函数和一组合成函数。它们以一种拓扑方式排序，每个函数的定义都正好在其被调用的位置后面。所有的分析函数都先出现，而所有的合成函数都最后出现。\n If you look carefully, you will notice that I reversed several of the decisions I made earlier in this chapter. For example, I inlined some extracted methods back into formatCompactedComparison, and I changed the sense of the shouldNotBeCompacted expression. This is typical. Often one refactoring leads to another that leads to the undoing of the first. Refactoring is an iterative process full of trial and error, inevitably converging on something that we feel is worthy of a professional.\n 仔细阅读，你会发现我推翻了在本章较前位置做出的几个决定。例如，我将几个分解出来的方法重新内联为 formatCompactComparison，我修改了 souldNotBeCompacted 表达式的意思。这种做法很常见。重构常会导致另一次推翻此次重构的重构。重构是一种不停试错的迭代过程，不可避免地集中于我们认为是专业人员该做的事。\n 15.2 CONCLUSION 小结 #  And so we have satisfied the Boy Scout Rule. We have left this module a bit cleaner than we found it. Not that it wasn’t clean already. The authors had done an excellent job with it. But no module is immune from improvement, and each of us has the responsibility to leave the code a little better than we found it.\n 如此我们遵循了童子军军规。模块比我们发现它时更整洁了。不是说它原本不整洁。作者们做了卓越的工作。但模块都能再改进，我们每个人也有责任把模块改进得比发现时更整洁。\n "});index.add({'id':204,'href':'/docs/Clean-Code/16.-Refactoring-SerialDate/ch16/','title':"Ch16",'section':"Go语言圣经",'content':"第 16 章 Refactoring SerialDate 重构 SerialDate #   If you go to http://www.jfree.org/jcommon/index.php, you will find the JCommon library. Deep within that library there is a package named org.jfree.date. Within that package there is a class named SerialDate. We are going to explore that class.\n 如果你访问 http://www.jfree.org/jcommon/index.php，就能找到 JCommon 类库。深入该类库，其中有个名为 org.jfree.date 的程序包。在该程序包中，有个名为 SerialDate 的类。我们即将剖析这个类。\n The author of SerialDate is David Gilbert. David is clearly an experienced and competent programmer. As we shall see, he shows a significant degree of professionalism and discipline within his code. For all intents and purposes, this is “good code.” And I am going to rip it to pieces.\n SerialDate 的作者是 David Gilbert。David 显然是位经验丰富、能力足够的程序员。如我们将看到的，他在代码中展示了极高的专业性和原则性。无论怎么说，这都是“好代码”。而我将把它撕成碎片。\n This is not an activity of malice. Nor do I think that I am so much better than David that I somehow have a right to pass judgment on his code. Indeed, if you were to find some of my code, I’m sure you could find plenty of things to complain about.\n 这并非恶意的行为。我也不认为自己比戴维强许多，有权对他的代码说三道四。其实，如果你看过我的代码，我敢说你也会发现好些该埋怨的东西。\n No, this is not an activity of nastiness or arrogance. What I am about to do is nothing more and nothing less than a professional review. It is something that we should all be comfortable doing. And it is something we should welcome when it is done for us. It is only through critiques like these that we will learn. Doctors do it. Pilots do it. Lawyers do it. And we programmers need to learn how to do it too.\n 不，这也并非傲慢无礼的行为。我所要做的，只是一种专业眼光的检视，不多也不少。那是我们都该坦然接受的做法。那是我们应该欢迎别人对自己做的事。只有通过这样的批评，我们才能学到东西。医生就是这样做的。飞行员就是这样做的。律师就是这样做的。我们程序员也需要学习如何这样做。\n One more thing about David Gilbert: David is more than just a good programmer. David had the courage and good will to offer his code to the community at large for free. He placed it out in the open for all to see and invited public usage and public scrutiny. This was well done!\n 多说一句关于 David Gilbert 的事：David 不止是位优秀的程序员。戴维有着将代码免费呈献给社区的勇气和好心。他公开代码，让所有人都能看到，邀请大众使用并审查。做得真好！\n SerialDate (Listing B-1, page 349) is a class that represents a date in Java. Why have a class that represents a date, when Java already has java.util.Date and java.util.Calendar, and others? The author wrote this class in response to a pain that I have often felt myself. The comment in his opening Javadoc (line 67) explains it well. We could quibble about his intention, but I have certainly had to deal with this issue, and I welcome a class that is about dates instead of times.\n SerialDate（见代码清单 B-1）是一个用 Java 呈现一个日期的类。为什么在 Java 已经有 java.util.Date 和 java.util.Calendar 的时候，还需要一个呈现日期的类呢？作者编写这个类，是为了响应我自己也常感到的痛苦。在开放的 Javadoc（第 67 行）中，他很好地解释了原因。我们可以质疑他的初衷，但我的确有处理这个问题的需要，而且我也欢迎有个关心日期甚于时间的类存在。\n 16.1 FIRST, MAKE IT WORK 首先，让它能工作 #  There are some unit tests in a class named SerialDateTests (Listing B-2, page 366). The tests all pass. Unfortunately a quick inspection of the tests shows that they don’t test everything [T1]. For example, doing a “Find Usages” search on the method MonthCodeToQuarter (line 334) indicates that it is not used [F4]. Therefore, the unit tests don’t test it.\n 在一个名为 SerialDateTests 的类（见代码清单 B-2）中，有一些单元测试。测试都通过了。不幸的是，快览一遍测试，发现它们并没有测试所有东西[T1]。例如，用“查找使用”搜索方法 MonthCodeToQuarter（第 334 行），会发现没有被用过[F4]。因此，单元测试并没有测试这个方法。\n So I fired up Clover to see what the unit tests covered and what they didn’t. Clover reported that the unit tests executed only 91 of the 185 executable statements in SerialDate (~50 percent) [T2]. The coverage map looks like a patchwork quilt, with big gobs of unexecuted code littered all through the class.\n 所以，我用 Clover 来检查单元测试覆盖了哪些代码。Clover 报告说，在 SerialDate 的 185 个可执行语句中，单元测试只执行了 91 个（约 50%）[T2]。覆盖图看起来像是一床满是补丁的棉被，整个类上布满大块的未执行代码。\n It was my goal to completely understand and also refactor this class. I couldn’t do that without much greater test coverage. So I wrote my own suite of completely independent unit tests (Listing B-4, page 374).\n 我的目标是完整地理解和重构这个类。没有好得多的测试覆盖率，做不到这个。所以，我完全重起炉灶编写了自己的单元测试（见代码清单 B-4）。\n As you look through these tests, you will note that many of them are commented out. These tests didn’t pass. They represent behavior that I think SerialDate should have. So as I refactor SerialDate, I’ll be working to make these tests pass too.\n 在阅读这些测试时，你可以看到，其中许多注释掉了。这些测试不能通过。它们代表了我以为 SerialDate 应该有的行为。在我重构 SerialDate 时，也将让这些测试通过。\n Even with some of the tests commented out, Clover reports that the new unit tests are executing 170 (92 percent) out of the 185 executable statements. This is pretty good, and I think we’ll be able to get this number higher.\n 即便有些测试被注释掉，Clover 还是报告新的单元测试执行了 185 个可执行语句中的 170 个（92%）。这样就好多了，而且我想我们可以把这个数字提高些。\n The first few commented-out tests (lines 23-63) were a bit of conceit on my part. The program was not designed to pass these tests, but the behavior seemed obvious [G2] to me. I’m not sure why the testWeekdayCodeToString method was written in the first place, but because it is there, it seems obvious that it should not be case sensitive. Writing these tests was trivial [T3]. Making them pass was even easier; I just changed lines 259 and 263 to use equalsIgnoreCase.\n 前几个注释掉的测试（第 23 ～ 63 行）是我一厢情愿。程序并没有设计为通过这些测试，但对我来说它们代表的行为显而易见[G2]。我不太确定 testWeekdayCodeToString 方法为何要写成那样，不过既然它已经在那儿，显然不该是区分大小写的。编写这些测试是区区小事[T3]，通过测试更加容易。我只修改了第 259 行和和 263 行，就能使用 equalsIgnoreCase 了。\n I left the tests at line 32 and line 45 commented out because it’s not clear to me that the “tues” and “thurs” abbreviations ought to be supported.\n 我注释掉了第 32 行和第 45 行的测试，因为我不太明确是否应该支持 tues 和 thurs 缩写。\n The tests on line 153 and line 154 don’t pass. Clearly, they should [G2]. We can easily fix this, and the tests on line 163 through line 213, by making the following changes to the stringToMonthCode function.\n 第 153 行和 154 行的测试不能通过。显然，它们本该通过[G2]。我们可以轻易地修正，只要对 stringToMonthCode 作出以下修改就行，对于第 163 行和 213 行的测试也一样。\n 457 if ((result \u0026lt; 1) || (result \u0026gt; 12)) { result = -1; 458 for (int i = 0; i \u0026lt; monthNames.length; i++) { 459 if (s.equalsIgnoreCase(shortMonthNames[i])) { 460 result = i + 1; 461 break; 462 } 463 if (s.equalsIgnoreCase(monthNames[i])) { 464 result = i + 1; 465 break; 466 } 467 } 468 } The commented test on line 318 exposes a bug in the getFollowingDayOfWeek method (line 672). December 25th, 2004, was a Saturday. The following Saturday was January 1st, 2005. However, when we run the test, we see that getFollowingDayOfWeek returns December 25th as the Saturday that follows December 25th. Clearly, this is wrong [G3],[T1]. We see the problem in line 685. It is a typical boundary condition error [T5]. It should read as follows:\n 第 318 行注释掉的测试暴露了 getFollowingDayOfWeek 方法中的一个缺陷（第 672 行）。2004 年 12 月 25 日是个周六。下一个周六是 2005 年 1 月 1 日。然而，运行测试时，会看到 getFollowingDayOfWeek 返回 12 月 25 日之后的周六还是 12 月 25 日。显然这不对[G3][t1]。我们看到问题在第 685 行。那是个典型的边界条件错误[T5]。应该是这样：\n 685 if (baseDOW \u0026gt;= targetWeekday) { It is interesting to note that this function was the target of an earlier repair. The change history (line 43) shows that “bugs” were fixed in getPreviousDayOfWeek, getFollowingDayOfWeek, and getNearestDayOfWeek [T6].\n 很有意思，这个函数是之前一次修改的结果。修改记录（第 43 行）显示，getPreviousDayOfWeek、getFollowingDayOfWeek 和 getNearestDayOfWeek 中的“缺陷”已被修正[T6]。\n The testGetNearestDayOfWeek unit test (line 329), which tests the getNearestDayOfWeek method (line 705), did not start out as long and exhaustive as it currently is. I added a lot of test cases to it because my initial test cases did not all pass [T6]. You can see the pattern of failure by looking at which test cases are commented out. That pattern is revealing [T7]. It shows that the algorithm fails if the nearest day is in the future. Clearly there is some kind of boundary condition error [T5].\n 测试 getNearestDayOfWeek（第 705 行）的单元测试 testGetNearestDayOfWeek（第 329 行）之前的版本不像现在一样没有遗漏。我添加了大量测试用例，因为初始的测试用例并没有全部通过 [T6]。查看哪些测试用例被注释掉，你可以看到失败的模式，这很有启发。如果最近的日期是在未来，算法就会失败。显然存在某种边界条件错误[T5]。\n The pattern of test coverage reported by Clover is also interesting [T8]. Line 719 never gets executed! This means that the if statement in line 718 is always false. Sure enough, a look at the code shows that this must be true. The adjust variable is always negative and so cannot be greater or equal to 4. So this algorithm is just wrong.\n Clover 汇报的测试覆盖模式也很有趣[T8]。第 719 行根本没有执行！这意味着第 718 行的 if 语句总是得到 false 的结果。没错，看一眼代码就知道是这样。变量 adjust 总是为负，所以不会大于或等于 4。所以，算法错了。\n The right algorithm is shown below:\n 正确的算法如下所示：\n int delta = targetDOW - base.getDayOfWeek(); int positiveDelta = delta + 7; int adjust = positiveDelta % 7; if (adjust \u0026gt; 3) adjust -= 7; return SerialDate.addDays(adjust, base); Finally, the tests at line 417 and line 429 can be made to pass simply by throwing an IllegalArgumentException instead of returning an error string from weekInMonthToString and relativeToString.\n 最后，只要简单地抛出 IllegalArgumentException 异常而不是从 weekInMonthToString 和 relativeToString 返回错误字符串，第 417 行和 429 行的测试也能通过。\n With these changes all the unit tests pass, and I believe SerialDate now works. So now it’s time to make it “right.”\n 做出这些修改后，所有的单元测试都通过了，我确信 SerialDate 现下可以工作。是时候让它“做对”了。\n 16.2 THEN MAKE IT RIGHT 让它做对 #  We are going to walk from the top to the bottom of SerialDate, improving it as we go along. Although you won’t see this in the discussion, I will be running all of the JCommon unit tests, including my improved unit test for SerialDate, after every change I make. So rest assured that every change you see here works for all of JCommon.\n 我们将从头到尾遍历 SerialDate，同时加以改进。尽管在本章的讨论中你看不到这个过程，在每次做修改后，我还是要运行全部 JCommon 单元测试，包括我为 SerialDate 改进的那些单元测试。所以，后面你看到的所有修改，对于 JCommon 都是可工作的。\n Starting at line 1, we see a ream of comments with license information, copyrights, authors, and change history. I acknowledge that there are certain legalities that need to be addressed, and so the copyrights and licenses must stay. On the other hand, the change history is a leftover from the 1960s. We have source code control tools that do this for us now. This history should be deleted [C1].\n 从第 1 行开始，我看到大量有关许可、版权、作者和修改历史的注释。我明白，的确有些法律事宜要说明，所以版权和许可信息应该保留。另外，修改历史是产生于 19 世纪 60 年代的古董，现今源代码控制工具可以帮我们做到这个。应该删掉修改历史[C1]。\n The import list starting at line 61 could be shortened by using java.text.* and java.util.*. [J1]\n 从第 61 行开始的导入列表应该通过使用 java.text.*和 java.util.*来缩短。[J1]\n I wince at the HTML formatting in the Javadoc (line 67). Having a source file with more than one language in it troubles me. This comment has four languages in it: Java, English, Javadoc, and html [G1]. With that many languages in use, it’s hard to keep things straight. For example, the nice positioning of line 71 and line 72 are lost when the Javadoc is generated, and yet who wants to see \u0026lt;ul\u0026gt; and \u0026lt;li\u0026gt; in the source code? A better strategy might be to just surround the whole comment with \u0026lt;pre\u0026gt; so that the formatting that is apparent in the source code is preserved within the Javadoc.1\n Javadoc 的 HTML 格式化工作（第 67 行）令我畏惧。一个源文件里面有多种语言，我有点发怵。这条注释有 4 种语言：Java、英文、Javadoc 和 html[G1]。有那么多语言，就很难直截了当。例如，生成 Javadoc 后，第 71 行和 72 行原本很好的位置就丢失了，而且谁想在源代码中看到\u0026lt;ul\u0026gt; 和\u0026lt;li\u0026gt;这样的东西呢？更好的策略可能是用\u0026lt;pre\u0026gt;标签把整个注释部分包围起来，这样，对于源代码的格式化只会限于 Javadoc 之内[1]。\n Line 86 is the class declaration. Why is this class named SerialDate? What is the significance of the word “serial”? Is it because the class is derived from Serializable? That doesn’t seem likely.\n 第 86 行是类声明。这个类为何要命名为 SerialDate？Serial 一词有什么妙处吗？是不是因为该类派生自 Serializable？看来不是这样的。\n I won’t keep you guessing. I know why (or at least I think I know why) the word “serial” was used. The clue is in the constants SERIAL_LOWER_BOUND and SERIAL_UPPER_BOUND on line 98 and line 101. An even better clue is in the comment that begins on line 830. This class is named SerialDate because it is implemented using a “serial number,” which happens to be the number of days since December 30th, 1899.\n 别猜了，我知道为什么（或者我认为自己知道）何以要用 Serial 一词。线索就在位于第 98 行和 101 行的常量 SERIAL LOWER BOUND 和 SERIAL UPPER BOUND。更好的线索在从第 830 行开始的注释中。该类被命名为 SerialDate，是因为它用“序列数”（serial number）来实现，该系列数恰好是从 1899 年 12 月 30 日后的天数。\n I have two problems with this. First, the term “serial number” is not really correct. This may be a quibble, but the representation is more of a relative offset than a serial number. The term “serial number” has more to do with product identification markers than dates. So I don’t find this name particularly descriptive [N1]. A more descriptive term might be “ordinal.”\n 对此我有两个问题。首先，术语“序列数”并不真对。可能有点诡辩，但其呈现方式却更接近相对偏移甚于序列数。术语“序列数”更多地用于产品版本标识，而非日期标识。我没发现这个名称特别有描述力[N1]。更有描述力的术语大概是“顺序”（ordinal）。\n The second problem is more significant. The name SerialDate implies an implementation. This class is an abstract class. There is no need to imply anything at all about the implementation. Indeed, there is good reason to hide the implementation! So I find this name to be at the wrong level of abstraction [N2]. In my opinion, the name of this class should simply be Date.\n 第二个问题更突出。名称 SerialDate 暗示了一种实现。该类是个抽象类。没必要暗示任何有关实现的事。实际上，没理由隐藏实现！我发现这个名称放在了不正确的抽象层级上[N2]。以我之见，该类的名称应该就是简单的 Date。\n Unfortunately, there are already too many classes in the Java library named Date, so this is probably not the best name to choose. Because this class is all about days, instead of time, I considered naming it Day, but this name is also heavily used in other places. In the end, I chose DayDate as the best compromise.\n 不幸的是，Java 类库里面有太多叫 Date 的类了，所以这大概也不是最好的名称。因为这个类是关于日期而非时间，我想将其命名为 Day，但这个名字也在多处被滥用。最后，我选了 DayDate 作为最佳折衷方案。\n From now on in this discussion I will use the term DayDate. I leave it to you to remember that the listings you are looking at still use SerialDate.\n 从现在起，我将使用术语 DayDate。请记住，你读到的代码清单，还是用的 SerialDate。\n I understand why DayDate inherits from Comparable and Serializable. But why does it inherit from MonthConstants? The class MonthConstants (Listing B-3, page 372) is just a bunch of static final constants that define the months. Inheriting from classes with constants is an old trick that Java programmers used so that they could avoid using expressions like MonthConstants.January, but it’s a bad idea [J2]. MonthConstants should really be an enum.\n 我理解为何 DayDate 继承自 Comparable 和 Serializable。不过，为什么它要继承自 MonthConstants 呢？类 MonthConstants（见代码清单 B-3）只是一大堆定义了月份的静态常量。从常量类继承是 Java 程序员用的一种老花招，这样他们就能避免形如 MonthConstants.January 的表达式，不过这是个坏主意[J2]。MonthConstants 其实应该是个枚举。\n public abstract class DayDate implements Comparable, Serializable { public static enum Month { JANUARY(1), FEBRUARY(2), MARCH(3), APRIL(4), MAY(5), JUNE(6), JULY(7), AUGUST(8), SEPTEMBER(9), OCTOBER(10), NOVEMBER(11), DECEMBER(12); Month(int index) { this.index = index; } public static Month make(int monthIndex) { for (Month m : Month.values()) { if (m.index == monthIndex) return m; } throw new IllegalArgumentException(\u0026#34;Invalid month index \u0026#34; + monthIndex); } public final int index; } } Changing MonthConstants to this enum forces quite a few changes to the DayDate class and all it’s users. It took me an hour to make all the changes. However, any function that used to take an int for a month, now takes a Month enumerator. This means we can get rid of the isValidMonthCode method (line 326), and all the month code error checking such as that in monthCodeToQuarter (line 356) [G5].\n 把 MonthConstants 改成枚举，导致对 DayDate 类和用到这个类的代码的一些修改。我花了一个小时来改代码。不过，原来以 int 为月份类型的函数，现在都用上 Month 枚举元素了。这意味着我们可以去除 isValidMonthCode 方法（第 326 行），以及 monthCodeToQuarter 等位置的月份代码错误检查（第 356 行）了[G5]。\n Next, we have line 91, serialVersionUID. This variable is used to control the serializer. If we change it, then any DayDate written with an older version of the software won’t be readable anymore and will result in an InvalidClassException. If you don’t declare the serialVersionUID variable, then the compiler automatically generates one for you, and it will be different every time you make a change to the module. I know that all the documents recommend manual control of this variable, but it seems to me that automatic control of serialization is a lot safer [G4]. After all, I’d much rather debug an InvalidClassException than the odd behavior that would ensue if I forgot to change the serialVersionUID. So I’m going to delete the variable—at least for the time being.2\n 下一步，我们看到第 91 行，serialVersionUID。该变量用于控制序列号。如果我们修改了它，用这个软件编写的旧版本 DayDate 都将不再可用，而是返回一个 InvalidClassException 异常。如果你没有声明 serialVersionUID 变量，则编译器会自动生成一个，每次修改模块时都会得到不一样的值。我知道，所有的文档都建议手工控制这个变量，但对我来说自动控制序列号安全得多[G4]。我宁肯调试 InvalidClassException，也不愿意见到如果忘记修改 serialVersionUID 引起的后续工作。所以，我要删除这个变量——至少暂时这么做[2]。\n I find the comment on line 93 redundant. Redundant comments are just places to collect lies and misinformation [C2]. So I’m going to get rid of it and its ilk.\n 我发现第 93 行的注释是多余的。这正是谎言和误导信息所在之地[C2]。所以我要干掉它和它的同类。\n The comments at line 97 and line 100 talk about serial numbers, which I discussed earlier [C1]. The variables they describe are the earliest and latest possible dates that DayDate can describe. This can be made a bit clearer [N1].\n 第 97 行和 100 行的注释有关序列数，我之前已经讨论过这个问题[C1]。它们描述的变量是 DayDate 能够描述的最早和最后的日期。这可以搞得更清楚些[N1]。\n public static final int EARLIEST_DATE_ORDINAL = 2; // 1/1/1900 public static final int LATEST_DATE_ORDINAL = 2958465; // 12/31/9999 It’s not clear to me why EARLIEST_DATE_ORDINAL is 2 instead of 0. There is a hint in the comment on line 829 that suggests that this has something to do with the way dates are represented in Microsoft Excel. There is a much deeper insight provided in a derivative of DayDate called SpreadsheetDate (Listing B-5, page 382). The comment on line 71 describes the issue nicely.\n 我不太清楚为什么 EARLIEST_DATE_ORDINAL 是 2 而不是 0。在第 829 行的注释中有个提示，说明这与用 Microsoft Excel 展示日期的方式有关。在 DayDate 的派生类 SpredsheetDate 中能看得更深入（见代码清单 B-5）。第 71 行的注释很好地描述了这个问题。\n The problem I have with this is that the issue seems to be related to the implementation of SpreadsheetDate and has nothing to do with DayDate. I conclude from this that EARLIEST_DATE_ORDINAL and LATEST_DATE_ORDINAL do not really belong in DayDate and should be moved to SpreadsheetDate [G6].\n 我的问题是，这看来应该与 SpreadsheetDate 有关，与 DayDate 无关才对。所以，EARLIEST_DATE_ORDINAL 和 LATEST_DATE_ORDINAL 实在不该属于 DayDate，应该移到 SpreadSheeDate 中[G6]。\n Indeed, a search of the code shows that these variables are used only within SpreadsheetDate. Nothing in DayDate, nor in any other class in the JCommon framework, uses them. Therefore, I’ll move them down into SpreadsheetDate.\n 的确，搜索一下代码就知道，这些变量值仅在 SpreadSheetDate 中用到。DayDate 中没用到，JCommon 框架的其他类中也没有用。所以，我将把它们向下移到 SpreadSheetDate 中。\n The next variables, MINIMUM_YEAR_SUPPORTED, and MAXIMUM_YEAR_SUPPORTED (line 104 and line 107), provide something of a dilemma. It seems clear that if DayDate is an abstract class that provides no foreshadowing of implementation, then it should not inform us about a minimum or maximum year. Again, I am tempted to move these variables down into SpreadsheetDate [G6]. However, a quick search of the users of these variables shows that one other class uses them: RelativeDayOfWeekRule (Listing B-6, page 390). We see that usage at line 177 and line 178 in the getDate function, where they are used to check that the argument to getDate is a valid year. The dilemma is that a user of an abstract class needs information about its implementation.\n 下面两个变量，MINIMUN_YEAR_SUPPORTED 和 MAXIMUM_YEAR_SUPPORTED（第 104 行和 107 行）地位尴尬。显然，如果 DayDate 是个没有提供实现铺垫的抽象类，它就不该告知我们有关最小和最大年份的信息。同样，我很想把这些变量向下移到 SpreadSheetDate 中[G6]。然而，快速查找这些变量的使用情况，会发现另一个类也在用：RelativeDayOfWeekRule （见代码清单 B-6）。在第 177 行和 178 行，getDate 函数中，它们被用来检查 getDate 的年份参数是否有效。抽象类的用户需要得知其实现信息，这是个矛盾。\n What we need to do is provide this information without polluting DayDate itself. Usually, we would get implementation information from an instance of a derivative. However, the getDate function is not passed an instance of a DayDate. It does, however, return such an instance, which means that somewhere it must be creating it. Line 187 through line 205 provide the hint. The DayDate instance is being created by one of the three functions, getPreviousDayOfWeek, getNearestDayOfWeek, or getFollowingDayOfWeek. Looking back at the DayDate listing, we see that these functions (lines 638–724) all return a date created by addDays (line 571), which calls createInstance (line 808), which creates a SpreadsheetDate! [G7].\n 我们要做的是既提供信息，又不污染 DayDate。通常，我们会从派生类实体中获取实现信息。不过，并未向 getDate 函数传入 DayDate 的实体，反而返回了这么一个实体。这意味着必须在某处创建实体。第 187 ～ 205 行提供了线索。DayDate 实体是在 getPreviousDayOfWeek、getNearestDayOfWeek 或 getFollowingDayOfWeek 这三个函数其中之一里面创建的。看回 DayDate 代码清单，我们看到，这些函数（第 638 ～ 724 行）全都返回了由 addDays（第 571 行）创建的日期实体，addDays 调用 CreateInstance（第 808 行），创建出一个 SpreadSheetDate！[G7]。\n It’s generally a bad idea for base classes to know about their derivatives. To fix this, we should use the ABSTRACT FACTORY3 pattern and create a DayDateFactory. This factory will create the instances of DayDate that we need and can also answer questions about the implementation, such as the maximum and minimum dates.\n 通常来说，基类不宜了解其派生类的情况。为了修正这个毛病，我们应该利用抽象工厂模式（ABSTRACT FACTORY）[3]，创建一个 DayDateFactory。该工厂将创建我们所需要的 DayDate 的实体，并回答有关实现的问题，例如最大和最小日期之类。\n public abstract class DayDateFactory { private static DayDateFactory factory = new SpreadsheetDateFactory(); public static void setInstance(DayDateFactory factory) { DayDateFactory.factory = factory; } protected abstract DayDate _makeDate(int ordinal); protected abstract DayDate _makeDate(int day, DayDate.Month month, int year); protected abstract DayDate _makeDate(int day, int month, int year); protected abstract DayDate _makeDate(java.util.Date date); protected abstract int _getMinimumYear(); protected abstract int _getMaximumYear(); public static DayDate makeDate(int ordinal) { return factory._makeDate(ordinal); } public static DayDate makeDate(int day, DayDate.Month month, int year) { return factory._makeDate(day, month, year); } public static DayDate makeDate(int day, int month, int year) { return factory._makeDate(day, month, year); } public static DayDate makeDate(java.util.Date date) { return factory._makeDate(date); } public static int getMinimumYear() { return factory._getMinimumYear(); } public static int getMaximumYear() { return factory._getMaximumYear(); } } This factory class replaces the createInstance methods with makeDate methods, which improves the names quite a bit [N1]. It defaults to a SpreadsheetDateFactory but can be changed at any time to use a different factory. The static methods that delegate to abstract methods use a combination of the SINGLETON,4 DECORATOR,5 and ABSTRACT FACTORY patterns that I have found to be useful.\n 该工厂类用 makeDate 方法替代了 createInstance 方法，前者的名称稍好一些[N1]。在初始状态下，它使用 SpreadsheetDateFactory，但随时可以使用其他工厂。委托到抽象方法的静态方法混合采用了单件模式（SINGLETON）、油漆工模式[4]和抽象工厂模式[5]，我发现这种手段很有用。\n The SpreadsheetDateFactory looks like this.\n SpreadsheetDateFactory 看起来像这个样子：\n public class SpreadsheetDateFactory extends DayDateFactory { public DayDate _makeDate(int ordinal) { return new SpreadsheetDate(ordinal); } public DayDate _makeDate(int day, DayDate.Month month, int year) { return new SpreadsheetDate(day, month, year); } public DayDate _makeDate(int day, int month, int year) { return new SpreadsheetDate(day, month, year); } public DayDate _makeDate(Date date) { final GregorianCalendar calendar = new GregorianCalendar(); calendar.setTime(date); return new SpreadsheetDate( calendar.get(Calendar.DATE), DayDate.Month.make(calendar.get(Calendar.MONTH) + 1), calendar.get(Calendar.YEAR)); } protected int _getMinimumYear() { return SpreadsheetDate.MINIMUM_YEAR_SUPPORTED; } protected int _getMaximumYear() { return SpreadsheetDate.MAXIMUM_YEAR_SUPPORTED; } } As you can see, I have already moved the MINIMUM_YEAR_SUPPORTED and MAXIMUM_YEAR_SUPPORTED variables into SpreadsheetDate, where they belong [G6].\n 如你所见，我已经把 MINIMUM_YEAR_SUPPORTED 和 MAXIMUM_YEAR_SUPPORTED 变量移到了它们该在的 SpreadsheetDate 中[G6]。\n The next issue in DayDate are the day constants beginning at line 109. These should really be another enum [J3]. We’ve seen this pattern before, so I won’t repeat it here. You’ll see it in the final listings.\n DayDate 的下一个问题是第 109 行的日期常量。这些常量其实应该是枚举[J3]。我们之前见过这种模式，不再赘述。你可以在最终的代码清单中看到。\n Next, we see a series of tables starting with LAST_DAY_OF_MONTH at line 140. My first issue with these tables is that the comments that describe them are redundant [C3]. Their names are sufficient. So I’m going to delete the comments.\n 跟着，我们看到第 140 行一系列以 LAST_DAY_OF_MONTH 开头的数组。首先，描述这些数组的注释全属多余[C3]。光看名称就够了。所以我要删除这些注释。\n There seems to be no good reason that this table isn’t private [G8], because there is a static function lastDayOfMonth that provides the same data.\n 这个数组没理由不是私有的[G8]，因为有个静态函数 lastDayOfMonth 提供同样的数据。\n The next table, AGGREGATE_DAYS_TO_END_OF_MONTH, is a bit more mysterious because it is not used anywhere in the JCommon framework [G9]. So I deleted it.\n 下一个数组 AGGREGATE_DAYS_TO_END_OF_MONTH 更神秘一些，在 JCommon 框架中根本没用到它[G9]。所以我直接删除了。\n The same goes for LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH.\n 对于 LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH 也一样。\n The next table, AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH, is used only in Spread-sheetDate (line 434 and line 473). This begs the question of whether it should be moved to SpreadsheetDate. The argument for not moving it is that the table is not specific to any particular implementation [G6]. On the other hand, no implementation other than SpreadsheetDate actually exists, and so the table should be moved close to where it is used [G10].\n AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH 只在 SpreadsheetDate 中用到（第 434 行和 473 行）。是否把它移到 SpreadsheetDate 中去是个问题。不转移的理由是，该数组并不专属于任何特定的实现[G6]。另一方面，实际上并不存在 SpreadsheetDate 之外的实现，所以，数组应该移到靠近其使用位置的地方[G10]。\n What settles the argument for me is that to be consistent [G11], we should make the table private and expose it through a function like julianDateOfLastDayOfMonth. Nobody seems to need a function like that. Moreover, the table can be moved back to DayDate easily if any new implementation of DayDate needs it. So I moved it.\n 说服我的理由是保持一致[G11]，数组应该私有，并通过类似 julianDateOfLastDayOfMonth 这样的函数来暴露。看来没人需要那样的函数。而且，如果有新的 DayDate 实现需要该数组，可以轻易地把它移回到 DayDate 中去。所以我就把它移到 SpreadsheetDate 里面了。\n The same goes for the table, LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH.\n 对于 LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH.也一样。\n Next, we see three sets of constants that can be turned into enums (lines 162–205). The first of the three selects a week within a month. I changed it into an enum named WeekInMonth.\n 跟着，我们看到三组可以转换为枚举的常量（第 162 ～ 205 行）。第一个用来选择月份中的一周。我将其转换为名为 WeekInMonth 的枚举。\n public enum WeekInMonth { FIRST(1), SECOND(2), THIRD(3), FOURTH(4), LAST(0); public final int index; WeekInMonth(int index) { this.index = index; } } The second set of constants (lines 177–187) is a bit more obscure. The INCLUDE_NONE, INCLUDE_FIRST, INCLUDE_SECOND, and INCLUDE_BOTH constants are used to describe whether the defining end-point dates of a range should be included in that range. Mathematically, this is described using the terms “open interval,” “half-open interval,” and “closed interval.” I think it is clearer using the mathematical nomenclature [N3], so I changed it to an enum named DateInterval with CLOSED, CLOSED_LEFT, CLOSED_RIGHT, and OPEN enumerators.\n 第二组常量（第 177 ～ 187 行）有点麻烦。INCLUDE_NONE、INCLUDE_FIRST、INCLUDE_SECOND 和 INCLUDE_BOTH 常量用于描述某个范围的终止日是否包含在该范围之内。数学上，用术语“开放区间”、“半开放区间”和“闭合区间”来表示。我想，用数学术语来命名会更清晰[N3]，所以就将其转换为枚举 DateInterval，其中包括 CLOSED、CLOSED_LEFT、CLOSED_RIGHT 和 OPEN 枚举元素。\n The third set of constants (lines 189–205) describe whether a search for a particular day of the week should result in the last, next, or nearest instance. Deciding what to call this is difficult at best. In the end, I settled for WeekdayRange with LAST, NEXT, and NEAREST enumerators.\n 第三组常量（第 18 ～ 205 行）描述了是否该在最后、下一个或最近的日期实体中呈现对某个星期的特定一天的查找结果。怎么命名是个难题。最终，我给 WeekdayRange 设定了 LAST、NEXT 和 NEAREST 枚举元素。\n You might not agree with the names I’ve chosen. They make sense to me, but they may not make sense to you. The point is that they are now in a form that makes them easy to change [J3]. They aren’t passed as integers anymore; they are passed as symbols. I can use the “change name” function of my IDE to change the names, or the types, without worrying that I missed some -1 or 2 somewhere in the code or that some int argument declaration is left poorly described.\n 你也许不会同意我取的名字。对我而言这些名字有意义，但对你可能就不然。要点是它们眼下变成了易于修改的形式[J3]。不再以整数形式传递，而是作为符号传递。我可以用 IDE 的“修改名称”功能来改动名称或类型，无需担忧漏掉代码中某处-1 或 2 之类的数字，也不必担忧某些 int 参数声明处于描述不佳的状态。\n The description field at line 208 does not seem to be used by anyone. I deleted it along with its accessor and mutator [G9].\n 第 208 行的描述字段看来没有任何地方用到。我把它及其取值器和赋值器都删掉了。\n I also deleted the degenerate default constructor at line 213 [G12]. The compiler will generate it for us.\n 我还删除了第 213 行的默认构造器[G12]。编译器会为我们自动生成的。\n We can skip over the isValidWeekdayCode method (lines 216–238) because we deleted it when we created the Day enumeration.\n 略过 isValidWeekdayCode 方法（第 216 ～ 238 行），在创建 Day 枚举时已经把它删掉了。\n This brings us to the stringToWeekdayCode method (lines 242–270). Javadocs that don’t add much to the method signature are just clutter [C3],[G12]. The only value this Javadoc adds is the description of the -1 return value. However, because we changed to the Day enumeration, the comment is actually wrong [C2]. The method now throws an IllegalArgumentException. So I deleted the Javadoc.\n 于是来到 stringToWeekdayCode 方法（第 242 ～ 270 行）。没有方法签名增添价值的 Javadoc 都是废话[C3]、[G12]，唯一的价值是对返回值－1 的描述。然而，因为我们改用了 Day 枚举，这条注释就完全错误了[C2]。该方法现在抛出一个 IllegalArgumentException 异常。所以我删除了 Javadoc。\n I also deleted all the final keywords in arguments and variable declarations. As far as I could tell, they added no real value but did add to the clutter [G12]. Eliminating final flies in the face of some conventional wisdom. For example, Robert Simmons6 strongly recommends us to “. . . spread final all over your code.” Clearly I disagree. I think that there are a few good uses for final, such as the occasional final constant, but otherwise the keyword adds little value and creates a lot of clutter. Perhaps I feel this way because the kinds of errors that final might catch are already caught by the unit tests I write.\n 我还删除了参数和变量声明中的全部 final 关键字。我敢说，它们毫无价值，空自混淆视听惑[G12]。删除这些 final，不合某些成例。例如，Robert Simmons[6]就强烈建议我们“……在代码中遍布 final。”我不能苟同。我认为，final 有少数的好用法，例如偶尔使用的 final 常量，但除此之外该关键字利小于弊。我这么认为，或许是因为 final 可能捕获到的那些错误类型，早已被我编写的单元测试捕获了。\n I didn’t care for the duplicate if statements [G5] inside the for loop (line 259 and line 263), so I connected them into a single if statement using the || operator. I also used the Day enumeration to direct the for loop and made a few other cosmetic changes.\n 我不喜欢 for 循环（第 259 行和 263 行）中的那些 if 语句[G5]，所以我利用“||”操作符把它们连接为单个 if 语句。我还使用 Day 枚举整理 for 循环，做了一些装饰性的修改。\n It occurred to me that this method does not really belong in DayDate. It’s really the parse function of Day. So I moved it into the Day enumeration. However, that made the Day enumeration pretty large. Because the concept of Day does not depend on DayDate, I moved the Day enumeration outside of the DayDate class into its own source file [G13].\n 我认为，这个方法并不真属于 DayDate 类。它其实是 Day 的一个解析函数。所以，我将它移到 Day 枚举中。不过，那样 Day 枚举就会变得太大。因为 Day 的概念并不依赖于 DayDate，我就把 Day 枚举移到 DayDate 类之外，放到它自己的源代码文件中。\n I also moved the next function, weekdayCodeToString (lines 272–286) into the Day enumeration and called it toString.\n 我还把下一个函数，weekdayCodeToString（第 272 ～ 286 行），移植到 Day 枚举中，称其为 toString。\n public enum Day { MONDAY(Calendar.MONDAY), TUESDAY(Calendar.TUESDAY), WEDNESDAY(Calendar.WEDNESDAY), THURSDAY(Calendar.THURSDAY), FRIDAY(Calendar.FRIDAY), SATURDAY(Calendar.SATURDAY), SUNDAY(Calendar.SUNDAY); public final int index; private static DateFormatSymbols dateSymbols = new DateFormatSymbols(); Day(int day) { index = day; } public static Day make(int index) throws IllegalArgumentException { for (Day d : Day.values()) if (d.index == index) return d; throw new IllegalArgumentException( String.format(\u0026#34;Illegal day index: %d.\u0026#34;, index)); } public static Day parse(String s) throws IllegalArgumentException { String[] shortWeekdayNames = dateSymbols.getShortWeekdays(); String[] weekDayNames = dateSymbols.getWeekdays(); s = s.trim(); for (Day day : Day.values()) { if (s.equalsIgnoreCase(shortWeekdayNames[day.index]) || s.equalsIgnoreCase(weekDayNames[day.index])) { return day; } } throw new IllegalArgumentException( String.format(\u0026#34;%s is not a valid weekday string\u0026#34;, s)); } public String toString() { return dateSymbols.getWeekdays()[index]; } } There are two getMonths functions (lines 288–316). The first calls the second. The second is never called by anyone but the first. Therefore, I collapsed the two into one and vastly simplified them [G9],[G12],[F4]. Finally, I changed the name to be a bit more self-descriptive [N1].\n 有两个 getMonth 函数（第 288 ～ 316 行）。第一个函数调用第二个函数。第二个函数只被第一个函数调用。所以，我把这两个函数合二为一，而且极大地简化之[G9][g12][F4]。最后，我把名称修改得更具自我描述力[N1]。\n public static String[] getMonthNames() { return dateFormatSymbols.getMonths(); } The isValidMonthCode function (lines 326–346) was made irrelevant by the Month enum, so I deleted it [G9].\n 由于有了 Month 枚举，函数 isValidMonthCode（第 326 ～ 346 行）就变得没什么用，所以我把它删除了[G9]。\n The monthCodeToQuarter function (lines 356–375) smells of FEATURE ENVY7 [G14] and probably belongs in the Month enum as a method named quarter. So I replaced it.\n 函数 monthCodeToQuarter（第 356 ～ 375 行）有特性依恋（FEATURE ENVY）[7]的味道，可以是 Month 枚举中的一个名为 quarter 的方法，我就这么办了。\n [Refactoring].  public int quarter() { return 1 + (index-1)/3; } This made the Month enum big enough to be in its own class. So I moved it out of DayDate to be consistent with the Day enum [G11],[G13].\n 这样一来，Month 枚举就大到需要放到自己的类中了。我把它从 DayDate 中移出来，与 Day 枚举保持一致[G11][g13]。\n The next two methods are named monthCodeToString (lines 377–426). Again, we see the pattern of one method calling its twin with a flag. It is usually a bad idea to pass a flag as an argument to a function, especially when that flag simply selects the format of the output [G15]. I renamed, simplified, and restructured these functions and moved them into the Month enum [N1],[N3],[C3],[G14].\n 下两个方法被命名为 monthCodeToString（第 377 ～ 426 行）。我们再次看到其中一个方法使用标识调用其兄弟方法的模式。将标识作为参数传递给函数的做法通常不太好，尤其是当该标识只是有关其输出格式时[G15]。我重命名、简化、重新构架了这些函数，并把它们移到 Month 枚举中[N1][n3][G14]。\n public String toString() { return dateFormatSymbols.getMonths()[index - 1]; } public String toShortString() { return dateFormatSymbols.getShortMonths()[index - 1]; } The next method is stringToMonthCode (lines 428–472). I renamed it, moved it into the Month enum, and simplified it [N1],[N3],[C3],[G14],[G12].\n 下一个方法是 stringToMonthCode（第 428 ～ 472 行）。我重新为它命名，转移到 Month 枚举中，并且简化之[N1][n3][C3][g14][G12]。\n public static Month parse(String s) { s = s.trim(); for (Month m : Month.values()) if (m.matches(s)) return m; try { return make(Integer.parseInt(s)); } catch (NumberFormatException e) {} throw new IllegalArgumentException(“Invalid month ” + s); } private boolean matches(String s) { return s.equalsIgnoreCase(toString()) || s.equalsIgnoreCase(toShortString()); } The isLeapYear method (lines 495–517) can be made a bit more expressive [G16].\n 方法 isLeapYear（第 495 ～ 517 行）可以写得更具表达力一些[G16]。\n public static boolean isLeapYear(int year) { boolean fourth = year % 4 == 0; boolean hundredth = year % 100 == 0; boolean fourHundredth = year % 400 == 0; return fourth \u0026amp;\u0026amp; (!hundredth || fourHundredth); } The next function, leapYearCount (lines 519–536) doesn’t really belong in DayDate. Nobody calls it except for two methods in SpreadsheetDate. So I pushed it down [G6].\n 下一个函数 leapYearCount（第 519 ～ 536 行）并不真属于 DayDate。除了 SpreadsheetDate 中的两个方法外，没有其他调用者。所以我将它往下放。\n The lastDayOfMonth function (lines 538–560) makes use of the LAST_DAY_OF_MONTH array. This array really belongs in the Month enum [G17], so I moved it there. I also simplified the function and made it a bit more expressive [G16].\n 函数 lastDayOfMonth（第 538 ～ 560 行）使用了 LAST_DAY_OF_MONTH 数组。该数组应该隶属于 Month 枚举[G17]，所以我就把它移到那儿去了。我还简化了这个函数，使其更具表达力[G16]。\n public static int lastDayOfMonth(Month month, int year) { if (month == Month.FEBRUARY \u0026amp;\u0026amp; isLeapYear(year)) return month.lastDay() + 1; else return month.lastDay(); } Now things start to get a bit more interesting. The next function is addDays (lines 562–576). First of all, because this function operates on the variables of DayDate, it should not be static [G18]. So I changed it to an instance method. Second, it calls the function toSerial. This function should be renamed toOrdinal [N1]. Finally, the method can be simplified.\n 现在，事情变得比较有趣一些了。下一个函数是 addDays（第 562 ～ 576 行）。首先，由于该函数对 DayDate 的变量进行操作，它就不该是静态的[G18]。所以，我把它修改为实体方法。其次，它调用了函数 toSerial。这个函数应该重新命名为 toOrdial [N1]。最后，该方法可以简化。\n public DayDate addDays(int days) { return DayDateFactory.makeDate(toOrdinal() + days); } The same goes for addMonths (lines 578–602). It should be an instance method [G18]. The algorithm is a bit complicated, so I used EXPLAINING TEMPORARY VARIABLES8 [G19] to make it more transparent. I also renamed the method getYYY to getYear [N1].\n 对于 addMonth（第 578 ～ 602 行）也一样。它应该是个实体方法[G18]。算法太过复杂，所以我利用解释临时变量模式（EXPLAINING TEMPORARY VARIABLES）[8]来使其更为透明。我还将方法 getYYY 重命名为 getYear [N1]。\n public DayDate addMonths(int months) { int thisMonthAsOrdinal = 12 * getYear() + getMonth().index - 1; int resultMonthAsOrdinal = thisMonthAsOrdinal + months; int resultYear = resultMonthAsOrdinal / 12; Month resultMonth = Month.make(resultMonthAsOrdinal % 12 + 1); int lastDayOfResultMonth = lastDayOfMonth(resultMonth, resultYear); int resultDay = Math.min(getDayOfMonth(), lastDayOfResultMonth); return DayDateFactory.makeDate(resultDay, resultMonth, resultYear); } The addYears function (lines 604–626) provides no surprises over the others.\n 对于函数 addYear（第 604 ～ 626 行）也照方办理。\n public DayDate plusYears(int years) { int resultYear = getYear() + years; int lastDayOfMonthInResultYear = lastDayOfMonth(getMonth(), resultYear); int resultDay = Math.min(getDayOfMonth(), lastDayOfMonthInResultYear); return DayDateFactory.makeDate(resultDay, getMonth(), resultYear); } There is a little itch at the back of my mind that is bothering me about changing these methods from static to instance. Does the expression date.addDays(5) make it clear that the date object does not change and that a new instance of DayDate is returned? Or does it erroneously imply that we are adding five days to the date object? You might not think that is a big problem, but a bit of code that looks like the following can be very deceiving [G20].\n 把这些方法从静态方法变为实体方法，让我有点心头发痒。用 date.addDays(5)这样的表达方法，是不是明确地表示了 date 对象并没变动以及返回了一个 DayDate 的新实体呢？或者，它只是错误地暗示我们往 date 对象添加了 5 天呢？你可能不会认为这是个大问题，但下列代码却可能会有欺骗性。\n DayDate date = DateFactory.makeDate(5, Month.DECEMBER, 1952); date.addDays(7); // bump date by one week. Someone reading this code would very likely just accept that addDays is changing the date object. So we need a name that breaks this ambiguity [N4]. So I changed the names to plusDays and plusMonths. It seems to me that the intent of the method is captured nicely by\n 有些读到这段代码的人会认为 addDays 在修改 date 对象。所以，我们需要消除这种歧义的名称[N4]。我把名称改为 plusDays 和 plusMonths。我认为，方法的初衷很清楚地被\n DayDate date = oldDate.plusDays(5); whereas the following doesn’t read fluidly enough for a reader to simply accept that the date object is changed:\n 所体现，不过下列代码对认为 date 对象被修改的读者来说，看起来并不那么顺畅：\n date.plusDays(5); The algorithms continue to get more interesting. getPreviousDayOfWeek (lines 628–660) works but is a bit complicated. After some thought about what was really going on [G21], I was able to simplify it and use EXPLAINING TEMPORARY VARIABLES [G19] to make it clearer. I also changed it from a static method to an instance method [G18], and got rid of the duplicate instance method [G5] (lines 997–1008).\n 算法越来越有趣，getPreviousDayOfWeek（第 628 ～ 660 行）可以工作，不过有点复杂了。经过一番思考，了解到它的功能后[G21]，我就能够使用解释临时变量模式来简化它[G19]，使其更为清晰。我还将它从静态方法改为实体方法[G18]，并删除了重复的实体方法[G5]（第 997 ～ 1008 行）。\n public DayDate getPreviousDayOfWeek(Day targetDayOfWeek) { int offsetToTarget = targetDayOfWeek.index - getDayOfWeek().index; if (offsetToTarget \u0026gt;= 0) offsetToTarget -= 7; return plusDays(offsetToTarget); } The exact same analysis and result occurred for getFollowingDayOfWeek (lines 662–693).\n 对 getFollowingDayOfWeek（第 662 ～ 693 行）也如法炮制：\n public DayDate getFollowingDayOfWeek(Day targetDayOfWeek) { int offsetToTarget = targetDayOfWeek.index - getDayOfWeek().index; if (offsetToTarget \u0026lt;= 0) offsetToTarget += 7; return plusDays(offsetToTarget); } The next function is getNearestDayOfWeek (lines 695–726), which we corrected back on page 270. But the changes I made back then aren’t consistent with the current pattern in the last two functions [G11]. So I made it consistent and used some EXPLAINING TEMPORARY VARIABLES [G19] to clarify the algorithm.\n 下一个函数是我们之前修改过的 getNearestDayOfWeek（第 695 ～ 726 行）。我之前所做的修改和前两个函数没有保持一致[G11]。所以我将它改得和这两个函数保持一致，并且使用解释临时变量模式[G19]来阐明算法。\n public DayDate getNearestDayOfWeek(final Day targetDay) { int offsetToThisWeeksTarget = targetDay.index - getDayOfWeek().index; int offsetToFutureTarget = (offsetToThisWeeksTarget + 7) % 7; int offsetToPreviousTarget = offsetToFutureTarget - 7; if (offsetToFutureTarget \u0026gt; 3) return plusDays(offsetToPreviousTarget); else return plusDays(offsetToFutureTarget); } The getEndOfCurrentMonth method (lines 728–740) is a little strange because it is an instance method that envies [G14] its own class by taking a DayDate argument. I made it a true instance method and clarified a few names.\n 方法 getEndOfCurrentMonth（第 728 ～ 740 行）有点奇怪，因为它获取了 DayDate 参数，从而成为一个依恋[G14]其自身类的实体方法。我将其改为真正的实体方法，并修改了几个名称。\n public DayDate getEndOfMonth() { Month month = getMonth(); int year = getYear(); int lastDay = lastDayOfMonth(month, year); return DayDateFactory.makeDate(lastDay, month, year); } Refactoring weekInMonthToString (lines 742–761) turned out to be very interesting indeed. Using the refactoring tools of my IDE, I first moved the method to the WeekInMonth enum that I created back on page 275. Then I renamed the method to toString. Next, I changed it from a static method to an instance method. All the tests still passed. (Can you guess where I am going?)\n 重构 weekInMonthToString（第 742 ～ 761 行）的过程非常有趣。利用 IDE 的重构工具，我先将其移到我之前创建的 WeekInMonth 枚举中，再将其重命名为 toString。跟着，我把它从静态方法改为实体方法。所有的测试都通过了。（你能猜出来我打算做什么吗？）\n Next, I deleted the method entirely! Five asserts failed (lines 411–415, Listing B-4, page 374). I changed these lines to use the names of the enumerators (FIRST, SECOND, …). All the tests passed. Can you see why? Can you also see why each of these steps was necessary? The refactoring tool made sure that all previous callers of weekInMonthToString now called toString on the weekInMonth enumerator because all enumerators implement toString to simply return their names.…\n 接下来，我删掉了整个方法！有 5 个断言失败了（第 411 ～ 415 行，代码清单 B-4）。我改动了这些代码行，让它们使用枚举元素的名称（FIRST、SECOND……）。全部测试都通过了。你知道为什么吗？你能否知道为什么这些步骤都是必要的吗？重构工具确保之前对 weekInMonthToString 方法的调用现在都调用 weekInMonth 枚举元素的 toString 方法，全部枚举元素都以返回其名称的形式实现了 toString 方法……\n Unfortunately, I was a bit too clever. As elegant as that wonderful chain of refactorings was, I finally realized that the only users of this function were the tests I had just modified, so I deleted the tests.\n 我不幸有点聪明过头了。这一套美妙的重构下来，我终于意识到，这个函数的唯一调用者，就是我刚修改的测试，所以我删除了这些测试。\n Fool me once, shame on you. Fool me twice, shame on me! So after determining that nobody other than the tests called relativeToString (lines 765–781), I simply deleted the function and its tests.\n 愚我一次，是你之耻。愚我两次，是我之耻！所以，在判定除了测试之外没有人调用过 relativeToString（第 765 ～ 781 行）后，我就删除了该函数及其测试。\n We have finally made it to the abstract methods of this abstract class. And the first one is as appropriate as they come: toSerial (lines 838–844). Back on page 279 I had changed the name to toOrdinal. Having looked at it in this context, I decided the name should be changed to getOrdinalDay.\n 我们最后将其改为这个抽象类的抽象方法。第一个函数保持了原样：toSerial（第 838 ～ 844 行）。前文我曾把名称改为 toOrdinal。以现在的情形看，我决定应该把名称改为 getOrdinalDay。\n The next abstract method is toDate (lines 838–844). It converts a DayDate to a java.util.Date. Why is this method abstract? If we look at its implementation in SpreadsheetDate (lines 198–207, Listing B-5, page 382), we see that it doesn’t depend on anything in the implementation of that class [G6]. So I pushed it up.\n 下一个抽象方法是 toDate（第 838 ～ 844 行）。它将 DayDate 转换为 java.util.Date。这个方法为何是抽象的？查看其在 SpreadsheetDate 中的实现（第 198 ～ 207 行，代码清单 B-5），可以看到它并不依赖于该类的实现[G6]。所以，我把它往上推了。\n The getYYYY, getMonth, and getDayOfMonth methods are nicely abstract. However, the getDayOfWeek method is another one that should be pulled up from SpreadSheetDate because it doesn’t depend on anything that can’t be found in DayDate [G6]. Or does it?\n 方法 getYYYY、getMonth 和 getDayOfMonth 已经是抽象方法。不过，getDayOfWeek 方法是另一个应该从 SpreadsheetDate 中提出来的方法，因为它不依赖于 DayDate 之外的东西[G6]。是这样吗？\n If you look carefully (line 247, Listing B-5, page 382), you’ll see that the algorithm implicitly depends on the origin of the ordinal day (in other words, the day of the week of day 0). So even though this function has no physical dependencies that couldn’t be moved to DayDate, it does have a logical dependency.\n 仔细阅读（第 247 行，代码清单 B-5），可以发现该算法暗中依赖于顺序日期的起点（换言之，第 0 天的星期日数）。所以，即便该方法没有物理上的依赖，也不能移到 DayDate 中，因为它的确有逻辑上的依赖。\n Logical dependencies like this bother me [G22]. If something logical depends on the implementation, then something physical should too. Also, it seems to me that the algorithm itself could be generic with a much smaller portion of it dependent on the implementation [G6].\n 这样的逻辑依赖困扰了我[G22]。如果有什么东西在逻辑上依赖实现的话，也该有什么物理上的依赖存在。我也认为，算法本身也该有一小部分依赖于实现。\n So I created an abstract method in DayDate named getDayOfWeekForOrdinalZero and implemented it in SpreadsheetDate to return Day.SATURDAY. Then I moved the getDayOfWeek method up to DayDate and changed it to call getOrdinalDay and getDayOfWeekForOrdinal-Zero.\n 所以我在 DayDate 中创建了一个名为 getDayOfWekForOrdinalZero 的抽象方法，并在 SpreadsheetDate 中实现它，返回 Day.SATURDAY。然后我把 getDayOfWeek 上移到 DayDate 中，并调用 getOrdinalDay 和 getDayOfWeekForOrdinal Zero。\n public Day getDayOfWeek() { Day startingDay = getDayOfWeekForOrdinalZero(); int startingOffset = startingDay.index - Day.SUNDAY.index; return Day.make((getOrdinalDay() + startingOffset) % 7 + 1); } As a side note, look carefully at the comment on line 895 through line 899. Was this repetition really necessary? As usual, I deleted this comment along with all the others.\n 顺便说一句，请仔细阅读第 895 ～ 899 行的注释。这样的重复有必要吗？通常，我会删除这类注释。\n The next method is compare (lines 902–913). Again, this method is inappropriately abstract [G6], so I pulled the implementation up into DayDate. Also, the name does not communicate enough [N1]. This method actually returns the difference in days since the argument. So I changed the name to daysSince. Also, I noted that there weren’t any tests for this method, so I wrote them.\n 下一个方法是 compare（第 902 ～ 913 行）。同样，该抽象方法是不恰当的[G6]。我将其实现上移到 DayDate。其名称也不足够有沟通意义 [N1]。方法实际上返回的是自参数日期以来的天数，所以我把名称改为 daysSince。我还注意到该方法没有测试，就为它编写了测试。\n The next six functions (lines 915–980) are all abstract methods that should be implemented in DayDate. So I pulled them all up from SpreadsheetDate.\n 下面 6 个函数（第 915 ～ 980 行）全都是应该在 DayDate 中实现的抽象方法。我把它们全都从 SpreadsheetDate 中抽出来了。\n The last function, isInRange (lines 982–995) also needs to be pulled up and refactored. The switch statement is a bit ugly [G23] and can be replaced by moving the cases into the DateInterval enum.\n 最后一个函数 isInRange（第 982 ～ 995 行）也需要推到上一层并重构之。那个 switch 语句有点丑陋[G23]，可以把那些条件判断移到 DateInterval 枚举中去。\n public enum DateInterval { OPEN { public boolean isIn(int d, int left, int right) { return d \u0026gt; left \u0026amp;\u0026amp; d \u0026lt; right; } }, CLOSED_LEFT { public boolean isIn(int d, int left, int right) { return d \u0026gt;= left \u0026amp;\u0026amp; d \u0026lt; right; } }, CLOSED_RIGHT { public boolean isIn(int d, int left, int right) { return d \u0026gt; left \u0026amp;\u0026amp; d \u0026lt;= right; } }, CLOSED { public boolean isIn(int d, int left, int right) { return d \u0026gt;= left \u0026amp;\u0026amp; d \u0026lt;= right; } }; public abstract boolean isIn(int d, int left, int right); } public boolean isInRange(DayDate d1, DayDate d2, DateInterval interval) { int left = Math.min(d1.getOrdinalDay(), d2.getOrdinalDay()); int right = Math.max(d1.getOrdinalDay(), d2.getOrdinalDay()); return interval.isIn(getOrdinalDay(), left, right); } That brings us to the end of DayDate. So now we’ll make one more pass over the whole class to see how well it flows.\n 我们来到了 DayDate 的末尾。现在我们要从头到尾再过一次，看看\u0026gt; 整个重构过程是怎样良好执行的。\n First, the opening comment is long out of date, so I shortened and improved it [C2].\n 首先，开端注释过时已久，我缩短并改进了它[C2]。\n Next, I moved all the remaining enums out into their own files [G12].\n 然后，我把全部枚举移到它们自己的文件中[G12]。\n Next, I moved the static variable (dateFormatSymbols) and three static methods (getMonthNames, isLeapYear, lastDayOfMonth) into a new class named DateUtil [G6].\n 跟着，我把静态变量（dateFormatSymbols）和 3 个静态方法（getMonthNames、isLeapYear 和 lastDayOfMonth）移到名为 DateUtil 的新类中[G6]。\n I moved the abstract methods up to the top where they belong [G24].\n 我把那些抽象方法上移到它们该在的顶层类中[G24]。\n I changed Month.make to Month.fromInt [N1] and did the same for all the other enums. I also created a toInt() accessor for all the enums and made the index field private.\n 我把 Month.make 改为 Month.fromInt [N1]，并如法炮制所有其他枚举。我还为全部枚举创建了 toInt( )访问器，把 index 字段改为私有。\n There was some interesting duplication [G5] in plusYears and plusMonths that I was able to eliminate by extracting a new method named correctLastDayOfMonth, making the all three methods much clearer.\n 在 plusYears 和 plusMonths 中存在一些有趣的重复[G5]，我通过抽离出名为 correctLastDayOfMonth 的新方法消解了重复，使这 3 个方法清晰多了。\n I got rid of the magic number 1 [G25], replacing it with Month.JANUARY.toInt() or Day.SUNDAY.toInt(), as appropriate. I spent a little time with SpreadsheetDate, cleaning up the algorithms a bit. The end result is contained in Listing B-7, page 394, through Listing B-16, page 405.\n 我消除了魔术数 1 [G25]，用 Month.JANUARY.toInt( )或 Day.SUNDAY.toInt( )做了恰当的替换。我在 SpreadsheetDate 上花了点时间，清理了一下算法。最终结果在代码清单 B-7 ～ 16 中。\n Interestingly the code coverage in DayDate has decreased to 84.9 percent! This is not because less functionality is being tested; rather it is because the class has shrunk so much that the few uncovered lines have a greater weight. DayDate now has 45 out of 53 executable statements covered by tests. The uncovered lines are so trivial that they weren’t worth testing.\n 有趣的是，DayDate 的代码覆盖率降低到了 84.9%！这并不是因为测试到的功能减少了，而是因为该类缩减得太多，导致少量未覆盖到的代码行拥有了更大权重。DayDate 的 53 个可执行语句中有 45 个得到测试覆盖。未覆盖的代码行微细到不值得测试。\n 16.3 CONCLUSION 小结 #  So once again we’ve followed the Boy Scout Rule. We’ve checked the code in a bit cleaner than when we checked it out. It took a little time, but it was worth it. Test coverage was increased, some bugs were fixed, the code was clarified and shrunk. The next person to look at this code will hopefully find it easier to deal with than we did. That person will also probably be able to clean it up a bit more than we did.\n 我们再一次遵从了童子军军规。我们签入的代码，要比签出时整洁了一点。虽然花了点时间，不过很值得。测试覆盖率提升了，修改了一些缺陷，代码清晰并缩短了。后来者有望比我们更容易地应付这些代码。他也有可能把代码整理得更干净些。\n "});index.add({'id':205,'href':'/docs/Clean-Code/17.-Smells-and-Heuristics/ch17/','title':"Ch17",'section':"Go语言圣经",'content':"第 17 章 Smells and Heuristics 味道与启发 #   In his wonderful book Refactoring,1 Martin Fowler identified many different “Code Smells.” The list that follows includes many of Martin’s smells and adds many more of my own. It also includes other pearls and heuristics that I use to practice my trade.\n Martin Fowler 在其妙书 Refectoring:Improving the Design of Existing Code[1]中指出了许多不同的“代码味道”。下面的清单包括很多 Martin 提出的味道，还添加了更多我自己提出的，也包括我借以历练本业的其他珍宝与启发。\n I compiled this list by walking through several different programs and refactoring them. As I made each change, I asked myself why I made that change and then wrote the reason down here. The result is a rather long list of things that smell bad to me when I read code.\n 我藉由遍览和重构几个不同的程序总结出这个清单。每次修改，我都问自己为什么要这样改，把修改的原因写下来。结果就是得到相当长的清单，给出在读代码时让我闻起来不舒服的味道。\n This list is meant to be read from top to bottom and also to be used as a reference. There is a cross-reference for each heuristic that shows you where it is referenced in the rest of the text in “Appendix C” on page 409.\n 清单应按顺序阅读，并作为一种参考来使用。\n 17.1 COMMENTS 注释 #  C1: Inappropriate Information\n C1：不恰当的信息\n It is inappropriate for a comment to hold information better held in a different kind of system such as your source code control system, your issue tracking system, or any other record-keeping system. Change histories, for example, just clutter up source files with volumes of historical and uninteresting text. In general, meta-data such as authors, last-modified-date, SPR number, and so on should not appear in comments. Comments should be reserved for technical notes about the code and design.\n 让注释传达本该更好地在源代码控制系统、问题追踪系统或任何其他记录系统中保存的信息，是不恰当的。例如，修改历史记录只会用大量过时而无趣的文本搞乱源代码文件。通常，作者、最后修改时间、SPR 数等元数据不该在注释中出现。注释只应该描述有关代码和设计的技术性信息。\n C2: Obsolete Comment\n C2：废弃的注释\n A comment that has gotten old, irrelevant, and incorrect is obsolete. Comments get old quickly. It is best not to write a comment that will become obsolete. If you find an obsolete comment, it is best to update it or get rid of it as quickly as possible. Obsolete comments tend to migrate away from the code they once described. They become floating islands of irrelevance and misdirection in the code.\n 过时、无关或不正确的注释就是废弃的注释。注释会很快过时。最好别编写将被废弃的注释。如果发现废弃的注释，最好尽快更新或删除掉。废弃的注释会远离它们曾经描述的代码，变成代码中无关和误导的浮岛。\n C3: Redundant Comment\n C3：冗余注释\n A comment is redundant if it describes something that adequately describes itself. For example:\n 如果注释描述的是某种充分自我描述了的东西，那么注释就是多余的。例如：\n i++; // increment i Another example is a Javadoc that says nothing more than (or even less than) the function signature:\n 另一个例子是除函数签名之外什么也没多说（或少说）的 Javadoc：\n /** * @param sellRequest * @return * @throws ManagedComponentException */ public SellResponse beginSellItem(SellRequest sellRequest) throws ManagedComponentException Comments should say things that the code cannot say for itself.\n 注释应该谈及代码自身没提到的东西。\n C4: Poorly Written Comment\n C4：糟糕的注释\n A comment worth writing is worth writing well. If you are going to write a comment, take the time to make sure it is the best comment you can write. Choose your words carefully. Use correct grammar and punctuation. Don’t ramble. Don’t state the obvious. Be brief.\n 值得编写的注释，也值得好好写。如果要编写一条注释，就花时间保证写出最好的注释。字斟句酌。使用正确的语法和拼写。别闲扯，别画蛇添足，保持简洁。\n C5: Commented-Out Code\n C5：注释掉的代码\n It makes me crazy to see stretches of code that are commented out. Who knows how old it is? Who knows whether or not it’s meaningful? Yet no one will delete it because everyone assumes someone else needs it or has plans for it.\n 看到被注释掉的代码会令我抓狂。谁知道它有多旧？谁知道它有没有意义？没人会删除它，因为大家都假设别人需要它或是有进一步计划。\n That code sits there and rots, getting less and less relevant with every passing day. It calls functions that no longer exist. It uses variables whose names have changed. It follows conventions that are long obsolete. It pollutes the modules that contain it and distracts the people who try to read it. Commented-out code is an abomination.\n 那样的代码就这样腐烂掉，随着时间推移，越来越与系统没关系。它调用不复存在的函数。它使用已改名的变量。它遵循已被废弃的约定。它污染了所属的模块，分散了想要读它的人的注意力。注释掉的代码纯属厌物。\n When you see commented-out code, delete it! Don’t worry, the source code control system still remembers it. If anyone really needs it, he or she can go back and check out a previous version. Don’t suffer commented-out code to survive.\n 看到注释掉的代码，就删除它！别担心，源代码控制系统还会记得它。如果有人真的需要，可以签出较前的版本。别被它搞到死去活来。\n 17.2 ENVIRONMENT 环境 #  E1: Build Requires More Than One Step\n E1：需要多步才能实现的构建\n Building a project should be a single trivial operation. You should not have to check many little pieces out from source code control. You should not need a sequence of arcane commands or context dependent scripts in order to build the individual elements. You should not have to search near and far for all the various little extra JARs, XML files, and other artifacts that the system requires. You should be able to check out the system with one simple command and then issue one other simple command to build it.\n 构建系统应该是单步的小操作。不应该从源代码控制系统中一小点一小点签出代码。不应该需要一系列神秘指令或环境依赖脚本来构建单个元素。不应该四处寻找额外的小 JAR、XML 文件和其他系统所需的杂物。你应当能够用单个命令签出系统，并用单个指令构建它。\n svn get mySystem cd mySystem ant all E2: Tests Require More Than One Step\n E2：需要多步才能做到的测试\n You should be able to run all the unit tests with just one command. In the best case you can run all the tests by clicking on one button in your IDE. In the worst case you should be able to issue a single simple command in a shell. Being able to run all the tests is so fundamental and so important that it should be quick, easy, and obvious to do.\n 你应当能够发出单个指令就可以运行全部单元测试。能够运行全部测试是如此基础和重要，应该快速、轻易和直截了当地做到。\n 17.3 FUNCTIONS 函数 #  F1: Too Many Arguments\n F1：过多的参数\n Functions should have a small number of arguments. No argument is best, followed by one, two, and three. More than three is very questionable and should be avoided with prejudice. (See “Function Arguments” on page 40.)\n 函数的参数量应该少。没参数最好，一个次之，两个、三个再次之。三个以上的参数非常值得质疑，应坚决避免。（参见前文“函数参数”一节。）\n F2: Output Arguments\n F2：输出参数\n Output arguments are counterintuitive. Readers expect arguments to be inputs, not outputs. If your function must change the state of something, have it change the state of the object it is called on. (See “Output Arguments” on page 45.)\n 输出参数违反直觉。读者期望参数用于输入而非输出。如果函数非要修改什么东西的状态不可，就修改它所在对象的状态好了。（参见前文“输出参数”一节。）\n F3: Flag Arguments\n F3：标识参数\n Boolean arguments loudly declare that the function does more than one thing. They are confusing and should be eliminated. (See “Flag Arguments” on page 41.)\n 布尔值参数大声宣告函数做了不止一件事。它们令人迷惑，应该消灭掉。（参见前文“标识参数”一节。）\n F4: Dead Function\n F4：死函数\n Methods that are never called should be discarded. Keeping dead code around is wasteful. Don’t be afraid to delete the function. Remember, your source code control system still remembers it.\n 永不被调用的方法应该丢弃。保留死代码纯属浪费。别害怕删除函数。记住，源代码控制系统还会记得它。\n 17.4 GENERAL 一般性问题 #  G1: Multiple Languages in One Source File\n G1：一个源文件中存在多种语言\n Today’s modern programming environments make it possible to put many different languages into a single source file. For example, a Java source file might contain snippets of XML, HTML, YAML, JavaDoc, English, JavaScript, and so on. For another example, in addition to HTML a JSP file might contain Java, a tag library syntax, English comments, Javadocs, XML, JavaScript, and so forth. This is confusing at best and carelessly sloppy at worst.\n 当今的现代编程环境允许在单个源文件中存在多种不同语言。例如，Java 源文件可能还包括 XML、HTML、YAML、JavaDoc、英文、JavaScript 等语言。另例，JSP 文件可能还包括 HTML、Java、标签库语法、英文注释、Javadoc、XML、JavaScript 等。往好处说是令人迷惑，往坏处说就是粗心大意、驳杂不精。\n The ideal is for a source file to contain one, and only one, language. Realistically, we will probably have to use more than one. But we should take pains to minimize both the number and extent of extra languages in our source files.\n 理想的源文件包括且只包括一种语言。现实上，我们可能会不得不使用多于一种语言。但应该尽力减少源文件中额外语言的数量和范围。\n G2: Obvious Behavior Is Unimplemented\n G2：明显的行为未被实现\n Following “The Principle of Least Surprise,”2 any function or class should implement the behaviors that another programmer could reasonably expect. For example, consider a function that translates the name of a day to an enum that represents the day.\n 遵循“最小惊异原则”（The Principle of Least Surprise）[2]，函数或类应该实现其他程序员有理由期待的行为。例如，考虑一个将日期名称翻译为表示该日期的枚举的函数。\n Day day = DayDate.StringToDay(String dayName); We would expect the string “Monday” to be translated to Day.MONDAY. We would also expect the common abbreviations to be translated, and we would expect the function to ignore case.\n 我们期望字符串 Monday 翻译为 Day.MONDAY。我们也期望常用缩写形式也能被翻译出来，我们还期待函数忽略大小写。\n When an obvious behavior is not implemented, readers and users of the code can no longer depend on their intuition about function names. They lose their trust in the original author and must fall back on reading the details of the code.\n 如果明显的行为未被实现，读者和用户就不能再依靠他们对函数名称的直觉。他们不再信任原作者，不得不阅读代码细节。\n G3: Incorrect Behavior at the Boundaries\n G3：不正确的边界行为\n It seems obvious to say that code should behave correctly. The problem is that we seldom realize just how complicated correct behavior is. Developers often write functions that they think will work, and then trust their intuition rather than going to the effort to prove that their code works in all the corner and boundary cases.\n 代码应该有正确行为，这话看似明白。问题是我们很少能明白正确行为有多复杂。开发者常常写出他们以为能工作的函数，信赖自己的直觉，而不是努力去证明代码在所有的角落和边界情形下真能工作。\n There is no replacement for due diligence. Every boundary condition, every corner case, every quirk and exception represents something that can confound an elegant and intuitive algorithm. Don’t rely on your intuition. Look for every boundary condition and write a test for it.\n 没什么可以替代谨小慎微。每种边界条件、每种极端情形、每个异常都代表了某种可能搞乱优雅而直白的算法的东西。别依赖直觉。追索每种边界条件，并编写测试。\n G4: Overridden Safeties\n G4：忽视安全\n Chernobyl melted down because the plant manager overrode each of the safety mechanisms one by one. The safeties were making it inconvenient to run an experiment. The result was that the experiment did not get run, and the world saw it’s first major civilian nuclear catastrophe.\n 切尔诺贝利核电站崩塌了，因为电厂经理一条又一条地忽视了安全机制。遵守安全就不便于做试验。结果就是试验未能运行，全世界都目睹首个民用核电站大灾难。\n It is risky to override safeties. Exerting manual control over serialVersionUID may be necessary, but it is always risky. Turning off certain compiler warnings (or all warnings!) may help you get the build to succeed, but at the risk of endless debugging sessions. Turning off failing tests and telling yourself you’ll get them to pass later is as bad as pretending your credit cards are free money.\n 忽视安全相当危险。手工控制 serialVersionUID 可能有必要，但总会有风险。关闭某些编译器警告（或者全部警告！）可能有助于构建成功，但也存在陷于无穷无尽的调试的风险。关闭失败测试、告诉自己过后再处理，这和假装刷信用卡不用还钱一样坏。\n G5: Duplication\n G5：重复\n This is one of the most important rules in this book, and you should take it very seriously. Virtually every author who writes about software design mentions this rule. Dave Thomas and Andy Hunt called it the DRY3 principle (Don’t Repeat Yourself). Kent Beck made it one of the core principles of Extreme Programming and called it: “Once, and only once.” Ron Jeffries ranks this rule second, just below getting all the tests to pass.\n 有一条本书提到的最重要的规则之一，你应该非常严肃地对待。实际上，每位编写有关软件设计的作者都提到这条规则。Dave Thomas 和 Andy Hunt 称之为 DRY 原则（Don’t Repeat Yourself，别重复自己）[3]。Kent Beck 将它列为极限编程核心原则之一，并称之为“一次，也只一次” 。Ron Jeffries 将这条规则列在第二位，地位只低于通过所有测试。\n Every time you see duplication in the code, it represents a missed opportunity for abstraction. That duplication could probably become a subroutine or perhaps another class outright. By folding the duplication into such an abstraction, you increase the vocabulary of the language of your design. Other programmers can use the abstract facilities you create. Coding becomes faster and less error prone because you have raised the abstraction level.\n 每次看到重复代码，都代表遗漏了抽象。重复的代码可能成为子程序或干脆是另一个类。将重复代码叠放进类似的抽象，增加了你的设计语言的词汇量。其他程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级。\n The most obvious form of duplication is when you have clumps of identical code that look like some programmers went wild with the mouse, pasting the same code over and over again. These should be replaced with simple methods.\n 重复最明显的形态是你不断看到明显一样的代码，就像是某位程序员疯狂地用鼠标不断复制粘贴代码。可以用单一方法来替代之。\n A more subtle form is the switch/case or if/else chain that appears again and again in various modules, always testing for the same set of conditions. These should be replaced with polymorphism.\n 较隐蔽的形态是在不同模块中不断重复出现、检测同一组条件的 switch/case 或 if/else 链。可以用多态来替代之。\n Still more subtle are the modules that have similar algorithms, but that don’t share similar lines of code. This is still duplication and should be addressed by using the TEMPLATE METHOD,4 or STRATEGY5 pattern.\n 更隐蔽的形态是采用类似算法但具体代码行不同的模块。这也是一种重复，可以使用模板方法模式[4]或策略模式[5]来修正。\n Indeed, most of the design patterns that have appeared in the last fifteen years are simply well-known ways to eliminate duplication. So too the Codd Normal Forms are a strategy for eliminating duplication in database schemae. OO itself is a strategy for organizing modules and eliminating duplication. Not surprisingly, so is structured programming.\n 的确，过去 15 年内出现的多数设计模式都是消除重复的有名手段。考德范式（Codd Normal Forms）是消除数据库规划中的重复的策略。OO 自身也是组织模块和消除重复的策略。毫不出奇，结构化编程也是。\n I think the point has been made. Find and eliminate duplication wherever you can.\n 重点已经在那里了。尽可能找到并消除重复。\n G6: Code at Wrong Level of Abstraction\n G6：在错误的抽象层级上的代码\n It is important to create abstractions that separate higher level general concepts from lower level detailed concepts. Sometimes we do this by creating abstract classes to hold the higher level concepts and derivatives to hold the lower level concepts. When we do this, we need to make sure that the separation is complete. We want all the lower level concepts to be in the derivatives and all the higher level concepts to be in the base class.\n 创建分离较高层级一般性概念与较低层级细节概念的抽象模型，这很重要。有时，我们创建抽象类来容纳较高层级概念，创建派生类来容纳较低层次概念。这样做的时候，需要确保分离完整。所有较低层级概念放在派生类中，所有较高层级概念放在基类中。\n For example, constants, variables, or utility functions that pertain only to the detailed implementation should not be present in the base class. The base class should know nothing about them.\n 例如，只与细节实现有关的常量、变量或工具函数不应该在基类中出现。基类应该对这些东西一无所知。\n This rule also pertains to source files, components, and modules. Good software design requires that we separate concepts at different levels and place them in different containers. Sometimes these containers are base classes or derivatives and sometimes they are source files, modules, or components. Whatever the case may be, the separation needs to be complete. We don’t want lower and higher level concepts mixed together.\n 这条规则对于源文件、组件和模块也适用。良好的软件设计要求分离位于不同层级的概念，将它们放到不同容器中。有时，这些容器是基类或派生类，有时是源文件、模块或组件。无论哪种情况，分离都要完整。较低层级概念和较高层级概念不应混杂在一起。\n Consider the following code:\n 看看下面的代码：\n public interface Stack { Object pop() throws EmptyException; void push(Object o) throws FullException; double percentFull(); class EmptyException extends Exception {} class FullException extends Exception {} } The percentFull function is at the wrong level of abstraction. Although there are many implementations of Stack where the concept of fullness is reasonable, there are other implementations that simply could not know how full they are. So the function would be better placed in a derivative interface such as BoundedStack.\n 函数 percentFull 位于错误的抽象层级。尽管存在许多在其中“充满”（fullness）概念有意义的 Stack 的实现，但也有其他不能知道自己有多满的实现存在。所以，该函数最好是放在类似 BoundedStack 之类的派生接口中。\n Perhaps you are thinking that the implementation could just return zero if the stack were boundless. The problem with that is that no stack is truly boundless. You cannot really prevent an OutOfMemoryException by checking for\n 你或许会认为，如果堆栈无边界，实现可以返回 0。问题是，不存在真的无边界的堆栈。你不能真的避免在做以下检查时出现 OutOfMemoryException 异常：\n stack.percentFull() \u0026lt; 50.0. Implementing the function to return 0 would be telling a lie.\n 实现返回 0 的函数可能是在撒谎。\n The point is that you cannot lie or fake your way out of a misplaced abstraction. Isolating abstractions is one of the hardest things that software developers do, and there is no quick fix when you get it wrong.\n 要点是你不能就错误放置的抽象模型撒谎。孤立抽象是软件开发者最难做到的事之一，而且一旦做错也没有快捷的修复手段。\n G7: Base Classes Depending on Their Derivatives\n G7：基类依赖于派生类\n The most common reason for partitioning concepts into base and derivative classes is so that the higher level base class concepts can be independent of the lower level derivative class concepts. Therefore, when we see base classes mentioning the names of their derivatives, we suspect a problem. In general, base classes should know nothing about their derivatives.\n 将概念分解到基类和派生类的最普遍的原因是较高层级基类概念可以不依赖于较低层级派生类概念。这样，如果看到基类提到派生类名称，就可能发现了问题。通常来说，基类对派生类应该一无所知。\n There are exceptions to this rule, of course. Sometimes the number of derivatives is strictly fixed, and the base class has code that selects between the derivatives. We see this a lot in finite state machine implementations. However, in that case the derivatives and base class are strongly coupled and always deploy together in the same jar file. In the general case we want to be able to deploy derivatives and bases in different jar files.\n 当然也有例外。有时，派生类数量严格固定，而基类中拥有在派生类之间选择的代码。在有限状态机的实现中这种情形很多见。然而，在那种情况下，派生类和基类紧密耦合，总是在同一个 jar 文件中部署。一般情况下，我们会想要把派生类和基类部署到不同的 jar 文件中。\n Deploying derivatives and bases in different jar files and making sure the base jar files know nothing about the contents of the derivative jar files allow us to deploy our systems in discrete and independent components. When such components are modified, they can be redeployed without having to redeploy the base components. This means that the impact of a change is greatly lessened, and maintaining systems in the field is made much simpler.\n 将派生类和基类部署到不同的 jar 文件中，确保基类 jar 文件对派生类 jar 文件的内容一无所知，我们就能把系统部署为分散和独立的组件。修改了这些组件时，不必重新部署基组件就能部署它们。这意味着修改产生的影响极大地降低了，而维护系统也变得更加简单。\n G8: Too Much Information\n G8：信息过多\n Well-defined modules have very small interfaces that allow you to do a lot with a little. Poorly defined modules have wide and deep interfaces that force you to use many different gestures to get simple things done. A well-defined interface does not offer very many functions to depend upon, so coupling is low. A poorly defined interface provides lots of functions that you must call, so coupling is high.\n 设计良好的模块有着非常小的接口，让你能事半功倍。设计低劣的模块有着广阔、深入的接口，你不得不事倍功半。设计良好的接口并不提供许多需要依靠的函数，所以耦合度也较低。设计低劣的借口提供大量你必须调用的函数，耦合度较高。\n Good software developers learn to limit what they expose at the interfaces of their classes and modules. The fewer methods a class has, the better. The fewer variables a function knows about, the better. The fewer instance variables a class has, the better.\n 优秀的软件开发人员学会限制类或模块中暴露的接口数量。类中的方法越少越好。函数知道的变量越少越好。类拥有的实体变量越少越好。\n Hide your data. Hide your utility functions. Hide your constants and your temporaries. Don’t create classes with lots of methods or lots of instance variables. Don’t create lots of protected variables and functions for your subclasses. Concentrate on keeping interfaces very tight and very small. Help keep coupling low by limiting information.\n 隐藏你的数据。隐藏你的工具函数。隐藏你的常量和你的临时变量。不要创建拥有大量方法或大量实体变量的类。不要为子类创建大量受保护变量和函数。尽力保持接口紧凑。通过限制信息来控制耦合度。\n G9: Dead Code\n G9：死代码\n Dead code is code that isn’t executed. You find it in the body of an if statement that checks for a condition that can’t happen. You find it in the catch block of a try that never throws. You find it in little utility methods that are never called or switch/case conditions that never occur.\n 死代码就是不执行的代码。可以在检查不会发生的条件的 if 语句体中找到。可以在从不抛出异常的 try 语句的 catch 块中找到。可以在从不被调用的小工具方法中找到，也可以在永不会发生的 switch/case 条件中找到。\n The problem with dead code is that after awhile it starts to smell. The older it is, the stronger and sourer the odor becomes. This is because dead code is not completely updated when designs change. It still compiles, but it does not follow newer conventions or rules. It was written at a time when the system was different. When you find dead code, do the right thing. Give it a decent burial. Delete it from the system.\n 死代码的问题是过不久它就会发出臭味。时间越久，味道就越酸臭。这是因为，在设计改变时，死代码不会随之更新。它还能通过编译，但并不会遵循较新的约定或规则。它编写的时候，系统是另一番模样。如果你找到死代码，就体面地埋葬它，将它从系统中删除掉。\n G10: Vertical Separation\n G10：垂直分隔\n Variables and function should be defined close to where they are used. Local variables should be declared just above their first usage and should have a small vertical scope. We don’t want local variables declared hundreds of lines distant from their usages.\n 变量和函数应该在靠近被使用的地方定义。本地变量应该正好在其首次被使用的位置上面声明，垂直距离要短。本地变量不该在其被使用之处几百行以外声明。\n Private functions should be defined just below their first usage. Private functions belong to the scope of the whole class, but we’d still like to limit the vertical distance between the invocations and definitions. Finding a private function should just be a matter of scanning downward from the first usage.\n 私有函数应该刚好在其首次被使用的位置下面定义。私有函数属于整个类，但我们还是要限制调用和定义之间的垂直距离。找个私有函数，应该只是从其首次被使用处往下看一点那么简单。\n G11: Inconsistency\n G11：前后不一致\n If you do something a certain way, do all similar things in the same way. This goes back to the principle of least surprise. Be careful with the conventions you choose, and once chosen, be careful to continue to follow them.\n 从一而终。这可以追溯到最小惊异原则。小心选择约定，一旦选中，就小心持续遵循。\n If within a particular function you use a variable named response to hold an HttpServletResponse, then use the same variable name consistently in the other functions that use HttpServletResponse objects. If you name a method processVerificationRequest, then use a similar name, such as processDeletionRequest, for the methods that process other kinds of requests.\n 如果在特定函数中用名为 response 的变量来持有 HttpServletResponse 对象，则在其他用到 HttpServletResponse 对象的函数中也用同样的变量名。如果将某个方法命名为 processVerificationRequest，则给处理其他请求类型的方法取类似的名字，例如 processDeletion Request。\n Simple consistency like this, when reliably applied, can make code much easier to read and modify.\n 如此简单的前后一致，一旦坚决贯彻，就能让代码更加易于阅读和修改。\n G12: Clutter\n G12：混淆视听\n Of what use is a default constructor with no implementation? All it serves to do is clutter up the code with meaningless artifacts. Variables that aren’t used, functions that are never called, comments that add no information, and so forth. All these things are clutter and should be removed. Keep your source files clean, well organized, and free of clutter.\n 没有实现的默认构造器有何用处呢？它只会用无意义的杂碎搞乱对代码的理解。没有用到的变量，从不调用的函数，没有信息量的注释，等等，这些都是应该移除的废物。保持源文件整洁，良好地组织，不被搞乱。\n G13: Artificial Coupling\n G13：人为耦合\n Things that don’t depend upon each other should not be artificially coupled. For example, general enums should not be contained within more specific classes because this forces the whole application to know about these more specific classes. The same goes for general purpose static functions being declared in specific classes.\n 不互相依赖的东西不该耦合。例如，普通的 enum 不应在特殊类中包括，因为这样一来应用程序就要了解这些更为特殊的类。对于在特殊类中声明一般目的的 static 函数也是如此。\n In general an artificial coupling is a coupling between two modules that serves no direct purpose. It is a result of putting a variable, constant, or function in a temporarily convenient, though inappropriate, location. This is lazy and careless.\n 一般来说，人为耦合是指两个没有直接目的之间的模块的耦合。其根源是将变量、常量或函数不恰当地放在临时方便的位置。这是种漫不经心的偷懒行为。\n Take the time to figure out where functions, constants, and variables ought to be declared. Don’t just toss them in the most convenient place at hand and then leave them there.\n 花点时间研究应该在什么地方声明函数、常量和变量。不要为了方便随手放置，然后置之不理。\n G14: Feature Envy\n G14：特性依恋\n This is one of Martin Fowler’s code smells.6 The methods of a class should be interested in the variables and functions of the class they belong to, and not the variables and functions of other classes. When a method uses accessors and mutators of some other object to manipulate the data within that object, then it envies the scope of the class of that other object. It wishes that it were inside that other class so that it could have direct access to the variables it is manipulating. For example:\n 这是 Martin Fowler 提出的代码味道之一[6]。类的方法只应对其所属类中的变量和函数感兴趣，不该垂青其他类中的变量和函数。当方法通过某个其他对象的访问器和修改器来操作该对象内部数据，则它就依恋于该对象所属类的范围。它期望自己在那个类里面，这样就能直接访问它操作的变量。例如：\n public class HourlyPayCalculator { public Money calculateWeeklyPay(HourlyEmployee e) { int tenthRate = e.getTenthRate().getPennies(); int tenthsWorked = e.getTenthsWorked(); int straightTime = Math.min(400, tenthsWorked); int overTime = Math.max(0, tenthsWorked - straightTime); int straightPay = straightTime * tenthRate; int overtimePay = (int)Math.round(overTime*tenthRate*1.5); return new Money(straightPay + overtimePay); } } The calculateWeeklyPay method reaches into the HourlyEmployee object to get the data on which it operates. The calculateWeeklyPay method envies the scope of HourlyEmployee. It “wishes” that it could be inside HourlyEmployee.\n 方法 calculateWeeklyPay 伸手到 HourlyEmployee 对象，获取要操作的数据。方法 calculateWeeklyPay 依恋于 HourlyEmployee 的作用范围。它“期望”自己在 HourlyEmployee 中。\n All else being equal, we want to eliminate Feature Envy because it exposes the internals of one class to another. Sometimes, however, Feature Envy is a necessary evil. Consider the following:\n 同样情况下，我们要消除特性依恋，因为它将一个类的内部情形暴露给了另外一个类。不过，有时特性依恋是种有必要的恶行。看下面的代码：\n public class HourlyEmployeeReport { private HourlyEmployee employee ; public HourlyEmployeeReport(HourlyEmployee e) { this.employee = e; } String reportHours() { return String.format( “Name: %s\\tHours:%d.%1d\\n”, employee.getName(), employee.getTenthsWorked()/10, employee.getTenthsWorked()%10); } } Clearly, the reportHours method envies the HourlyEmployee class. On the other hand, we don’t want HourlyEmployee to have to know about the format of the report. Moving that format string into the HourlyEmployee class would violate several principles of object oriented design.7 It would couple HourlyEmployee to the format of the report, exposing it to changes in that format.\n 显然，reportHours 方法依恋于 HourlyEmployee 类。另一方面，我们并不想要 HourlyEmployee 得知报告的格式。把格式化字符串移到 HourlyEmployee 会破坏好几种面向对象设计原则[7]。它将把 HourlyEmployee 与报告的格式耦合起来，向该格式的修改暴露这个类。\n G15: Selector Arguments\n G15：选择算子参数\n There is hardly anything more abominable than a dangling false argument at the end of a function call. What does it mean? What would it change if it were true? Not only is the purpose of a selector argument difficult to remember, each selector argument combines many functions into one. Selector arguments are just a lazy way to avoid splitting a large function into several smaller functions. Consider:\n 没有什么比在函数调用末尾遇到一个 false 参数更为可憎的事情了。那个 false 是什么意思？如果它是 true，会有什么变化吗？不仅是一个选择算子（selector）参数的目的难以记住，每个选择算子参数将多个函数绑到了一起。选择算子参数只是一种避免把大函数切分为多个小函数的偷懒做法。考虑下面这段代码：\n public int calculateWeeklyPay(boolean overtime) { int tenthRate = getTenthRate(); int tenthsWorked = getTenthsWorked(); int straightTime = Math.min(400, tenthsWorked); int overTime = Math.max(0, tenthsWorked - straightTime); int straightPay = straightTime * tenthRate; double overtimeRate = overtime ? 1.5 : 1.0 * tenthRate; int overtimePay = (int)Math.round(overTime*overtimeRate); return straightPay + overtimePay; } You call this function with a true if overtime is paid as time and a half, and with a false if overtime is paid as straight time. It’s bad enough that you must remember what calculateWeeklyPay(false) means whenever you happen to stumble across it. But the real shame of a function like this is that the author missed the opportunity to write the following:\n 当加班时间以一倍半计算薪资时，用 true 调用这个函数，false 则表示直接计算。每次用到这个函数，你都得记住 calculateWeeklyPay(false) 表示什么，这已经足够糟糕了。但这种函数真正的坏处在于作者错过了这样写的机会：\n public int straightPay() { return getTenthsWorked() * getTenthRate(); } public int overTimePay() { int overTimeTenths = Math.max(0, getTenthsWorked() - 400); int overTimePay = overTimeBonus(overTimeTenths); return straightPay() + overTimePay; } private int overTimeBonus(int overTimeTenths) { double bonus = 0.5 * getTenthRate() * overTimeTenths; return (int) Math.round(bonus); } Of course, selectors need not be boolean. They can be enums, integers, or any other type of argument that is used to select the behavior of the function. In general it is better to have many functions than to pass some code into a function to select the behavior.\n 当然，选择算子不一定是 boolean 类型。可能是枚举元素、整数或任何一种用于选择函数行为的参数。使用多个函数，通常优于向单个函数传递某些代码来选择函数行为。\n G16: Obscured Intent\n G16：晦涩的意图\n We want code to be as expressive as possible. Run-on expressions, Hungarian notation, and magic numbers all obscure the author’s intent. For example, here is the overTimePay function as it might have appeared:\n 代码要尽可能具有表达力。联排表达式、匈牙利语标记法和魔术数都遮蔽了作者的意图。例如，下面是 overTimePay 函数可能的一种表现形式：\n public int m_otCalc() { return iThsWkd * iThsRte + (int) Math.round(0.5 * iThsRte * Math.max(0, iThsWkd - 400) ); } Small and dense as this might appear, it’s also virtually impenetrable. It is worth taking the time to make the intent of our code visible to our readers.\n 它既短小又紧凑，但实际上不可捉摸。值得花时间将代码的意图呈现给读者。\n G17: Misplaced Responsibility\n G17：位置错误的权责\n One of the most important decisions a software developer can make is where to put code. For example, where should the PI constant go? Should it be in the Math class? Perhaps it belongs in the Trigonometry class? Or maybe in the Circle class?\n 软件开发者做出的最重要决定之一就是在哪里放代码。例如，PI 常量放在何处？是该在 Math 类中吗？或者应该属于 Trigonometry 类？还是在 Circle 类？\n The principle of least surprise comes into play here. Code should be placed where a reader would naturally expect it to be. The PI constant should go where the trig functions are declared. The OVERTIME_RATE constant should be declared in the HourlyPay-Calculator class.\n 最小惊异原则在这里起作用了。代码应该放在读者自然而然期待它所在的地方。PI 常量应该在出现在声明三角函数的地方。OVERTIME_RATE 常量应该在 HourlyPayCalculator 类中声明。\n Sometimes we get “clever” about where to put certain functionality. We’ll put it in a function that’s convenient for us, but not necessarily intuitive to the reader. For example, perhaps we need to print a report with the total of hours that an employee worked. We could sum up those hours in the code that prints the report, or we could try to keep a running total in the code that accepts time cards.\n 有时，我们“聪明”地知道在何处放置功能代码。我们会放在自己方便而读者不能随直觉找到的地方。例如，也许我们需要打印出某个雇员的总工作时间的报表。我们可以在打印报表的代码中做工作时间统计，或者我们可以在接受工作时间卡的代码中保留一份工作时间记录。\n One way to make this decision is to look at the names of the functions. Let’s say that our report module has a function named getTotalHours. Let’s also say that the module that accepts time cards has a saveTimeCard function. Which of these two functions, by it’s name, implies that it calculates the total? The answer should be obvious.\n 做这个决定的途径之一是看函数名称。比如，报表模块有个名为 getTotalHours 的函数。接受时间卡的模块有一个 saveTimeCard 函数。顾名思义，哪个名称暗示了函数会计算总时间呢？答案显而易见。\n Clearly, there are sometimes performance reasons why the total should be calculated as time cards are accepted rather than when the report is printed. That’s fine, but the names of the functions ought to reflect this. For example, there should be a computeRunning-TotalOfHours function in the timecard module.\n 显然，对于总时间应该在接受时间卡的时候计算而不是在打印报表时计算，这里面有些性能上的考量。没问题，但函数名称应该反映这种考虑。例如，应该在时间卡模块中有个 computeRunningTotalOfHours 函数。\n G18: Inappropriate Static\n G18：不恰当的静态方法\n Math.max(double a, double b) is a good static method. It does not operate on a single instance; indeed, it would be silly to have to say new Math().max(a,b) or even a.max(b). All the data that max uses comes from its two arguments, and not from any “owning” object. More to the point, there is almost no chance that we’d want Math.max to be polymorphic.\n Math.max(double a, double)是个良好的静态方法。它并不在单个实体上操作；的确，不得不写 new Math( ).max(a,b)甚至 a.max(b)实在愚蠢。那个 max 用到的全部数据来自其两个参数，而不是来自“所属”对象。而且，我们也没机会用到 Math.max 的多态特征。\n Sometimes, however, we write static functions that should not be static. For example, consider:\n 不过，我们有时也编写不该是静态的静态方法。例如：\n HourlyPayCalculator.calculatePay(employee, overtimeRate). Again, this seems like a reasonable static function. It doesn’t operate on any particular object and gets all it’s data from it’s arguments. However, there is a reasonable chance that we’ll want this function to be polymorphic. We may wish to implement several different algorithms for calculating hourly pay, for example, OvertimeHourlyPayCalculator and StraightTimeHourlyPayCalculator. So in this case the function should not be static. It should be a nonstatic member function of Employee.\n 这看起来像是个有道理的 static 函数。它并不在任何特定对象上操作，而且从参数中获得全部数据。然而，我们却有理由希望这个函数是多态的。我们可能希望为计算每小时支付工资实现几种不同算法，例如 OvertimeHourlyPayCalculator 和 StraightTimeHourlyPayCalculator。所以，在这种情况下，该函数就不该是静态的。它该是 Employee 的非静态成员函数。\n In general you should prefer nonstatic methods to static methods. When in doubt, make the function nonstatic. If you really want a function to be static, make sure that there is no chance that you’ll want it to behave polymorphically.\n 通常应该倾向于选用非静态方法。如果有疑问，就是用非静态函数。如果的确需要静态函数，确保没机会打算让它有多态行为。\n G19: Use Explanatory Variables\n G19：使用解释性变量\n Kent Beck wrote about this in his great book Smalltalk Best Practice Patterns8 and again more recently in his equally great book Implementation Patterns.9 One of the more powerful ways to make a program readable is to break the calculations up into intermediate values that are held in variables with meaningful names.\n Kent Beck 在其巨著 Smalltalk Best Practice Patterns[8]和另一部巨著 Implementation Patterns （中译版 《实现模式》）[9]中都写到这个。让程序可读的最有力方法之一就是将计算过程打散成在用有意义的单词命名的变量中放置的中间值。\n Consider this example from FitNesse:\n 看看来自 FitNesse 的这个例子：\n Matcher match = headerPattern.matcher(line); if(match.find()) { String key = match.group(1); String value = match.group(2); headers.put(key.toLowerCase(), value); } The simple use of explanatory variables makes it clear that the first matched group is the key, and the second matched group is the value.\n 解释性变量的这种简单用法，说明了第一个匹配组是 key，而第二个匹配组是 value。\n It is hard to overdo this. More explanatory variables are generally better than fewer. It is remarkable how an opaque module can suddenly become transparent simply by breaking the calculations up into well-named intermediate values.\n 这事很难做过火。解释性变量多比少好。只要把计算过程打散成一系列良好命名的中间值，不透明的模块就会突然变得透明，这很值得注意。\n G20: Function Names Should Say What They Do\n G20：函数名称应该表达其行为\n Look at this code:\n 看看这行代码：\n Date newDate = date.add(5); Would you expect this to add five days to the date? Or is it weeks, or hours? Is the date instance changed or does the function just return a new Date without changing the old one? You can’t tell from the call what the function does.\n 你会期望它向日期添加 5 天吗？或者是 5 个星期？5 个小时？该 date 实体会变化吗？或者该函数只是返回一个新的 Date 实体，并不改动旧的？从函数调用中看不出函数的行为。\n If the function adds five days to the date and changes the date, then it should be called addDaysTo or increaseByDays. If, on the other hand, the function returns a new date that is five days later but does not change the date instance, it should be called daysLater or daysSince.\n 如果函数向日期添加 5 天并且修改该日期，就该命名为 addDaysTo 或 increaseByDays。如果函数返回一个表示 5 天后的日期，而不修改日期实体，就该叫做 daysLater 或 daysSince。\n If you have to look at the implementation (or documentation) of the function to know what it does, then you should work to find a better name or rearrange the functionality so that it can be placed in functions with better names.\n 如果你必须查看函数的实现（或文档）才知道它是做什么的，就该换个更好的函数名，或者重新安排功能代码，放到有较好名称的函数中。\n G21: Understand the Algorithm\n G21：理解算法\n Lots of very funny code is written because people don’t take the time to understand the algorithm. They get something to work by plugging in enough if statements and flags, without really stopping to consider what is really going on.\n 好多可笑代码的出现，是因为人们没花时间去理解算法。他们硬塞进足够多的 if 语句和标识，从不真正停下来考虑发生了什么，勉强让系统能工作。\n Programming is often an exploration. You think you know the right algorithm for something, but then you wind up fiddling with it, prodding and poking at it, until you get it to “work.” How do you know it “works”? Because it passes the test cases you can think of.\n 编程常常是一种探险。你以为自己知道某事的正确算法，然后就卷起袖子瞎干一气，搞到“可以工作”为止。你怎么知道它“可以工作”？因为它通过了你能想到的单元测试。\n There is nothing wrong with this approach. Indeed, often it is the only way to get a function to do what you think it should. However, it is not sufficient to leave the quotation marks around the word “work.”\n 这种做法没错。实际上，这也是让函数按你设想的方式执行的唯一途径。不过，“可以工作”周围的引号可不能一直保留。\n Before you consider yourself to be done with a function, make sure you understand how it works. It is not good enough that it passes all the tests. You must know10 that the solution is correct.\n 在你认为自己完成某个函数之前，确认自己理解了它是怎么工作的。通过全部测试还不够好。你必须知道[10]解决方案是正确的。\n Often the best way to gain this knowledge and understanding is to refactor the function into something that is so clean and expressive that it is obvious how it works.\n 获得这种知识和理解的最好途径，往往是重构函数，得到某种整洁而足具表达力、清楚呈示如何工作的东西。\n G22: Make Logical Dependencies Physical\n G22：把逻辑依赖改为物理依赖\n If one module depends upon another, that dependency should be physical, not just logical. The dependent module should not make assumptions (in other words, logical dependencies) about the module it depends upon. Rather it should explicitly ask that module for all the information it depends upon.\n 如果某个模块依赖于另一个模块，依赖就该是物理上的而不是逻辑上的。依赖者模块不应对被依赖者模块有假定（换言之，逻辑依赖）。它应当明确地询问后者全部信息。\n For example, imagine that you are writing a function that prints a plain text report of hours worked by employees. One class named HourlyReporter gathers all the data into a convenient form and then passes it to HourlyReportFormatter to print it. (See Listing 17-1.)\n 例如，想像你在编写一个打印出雇员工作时长的纯文本报表的函数。有个名为 HourlyReporter 的类把数据收集为某种方便的形式，传递到 HourlyReportFormatter 中，再打印出来。（如代码清单 17-1 所示。）\n Listing 17-1 HourlyReporter.java\n 代码清单 17-1 HourlyReporter.java\n public class HourlyReporter { private HourlyReportFormatter formatter; private List\u0026lt;LineItem\u0026gt; page; private final int PAGE_SIZE = 55; public HourlyReporter(HourlyReportFormatter formatter) { this.formatter = formatter; page = new ArrayList\u0026lt;LineItem\u0026gt;(); } public void generateReport(List\u0026lt;HourlyEmployee\u0026gt; employees) { for (HourlyEmployee e : employees) { addLineItemToPage(e); if (page.size() == PAGE_SIZE) printAndClearItemList(); } if (page.size() \u0026gt; 0) printAndClearItemList(); } private void printAndClearItemList() { formatter.format(page); page.clear(); } private void addLineItemToPage(HourlyEmployee e) { LineItem item = new LineItem(); item.name = e.getName(); item.hours = e.getTenthsWorked() / 10; item.tenths = e.getTenthsWorked() % 10; page.add(item); } public class LineItem { public String name; public int hours; public int tenths; } } This code has a logical dependency that has not been physicalized. Can you spot it? It is the constant PAGE_SIZE. Why should the HourlyReporter know the size of the page? Page size should be the responsibility of the HourlyReportFormatter.\n 这段代码有尚未物理化的逻辑依赖。你能指出来吗？那就是常量 PAGE_SIZE。HourlyReporter 为什么要知道页面尺寸？页面尺寸只该是 HourlyReportFormatter 的权责。\n The fact that PAGE_SIZE is declared in HourlyReporter represents a misplaced responsibility [G17] that causes HourlyReporter to assume that it knows what the page size ought to be. Such an assumption is a logical dependency. HourlyReporter depends on the fact that HourlyReportFormatter can deal with page sizes of 55. If some implementation of HourlyReportFormatter could not deal with such sizes, then there would be an error.\n AGE_SIZE 在 HourlyReporter 中声明，代表了一种位置错误的权责 [G17]，导致 HourlyReporter 假定它知道页面尺寸。这类假设是一种逻辑依赖。HourlyReporter 依赖于 HourlyReportFormatter 能应付 55 的页面尺寸。如果 HourlyReportFormatter 的某些实现不能处理这样的尺寸，就会出错。\n We can physicalize this dependency by creating a new method in HourlyReport-Formatter named getMaxPageSize(). HourlyReporter will then call that function rather than using the PAGE_SIZE constant.\n 可以通过创建 HourlyReport 中名为 getMaxPageSize() 的新方法来物理化这种依赖。HourlyReporter 将调用这个方法，而不是使用 PAGE_SIZE 常量。\n G23: Prefer Polymorphism to If/Else or Switch/Case\n G23：用多态替代 If/Else 或 Switch/Case\n This might seem a strange suggestion given the topic of Chapter 6. After all, in that chapter I make the point that switch statements are probably appropriate in the parts of the system where adding new functions is more likely than adding new types.\n 有了第 6 章谈及的主题，这条建议看似奇怪。在那章中，我提出在添加新函数甚于添加新类型的系统中，switch 语句是恰当的。\n First, most people use switch statements because it’s the obvious brute force solution, not because it’s the right solution for the situation. So this heuristic is here to remind us to consider polymorphism before using a switch.\n 首先，多数人使用 switch 语句，因为它是最直截了当又有力的方案，而不是因为它适合当前情形。这给我们的启发是在使用 switch 之前，先考虑使用多态。\n Second, the cases where functions are more volatile than types are relatively rare. So every switch statement should be suspect.\n 其次，函数变化甚于类型变化的情形相对罕见。每个 switch 语句都值得怀疑。\n I use the following “ONE SWITCH” rule: There may be no more than one switch statement for a given type of selection. The cases in that switch statement must create polymorphic objects that take the place of other such switch statements in the rest of the system.\n 我使用所谓“单个 switch”规则：对于给定的选择类型，不应有多于一个 switch 语句。在那个 switch 语句中的多个 case，必须创建多态对象，取代系统中其他类似 switch 语句。\n G24: Follow Standard Conventions\n G24：遵循标准约定\n Every team should follow a coding standard based on common industry norms. This coding standard should specify things like where to declare instance variables; how to name classes, methods, and variables; where to put braces; and so on. The team should not need a document to describe these conventions because their code provides the examples.\n 每个团队都应遵循基于通用行业规范的一套编码标准。编码标准应指定诸如在何处声明实体变量，如何命名类，方法和变量，在何处放置括号，等等。团队不应用文档描述这些约定，因为代码本身提供了范例。\n Everyone on the team should follow these conventions. This means that each team member must be mature enough to realize that it doesn’t matter a whit where you put your braces so long as you all agree on where to put them.\n 团队中的每个成员都应遵循这些约定。这意味着每个团队成员必须成熟到能了解只要全体同意在何处放置括号，那么在哪里放置都无关紧要。\n If you would like to know what conventions I follow, you’ll see them in the refactored code in Listing B-7 on page 394, through Listing B-14.\n 如果你想知道我遵循哪些约定，可以查看代码清单 B-7~B-14 中重构之后的代码。\n G25: Replace Magic Numbers with Named Constants\n G25：用命名常量替代魔术数\n This is probably one of the oldest rules in software development. I remember reading it in the late sixties in introductory COBOL, FORTRAN, and PL/1 manuals. In general it is a bad idea to have raw numbers in your code. You should hide them behind well-named constants.\n 这大概是软件开发中最古老的规则之一了。我记得，在 20 世纪 60 年代介绍 COBOL、FORTRAN 和 PL/1 的手册中就读到过。在代码中出现原始形态数字通常来说是坏现象。应该用良好命名的常量来隐藏它。\n For example, the number 86,400 should be hidden behind the constant SECONDS_PER_DAY. If you are printing 55 lines per page, then the constant 55 should be hidden behind the constant LINES_PER_PAGE.\n 例如，数字 86400 应当藏在常量 SECONDS_PER_DAY 后面。如果每页打印 55 行，则常数 55 应该藏在常量 LINES_PER_PAGE 后面。\n Some constants are so easy to recognize that they don’t always need a named constant to hide behind so long as they are used in conjunction with very self-explanatory code. For example:\n 有些常量与非常具有自我解释能力的代码协同工作时，如此易于识别，也就不必总是需要命名常量来隐藏了。例如：\n double milesWalked = feetWalked/5280.0; int dailyPay = hourlyRate * 8; double circumference = radius * Math.PI * 2; Do we really need the constants FEET_PER_MILE, WORK_HOURS_PER_DAY, and TWO in the above examples? Clearly, the last case is absurd. There are some formulae in which constants are simply better written as raw numbers. You might quibble about the WORK_HOURS_PER_DAY case because the laws or conventions might change. On the other hand, that formula reads so nicely with the 8 in it that I would be reluctant to add 17 extra characters to the readers’ burden. And in the FEET_PER_MILE case, the number 5280 is so very well known and so unique a constant that readers would recognize it even if it stood alone on a page with no context surrounding it.\n 在上例中，我们真需要常量 FEET_PER_MILE、WORK_HOURS_PER_DAY 和 TWO 吗？显然，最后那个很可笑。有些情况下，常量直接写作原始形态数字会更好。你可能会质疑 WORK_HOURS_PER_DAY，因为约定规则可能会改变。另一方面，在这里直接用数字 8 读起来很舒服，也就没必要非用 17 个额外的字母来加重读者负担不可。对于 FEET_PER_MILE，数字 5280 众人皆知，意义独特，即便没有上下文环境，读者也能识别它。\n Constants like 3.141592653589793 are also very well known and easily recognizable. However, the chance for error is too great to leave them raw. Every time someone sees 3.1415927535890793, they know that it is π, and so they fail to scrutinize it. (Did you catch the single-digit error?) We also don’t want people using 3.14, 3.14159, 3.142, and so forth. Therefore, it is a good thing that Math.PI has already been defined for us.\n 3.141592653589793 之类常数也众所周知，很容易识别。不过，如果直接使用原始形式，却很有可能出错。每次有人看到 3.141592653589793，都会知道那是 p 值，从而不会去仔细查看。（你发现那个错误的数字了吗？）我们不想要人们使用 3.14、3.14159 或 3.142 等。所以，为我们定义好 Math.PI 是件好事。\n The term “Magic Number” does not apply only to numbers. It applies to any token that has a value that is not self-describing. For example:\n 术语“魔术数”不仅是说数字。它泛指任何不能自我描述的符号。例如：\n assertEquals(7777, Employee.find(“John Doe”).employeeNumber()); There are two magic numbers in this assertion. The first is obviously 7777, though what it might mean is not obvious. The second magic number is “John Doe,” and again the intent is not clear.\n 上列断言中有两个魔术数。第一个显然是 777，它的意义并不明确。第二个魔术数是 John Doe，因为其意图不明显。\n It turns out that “John Doe” is the name of employee #7777 in a well-known test database created by our team. Everyone in the team knows that when you connect to this database, it will have several employees already cooked into it with well-known values and attributes. It also turns out that “John Doe” represents the sole hourly employee in that test database. So this test should really read:\n John Doe 是开发团队创建的测试数据中编号为#7777 的雇员。团队中每个成员都知道，当连接到数据库时，里面已经有数个雇员信息，其值和属性都是大家熟知的。所以，这个测试应该读作：\n assertEquals( HOURLY_EMPLOYEE_ID, Employee.find(HOURLY_EMPLOYEE_NAME).employeeNumber()); G26: Be Precise\n G26：准确\n Expecting the first match to be the only match to a query is probably naive. Using floating point numbers to represent currency is almost criminal. Avoiding locks and/or transaction management because you don’t think concurrent update is likely is lazy at best. Declaring a variable to be an ArrayList when a List will due is overly constraining. Making all variables protected by default is not constraining enough.\n 期望某个查询的第一次匹配就是唯一匹配可能过于天真。用浮点数表示货币几近于犯罪。因为你不想做并发更新就避免使用锁和/或事务管理往好处说也是一种懒惰行为。在可以用 List 的时候非要把变量声明为 ArrayList 就过分拘束了。把所有变量设置为 protected 却不够自律。\n When you make a decision in your code, make sure you make it precisely. Know why you have made it and how you will deal with any exceptions. Don’t be lazy about the precision of your decisions. If you decide to call a function that might return null, make sure you check for null. If you query for what you think is the only record in the database, make sure your code checks to be sure there aren’t others. If you need to deal with currency, use integers11 and deal with rounding appropriately. If there is the possibility of concurrent update, make sure you implement some kind of locking mechanism.\n 在代码中做决定时，确认自己足够准确。明确自己为何要这么做，如果遇到异常情况如何处理。别懒得理会决定的准确性。如果你打算调用可能返回 null 的函数，确认自己检查了 null 值。如果查询你认为是数据库中唯一的记录，确保代码检查不存在其他记录。如果要处理货币数据，使用整数[11]，并恰当地处理四舍五入。如果可能有并发更新，确认你实现了某种锁定机制。\n Ambiguities and imprecision in code are either a result of disagreements or laziness. In either case they should be eliminated.\n 代码中的含糊和不准确要么是意见不同的结果，要么源于懒惰。无论原因是什么，都要消除。\n G27: Structure over Convention\n G27：结构甚于约定\n Enforce design decisions with structure over convention. Naming conventions are good, but they are inferior to structures that force compliance. For example, switch/cases with nicely named enumerations are inferior to base classes with abstract methods. No one is forced to implement the switch/case statement the same way each time; but the base classes do enforce that concrete classes have all abstract methods implemented.\n 坚守结构甚于约定的设计决策。命名约定很好，但却次于强制性的结构。例如，用到良好命名的枚举的 switch/case 要弱于拥有抽象方法的基类。没人会被强迫每次都以同样方式实现 switch/case 语句，但基类却让具体类必须实现所有抽象方法。\n G28: Encapsulate Conditionals\n G28：封装条件\n Boolean logic is hard enough to understand without having to see it in the context of an if or while statement. Extract functions that explain the intent of the conditional.\n 如果没有 if 或 while 语句的上下文，布尔逻辑就难以理解。应该把解释了条件意图的函数抽离出来。\n For example:\n 例如：\n if (shouldBeDeleted(timer)) is preferable to\n 好于\n if (timer.hasExpired() \u0026amp;\u0026amp; !timer.isRecurrent()) G29: Avoid Negative Conditionals\n G29：避免否定性条件\n Negatives are just a bit harder to understand than positives. So, when possible, conditionals should be expressed as positives. For example:\n 否定式要比肯定式难明白一些。所以，尽可能将条件表示为肯定形式。例如：\n if (buffer.shouldCompact()) is preferable to\nif (!buffer.shouldNotCompact()) G30: Functions Should Do One Thing\n G30：函数只该做一件事\n It is often tempting to create functions that have multiple sections that perform a series of operations. Functions of this kind do more than one thing, and should be converted into many smaller functions, each of which does one thing.\n 编写执行一系列操作的包括多段代码的函数常常是诱人的。这类函数做了不只一件事，应该转换为多个更小的函数，每个只做一件事。\n For example:\n 例如：\n public void pay() { for (Employee e : employees) { if (e.isPayday()) { Money pay = e.calculatePay(); e.deliverPay(pay); } } } This bit of code does three things. It loops over all the employees, checks to see whether each employee ought to be paid, and then pays the employee. This code would be better written as:\n 这段代码做了三件事。它遍历所有雇员，检查是否该给雇员付工资，然后支付薪水。代码可以写得更好，如：\n public void pay() { for (Employee e : employees) payIfNecessary(e); } private void payIfNecessary(Employee e) { if (e.isPayday()) calculateAndDeliverPay(e); } private void calculateAndDeliverPay(Employee e) { Money pay = e.calculatePay(); e.deliverPay(pay); } Each of these functions does one thing. (See “Do One Thing” on page 35.)\n 上列每个函数都只做一件事。（见前文“只做一件事”一节。）\n G31: Hidden Temporal Couplings\n》 G31：掩蔽时序耦合\nTemporal couplings are often necessary, but you should not hide the coupling. Structure the arguments of your functions such that the order in which they should be called is obvious. Consider the following:\n》 常常有必要使用时序耦合，但你不应该掩蔽它。排列函数参数，好让它们被调用的次序显而易见。看下列代码：\npublic class MoogDiver { Gradient gradient; List\u0026lt;Spline\u0026gt; splines; public void dive(String reason) { saturateGradient(); reticulateSplines(); diveForMoog(reason); } … } The order of the three functions is important. You must saturate the gradient before you can reticulate the splines, and only then can you dive for the moog. Unfortunately, the code does not enforce this temporal coupling. Another programmer could call reticulate-Splines before saturateGradient was called, leading to an UnsaturatedGradientException. A better solution is:\n 三个函数的次序很重要。捕鱼之前先织网，织网之前先编绳。不幸的是，代码并没有强制这种时序耦合。其他程序员可以在调用 saturateGradient 之前调用 reticulateSplines，从而导致抛出 UnsaturatedGradientException 异常。更好的方式是：\n public class MoogDiver { Gradient gradient; List\u0026lt;Spline\u0026gt; splines; public void dive(String reason) { Gradient gradient = saturateGradient(); List\u0026lt;Spline\u0026gt; splines = reticulateSplines(gradient); diveForMoog(splines, reason); } … } This exposes the temporal coupling by creating a bucket brigade. Each function produces a result that the next function needs, so there is no reasonable way to call them out of order.\n 这样就通过创建顺序队列暴露了时序耦合。每个函数都产生出下一个函数所需的结果，这样一来就没理由不按顺序调用了。\n You might complain that this increases the complexity of the functions, and you’d be right. But that extra syntactic complexity exposes the true temporal complexity of the situation.\n 你可能会抱怨着增加了函数的复杂度，没错，不过这点额外的复杂度却曝露了该种情况真正的时序复杂性。\n Note that I left the instance variables in place. I presume that they are needed by private methods in the class. Even so, I want the arguments in place to make the temporal coupling explicit.\n 注意我保留了那些实体变量。我假设类中的私有方法可能会用到它们。即便如此，我还是希望参数能让时序耦合变得可见。\n G32: Don’t Be Arbitrary\n G32：别随意\n Have a reason for the way you structure your code, and make sure that reason is communicated by the structure of the code. If a structure appears arbitrary, others will feel empowered to change it. If a structure appears consistently throughout the system, others will use it and preserve the convention. For example, I was recently merging changes to FitNesse and discovered that one of our committers had done this:\n 构建代码需要理由，而且理由应与代码结构相契合。如果结构显得太随意，其他人就会想修改它。如果结构自始至终保持一致，其他人就会使用它，并且遵循其约定。例如，我最近对 FitNesse 做合并修改，发现有位贡献者这么做：\n public class AliasLinkWidget extends ParentWidget { public static class VariableExpandingWidgetRoot { … … } The problem with this was that VariableExpandingWidgetRoot had no need to be inside the scope of AliasLinkWidget. Moreover, other unrelated classes made use of AliasLinkWidget.VariableExpandingWidgetRoot. These classes had no need to know about AliasLinkWidget.\n 问题在于，VariableExpandingWidgetRoot 没必要在 AliasLinkWidget 作用范围之内。而且，其他无关的类也用到 AliasLinkWidget.VariableExpandingWidgetRoot。这些类没必要了解 AliasLinkWidget。\n Perhaps the programmer had plopped the VariableExpandingWidgetRoot into AliasWidget as a matter of convenience, or perhaps he thought it really needed to be scoped inside AliasWidget. Whatever the reason, the result wound up being arbitrary. Public classes that are not utilities of some other class should not be scoped inside another class. The convention is to make them public at the top level of their package.\n 或许那位程序员只是循例把 VariableExpandingWidgetRoot 放到 AliasWidget 里面，或者他真认为这么做是对的。不管原因是什么，结果都显得随心所欲。不作为类工具的公共类，不应该放到其他类里面。惯例是将它置为 public，并且放在代码包的顶部。\n G33: Encapsulate Boundary Conditions\n G33：封装边界条件\n Boundary conditions are hard to keep track of. Put the processing for them in one place. Don’t let them leak all over the code. We don’t want swarms of +1s and -1s scattered hither and yon. Consider this simple example from FIT:\n 边界条件难以追踪。把处理边界条件的代码集中到一处，不要散落于代码中。我们不想见到四处散见的+1 和－1 字样。看看这个来自 FIT 的简单例子：\n if(level + 1 \u0026lt; tags.length) { parts = new Parse(body, tags, level + 1, offset + endTag); body = null; } Notice that level+1 appears twice. This is a boundary condition that should be encapsulated within a variable named something like nextLevel.\n 注意，level + 1 出现了两次。这是个应该封装到名为 nextLevel 之类的变量中的边界条件。\n int nextLevel = level + 1; if(nextLevel \u0026lt; tags.length) { parts = new Parse(body, tags, nextLevel, offset + endTag); body = null; } G34: Functions Should Descend Only One Level of Abstraction\n G34：函数应该只在一个抽象层级上\n The statements within a function should all be written at the same level of abstraction, which should be one level below the operation described by the name of the function. This may be the hardest of these heuristics to interpret and follow. Though the idea is plain enough, humans are just far too good at seamlessly mixing levels of abstraction. Consider, for example, the following code taken from FitNesse:\n 函数中的语句应该在同一抽象层级上，该层级应该是函数名所示操作的下一层。这可能是最难理解和遵循的启发。尽管概念足够直白，人们还是很容易混淆抽象层级。例如，请看下面来自 FitNesse 的例子：\n public String render() throws Exception { StringBuffer html = new StringBuffer(“\u0026lt;hr”); if(size \u0026gt; 0) html.append(” size=\\“”).append(size + 1).append(”\\“”); html.append(“\u0026gt;”); return html.toString(); } A moment’s study and you can see what’s going on. This function constructs the HTML tag that draws a horizontal rule across the page. The height of that rule is specified in the size variable.\n 稍微研究一下，你就会看到发生了什么。该函数构建了绘制横贯页面线条的 HTML 标记。线条高度在 size 变量中指定。\n Now look again. This method is mixing at least two levels of abstraction. The first is the notion that a horizontal rule has a size. The second is the syntax of the HR tag itself. This code comes from the HruleWidget module in FitNesse. This module detects a row of four or more dashes and converts it into the appropriate HR tag. The more dashes, the larger the size.\n 再看一遍。方法混杂了至少两个抽象层级。第一个是横线有尺寸这个概念。第二个是 hr 标记自身的语法。这段代码来自 FitNesse 的 HruleWidget 模块。该模块检测一行 4 个或更多个破折号，并将其转换为恰当的 hr 标记。破折号越多，尺寸越大。\n I refactored this bit of code as follows. Note that I changed the name of the size field to reflect its true purpose. It held the number of extra dashes.\n 我重构了这段代码。注意，我修改了 size 字段的名称，反映其真正目的。它表示额外破折号的数量。\n public String render() throws Exception { HtmlTag hr = new HtmlTag(“hr”); if (extraDashes \u0026gt; 0) hr.addAttribute(“size”, hrSize(extraDashes)); return hr.html(); } private String hrSize(int height) { int hrSize = height + 1; return String.format(“%d”, hrSize); } This change separates the two levels of abstraction nicely. The render function simply constructs an HR tag, without having to know anything about the HTML syntax of that tag. The HtmlTag module takes care of all the nasty syntax issues.\n 这次修改很好地拆开了两个抽象层级。函数 render 只构造一个 hr 标记，不去管该标记的 HTML 语法。而 HtmlTag 模块则照管所有这些肮脏的语法问题。\n Indeed, by making this change I caught a subtle error. The original code did not put the closing slash on the HR tag, as the XHTML standard would have it. (In other words, it emitted \u0026lt;hr\u0026gt; instead of \u0026lt;hr/\u0026gt;.) The HtmlTag module had been changed to conform to XHTML long ago.\n 做出修改时，我发现了一处微小的错误。原始代码没有加上 hr 标记的结束斜线符，而 XHTML 标准要求这样做。（换言之，代码使用了\u0026lt;hr\u0026gt;而不是\u0026lt;hr/\u0026gt;。）HtmlTag 模块很早就改造成符合 XHTML 标准了。\n Separating levels of abstraction is one of the most important functions of refactoring, and it’s one of the hardest to do well. As an example, look at the code below. This was my first attempt at separating the abstraction levels in the HruleWidget.render method.\n 拆分不同抽象层级是重构的最重要功能之一，也是最难做的一个。以下面的代码为例。这是我第一次尝试拆分 HruleWidget.rendermethod 中的抽象层级的结果。\n public String render() throws Exception { HtmlTag hr = new HtmlTag(“hr”); if (size \u0026gt; 0) { hr.addAttribute(“size”, “”+(size+1)); } return hr.html(); } My goal, at this point, was to create the necessary separation and get the tests to pass. I accomplished that goal easily, but the result was a function that still had mixed levels of abstraction. In this case the mixed levels were the construction of the HR tag and the interpretation and formatting of the size variable. This points out that when you break a function along lines of abstraction, you often uncover new lines of abstraction that were obscured by the previous structure.\n 此时，我的目的是做必要的拆分，并让测试通过。我轻易达到了这一目的，但结果是该函数仍然混杂了多个抽象层级。此时，混杂的层级是 hr 标记的构建，以及 size 变量的翻译和格式化。这说明当你偱抽象界线拆解函数时，经常会挖出原本被之前的结构所掩蔽的新抽象界线。\n G35: Keep Configurable Data at High Levels\nG35：在较高层级放置可配置数据\n If you have a constant such as a default or configuration value that is known and expected at a high level of abstraction, do not bury it in a low-level function. Expose it as an argument to that low-level function called from the high-level function. Consider the following code from FitNesse:\n  如果你有个已知并该在较高抽象层级的默认常量或配置值，不要将它埋藏到较低层级的函数中。把它作为较高层级函数调用较低层级函数时的一个参数。看看以下来自 FItNesse 的代码：\n public static void main(String[] args) throws Exception { Arguments arguments = parseCommandLine(args); … } public class Arguments { public static final String DEFAULT_PATH = “.”; public static final String DEFAULT_ROOT = “FitNesseRoot”; public static final int DEFAULT_PORT = 80; public static final int DEFAULT_VERSION_DAYS = 14; … } The command-line arguments are parsed in the very first executable line of FitNesse. The default values of those arguments are specified at the top of the Argument class. You don’t have to go looking in low levels of the system for statements like this one:\n 命令行参数在 FitNesse 中的第一行可执行代码得到解析。这些参数的默认值在 Argument 类的顶部指定。你不必到系统的较低层级去查看类似的语句：\n if (arguments.port == 0) // use 80 by default The configuration constants reside at a very high level and are easy to change. They get passed down to the rest of the application. The lower levels of the application do not own the values of these constants.\n 位于较高层级的配置性常量易于修改。它们向下贯穿应用程序。应用程序的较低层级并不拥有这些常量的值。\n G36: Avoid Transitive Navigation\n G36：避免传递浏览\n In general we don’t want a single module to know much about its collaborators. More specifically, if A collaborates with B, and B collaborates with C, we don’t want modules that use A to know about C. (For example, we don’t want a.getB().getC().doSomething();.)\n 通常我们不想让某个模块了解太多其协作者的信息。更具体地说，如果 A 与 B 协作，B 与 C 协作，我们不想让使用 A 的模块了解 C 的信息。（例如，我们不想写类似 a.getB( ).getC( ).doSomething( )的代码。）\n This is sometimes called the Law of Demeter. The Pragmatic Programmers call it “Writing Shy Code.”12 In either case it comes down to making sure that modules know only about their immediate collaborators and do not know the navigation map of the whole system.\n 这就是所谓得墨忒耳律。The Pragmatic Programmers（中译版《程序员修炼之道》）称之为“编写害羞代码”[12]。两者都归结为确保模块只了解其直接协作者，不了解整个系统的游览图。\n If many modules used some form of the statement a.getB().getC(), then it would be difficult to change the design and architecture to interpose a Q between B and C. You’d have to find every instance of a.getB().getC() and convert it to a.getB().getQ().getC(). This is how architectures become rigid. Too many modules know too much about the architecture.\n 如果有多个模块使用类似 a.getB( ).getC( )这样的语句形式，就难以修改设计和架构，在 B 和 C 之间插进一个 Q。你得找到 a.getB( ).getC( )出现的所有地方，并将其改为 a.getB( ).getQ( ).getC( )。系统就此变得缺乏柔韧性。太多的模块了解了太多有关架构的信息。\n Rather we want our immediate collaborators to offer all the services we need. We should not have to roam through the object graph of the system, hunting for the method we want to call. Rather we should simply be able to say:\n 正确的做法是让直接协作者提供所需的全部服务。不必逛遍系统的对象全图，搜寻我们要调用的方法。只要简单地说： myCollaborator.doSomething().\n myCollaborator.doSomething(). 17.5 JAVA #  J1: Avoid Long Import Lists by Using Wildcards\n J1：通过使用通配符避免过长的导入清单\n If you use two or more classes from a package, then import the whole package with\n 如果使用了来自同一程序包的两个或多个类，用以下语句导入整个包：\n import package.*; Long lists of imports are daunting to the reader. We don’t want to clutter up the tops of our modules with 80 lines of imports. Rather we want the imports to be a concise statement about which packages we collaborate with.\n 过长的导入清单令读者望而却步。我们不想用 80 行导入语句搞乱模块顶部位置。我们想要导入语句简约地列出我们要使用的包。\n Specific imports are hard dependencies, whereas wildcard imports are not. If you specifically import a class, then that class must exist. But if you import a package with a wildcard, no particular classes need to exist. The import statement simply adds the package to the search path when hunting for names. So no true dependency is created by such imports, and they therefore serve to keep our modules less coupled.\n 指定导入包是种硬依赖，而通配符导入则不是。如果你具体指定导入某个类，该类必须存在。但如果你用通配符导入某个包，则不需要存在具体的类。导入语句只是在搜寻名称时把这个包列入查找路径。所以，这种导入并未构成真正的依赖，也就让我们的模块较少耦合。\n There are times when the long list of specific imports can be useful. For example, if you are dealing with legacy code and you want to find out what classes you need to build mocks and stubs for, you can walk down the list of specific imports to find out the true qualified names of all those classes and then put the appropriate stubs in place. However, this use for specific imports is very rare. Furthermore, most modern IDEs will allow you to convert the wildcarded imports to a list of specific imports with a single command. So even in the legacy case it’s better to import wildcards.\n 有时，长长的具体导入清单也会有用。例如，如果你在处理遗留下来的代码，想要找出需要为哪些类构造替身类和占位代码，就可以遍历导入清单，找出这些类的真名，再恰当地放置占位代码。不过，这种用法很罕见。而且，多数现代 IDE 允许你用一个命令就把通配符导入语句转换为指定导入清单。所以，即便在处理遗留代码时，最好也用通配符导入。\n Wildcard imports can sometimes cause name conflicts and ambiguities. Two classes with the same name, but in different packages, will need to be specifically imported, or at least specifically qualified when used. This can be a nuisance but is rare enough that using wildcard imports is still generally better than specific imports.\n 通配符导入有时会导致名称冲突和歧义。两个同名但位于不同包中的类需要指名导入，或至少在使用时指定名称。这种情形的确讨厌，不过很罕见，所以使用通配符导入通常仍优于指定名称导入。\n J2: Don’t Inherit Constants\n J2：不要继承常量\n I have seen this several times and it always makes me grimace. A programmer puts some constants in an interface and then gains access to those constants by inheriting that interface. Take a look at the following code:\n 我见过这种情况好几次，它总是让我面露苦笑。某个程序在接口中放了些常量，再通过继承结构来访问这些常量。看看以下代码：\n public class HourlyEmployee extends Employee { private int tenthsWorked; private double hourlyRate; public Money calculatePay() { int straightTime = Math.min(tenthsWorked, TENTHS_PER_WEEK); int overTime = tenthsWorked - straightTime; return new Money( hourlyRate * (tenthsWorked + OVERTIME_RATE * overTime) ); } … } Where did the constants TENTHS_PER_WEEK and OVERTIME_RATE come from? They might have come from class Employee; so let’s take a look at that:\n 常量 TENTHS_PER_WEEK 和 OVERTIME_RATE 来自何方？它们可能来自 Employee 类。来看看：\n public abstract class Employee implements PayrollConstants { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } Nope, not there. But then where? Look closely at class Employee. It implements PayrollConstants.\n 不，不在那儿。不过在哪儿呢？再仔细看 Employee 类。它实现了 PayrollConstants 接口。\n public interface PayrollConstants { public static final int TENTHS_PER_WEEK = 400; public static final double OVERTIME_RATE = 1.5; } This is a hideous practice! The constants are hidden at the top of the inheritance hierarchy. Ick! Don’t use inheritance as a way to cheat the scoping rules of the language. Use a static import instead.\n 真是丑陋不堪！常量躲在了继承结构的最顶端。呸！别利用继承欺骗编程语言的作用范围规则。应该用静态导入。\n import static PayrollConstants.*; public class HourlyEmployee extends Employee { private int tenthsWorked; private double hourlyRate; public Money calculatePay() { int straightTime = Math.min(tenthsWorked, TENTHS_PER_WEEK); int overTime = tenthsWorked - straightTime; return new Money( hourlyRate * (tenthsWorked + OVERTIME_RATE * overTime) ); } … } J3: Constants versus Enums\n J3：常量 vs. 枚举\n Now that enums have been added to the language (Java 5), use them! Don’t keep using the old trick of public static final ints. The meaning of ints can get lost. The meaning of enums cannot, because they belong to an enumeration that is named.\n 现在 enum 已经加入 Java 语言（Java 5），放心用吧！别再用那个 public static final int 老花招。那样做 int 的意义就丧失了，而用 enum 则不然，因为它们隶属于有名称的枚举。\n What’s more, study the syntax for enums carefully. They can have methods and fields. This makes them very powerful tools that allow much more expression and flexibility than ints. Consider this variation on the payroll code:\n 而且，仔细研究 enum 的语法。它可以拥有方法和字段，从而成为能比 int 提供更多表达力和灵活性的强有力工具。看看以下发薪代码中的不同做法：\n public class HourlyEmployee extends Employee { private int tenthsWorked; HourlyPayGrade grade; public Money calculatePay() { int straightTime = Math.min(tenthsWorked, TENTHS_PER_WEEK); int overTime = tenthsWorked - straightTime; return new Money( grade.rate() * (tenthsWorked + OVERTIME_RATE * overTime) ); } … } public enum HourlyPayGrade { APPRENTICE { public double rate() { return 1.0; } }, LEUTENANT_JOURNEYMAN { public double rate() { return 1.2; } }, JOURNEYMAN { public double rate() { return 1.5; } }, MASTER { public double rate() { return 2.0; } }; public abstract double rate(); } 17.6 NAMES 名称 #  N1: Choose Descriptive Names\n N1：采用描述性名称\n Don’t be too quick to choose a name. Make sure the name is descriptive. Remember that meanings tend to drift as software evolves, so frequently reevaluate the appropriateness of the names you choose.\n 不要太快取名。确认名称具有描述性。记住，事物的意义随着软件的演化而变化，所以，要经常性地重新估量名称是否恰当。\n This is not just a “feel-good” recommendation. Names in software are 90 percent of what make software readable. You need to take the time to choose them wisely and keep them relevant. Names are too important to treat carelessly.\n 这不仅是一条“感觉良好式”建议。软件中的名称对于软件可读性有 90%的作用。你要花时间明智地取名，保持名称有关。名称太重要了，不可随意对待。\n Consider the code below. What does it do? If I show you the code with well-chosen names, it will make perfect sense to you, but like this it’s just a hodge-podge of symbols and magic numbers.\n 看看以下代码。这段代码是做什么的？用了好名称的代码一目了然，而这样的代码却是符号和魔术数的大杂烩。\n public int x() { int q = 0; int z = 0; for (int kk = 0; kk \u0026lt; 10; kk++) { if (l[z] == 10) { q += 10 + (l[z + 1] + l[z + 2]); z += 1; } else if (l[z] + l[z + 1] == 10) { q += 10 + l[z + 2]; z += 2; } else { q += l[z] + l[z + 1]; z += 2; } } return q; } Here is the code the way it should be written. This snippet is actually less complete than the one above. Yet you can infer immediately what it is trying to do, and you could very likely write the missing functions based on that inferred meaning. The magic numbers are no longer magic, and the structure of the algorithm is compellingly descriptive.\n 下面是这段代码应该写成的样子。代码片段实际上不如上段完整。但你还是能马上推断出它要做什么，而且很有可能依据推断出的意思写出遗漏的函数。魔术数不复神秘，算法的结构也足具描述性。\n public int score() { int score = 0; int frame = 0; for (int frameNumber = 0; frameNumber \u0026lt; 10; frameNumber++) { if (isStrike(frame)) { score += 10 + nextTwoBallsForStrike(frame); frame += 1; } else if (isSpare(frame)) { score += 10 + nextBallForSpare(frame); frame += 2; } else { score += twoBallsInFrame(frame); frame += 2; } } return score; } The power of carefully chosen names is that they overload the structure of the code with description. That overloading sets the readers’ expectations about what the other functions in the module do. You can infer the implementation of isStrike() by looking at the code above. When you read the isStrike method, it will be “pretty much what you expected.”13\n 仔细取好的名称的威力在于，它用描述性信息覆盖了代码。这种信息覆盖设定了读者对于模块中其他函数行为的期待。看看上面的代码，你就能推断出 isStrike( )的实现。读到 isStrick 方法时，它“深合你意”[13]。\n private boolean isStrike(int frame) { return rolls[frame] == 10; } N2: Choose Names at the Appropriate Level of Abstraction\n N2：名称应与抽象层级相符\n Don’t pick names that communicate implementation; choose names the reflect the level of abstraction of the class or function you are working in. This is hard to do. Again, people are just too good at mixing levels of abstractions. Each time you make a pass over your code, you will likely find some variable that is named at too low a level. You should take the opportunity to change those names when you find them. Making code readable requires a dedication to continuous improvement. Consider the Modem interface below:\n 不要取沟通实现的名称；取反映类或函数抽象层级的名称。这样做不容易。人们擅长于混杂抽象层级。每次浏览代码，你总会发现有些变量的名称层级太低。你应当趁机为之改名。要让代码可读，需要持续不断的改进。看看下面的 Modem 接口：\n public interface Modem { boolean dial(String phoneNumber); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber(); } At first this looks fine. The functions all seem appropriate. Indeed, for many applications they are. But now consider an application in which some modems aren’t connected by dialling. Rather they are connected permanently by hard wiring them together (think of the cable modems that provide Internet access to most homes nowadays). Perhaps some are connected by sending a port number to a switch over a USB connection. Clearly the notion of phone numbers is at the wrong level of abstraction. A better naming strategy for this scenario might be:\n 粗看还行。函数看来都很合适，对于多数应用程序来说是这样。不过，想想看某个应用中有些调制解调器并不用拨号连接的情形。有些用线缆直连（就像如今为多数家庭提供 Internet 连接的线缆解调器）的情形。有些通过向 USB 口发送端口信息连接。显然，有关电话号码的信息就是位于错误的抽象层级了。对于这种情形，更好的命名策略可能是：\n public interface Modem { boolean connect(String connectionLocator); boolean disconnect(); boolean send(char c); char recv(); String getConnectedLocator(); } Now the names don’t make any commitments about phone numbers. They can still be used for phone numbers, or they could be used for any other kind of connection strategy.\n 现在名称再不与电话号码有关系。还是可以用于用电话号码的情形，也可以用于其他连接策略。\n N3: Use Standard Nomenclature Where Possible\n N3：尽可能使用标准命名法\n Names are easier to understand if they are based on existing convention or usage. For example, if you are using the DECORATOR pattern, you should use the word Decorator in the names of the decorating classes. For example, AutoHangupModemDecorator might be the name of a class that decorates a Modem with the ability to automatically hang up at the end of a session.\n 如果名称基于既存约定或用法，就比较易于理解。例如，如果你采用油漆工模式，就该在给油漆类命名时用上 Decorator 字样。例如， AutoHangupModemDecorator 可能是某个给 Modem 类刷上在会话结束时自动挂机的能力的类的名称。\n Patterns are just one kind of standard. In Java, for example, functions that convert objects to string representations are often named toString. It is better to follow conventions like these than to invent your own.\n 模式只是标准的一种。例如，在 Java 中，将对象转换为字符串的函数通常命名为 toString。最好是遵循这些约定，而不是自己创造命名法。\n Teams will often invent their own standard system of names for a particular project. Eric Evans refers to this as a ubiquitous language for the project.14 Your code should use the terms from this language extensively. In short, the more you can use names that are overloaded with special meanings that are relevant to your project, the easier it will be for readers to know what your code is talking about.\n 对于特定项目，开发团队常常发明自己的命名标准系统。Eric Evans 称之为项目的共同语言[14]。代码应该使用来自这种语言的术语。简言之，具有与项目有关的特定意义的名称用得越多，读者就越容易明白你的代码是做什么的。\n N4: Unambiguous Names\n N4：无歧义的名称\n Choose names that make the workings of a function or variable unambiguous. Consider this example from FitNesse:\n 选用不会混淆函数或变量意义的名称。看看来自 FitNesse 的这个例子：\n private String doRename() throws Exception { if(refactorReferences) renameReferences(); renamePage(); pathToRename.removeNameFromEnd(); pathToRename.addNameToEnd(newName); return PathParser.render(pathToRename); } The name of this function does not say what the function does except in broad and vague terms. This is emphasized by the fact that there is a function named renamePage inside the function named doRename! What do the names tell you about the difference between the two functions? Nothing.\n 该函数的名称含混不清，没有说明函数的作用。由于在 doRename 函数里面还有个名为 renamePage 的函数，这就更不明白了！这些名称有没有说明两个函数之间的区别呢？没有。\n A better name for that function is renamePageAndOptionallyAllReferences. This may seem long, and it is, but it’s only called from one place in the module, so it’s explanatory value outweighs the length.\n 该函数的更好名称应该是 renamePageAndOptionallyAllReferences。看似太长，的确也很长，不过它只在模块中的一处被调用，所以其解释性的好处大过了长度的坏处。\n N5: Use Long Names for Long Scopes\n N5：为较大作用范围选用较长名称\n The length of a name should be related to the length of the scope. You can use very short variable names for tiny scopes, but for big scopes you should use longer names.\n 名称的长度应与作用范围的广泛度相关。对于较小的作用范围，可以用很短的名称，而对于较大作用范围就该用较长的名称。\n Variable names like i and j are just fine if their scope is five lines long. Consider this snippet from the old standard “Bowling Game”:\n 类似 i 和 j 之类的变量名对于作用范围在 5 行之内的情形没问题。看看以下来自老“标准保龄球游戏”的代码片段：\n private void rollMany(int n, int pins) { for (int i=0; i\u0026lt;n; i++) g.roll(pins); } This is perfectly clear and would be obfuscated if the variable i were replaced with something annoying like rollCount. On the other hand, variables and functions with short names lose their meaning over long distances. So the longer the scope of the name, the longer and more precise the name should be.\n 这段代码很明白，如果用 rollCount 之类烦人的名称代替变量 i，反而是徒增混乱。另一方面，在较长距离上，使用短名称的变量和函数会丧失其含义。名称的作用范围越大，名称就该越长、越准确。\n N6: Avoid Encodings\n N6：避免编码\n Names should not be encoded with type or scope information. Prefixes such as m_ or f are useless in today’s environments. Also project and/or subsystem encodings such as vis_ (for visual imaging system) are distracting and redundant. Again, today’s environments provide all that information without having to mangle the names. Keep your names free of Hungarian pollution.\n 不应在名称中包括类型或作用范围信息。在如今的开发环境中， m_ 或 f 之类前缀完全无用。类似 vis_（表示图形系统）之类的项目或子系统名称也属多余。当今的开发环境不用纠缠于名称也能提供这些信息。不要用匈牙利语命名法污染你的名称。\n N7: Names Should Describe Side-Effects\n》 N7：名称应该说明副作用\nNames should describe everything that a function, variable, or class is or does. Don’t hide side effects with a name. Don’t use a simple verb to describe a function that does more than just that simple action. For example, consider this code from TestNG:\n》 名称应该说明函数、变量或类的一切信息。不要用名称掩蔽副作用。不要用简单的动词来描述做了不止一个简单动作的函数。例如，请看以下来自 TestNG 的代码：\npublic ObjectOutputStream getOos() throws IOException { if (m_oos == null) { m_oos = new ObjectOutputStream(m_socket.getOutputStream()); } return m_oos; } This function does a bit more than get an “oos”; it creates the “oos” if it hasn’t been created already. Thus, a better name might be createOrReturnOos.\n 该函数不只是获取一个 oos，如果 oos 不存在，还会创建一个。所以，更好的名称大概是 createOrReturnOos。\n 17.7 TESTS 测试 #  T1: Insufficient Tests\n T1：测试不足\n How many tests should be in a test suite? Unfortunately, the metric many programmers use is “That seems like enough.” A test suite should test everything that could possibly break. The tests are insufficient so long as there are conditions that have not been explored by the tests or calculations that have not been validated.\n 一套测试中应该有多少个测试？不幸的是，许多程序员的衡量标准是“看起来够了”。一套测试应该测到所有可能失败的东西。只要还有没被测试探测过的条件，或是还有没被验证过的计算，测试就还不够。\n T2: Use a Coverage Tool!\n T2：使用覆盖率工具\n Coverage tools reports gaps in your testing strategy. They make it easy to find modules, classes, and functions that are insufficiently tested. Most IDEs give you a visual indication, marking lines that are covered in green and those that are uncovered in red. This makes it quick and easy to find if or catch statements whose bodies haven’t been checked.\n 覆盖率工具能汇报你测试策略中的缺口。使用覆盖率工具能更容易地找到测试不足的模块、类和函数。多数 IDE 都给出直观的指示，用绿色标记测试覆盖了的代码行，而未覆盖的代码行则是红色。这样就能又快又容易地找到尚未检测过的 if 或 catch 语句。\n T3: Don’t Skip Trivial Tests\n T3：别略过小测试\n 小测试易于编写，其文档上的价值高于编写成本。\n They are easy to write and their documentary value is higher than the cost to produce them.\n T4: An Ignored Test Is a Question about an Ambiguity\n T4：被忽略的测试就是对不确定事物的疑问\n Sometimes we are uncertain about a behavioral detail because the requirements are unclear. We can express our question about the requirements as a test that is commented out, or as a test that annotated with @Ignore. Which you choose depends upon whether the ambiguity is about something that would compile or not.\n 有时，我们会因为需求不明而不能确定某个行为细节。可以用注释掉的测试或者用@Ignore 标记的测试来表达我们对于需求的疑问。使用哪种方式，取决于该不确定性所关涉代码是否要编译。\n T5: Test Boundary Conditions\n T5：测试边界条件\n Take special care to test boundary conditions. We often get the middle of an algorithm right but misjudge the boundaries.\n 特别注意测试边界条件。算法的中间部分正确但边界判断错误的情形很常见。\n T6: Exhaustively Test Near Bugs\n T6：全面测试相近的缺陷\n Bugs tend to congregate. When you find a bug in a function, it is wise to do an exhaustive test of that function. You’ll probably find that the bug was not alone.\n 缺陷趋向于扎堆。在某个函数中发现一个缺陷时，最好全面测试那个函数。你可能会发现缺陷不止一个。\n T7: Patterns of Failure Are Revealing\n T7：测试失败的模式有启发性\n Sometimes you can diagnose a problem by finding patterns in the way the test cases fail. This is another argument for making the test cases as complete as possible. Complete test cases, ordered in a reasonable way, expose patterns.\n 有时，你可以通过找到测试用例失败的模式来诊断问题所在。这也是尽可能编写足够完整的测试用例的理由之一。完整的测试用例，按合理的顺序排列，能暴露出模式。\n As a simple example, suppose you noticed that all tests with an input larger than five characters failed? Or what if any test that passed a negative number into the second argument of a function failed? Sometimes just seeing the pattern of red and green on the test report is enough to spark the “Aha!” that leads to the solution. Look back at page 267 to see an interesting example of this in the SerialDate example.\n 简单举例，假设你注意到所有长于 5 个字符的输入都会导致测试失败，或者向函数的第二个参数传入负数都会导致测试失败。有时，只要看看测试报告的红绿模式，就足以绽放出那句带来解决方法的“啊哈！”回头看看第 16 章“重构 SerialDate”中的有趣例子吧。\n T8: Test Coverage Patterns Can Be Revealing\n T8：测试覆盖率的模式有启发性\n Looking at the code that is or is not executed by the passing tests gives clues to why the failing tests fail.\n 查看被或未被已通过的测试执行的代码，往往能发现失败的测试为何失败的线索。\n T9: Tests Should Be Fast\n T9：测试应该快速\n A slow test is a test that won’t get run. When things get tight, it’s the slow tests that will be dropped from the suite. So do what you must to keep your tests fast.\n 慢速的测试是不会被运行的测试。时间一紧，较慢的测试就会被摘掉。所以，竭尽所能让测试够快。\n 17.8 CONCLUSION 小结 #  This list of heuristics and smells could hardly be said to be complete. Indeed, I’m not sure that such a list can ever be complete. But perhaps completeness should not be the goal, because what this list does do is imply a value system.\n 这份启发与味道的清单很难说已完备无缺。我不能确定这样一份清单会不会完备无缺。但或许完整性不该是目标，因为该清单确实给出了一套价值体系。\n Indeed, that value system has been the goal, and the topic, of this book. Clean code is not written by following a set of rules. You don’t become a software craftsman by learning a list of heuristics. Professionalism and craftsmanship come from values that drive disciplines.\n 那套价值体系才该是目标，也是本书的主题所在。整洁代码并非遵循一套规则写就。学习一系列启发并不足以让你成为软件匠人。专业性和技艺来自于驱动规程的价值观。\n "});index.add({'id':206,'href':'/docs/Clean-Code/3.-Functions/ch3/','title':"Ch3",'section':"Go语言圣经",'content':"第 3 章 Functions 函数 #   In the early days of programming we composed our systems of routines and subroutines. Then, in the era of Fortran and PL/1 we composed our systems of programs, subprograms, and functions. Nowadays only the function survives from those early days. Functions are the first line of organization in any program. Writing them well is the topic of this chapter.\n 在编程的早年岁月，系统由程序和子程序组成。后来，在 Fortran 和 PL/1 的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。本章将讨论如何写好函数。\n Consider the code in Listing 3-1. It’s hard to find a long function in FitNesse,1 but after a bit of searching I came across this one. Not only is it long, but it’s got duplicated code, lots of odd strings, and many strange and inobvious data types and APIs. See how much sense you can make of it in the next three minutes.\n 请看代码清单 3-1。在 FitNesse 中，很难找到长函数，不过我还是搜寻到一个。它不光长，而且代码也很复杂，有大量字符串、怪异而不显见的数据类型和 API。花 3 分钟时间，看能读懂多少？\n Listing 3-1 HtmlUtil.java (FitNesse 20070619)\n 代码清单 3-1 HtmlUtil.java（FitNesse 20070619）\n public static String testableHtml( PageData pageData, boolean includeSuiteSetup ) throws Exception { WikiPage wikiPage = pageData.getWikiPage(); StringBuffer buffer = new StringBuffer(); if (pageData.hasAttribute(\u0026#34;Test\u0026#34;)) { if (includeSuiteSetup) { WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage( SuiteResponder.SUITE_SETUP_NAME, wikiPage ); if (suiteSetup != null) { WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup); String pagePathName = PathParser.render(pagePath); buffer.append(\u0026#34;!include -setup .\u0026#34;) .append(pagePathName) .append(\u0026#34;\\n\u0026#34;); } } WikiPage setup = PageCrawlerImpl.getInheritedPage(\u0026#34;SetUp\u0026#34;, wikiPage); if (setup != null) { WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup); String setupPathName = PathParser.render(setupPath); buffer.append(\u0026#34;!include -setup .\u0026#34;) .append(setupPathName) .append(\u0026#34;\\n\u0026#34;); } } buffer.append(pageData.getContent()); if (pageData.hasAttribute(\u0026#34;Test\u0026#34;)) { WikiPage teardown = PageCrawlerImpl.getInheritedPage(\u0026#34;TearDown\u0026#34;, wikiPage); if (teardown != null) { WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown); String tearDownPathName = PathParser.render(tearDownPath); buffer.append(\u0026#34;\\n\u0026#34;) .append(\u0026#34;!include -teardown .\u0026#34;) .append(tearDownPathName) .append(\u0026#34;\\n\u0026#34;); } if (includeSuiteSetup) { WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage( SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage ); if (suiteTeardown != null) { WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown); String pagePathName = PathParser.render(pagePath); buffer.append(\u0026#34;!include -teardown .\u0026#34;) .append(pagePathName) .append(\u0026#34;\\n\u0026#34;); } } } pageData.setContent(buffer.toString()); return pageData.getHtml(); } Do you understand the function after three minutes of study? Probably not. There’s too much going on in there at too many different levels of abstraction. There are strange strings and odd function calls mixed in with doubly nested if statements controlled by flags.\n 搞懂这个函数了吗？大概没有。有太多事发生，有太多不同层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的 if 语句等，不一而足。\n However, with just a few simple method extractions, some renaming, and a little restructuring, I was able to capture the intent of the function in the nine lines of Listing 3-2. See whether you can understand that in the next 3 minutes.\n 不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在 9 行代码之内搞掂（如代码清单 3-2 所示）。用 3 分钟阅读以下代码，看你能理解吗？\n Listing 3-2 HtmlUtil.java (refactored)\n 代码清单 3-2 HtmlUtil.java（重构之后）\n public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite ) throws Exception { boolean isTestPage = pageData.hasAttribute(\u0026#34;Test\u0026#34;); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); } Unless you are a student of FitNesse, you probably don’t understand all the details. Still, you probably understand that this function performs the inclusion of some setup and teardown pages into a test page and then renders that page into HTML. If you are familiar with JUnit,2 you probably realize that this function belongs to some kind of Web-based testing framework. And, of course, that is correct. Divining that information from Listing 3-2 is pretty easy, but it’s pretty well obscured by Listing 3-1.\n 除非你正在研究 FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为 HTML 的操作。如果你熟悉 JUnit，或许会想到，该函数归属于某个基于 Web 的测试框架。而且，这当然没错。从代码清单 3-2 中获得信息很容易，而代码清单 3-1 则晦涩难明。\n So what is it that makes a function like Listing 3-2 easy to read and understand? How can we make a function communicate its intent? What attributes can we give our functions that will allow a casual reader to intuit the kind of program they live inside?\n 是什么让代码清单 3-2 易于阅读和理解？怎么才能让函数表达其意图？该给函数赋予哪些属性，好让读者一看就明白函数是属于怎样的程序？\n 3.1 SMALL! 短小 #  The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that. This is not an assertion that I can justify. I can’t provide any references to research that shows that very small functions are better. What I can tell you is that for nearly four decades I have written functions of all different sizes. I’ve written several nasty 3,000-line abominations. I’ve written scads of functions in the 100 to 300 line range. And I’ve written functions that were 20 to 30 lines long. What this experience has taught me, through long trial and error, is that functions should be very small.\n 函数的第一规则是要短小。第二条规则是还要更短小。我无法证明这个断言。我给不出任何证实了小函数更好的研究结果。我能说的是，近 40 年来，我写过各种不同大小的函数。我写过令人憎恶的长达 3000 行的厌物，也写过许多 100 行到 300 行的函数，我还写过 20 行到 30 行的。经过漫长的试错，经验告诉我，函数就该小。\n In the eighties we used to say that a function should be no bigger than a screen-full. Of course we said that at a time when VT100 screens were 24 lines by 80 columns, and our editors used 4 lines for administrative purposes. Nowadays with a cranked-down font and a nice big monitor, you can fit 150 characters on a line and a 100 lines or more on a screen. Lines should not be 150 characters long. Functions should not be 100 lines long. Functions should hardly ever be 20 lines long.\n 在 20 世纪 80 年代，我们常说函数不该长于一屏。当然，说这话的时候，VT100 屏幕只有 24 行、80 列，而编辑器就得先占去 4 行空间放菜单。如今，用上了精致的字体和宽大的显示器，一屏里面可以显示 100 行，每行能容纳 150 个字符。每行都不应该有 150 个字符那么长。函数也不该有 100 行那么长，20 行封顶最佳。\n How short should a function be? In 1999 I went to visit Kent Beck at his home in Oregon. We sat down and did some programming together. At one point he showed me a cute little Java/Swing program that he called Sparkle. It produced a visual effect on the screen very similar to the magic wand of the fairy godmother in the movie Cinderella. As you moved the mouse, the sparkles would drip from the cursor with a satisfying scintillation, falling to the bottom of the window through a simulated gravitational field. When Kent showed me the code, I was struck by how small all the functions were. I was used to functions in Swing programs that took up miles of vertical space. Every function in this program was just two, or three, or four lines long. Each was transparently obvious. Each told a story. And each led you to the next in a compelling order. That’s how short your functions should be!3\n 函数到底该有多长？1991 年，我去 Kent Beck 位于奥勒冈州（Oregon）的家中拜访。我们坐到一起写了些代码。他给我看一个叫做 Sparkle（火花闪耀）的有趣的 Java/Swing 小程序。程序在屏幕上描画电影 Cinderella（《灰姑娘》）中仙女用魔棒造出的那种视觉效果。只要移动鼠标，光标所在处就会爆发出一团令人欣喜的火花，沿着模拟重力场划落到窗口底部。肯特给我看代码的时候，我惊讶于其中那些函数尺寸之小。我看惯了 Swing 程序中长度数以里计的函数。但这个程序中每个函数都只有两行、三行或四行长。每个函数都一目了然。每个函数都只说一件事。而且，每个函数都依序把你带到下一个函数。这就是函数应该达到的短小程度！\n How short should your functions be? They should usually be shorter than Listing 3-2! Indeed, Listing 3-2 should really be shortened to Listing 3-3.\n 函数应该有多短小？通常来说，应该短于代码清单 3-2 中的函数！代码清单 3-2 实在应该缩短成代码清单 3-3 这个样子。\n Listing 3-3 HtmlUtil.java (re-refactored)\n 代码清单 3-3 HtmlUtil.java（再次重构之后）\n public static String renderPageWith; SetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml(); } Blocks and Indenting 代码块和缩进 #  This implies that the blocks within if statements, else statements, while statements, and so on should be one line long. Probably that line should be a function call. Not only does this keep the enclosing function small, but it also adds documentary value because the function called within the block can have a nicely descriptive name.\n if 语句、else 语句、while 语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。\n This also implies that functions should not be large enough to hold nested structures. Therefore, the indent level of a function should not be greater than one or two. This, of course, makes the functions easier to read and understand.\n 这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。\n 3.2 DO ONE THING 只做一件事 #  It should be very clear that Listing 3-1 is doing lots more than one thing. It’s creating buffers, fetching pages, searching for inherited pages, rendering paths, appending arcane strings, and generating HTML, among other things. Listing 3-1 is very busy doing lots of different things. On the other hand, Listing 3-3 is doing one simple thing. It’s including setups and teardowns into test pages.\n 代码清单 3-1 显然想做好几件事。它创建缓冲区、获取页面、搜索继承下来的页面、渲染路径、添加神秘的字符串、生成 HTML，如此等等。代码清单 3-1 手忙脚乱。而代码清单 3-3 则只做一件简单的事。它将设置和拆解包纳到测试页面中。\n The following advice has appeared in one form or another for 30 years or more.\n 过去 30 年以来，以下建议以不同形式一再出现：\n  FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL. THEY SHOULD DO IT ONLY.\n 函数应该做一件事。做好这件事。只做这一件事。\n The problem with this statement is that it is hard to know what “one thing” is. Does Listing 3-3 do one thing? It’s easy to make the case that it’s doing three things:\n 问题在于很难知道那件该做的事是什么。代码清单 3-3 只做了一件事，对吧？其实也很容易看作是三件事：\n  Determining whether the page is a test page. If so, including setups and teardowns. Rendering the page in HTML.     判断是否为测试页面； 如果是，则容纳进设置和分拆步骤； 渲染成 HTML。   So which is it? Is the function doing one thing or three things? Notice that the three steps of the function are one level of abstraction below the stated name of the function. We can describe the function by describing it as a brief TO4 paragraph:\n 那件事是什么？函数是做了一件事呢，还是做了三件事？注意，这三个步骤均在该函数名下的同一抽象层上。可以用简洁的 TO 起头段落来描述这个函数：\n TO RenderPageWithSetupsAndTeardowns, we check to see whether the page is a test page and if so, we include the setups and teardowns. In either case we render the page in HTML.\n （要 RenderPageWithSetupsAndTeardowns，检查页面是否为测试页，如果是测试页，就容纳进设置和分拆步骤。无论是否测试页，都渲染成 HTML）\n If a function does only those steps that are one level below the stated name of the function, then the function is doing one thing. After all, the reason we write functions is to decompose a larger concept (in other words, the name of the function) into a set of steps at the next level of abstraction.\n 如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事。编写函数毕竟是为了把大一些的概念（换言之，函数的名称）拆分为另一抽象层上的一系列步骤。\n It should be very clear that Listing 3-1 contains steps at many different levels of abstraction. So it is clearly doing more than one thing. Even Listing 3-2 has two levels of abstraction, as proved by our ability to shrink it down. But it would be very hard to meaningfully shrink Listing 3-3. We could extract the if statement into a function named includeSetupsAndTeardownsIfTestPage, but that simply restates the code without changing the level of abstraction.\n 代码清单 3-1 明显包括了处于多个不同抽象层级的步骤。显然，它所做的不止一件事。即便是代码清单 3-2 也有两个抽象层，这已被我们将其缩短的能力所证明。然而，很难再将代码清单 3-3 做有意义的缩短。可以将 if 语句拆出来做一个名为 includeSetupAndTeardonwsIfTestpage 的函数，但那只是重新诠释代码，并未改变抽象层级。\n So, another way to know that a function is doing more than “one thing” is if you can extract another function from it with a name that is not merely a restatement of its implementation [G34].\n 所以，要判断函数是否不止做了一件事，还有一个方法，就是看是否能再拆出一个函数，该函数不仅只是单纯地重新诠释其实现[G34]。\n Sections within Functions 函数中的区段 #  Look at Listing 4-7 on page 71. Notice that the generatePrimes function is divided into sections such as declarations, initializations, and sieve. This is an obvious symptom of doing more than one thing. Functions that do one thing cannot be reasonably divided into sections.\n 请看代码清单 4-7。注意，generatePrimes 函数被切分为 declarations、initializations 和 sieve 等区段。这就是函数做事太多的明显征兆。只做一件事的函数无法被合理地切分为多个区段。\n 3.3 ONE LEVEL OF ABSTRACTION PER FUNCTION 每个函数一个抽象层级 #  In order to make sure our functions are doing “one thing,” we need to make sure that the statements within our function are all at the same level of abstraction. It is easy to see how Listing 3-1 violates this rule. There are concepts in there that are at a very high level of abstraction, such as getHtml(); others that are at an intermediate level of abstraction, such as: String pagePathName = PathParser.render(pagePath); and still others that are remarkably low level, such as: .append(”\\n”).\n 要确保函数只做一件事，函数中的语句都要在同一抽象层级上。一眼就能看出，代码清单 3-1 违反了这条规矩。那里面有 getHtml() 等位于较高抽象层的概念，也有 String pagePathName = PathParser.render(pagePath)等位于中间抽象层的概念，还有.append(\u0026quot;\\n\u0026rdquo;) 等位于相当低的抽象层的概念。\n Mixing levels of abstraction within a function is always confusing. Readers may not be able to tell whether a particular expression is an essential concept or a detail. Worse, like broken windows, once details are mixed with essential concepts, more and more details tend to accrete within the function.\n 函数中混杂不同抽象层级，往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是，就像破损的窗户，一旦细节与基础概念混杂，更多的细节就会在函数中纠结起来。\n Reading Code from Top to Bottom: The Stepdown Rule 自顶向下读代码：向下规则 #  We want the code to read like a top-down narrative.5 We want every function to be followed by those at the next level of abstraction so that we can read the program, descending one level of abstraction at a time as we read down the list of functions. I call this The Step-down Rule.\n 我们想要让代码拥有自顶向下的阅读顺序。我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能偱抽象层级向下阅读了。我把这叫做向下规则。\n To say this differently, we want to be able to read the program as though it were a set of TO paragraphs, each of which is describing the current level of abstraction and referencing subsequent TO paragraphs at the next level down.\n 换一种说法。我们想要这样读程序：程序就像是一系列 TO 起头的段落，每一段都描述当前抽象层级，并引用位于下一抽象层级的后续 TO 起头段落。\n  To include the setups and teardowns, we include setups, then we include the test page content, and then we include the teardowns. To include the setups, we include the suite setup if this is a suite, then we include the regular setup. To include the suite setup, we search the parent hierarchy for the “SuiteSetUp” page and add an include statement with the path of that page. To search the parent…     （要容纳设置和分拆步骤，就先容纳设置步骤，然后纳入测试页面内容，再纳入分拆步骤。） （要容纳设置步骤，如果是套件，就纳入套件设置步骤，然后再纳入普通设置步骤。） （要容纳套件设置步骤，先搜索“SuiteSetUp”页面的上级继承关系，再添加一个包括该页面路径的语句。） （要搜索……）   It turns out to be very difficult for programmers to learn to follow this rule and write functions that stay at a single level of abstraction. But learning this trick is also very important. It is the key to keeping functions short and making sure they do “one thing.” Making the code read like a top-down set of TO paragraphs is an effective technique for keeping the abstraction level consistent.\n 程序员往往很难学会遵循这条规则，写出只停留于一个抽象层级上的函数。尽管如此，学习这个技巧还是很重要。这是保持函数短小、确保只做一件事的要诀。让代码读起来像是一系列自顶向下的 TO 起头段落是保持抽象层级协调一致的有效技巧。\n Take a look at Listing 3-7 at the end of this chapter. It shows the whole testableHtml function refactored according to the principles described here. Notice how each function introduces the next, and each function remains at a consistent level of abstraction.\n 看看本章末尾的代码清单 3-7。它展示了遵循这条原则重构的完整 testableHtml 函数。留意每个函数是如何引出下一个函数，如何保持在同一抽象层上的。\n 3.4 SWITCH STATEMENTS switch 语句 #  It’s hard to make a small switch statement.6 Even a switch statement with only two cases is larger than I’d like a single block or function to be. It’s also hard to make a switch statement that does one thing. By their nature, switch statements always do N things. Unfortunately we can’t always avoid switch statements, but we can make sure that each switch statement is buried in a low-level class and is never repeated. We do this, of course, with polymorphism.\n 写出短小的 switch 语句很难。即便是只有两种条件的 switch 语句也要比我想要的单个代码块或函数大得多。写出只做一件事的 switch 语句也很难。Switch 天生要做 N 件事。不幸我们总无法避开 switch 语句，不过还是能够确保每个 switch 都埋藏在较低的抽象层级，而且永远不重复。当然，我们利用多态来实现这一点。\n Consider Listing 3-4. It shows just one of the operations that might depend on the type of employee.\n 请看代码清单 3-4。它呈现了可能依赖于雇员类型的仅仅一种操作。\n Listing 3-4 Payroll.java\n 代码清单 3-4 Payroll.java\n public Money calculatePay(Employee e) throws InvalidEmployeeType { switch (e.type) { case COMMISSIONED: return calculateCommissionedPay(e); case HOURLY: return calculateHourlyPay(e); case SALARIED: return calculateSalariedPay(e); default: throw new InvalidEmployeeType(e.type); } } There are several problems with this function. First, it’s large, and when new employee types are added, it will grow. Second, it very clearly does more than one thing. Third, it violates the Single Responsibility Principle7 (SRP) because there is more than one reason for it to change. Fourth, it violates the Open Closed Principle8 (OCP) because it must change whenever new types are added. But possibly the worst problem with this function is that there are an unlimited number of other functions that will have the same structure. For example we could have\n 该函数有好几个问题。首先，它太长，当出现新的雇员类型时，还会变得更长。其次，它明显做了不止一件事。第三，它违反了单一权责原则（Single Responsibility Principle, SRP），因为有好几个修改它的理由。第四，它违反了开放闭合原则（Open Closed Principle,OCP），因为每当添加新类型时，就必须修改之。不过，该函数最麻烦的可能是到处皆有类似结构的函数。例如，可能会有\n isPayday(Employee e, Date date), or\n 或\n deliverPay(Employee e, Money pay), or a host of others. All of which would have the same deleterious structure.\n 如此等等。它们的结构都有同样的问题。\n The solution to this problem (see Listing 3-5) is to bury the switch statement in the basement of an ABSTRACT FACTORY,9 and never let anyone see it. The factory will use the switch statement to create appropriate instances of the derivatives of Employee, and the various functions, such as calculatePay, isPayday, and deliverPay, will be dispatched polymorphically through the Employee interface.\n 该问题的解决方案（如代码清单 3-5 所示）是将 switch 语句埋到抽象工厂底下，不让任何人看到。该工厂使用 switch 语句为 Employee 的派生物创建适当的实体，而不同的函数，如 calculatePay、isPayday 和 deliverPay 等，则藉由 Employee 接口多态地接受派遣。\n My general rule for switch statements is that they can be tolerated if they appear only once, are used to create polymorphic objects, and are hidden behind an inheritance relationship so that the rest of the system can’t see them [G23]. Of course every circumstance is unique, and there are times when I violate one or more parts of that rule.\n 对于 switch 语句，我的规矩是如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他部分看不到，就还能容忍 [G23]。当然也要就事论事，有时我也会部分或全部违反这条规矩。\n Listing 3-5 Employee and Factory\n 代码清单 3-5 Employee 与工厂\n public abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } ----------------- public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } ----------------- public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r); case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } } } 3.5 USE DESCRIPTIVE NAMES 使用描述性的名称 #  In Listing 3-7 I changed the name of our example function from testableHtml to SetupTeardownIncluder.render. This is a far better name because it better describes what the function does. I also gave each of the private methods an equally descriptive name such as isTestable or includeSetupAndTeardownPages. It is hard to overestimate the value of good names. Remember Ward’s principle: “You know you are working on clean code when each routine turns out to be pretty much what you expected.” Half the battle to achieving that principle is choosing good names for small functions that do one thing. The smaller and more focused a function is, the easier it is to choose a descriptive name.\n 在代码清单 3-7 中，我把示例函数的名称从 testableHtml 改为 SetupTeardownIncluder.render。这个名称好得多，因为它较好地描述了函数做的事。我也给每个私有方法取个同样具有描述性的名称，如 isTestable 或 includeSetupAndTeardownPages。好名称的价值怎么好评都不为过。记住沃德原则：“如果每个例程都让你感到深合己意，那就是整洁代码。”要遵循这一原则，泰半工作都在于为只做一件事的小函数取个好名字。函数越短小、功能越集中，就越便于取个好名字。\n Don’t be afraid to make a name long. A long descriptive name is better than a short enigmatic name. A long descriptive name is better than a long descriptive comment. Use a naming convention that allows multiple words to be easily read in the function names, and then make use of those multiple words to give the function a name that says what it does.\n 别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。使用某种命名约定，让函数名称中的多个单词容易阅读，然后使用这些单词给函数取个能说清其功用的名称。\n Don’t be afraid to spend time choosing a name. Indeed, you should try several different names and read the code with each in place. Modern IDEs like Eclipse or IntelliJ make it trivial to change names. Use one of those IDEs and experiment with different names until you find one that is as descriptive as you can make it.\n 别害怕花时间取名字。你当尝试不同的名称，实测其阅读效果。在 Eclipse 或 IntelliJ 等现代 IDE 中改名称易如反掌。使用这些 IDE 测试不同名称，直至找到最具有描述性的那一个为止。\n Choosing descriptive names will clarify the design of the module in your mind and help you to improve it. It is not at all uncommon that hunting for a good name results in a favorable restructuring of the code.\n 选择描述性的名称能理清你关于模块的设计思路，并帮你改进之。追索好名称，往往导致对代码的改善重构。\n Be consistent in your names. Use the same phrases, nouns, and verbs in the function names you choose for your modules. Consider, for example, the names includeSetup-AndTeardownPages, includeSetupPages, includeSuiteSetupPage, and includeSetupPage. The similar phraseology in those names allows the sequence to tell a story. Indeed, if I showed you just the sequence above, you’d ask yourself: “What happened to includeTeardownPages, includeSuiteTeardownPage, and includeTeardownPage?” How’s that for being “… pretty much what you expected.”\n 命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。例如，includeSetupAndTeardownPages、includeSetupPages、includeSuiteSetupPage 和 includeSetupPage 等。这些名称使用了类似的措辞，依序讲出一个故事。实际上，假使我只给你看上述函数序列，你就会自问：“includeTeardownPages、includeSuiteTeardownPages 和 includeTeardownPage 又会如何？”这就是所谓“深合己意”了。\n 3.6 FUNCTION ARGUMENTS 函数参数 #  The ideal number of arguments for a function is zero (niladic). Next comes one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than three (polyadic) requires very special justification—and then shouldn’t be used anyway.\n 最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）——所以无论如何也不要这么做。\n  Arguments are hard. They take a lot of conceptual power. That’s why I got rid of almost all of them from the example. Consider, for instance, the StringBuffer in the example. We could have passed it around as an argument rather than making it an instance variable, but then our readers would have had to interpret it each time they saw it. When you are reading the story told by the module, includeSetupPage() is easier to understand than includeSetupPageInto(newPage-Content). The argument is at a different level of abstraction than the function name and forces you to know a detail (in other words, StringBuffer) that isn’t particularly important at that point.\n 参数不易对付。它们带有太多概念性。所以我在代码范例中几乎不加参数。比如，以 StringBuffer 为例，我们可能不把它作为实体变量，而是当作参数来传递，那样的话，读者每次看到它都得要翻译一遍。阅读模块所讲述的故事时，includeSetupPage()要比 includeSetupPageInto（newPage-Content）易于理解。参数与函数名处在不同的抽象层级，它要求你了解目前并不特别重要的细节（即那个 StringBuffer）。\n Arguments are even harder from a testing point of view. Imagine the difficulty of writing all the test cases to ensure that all the various combinations of arguments work properly. If there are no arguments, this is trivial. If there’s one argument, it’s not too hard. With two arguments the problem gets a bit more challenging. With more than two arguments, testing every combination of appropriate values can be daunting.\n 从测试的角度看，参数甚至更叫人为难。想想看，要编写能确保参数的各种组合运行正常的测试用例，是多么困难的事。如果没有参数，就是小菜一碟。如果只有一个参数，也不太困难。有两个参数，问题就麻烦多了。如果参数多于两个，测试覆盖所有可能值的组合简直让人生畏。\n Output arguments are harder to understand than input arguments. When we read a function, we are used to the idea of information going in to the function through arguments and out through the return value. We don’t usually expect information to be going out through the arguments. So output arguments often cause us to do a double-take.\n 输出参数比输入参数还要难以理解。读函数时，我们惯于认为信息通过参数输入函数，通过返回值从函数中输出。我们不太期望信息通过参数输出。所以，输出参数往往让人苦思之后才恍然大悟。\n One input argument is the next best thing to no arguments. SetupTeardown-Includer.render(pageData) is pretty easy to understand. Clearly we are going to render the data in the pageData object.\n 相较于没有参数，只有一个输入参数算是第二好的做法。SetupTeardownInclude.render （pageData）也相当易于理解。很明显，我们将渲染 pageData 对象中的数据。\n 3.6.1 Common Monadic Forms 一元函数的普遍形式 #  There are two very common reasons to pass a single argument into a function. You may be asking a question about that argument, as in boolean fileExists(“MyFile”). Or you may be operating on that argument, transforming it into something else and returning it. For example, InputStream fileOpen(“MyFile”) transforms a file name String into an InputStream return value. These two uses are what readers expect when they see a function. You should choose names that make the distinction clear, and always use the two forms in a consistent context. (See Command Query Separation below.)\n 向函数传入单个参数有两种极普遍的理由。你也许会问关于那个参数的问题，就像在 boolean fileExists(\u0026ldquo;MyFile\u0026rdquo;)中那样。也可能是操作该参数，将其转换为其他什么东西，再输出之。例如，InputStream fileOpen(\u0026ldquo;MyFile\u0026rdquo;)把 String 类型的文件名转换为 InputStream 类型的返回值。这就是读者看到函数时所期待的东西。你应当选用较能区别这两种理由的名称，而且总在一致的上下文中使用这两种形式。\n A somewhat less common, but still very useful form for a single argument function, is an event. In this form there is an input argument but no output argument. The overall program is meant to interpret the function call as an event and use the argument to alter the state of the system, for example, void passwordAttemptFailedNtimes(int attempts). Use this form with care. It should be very clear to the reader that this is an event. Choose names and contexts carefully.\n 还有一种虽不那么普遍但仍极有用的单参数函数形式，那就是事件（event）。在这种形式中，有输入参数而无输出参数。程序将函数看作是一个事件，使用该参数修改系统状态，例如 void passwordAttemptFailedNtimes(int attempts)。小心使用这种形式。应该让读者很清楚地了解它是个事件。谨慎地选用名称和上下文语境。\n Try to avoid any monadic functions that don’t follow these forms, for example, void includeSetupPageInto(StringBuffer pageText). Using an output argument instead of a return value for a transformation is confusing. If a function is going to transform its input argument, the transformation should appear as the return value. Indeed, StringBuffer transform(StringBuffer in) is better than void transform(StringBuffer out), even if the implementation in the first case simply returns the input argument. At least it still follows the form of a transformation.\n 尽量避免编写不遵循这些形式的一元函数，例如，void includeSetupPageInto(StringBuffer pageText)。对于转换，使用输出参数而非返回值令人迷惑。如果函数要对输入参数进行转换操作，转换结果就该体现为返回值。实际上，StringBuffer transform(StringBuffer in)要比 void transform(StringBuffer out)强，即便第一种形式只简单地返回输参数也是这样。至少，它遵循了转换的形式。\n 3.6.2 Flag Arguments 标识参数 #  Flag arguments are ugly. Passing a boolean into a function is a truly terrible practice. It immediately complicates the signature of the method, loudly proclaiming that this function does more than one thing. It does one thing if the flag is true and another if the flag is false!\n 标识参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。如果标识为 true 将会这样做，标识为 false 则会那样做！\n In Listing 3-7 we had no choice because the callers were already passing that flag in, and I wanted to limit the scope of refactoring to the function and below. Still, the method call render(true) is just plain confusing to a poor reader. Mousing over the call and seeing render(boolean isSuite) helps a little, but not that much. We should have split the function into two: renderForSuite() and renderForSingleTest().\n 在代码清单 3-7 中，我们别无选择，因为调用者已经传入了那个标识，而我想把重构范围限制在该函数及该函数以下范围之内。方法调用 render(true)对于可怜的读者来说仍然摸不着头脑。卷动屏幕，看到 render(Boolean isSuite)，稍许有点帮助，不过仍然不够。应该把该函数一分为二：reanderForSuite( )和 renderForSingleTest( )。\n 3.6.3 Dyadic Functions 二元函数 #  A function with two arguments is harder to understand than a monadic function. For example, writeField(name) is easier to understand than writeField(output-Stream, name).10 Though the meaning of both is clear, the first glides past the eye, easily depositing its meaning. The second requires a short pause until we learn to ignore the first parameter. And that, of course, eventually results in problems because we should never ignore any part of code. The parts we ignore are where the bugs will hide.\n 有两个参数的函数要比一元函数难懂。例如，writeField(name)比 writeField(outputStream,name)好懂。尽管两种情况下意义都很清楚，但第一个只要扫一眼就明白，更好地表达了其意义。第二个就得暂停一下才能明白，除非我们学会忽略第一个参数。而且最终那也会导致问题，因为我们根本就不该忽略任何代码。忽略掉的部分就是缺陷藏身之地。\n There are times, of course, where two arguments are appropriate. For example, Point p = new Point(0,0); is perfectly reasonable. Cartesian points naturally take two arguments. Indeed, we’d be very surprised to see new Point(0). However, the two arguments in this case are ordered components of a single value! Whereas output-Stream and name have neither a natural cohesion, nor a natural ordering.\n 当然，有些时候两个参数正好。例如，Point p = new Point(0,0);就相当合理。笛卡儿点天生拥有两个参数。如果看到 new Point(0)，我们会倍感惊讶。然而，本例中的两个参数却只是单个值的有序组成部分！而 output-Stream 和 name 则既非自然的组合，也不是自然的排序。\n Even obvious dyadic functions like assertEquals(expected, actual) are problematic. How many times have you put the actual where the expected should be? The two arguments have no natural ordering. The expected, actual ordering is a convention that requires practice to learn.\n 即便是如 assertEquals(expected, actual)这样的二元函数也有其问题。你有多少次会搞错 actual 和 expected 的位置呢？这两个参数没有自然的顺序。expected 在前，actual 在后，只是一种需要学习的约定罢了。\n Dyads aren’t evil, and you will certainly have to write them. However, you should be aware that they come at a cost and should take advantage of what mechanisms may be available to you to convert them into monads. For example, you might make the writeField method a member of outputStream so that you can say outputStream. writeField(name). Or you might make the outputStream a member variable of the current class so that you don’t have to pass it. Or you might extract a new class like FieldWriter that takes the outputStream in its constructor and has a write method.\n 二元函数不算恶劣，而且你当然也会编写二元函数。不过，你得小心，使用二元函数要付出代价。你应该尽量利用一些机制将其转换成一元函数。例如，可以把 writeField 方法写成 outputStream 的成员之一，从而能这样用：outputStream.writeField(name)。或者，也可以把 outputStream 写成当前类的成员变量，从而无需再传递它。还可以分离出类似 FieldWriter 的新类，在其构造器中采用 outputStream，并且包含一个 write 方法。\n 3.6.4 Triads 三元函数 #  Functions that take three arguments are significantly harder to understand than dyads. The issues of ordering, pausing, and ignoring are more than doubled. I suggest you think very carefully before creating a triad.\n 有三个参数的函数要比二元函数难懂得多。排序、琢磨、忽略的问题都会加倍体现。建议你在写三元函数前一定要想清楚。\n For example, consider the common overload of assertEquals that takes three arguments: assertEquals(message, expected, actual). How many times have you read the message and thought it was the expected? I have stumbled and paused over that particular triad many times. In fact, every time I see it, I do a double-take and then learn to ignore the message.\n 例如，设想 assertEquals 有三个参数：assertEquals(message, expected, actual)。有多少次，你读到 message，错以为它是 expected 呢？我就常栽在这个三元函数上。实际上，每次我看到这里，总会绕半天圈子，最后学会了忽略 message 参数。\n On the other hand, here is a triad that is not quite so insidious: assertEquals(1.0, amount, .001). Although this still requires a double-take, it’s one that’s worth taking. It’s always good to be reminded that equality of floating point values is a relative thing.\n 另一方面，这里有个并不那么险恶的三元函数：assertEquals(1.0, amount, .001)。虽然也要费点神，还是值得的。得到“浮点值的等值是相对而言”的提示总是好的。\n 3.6.5 Argument Objects 参数对象 #  When a function seems to need more than two or three arguments, it is likely that some of those arguments ought to be wrapped into a class of their own. Consider, for example, the difference between the two following declarations:\n 如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。例如，下面两个声明的差别：\n Circle makeCircle(double x, double y, double radius); Circle makeCircle(Point center, double radius); Reducing the number of arguments by creating objects out of them may seem like cheating, but it’s not. When groups of variables are passed together, the way x and y are in the example above, they are likely part of a concept that deserves a name of its own.\n 从参数创建对象，从而减少参数数量，看起来像是在作弊，但实则并非如此。当一组参数被共同传递，就像上例中的 x 和 y 那样，往往就是该有自己名称的某个概念的一部分。\n 3.6.6 Argument Lists 参数列表 #  Sometimes we want to pass a variable number of arguments into a function. Consider, for example, the String.format method:\n 有时，我们想要向函数传入数量可变的参数。例如，\n String.format(”%s worked %.2f hours.”, name, hours); If the variable arguments are all treated identically, as they are in the example above, then they are equivalent to a single argument of type List. By that reasoning, String.format is actually dyadic. Indeed, the declaration of String.format as shown below is clearly dyadic.\n 如果可变参数像上例中那样被同等对待，就和类型为 List 的单个参数没什么两样。这样一来，String.formate 实则是二元函数。下列 String.format 的声明也很明显是二元的：\n public String format(String format, Object… args) So all the same rules apply. Functions that take variable arguments can be monads, dyads, or even triads. But it would be a mistake to give them more arguments than that.\n 同理，有可变参数的函数可能是一元、二元甚至三元。超过这个数量就可能要犯错了。\n void monad(Integer… args); void dyad(String name, Integer… args); void triad(String name, int count, Integer… args); 3.6.7 Verbs and Keywords 动词与关键字 #  Choosing good names for a function can go a long way toward explaining the intent of the function and the order and intent of the arguments. In the case of a monad, the function and argument should form a very nice verb/noun pair. For example, write(name) is very evocative. Whatever this “name” thing is, it is being “written.” An even better name might be writeField(name), which tells us that the “name” thing is a “field.”\n 给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如，write(name)就相当令人认同。不管这个“name”是什么，都要被“write”。更好的名称大概是 writeField(name)，它告诉我们，“name”是一个“field”。\n This last is an example of the keyword form of a function name. Using this form we encode the names of the arguments into the function name. For example, assertEquals might be better written as assertExpectedEqualsActual(expected, actual). This strongly mitigates the problem of having to remember the ordering of the arguments.\n 最后那个例子展示了函数名称的关键字（keyword）形式。使用这种形式，我们把参数的名称编码成了函数名。例如，assertEqual 改成 assertExpectedEqualsActual(expected, actual)可能会好些。这大大减轻了记忆参数顺序的负担。\n 3.7 HAVE NO SIDE EFFECTS 无副作用 #  Side effects are lies. Your function promises to do one thing, but it also does other hidden things. Sometimes it will make unexpected changes to the variables of its own class. Sometimes it will make them to the parameters passed into the function or to system globals. In either case they are devious and damaging mistruths that often result in strange temporal couplings and order dependencies.\n 副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。\n Consider, for example, the seemingly innocuous function in Listing 3-6. This function uses a standard algorithm to match a userName to a password. It returns true if they match and false if anything goes wrong. But it also has a side effect. Can you spot it?\n 以代码清单 3-6 中看似无伤大雅的函数为例。该函数使用标准算法来匹配 userName 和 password。如果匹配成功，返回 true，如果失败则返回 false。但它会有副作用。你知道问题所在吗？\n Listing 3-6 UserValidator.java\n 代码清单 3-6 UserValidator.java\n public class UserValidator { private Cryptographer cryptographer; public boolean checkPassword(String userName, String password) { User user = UserGateway.findByName(userName); if (user != User.NULL) { String codedPhrase = user. getPhraseEncodedByPassword(); String phrase = cryptographer.decrypt(codedPhrase, password); if (\u0026#34;Valid Password\u0026#34;.equals(phrase)) { Session.initialize(); return true; } } return false; } } The side effect is the call to Session.initialize(), of course. The checkPassword function, by its name, says that it checks the password. The name does not imply that it initializes the session. So a caller who believes what the name of the function says runs the risk of erasing the existing session data when he or she decides to check the validity of the user.\n 当然了，副作用就在于对 Session.initialize( )的调用。checkPassword 函数，顾名思义，就是用来检查密码的。该名称并未暗示它会初始化该次会话。所以，当某个误信了函数名的调用者想要检查用户有效性时，就得冒抹除现有会话数据的风险。\n This side effect creates a temporal coupling. That is, checkPassword can only be called at certain times (in other words, when it is safe to initialize the session). If it is called out of order, session data may be inadvertently lost. Temporal couplings are confusing, especially when hidden as a side effect. If you must have a temporal coupling, you should make it clear in the name of the function. In this case we might rename the function checkPasswordAndInitializeSession, though that certainly violates “Do one thing.”\n 这一副作用造出了一次时序性耦合。也就是说，checkPassword 只能在特定时刻调用（换言之，在初始化会话是安全的时候调用）。如果在不合适的时候调用，会话数据就有可能沉默地丢失。时序性耦合令人迷惑，特别是当它躲在副作用后面时。如果一定要时序性耦合，就应该在函数名称中说明。在本例中，可以重命名函数为 checkPasswordAndInitializeSession，虽然那还是违反了“只做一件事”的规则。\n Output Arguments 输出参数 #  Arguments are most naturally interpreted as inputs to a function. If you have been programming for more than a few years, I’m sure you’ve done a double-take on an argument that was actually an output rather than an input. For example:\n 参数多数会被自然而然地看作是函数的输入。如果你编过好些年程序，我担保你一定被用作输出而非输入的参数迷惑过。例如：\n appendFooter(s); Does this function append s as the footer to something? Or does it append some footer to s? Is s an input or an output? It doesn’t take long to look at the function signature and see:\n 这个函数是把 s 添加到什么东西后面吗？或者它把什么东西添加到了 s 后面？s 是输入参数还是输出参数？稍许花点时间看看函数签名：\n public void appendFooter(StringBuffer report) This clarifies the issue, but only at the expense of checking the declaration of the function. Anything that forces you to check the function signature is equivalent to a double-take. It’s a cognitive break and should be avoided.\n 事情清楚了，但付出了检查函数声明的代价。你被迫检查函数签名，就得花上一点时间。应该避免这种中断思路的事。\n In the days before object oriented programming it was sometimes necessary to have output arguments. However, much of the need for output arguments disappears in OO languages because this is intended to act as an output argument. In other words, it would be better for appendFooter to be invoked as\n 在面向对象编程之前的岁月里，有时的确需要输出参数。然而，面向对象语言中对输出参数的大部分需求已经消失了，因为 this 也有输出函数的意味在内。换言之，最好是这样调用 appendFooter：\n report.appendFooter(); In general output arguments should be avoided. If your function must change the state of something, have it change the state of its owning object.\n 在面向对象编程之前的岁月里，有时的确需要输出参数。然而，面向对象语言中对输出参数的大部分需求已经消失了，因为 this 也有输出函数的意味在内。换言之，最好是这样调用 appendFooter：\n 3.8 COMMAND QUERY SEPARATION 分隔指令与询问 #  Functions should either do something or answer something, but not both. Either your function should change the state of an object, or it should return some information about that object. Doing both often leads to confusion. Consider, for example, the following function:\n 函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。看看下面的例子：\n public boolean set(String attribute, String value); This function sets the value of a named attribute and returns true if it is successful and false if no such attribute exists. This leads to odd statements like this:\n 该函数设置某个指定属性，如果成功就返回 true，如果不存在那个属性则返回 false。这样就导致了以下语句：\n if (set(\u0026#34;username\u0026#34;, \u0026#34;unclebob\u0026#34;))… Imagine this from the point of view of the reader. What does it mean? Is it asking whether the “username” attribute was previously set to “unclebob”? Or is it asking whether the “username” attribute was successfully set to “unclebob”? It’s hard to infer the meaning from the call because it’s not clear whether the word “set” is a verb or an adjective.\n 从读者的角度考虑一下吧。这是什么意思呢？它是在问 username 属性值是否之前已设置为 unclebob 吗？或者它是在问 username 属性值是否成功设置为 unclebob 呢？从这行调用很难判断其含义，因为 set 是动词还是形容词并不清楚。\n The author intended set to be a verb, but in the context of the if statement it feels like an adjective. So the statement reads as “If the username attribute was previously set to unclebob” and not “set the username attribute to unclebob and if that worked then.…” We could try to resolve this by renaming the set function to setAndCheckIfExists, but that doesn’t much help the readability of the if statement. The real solution is to separate the command from the query so that the ambiguity cannot occur.\n 作者本意，set 是个动词，但在 if 语句的上下文中，感觉它像是个形容词。该语句读起来像是说“如果 username 属性值之前已被设置为 uncleob”，而不是“设置 username 属性值为 unclebob，看看是否可行，然后……”。要解决这个问题，可以将 set 函数重命名为 setAndCheckIfExists，但这对提高 if 语句的可读性帮助不大。真正的解决方案是把指令与询问分隔开来，防止混淆的发生：\n if (attributeExists(\u0026#34;username\u0026#34;)) { setAttribute(\u0026#34;username\u0026#34;, \u0026#34;unclebob\u0026#34;); … } 3.9 PREFER EXCEPTIONS TO RETURNING ERROR CODES 使用异常替代返回错误码 #  Returning error codes from command functions is a subtle violation of command query separation. It promotes commands being used as expressions in the predicates of if statements.\n 从指令式函数返回错误码轻微违反了指令与询问分隔的规则。它鼓励了在 if 语句判断中把指令当作表达式使用。\n if (deletePage(page) == E_OK) This does not suffer from verb/adjective confusion but does lead to deeply nested structures. When you return an error code, you create the problem that the caller must deal with the error immediately.\n 这不会引起动词/形容词混淆，但却导致更深层次的嵌套结构。当返回错误码时，就是在要求调用者立刻处理错误。\n if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\u0026#34;page deleted\u0026#34;); } else { logger.log(\u0026#34;configKey not deleted\u0026#34;); } } else { logger.log(\u0026#34;deleteReference from registry failed\u0026#34;); } } else { logger.log(\u0026#34;delete failed\u0026#34;); return E_ERROR; } On the other hand, if you use exceptions instead of returned error codes, then the error processing code can be separated from the happy path code and can be simplified:\n 另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化：\n try { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } catch (Exception e) { logger.log(e.getMessage()); } 3.9.1 Extract Try/Catch Blocks 抽离 Try/Catch 代码块 #  Try/catch blocks are ugly in their own right. They confuse the structure of the code and mix error processing with normal processing. So it is better to extract the bodies of the try and catch blocks out into functions of their own.\n Try/catch 代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把 try 和 catch 代码块的主体部分抽离出来，另外形成函数。\n public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); } In the above, the delete function is all about error processing. It is easy to understand and then ignore. The deletePageAndAllReferences function is all about the processes of fully deleting a page. Error handling can be ignored. This provides a nice separation that makes the code easier to understand and modify.\n 在上例中，delete 函数只与错误处理有关。很容易理解然后就忽略掉。deletePageAndAllReference 函数只与完全删除一个 page 有关。错误处理可以忽略掉。有了这样美妙的区隔，代码就更易于理解和修改了。\n 3.9.2 Error Handling Is One Thing 错误处理就是一件事 #  Functions should do one thing. Error handing is one thing. Thus, a function that handles errors should do nothing else. This implies (as in the example above) that if the keyword try exists in a function, it should be the very first word in the function and that there should be nothing after the catch/finally blocks.\n 函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数不该做其他事。这意味着（如上例所示）如果关键字 try 在某个函数中存在，它就该是这个函数的第一个单词，而且在 catch/finally 代码块后面也不该有其他内容。\n 3.9.3 The Error.java Dependency Magnet Error.java 依赖磁铁 #  Returning error codes usually implies that there is some class or enum in which all the error codes are defined.\n 返回错误码通常暗示某处有个类或是枚举，定义了所有错误码。\n public enum Error { OK, INVALID, NO_SUCH, LOCKED, OUT_OF_RESOURCES, WAITING_FOR_EVENT; } Classes like this are a dependency magnet; many other classes must import and use them. Thus, when the Error enum changes, all those other classes need to be recompiled and redeployed.11 This puts a negative pressure on the Error class. Programmers don’t want to add new errors because then they have to rebuild and redeploy everything. So they reuse old error codes instead of adding new ones.\n 这样的类就是一块依赖磁铁（dependency magnet）；其他许多类都得导入和使用它。当 Error 枚举修改时，所有这些其他的类都需要重新编译和部署。这对 Error 类造成了负面压力。程序员不愿增加新的错误代码，因为这样他们就得重新构建和部署所有东西。于是他们就复用旧的错误码，而不添加新的。\n When you use exceptions rather than error codes, then new exceptions are derivatives of the exception class. They can be added without forcing any recompilation or redeployment.12\n 使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。\n 3.10 DON’T REPEAT YOURSELF13 别重复自己 #  Look back at Listing 3-1 carefully and you will notice that there is an algorithm that gets repeated four times, once for each of the SetUp, SuiteSetUp, TearDown, and SuiteTearDown cases. It’s not easy to spot this duplication because the four instances are intermixed with other code and aren’t uniformly duplicated. Still, the duplication is a problem because it bloats the code and will require four-fold modification should the algorithm ever have to change. It is also a four-fold opportunity for an error of omission.\n 回头仔细看看代码清单 3-1，你会注意到，有个算法在 SetUp、SuiteSetUp、TearDown 和 SuiteTearDown 中总共被重复了 4 次。识别重复不太容易，因为这 4 次重复与其他代码混在一起，而且也不完全一样。这样的重复还是会导致问题，因为代码因此而臃肿，且当算法改变时需要修改 4 处地方。而且也会增加 4 次放过错误的可能性。\n  This duplication was remedied by the include method in Listing 3-7. Read through that code again and notice how the readability of the whole module is enhanced by the reduction of that duplication.\n 使用代码清单 3-7 中的 include 方法修正了这些重复。再读一遍那段代码，你会注意到，整个模块的可读性因为重复的消除而得到了提升。\n Duplication may be the root of all evil in software. Many principles and practices have been created for the purpose of controlling or eliminating it. Consider, for example, that all of Codd’s database normal forms serve to eliminate duplication in data. Consider also how object-oriented programming serves to concentrate code into base classes that would otherwise be redundant. Structured programming, Aspect Oriented Programming, Component Oriented Programming, are all, in part, strategies for eliminating duplication. It would appear that since the invention of the subroutine, innovations in software development have been an ongoing attempt to eliminate duplication from our source code.\n 重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。例如，全部考德（Codd）数据库范式都是为消灭数据重复而服务。再想想看，面向对象编程是如何将代码集中到基类，从而避免了冗余。面向方面编程（Aspect Oriented Programming）、面向组件编程（Component Oriented Programming）多少也都是消除重复的一种策略。看来，自子程序发明以来，软件开发领域的所有创新都是在不断尝试从源代码中消灭重复。\n 3.11 STRUCTURED PROGRAMMING 结构化编程 #  Some programmers follow Edsger Dijkstra’s rules of structured programming.14 Dijkstra said that every function, and every block within a function, should have one entry and one exit. Following these rules means that there should only be one return statement in a function, no break or continue statements in a loop, and never, ever, any goto statements.\n 有些程序员遵循 Edsger Dijkstra 的结构化编程规则。Dijkstra 认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。遵循这些规则，意味着在每个函数中只该有一个 return 语句，循环中不能有 break 或 continue 语句，而且永永远远不能有任何 goto 语句。\n While we are sympathetic to the goals and disciplines of structured programming, those rules serve little benefit when functions are very small. It is only in larger functions that such rules provide significant benefit.\n 我们赞成结构化编程的目标和规范，但对于小函数，这些规则助益不大。只有在大函数中，这些规则才会有明显的好处。\n So if you keep your functions small, then the occasional multiple return, break, or continue statement does no harm and can sometimes even be more expressive than the single-entry, single-exit rule. On the other hand, goto only makes sense in large functions, so it should be avoided.\n 所以，只要函数保持短小，偶尔出现的 return、break 或 continue 语句没有坏处，甚至还比单入单出原则更具有表达力。另外一方面，goto 只在大函数中才有道理，所以应该尽量避免使用。\n 3.12 HOW DO YOU WRITE FUNCTIONS LIKE THIS? 如何写出这样的函数 #  Writing software is like any other kind of writing. When you write a paper or an article, you get your thoughts down first, then you massage it until it reads well. The first draft might be clumsy and disorganized, so you wordsmith it and restructure it and refine it until it reads the way you want it to read.\n 写代码和写别的东西很像。在写论文或文章时，你先想什么就写什么，然后再打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。\n When I write functions, they come out long and complicated. They have lots of indenting and nested loops. They have long argument lists. The names are arbitrary, and there is duplicated code. But I also have a suite of unit tests that cover every one of those clumsy lines of code.\n 我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的，也会有重复的代码。不过我会配上一套单元测试，覆盖每行丑陋的代码。\n So then I massage and refine that code, splitting out functions, changing names, eliminating duplication. I shrink the methods and reorder them. Sometimes I break out whole classes, all the while keeping the tests passing.\n 然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。同时保持测试通过。最后，遵循本章列出的规则，我组装好这些函数。\n In the end, I wind up with functions that follow the rules I’ve laid down in this chapter. I don’t write them that way to start. I don’t think anyone could.\n 我并不从一开始就按照规则写函数。我想没人做得到。\n 3.13 CONCLUSION 小结 #  Every system is built from a domain-specific language designed by the programmers to describe that system. Functions are the verbs of that language, and classes are the nouns. This is not some throwback to the hideous old notion that the nouns and verbs in a requirements document are the first guess of the classes and functions of a system. Rather, this is a much older truth. The art of programming is, and has always been, the art of language design.\n 每个系统都是使用某种领域特定语言搭建，而这种语言是程序员设计来描述那个系统的。函数是语言的动词，类是名词。这并非是退回到那种认为需求文档中的名词和动词就是系统中类和函数的最初设想的可怕的旧观念。其实这是个历史更久的真理。编程艺术是且一直就是语言设计的艺术。\n Master programmers think of systems as stories to be told rather than programs to be written. They use the facilities of their chosen programming language to construct a much richer and more expressive language that can be used to tell that story. Part of that domain-specific language is the hierarchy of functions that describe all the actions that take place within that system. In an artful act of recursion those actions are written to use the very domain-specific language they define to tell their own small part of the story.\n 大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言，用来讲那个故事。那种领域特定语言的一个部分，就是描述在系统中发生的各种行为的函数层级。在一种狡猾的递归操作中，这些行为使用它们定义的与领域紧密相关的语言讲述自己那个小故事。\n This chapter has been about the mechanics of writing functions well. If you follow the rules herein, your functions will be short, well named, and nicely organized. But never forget that your real goal is to tell the story of the system, and that the functions you write need to fit cleanly together into a clear and precise language to help you with that telling.\n 本章所讲述的是有关编写良好函数的机制。如果你遵循这些规则，函数就会短小，有个好名字，而且被很好地归置。不过永远别忘记，真正的目标在于讲述系统的故事，而你编写的函数必须干净利落地拼装到一起，形成一种精确而清晰的语言，帮助你讲故事。\n 3.14 SETUPTEARDOWNINCLUDER SetupTeardownIncluder 程序 #  Listing 3-7 SetupTeardownIncluder.java\n 代码清单 3-7 SetupTeardownIncluder.java\n package fitnesse.html; import fitnesse.responders.run.SuiteResponder; import fitnesse.wiki.*; public class SetupTeardownIncluder { private PageData pageData; private boolean isSuite; private WikiPage testPage; private StringBuffer newPageContent; private PageCrawler pageCrawler; public static String render(PageData pageData) throws Exception { return render(pageData, false); } public static String render(PageData pageData, boolean isSuite) throws Exception { return new SetupTeardownIncluder(pageData).render(isSuite); } private SetupTeardownIncluder(PageData pageData) { this.pageData = pageData; testPage = pageData.getWikiPage(); pageCrawler = testPage.getPageCrawler(); newPageContent = new StringBuffer(); } private String render(boolean isSuite) throws Exception { this.isSuite = isSuite; if (isTestPage()) includeSetupAndTeardownPages(); return pageData.getHtml(); } private boolean isTestPage() throws Exception { return pageData.hasAttribute(\u0026#34;Test\u0026#34;); } private void includeSetupAndTeardownPages() throws Exception { includeSetupPages(); includePageContent(); includeTeardownPages(); updatePageContent(); } private void includeSetupPages() throws Exception { if (isSuite) includeSuiteSetupPage(); includeSetupPage(); } private void includeSuiteSetupPage() throws Exception { include(SuiteResponder.SUITE_SETUP_NAME, \u0026#34;-setup\u0026#34;); } private void includeSetupPage() throws Exception { include(\u0026#34;SetUp\u0026#34;, \u0026#34;-setup\u0026#34;); } private void includePageContent() throws Exception { newPageContent.append(pageData.getContent()); } private void includeTeardownPages() throws Exception { includeTeardownPage(); if (isSuite) includeSuiteTeardownPage(); } private void includeTeardownPage() throws Exception { include(\u0026#34;TearDown\u0026#34;, \u0026#34;-teardown\u0026#34;); } private void includeSuiteTeardownPage() throws Exception { include(SuiteResponder.SUITE_TEARDOWN_NAME, \u0026#34;-teardown\u0026#34;); } private void updatePageContent() throws Exception { pageData.setContent(newPageContent.toString()); } private void include(String pageName, String arg) throws Exception { WikiPage inheritedPage = findInheritedPage(pageName); if (inheritedPage != null) { String pagePathName = getPathNameForPage(inheritedPage); buildIncludeDirective(pagePathName, arg); } } private WikiPage findInheritedPage(String pageName) throws Exception { return PageCrawlerImpl.getInheritedPage(pageName, testPage); } private String getPathNameForPage(WikiPage page) throws Exception { WikiPagePath pagePath = pageCrawler.getFullPath(page); return PathParser.render(pagePath); } private void buildIncludeDirective(String pagePathName, String arg) { newPageContent .append(\u0026#34;\\n!include \u0026#34;) .append(arg) .append(\u0026#34; .\u0026#34;) .append(pagePathName) .append(\u0026#34;\\n\u0026#34;); } } "});index.add({'id':207,'href':'/docs/Clean-Code/4.-Comments/ch4/','title':"Ch4",'section':"Go语言圣经",'content':"第 4 章 Comments 注释 #   “Don’t comment bad code—rewrite it.”—Brian W. Kernighan and P. J. Plaugher1\n “别给糟糕的代码加注释——重新写吧。”——Brian W. Kernighan 与 P. J.\n Nothing can be quite so helpful as a well-placed comment. Nothing can clutter up a module more than frivolous dogmatic comments. Nothing can be quite so damaging as an old crufty comment that propagates lies and misinformation.\n 什么也比不上放置良好的注释来得有用。什么也不会比乱七八糟的注释更有本事搞乱一个模块。什么也不会比陈旧、提供错误信息的注释更有破坏性。\n Comments are not like Schindler’s List. They are not “pure good.” Indeed, comments are, at best, a necessary evil. If our programming languages were expressive enough, or if we had the talent to subtly wield those languages to express our intent, we would not need comments very much—perhaps not at all.\n 注释并不像辛德勒的名单。它们并不“纯然地好”。实际上，注释最多也就是一种必须的恶。若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不那么需要注释——也许根本不需要。\n The proper use of comments is to compensate for our failure to express ourself in code. Note that I used the word failure. I meant it. Comments are always failures. We must have them because we cannot always figure out how to express ourselves without them, but their use is not a cause for celebration.\n 注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。注意，我用了“失败”一词。我是说真的。注释总是一种失败。我们总无法找到不用注释就能表达自我的方法，所以总要有注释，这并不值得庆贺。\n So when you find yourself in a position where you need to write a comment, think it through and see whether there isn’t some way to turn the tables and express yourself in code. Every time you express yourself in code, you should pat yourself on the back. Every time you write a comment, you should grimace and feel the failure of your ability of expression.\n 如果你发现自己需要写注释，再想想看是否有办法翻盘，用代码来表达。每次用代码表达，你都该夸奖一下自己。每次写注释，你都该做个鬼脸，感受自己在表达能力上的失败。\n Why am I so down on comments? Because they lie. Not always, and not intentionally, but too often. The older a comment is, and the farther away it is from the code it describes, the more likely it is to be just plain wrong. The reason is simple. Programmers can’t realistically maintain them.\n 我为什么要极力贬低注释？因为注释会撒谎。也不是说总是如此或有意如此，但出现得实在太频繁。注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误。原因很简单。程序员不能坚持维护注释。\n Code changes and evolves. Chunks of it move from here to there. Those chunks bifurcate and reproduce and come together again to form chimeras. Unfortunately the comments don’t always follow them—can’t always follow them. And all too often the comments get separated from the code they describe and become orphaned blurbs of ever-decreasing accuracy. For example, look what has happened to this comment and the line it was intended to describe:\n 代码在变动，在演化。从这里移到那里。彼此分离、重造又合到一处。很不幸，注释并不总是随之变动——不能总是跟着走。注释常常会与其所描述的代码分隔开来，孑然飘零，越来越不准确。例如，看看以下注释以及它本来要描述的代码行变成了什么样子：\n MockRequest request; private final String HTTP_DATE_REGEXP = \u0026#34;[SMTWF][a-z]{2}\\\\,\\\\s[0-9]{2}\\\\s[JFMASOND][a-z]{2}\\\\s\u0026#34; + \u0026#34;[0-9]{4}\\\\s[0-9]{2}\\\\:[0-9]{2}\\\\:[0-9]{2}\\\\sGMT\u0026#34;; private Response response; private FitNesseContext context; private FileResponder responder; private Locale saveLocale; // Example: \u0026#34;Tue, 02 Apr 2003 22:18:49 GMT\u0026#34; Other instance variables that were probably added later were interposed between the HTTP_DATE_REGEXP constant and it’s explanatory comment.\n 在 HTTP_DATE_REGEXP 常量及其注释之间，有可能插入其他实体变量。\n It is possible to make the point that programmers should be disciplined enough to keep the comments in a high state of repair, relevance, and accuracy. I agree, they should. But I would rather that energy go toward making the code so clear and expressive that it does not need the comments in the first place.\n 程序员应当负责将注释保持在可维护、有关联、精确的高度。我同意这种说法。但我更主张把力气用在写清楚代码上，直接保证无须编写注释。\n Inaccurate comments are far worse than no comments at all. They delude and mislead. They set expectations that will never be fulfilled. They lay down old rules that need not, or should not, be followed any longer.\n 不准确的注释要比没注释坏得多。它们满口胡言。它们预期的东西永不能实现。它们设定了无需也不应再遵循的旧规则。\n Truth can only be found in one place: the code. Only the code can truly tell you what it does. It is the only source of truly accurate information. Therefore, though comments are sometimes necessary, we will expend significant energy to minimize them.\n 真实只在一处地方有：代码。只有代码能忠实地告诉你它做的事。那是唯一真正准确的信息来源。所以，尽管有时也需要注释，我们也该多花心思尽量减少注释量。\n 4.1 COMMENTS DO NOT MAKE UP FOR BAD CODE 注释不能美化糟糕的代码 #  One of the more common motivations for writing comments is bad code. We write a module and we know it is confusing and disorganized. We know it’s a mess. So we say to ourselves, “Ooh, I’d better comment that!” No! You’d better clean it!\n 写注释的常见动机之一是糟糕的代码的存在。我们编写一个模块，发现它令人困扰、乱七八糟。我们知道，它烂透了。我们告诉自己：“喔，最好写点注释！”不！最好是把代码弄干净！\n Clear and expressive code with few comments is far superior to cluttered and complex code with lots of comments. Rather than spend your time writing the comments that explain the mess you’ve made, spend it cleaning that mess.\n 带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样得多。与其花时间编写解释你搞出的糟糕的代码的注释，不如花时间清洁那堆糟糕的代码。\n 4.2 EXPLAIN YOURSELF IN CODE 用代码来阐述 #  There are certainly times when code makes a poor vehicle for explanation. Unfortunately, many programmers have taken this to mean that code is seldom, if ever, a good means for explanation. This is patently false. Which would you rather see? This:\n 有时，代码本身不足以解释其行为。不幸的是，许多程序员据此以为代码很少——如果有的话——能做好解释工作。这种观点纯属错误。\n // Check to see if the employee is eligible for full benefits if ((employee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)) Or this?\n 你愿意看到这个：\n if (employee.isEligibleForFullBenefits()) It takes only a few seconds of thought to explain most of your intent in code. In many cases it’s simply a matter of creating a function that says the same thing as the comment you want to write.\n 只要想上那么几秒钟，就能用代码解释你大部分的意图。很多时候，简单到只需要创建一个描述与注释所言同一事物的函数即可。\n 4.3 GOOD COMMENTS 好注释 #  Some comments are necessary or beneficial. We’ll look at a few that I consider worthy of the bits they consume. Keep in mind, however, that the only truly good comment is the comment you found a way not to write.\n 有些注释是必须的，也是有利的。来看看一些我认为值得写的注释。不过要记住，唯一真正好的注释是你想办法不去写的注释。\n 4.3.1 Legal Comments 法律信息 #  Sometimes our corporate coding standards force us to write certain comments for legal reasons. For example, copyright and authorship statements are necessary and reasonable things to put into a comment at the start of each source file.\n 有时，公司代码规范要求编写与法律有关的注释。例如，版权及著作权声明就是必须和有理由在每个源文件开头注释处放置的内容。\n Here, for example, is the standard comment header that we put at the beginning of every source file in FitNesse. I am happy to say that our IDE hides this comment from acting as clutter by automatically collapsing it.\n 下例是我们在 FitNesse 项目每个源文件开头放置的标准注释。我可以很开心地说，IDE 自动卷起这些注释，这样就不会显得凌乱了。\n // Copyright (C) 2003,2004,2005 by Object Mentor, Inc. All rights reserved. // Released under the terms of the GNU General Public License version 2 or later. Comments like this should not be contracts or legal tomes. Where possible, refer to a standard license or other external document rather than putting all the terms and conditions into the comment.\n 这类注释不应是合同或法典。只要有可能，就指向一份标准许可或其他外部文档，而不要把所有条款放到注释中。\n 4.3.2 Informative Comments 提供信息的注释 #  It is sometimes useful to provide basic information with a comment. For example, consider this comment that explains the return value of an abstract method:\n 有时，用注释来提供基本信息也有其用处。例如，以下注释解释了某个抽象方法的返回值：\n // Returns an instance of the Responder being tested. protected abstract Responder responderInstance(); A comment like this can sometimes be useful, but it is better to use the name of the function to convey the information where possible. For example, in this case the comment could be made redundant by renaming the function: responderBeingTested.\n 这类注释有时管用，但更好的方式是尽量利用函数名称传达信息。比如，在本例中，只要把函数重新命名为 responderBeingTested，注释就是多余的了。\n Here’s a case that’s a bit better:\n 下例稍好一些：\n // format matched kk:mm:ss EEE, MMM dd, yyyy Pattern timeMatcher = Pattern.compile( \u0026#34;\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w* \\\\d*, \\\\d*\u0026#34;); In this case the comment lets us know that the regular expression is intended to match a time and date that were formatted with the SimpleDateFormat.format function using the specified format string. Still, it might have been better, and clearer, if this code had been moved to a special class that converted the formats of dates and times. Then the comment would likely have been superfluous.\n SimpleDateFormat.format 函数利用特定格式字符串格式化的时间和日期。同样，如果把这段代码移到某个转换日期和时间格式的类中，就会更好、更清晰，而注释也就变得多此一举了。\n 4.3.3 Explanation of Intent 对意图的解释 #  Sometimes a comment goes beyond just useful information about the implementation and provides the intent behind a decision. In the following case we see an interesting decision documented by a comment. When comparing two objects, the author decided that he wanted to sort objects of his class higher than objects of any other.\n 有时，注释不仅提供了有关实现的有用信息，而且还提供了某个决定后面的意图。在下例中，我们看到注释反映出来的一个有趣决定。在对比两个对象时，作者决定将他的类放置在比其他东西更高的位置。\n public int compareTo(Object o) { if (o instanceof WikiPagePath) { WikiPagePath p = (WikiPagePath) o; String compressedName = StringUtil.join(names, \u0026#34;\u0026#34;); String compressedArgumentName = StringUtil.join(p.names, \u0026#34;\u0026#34;); return compressedName.compareTo(compressedArgumentName); } return 1; // we are greater because we are the right type. } Here’s an even better example. You might not agree with the programmer’s solution to the problem, but at least you know what he was trying to do.\n 下面的例子甚至更好。你也许不同意程序员给这个问题提供的解决方案，但至少你知道他想干什么。\n public void testConcurrentAddWidgets() throws Exception { WidgetBuilder widgetBuilder = new WidgetBuilder(new Class[]{BoldWidget.class}); String text = \u0026#34;’’’bold text’’’\u0026#34;; ParentWidget parent = new BoldWidget(new MockWidgetRoot(), \u0026#34;’’’bold text’’’\u0026#34;); AtomicBoolean failFlag = new AtomicBoolean(); failFlag.set(false); //This is our best attempt to get a race condition  //by creating large number of threads.  for (int i = 0; i \u0026lt; 25000; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); } assertEquals(false, failFlag.get()); } 4.3.4 Clarification 阐释 #  Sometimes it is just helpful to translate the meaning of some obscure argument or return value into something that’s readable. In general it is better to find a way to make that argument or return value clear in its own right; but when its part of the standard library, or in code that you cannot alter, then a helpful clarifying comment can be useful.\n 有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。通常，更好的方法是尽量让参数或返回值自身就足够清楚；但如果参数或返回值是某个标准库的一部分，或是你不能修改的代码，帮助阐释其含义的代码就会有用。\n public void testCompareTo() throws Exception { WikiPagePath a = PathParser.parse(\u0026#34;PageA\u0026#34;); WikiPagePath ab = PathParser.parse(\u0026#34;PageA.PageB\u0026#34;); WikiPagePath b = PathParser.parse(\u0026#34;PageB\u0026#34;); WikiPagePath aa = PathParser.parse(\u0026#34;PageA.PageA\u0026#34;); WikiPagePath bb = PathParser.parse(\u0026#34;PageB.PageB\u0026#34;); WikiPagePath ba = PathParser.parse(\u0026#34;PageB.PageA\u0026#34;); assertTrue(a.compareTo(a) == 0); // a == a  assertTrue(a.compareTo(b) != 0); // a != b  assertTrue(ab.compareTo(ab) == 0); // ab == ab  assertTrue(a.compareTo(b) == -1); // a \u0026lt; b  assertTrue(aa.compareTo(ab) == -1); // aa \u0026lt; ab  assertTrue(ba.compareTo(bb) == -1); // ba \u0026lt; bb  assertTrue(b.compareTo(a) == 1); // b \u0026gt; a  assertTrue(ab.compareTo(aa) == 1); // ab \u0026gt; aa  assertTrue(bb.compareTo(ba) == 1); // bb \u0026gt; ba } There is a substantial risk, of course, that a clarifying comment is incorrect. Go through the previous example and see how difficult it is to verify that they are correct. This explains both why the clarification is necessary and why it’s risky. So before writing comments like this, take care that there is no better way, and then take even more care that they are accurate.\n 当然，这也会冒阐释性注释本身就不正确的风险。回头看看上例，你会发现想要确认注释的正确性有多难。这一方面说明了阐释有多必要，另外也说明了它有风险。所以，在写这类注释之前，考虑一下是否还有更好的办法，然后再加倍小心地确认注释正确性。\n 4.3.5 Warning of Consequences 警示 #  Sometimes it is useful to warn other programmers about certain consequences. For example, here is a comment that explains why a particular test case is turned off:\n 有时，用于警告其他程序员会出现某种后果的注释也是有用的。例如，下面的注释解释了为什么要关闭某个特定的测试用例：\n  // Don\u0026#39;t run unless you // have some time to kill. public void _testWithReallyBigFile() { writeLinesToFile(10000000); response.setBody(testFile); response.readyToSend(this); String responseString = output.toString(); assertSubString(\u0026#34;Content-Length: 1000000000\u0026#34;, responseString); assertTrue(bytesSent \u0026gt; 1000000000); } Nowadays, of course, we’d turn off the test case by using the @Ignore attribute with an appropriate explanatory string. @Ignore(”Takes too long to run”). But back in the days before JUnit 4, putting an underscore in front of the method name was a common convention. The comment, while flippant, makes the point pretty well.\n 当然，如今我们多数会利用附上恰当解释性字符串的@Ignore 属性来关闭测试用例。比如@Ignore(\u0026ldquo;Takes too long to run\u0026rdquo;)。但在 JUnit4 之前的日子里，惯常的做法是在方法名前面加上下划线。如果注释足够有说服力，就会很有用了。\n Here’s another, more poignant example:\n 这里有个更麻烦的例子：\n public static SimpleDateFormat makeStandardHttpDateFormat() { //SimpleDateFormat is not thread safe,  //so we need to create each instance independently.  SimpleDateFormat df = new SimpleDateFormat(\u0026#34;EEE, dd MMM yyyy HH:mm:ss z\u0026#34;); df.setTimeZone(TimeZone.getTimeZone(\u0026#34;GMT\u0026#34;)); return df; } You might complain that there are better ways to solve this problem. I might agree with you. But the comment, as given here, is perfectly reasonable. It will prevent some overly eager programmer from using a static initializer in the name of efficiency.\n 你也许会抱怨说，还会有更好的解决方法。我大概会同意。不过上面的注释绝对有道理存在，它能阻止某位急切的程序员以效率之名使用静态初始器。\n 4.3.6 TODO Comments TODO 注释 #  It is sometimes reasonable to leave “To do” notes in the form of //TODO comments. In the following case, the TODO comment explains why the function has a degenerate implementation and what that function’s future should be.\n 有时，有理由用//TODO 形式在源代码中放置要做的工作列表。在下例中，TODO 注释解释了为什么该函数的实现部分无所作为，将来应该是怎样。\n //TODO-MdM these are not needed // We expect this to go away when we do the checkout model protected VersionInfo makeVersion() throws Exception { return null; } TODOs are jobs that the programmer thinks should be done, but for some reason can’t do at the moment. It might be a reminder to delete a deprecated feature or a plea for someone else to look at a problem. It might be a request for someone else to think of a better name or a reminder to make a change that is dependent on a planned event. Whatever else a TODO might be, it is not an excuse to leave bad code in the system.\n TODO 是一种程序员认为应该做，但由于某些原因目前还没做的工作。它可能是要提醒删除某个不必要的特性，或者要求他人注意某个问题。它可能是恳请别人取个好名字，或者提示对依赖于某个计划事件的修改。无论 TODO 的目的如何，它都不是在系统中留下糟糕的代码的借口。\n Nowadays, most good IDEs provide special gestures and features to locate all the TODO comments, so it’s not likely that they will get lost. Still, you don’t want your code to be littered with TODOs. So scan through them regularly and eliminate the ones you can.\n 如今，大多数好 IDE 都提供了特别的手段来定位所有 TODO 注释，这些注释看来丢不了。你不会愿意代码因为 TODO 的存在而变成一堆垃圾，所以要定期查看，删除不再需要的。\n 4.3.7 Amplification 放大 #  A comment may be used to amplify the importance of something that may otherwise seem inconsequential.\n 注释可以用来放大某种看来不合理之物的重要性。\n String listItemContent = match.group(3).trim(); // the trim is real important. It removes the starting // spaces that could cause the item to be recognized // as another list. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end())); 4.3.8 Javadocs in Public APIs 公共 API 中的 Javadoc #  There is nothing quite so helpful and satisfying as a well-described public API. The java-docs for the standard Java library are a case in point. It would be difficult, at best, to write Java programs without them.\n 没有什么比被良好描述的公共 API 更有用和令人满意的了。标准 Java 库中的 Javadoc 就是一例。没有它们，写 Java 程序就会变得很难。\n If you are writing a public API, then you should certainly write good javadocs for it. But keep in mind the rest of the advice in this chapter. Javadocs can be just as misleading, nonlocal, and dishonest as any other kind of comment.\n 如果你在编写公共 API，就该为它编写良好的 Javadoc。不过要记住本章中的其他建议。就像其他注释一样，Javadoc 也可能误导、不适用或者提供错误信息。\n 4.4 BAD COMMENTS 坏注释 #  Most comments fall into this category. Usually they are crutches or excuses for poor code or justifications for insufficient decisions, amounting to little more than the programmer talking to himself.\n 大多数注释都属此类。通常，坏注释都是糟糕的代码的支撑或借口，或者对错误决策的修正，基本上等于程序员自说自话。\n 4.4.1 Mumbling 喃喃自语 #  Plopping in a comment just because you feel you should or because the process requires it, is a hack. If you decide to write a comment, then spend the time necessary to make sure it is the best comment you can write.\n 如果只是因为你觉得应该或者因为过程需要就添加注释，那就是无谓之举。如果你决定写注释，就要花必要的时间确保写出最好的注释。\n Here, for example, is a case I found in FitNesse, where a comment might indeed have been useful. But the author was in a hurry or just not paying much attention. His mumbling left behind an enigma:\n 例如，我在 FitNesse 中找到的这个例子，例中的注释大概确实有用。不过，作者太着急，或者没太花心思。他的喃喃自语变成了一个谜团。\n public void loadProperties() { try { String propertiesPath = propertiesLocation + \u0026#34;/\u0026#34; + PROPERTIES_FILE; FileInputStream propertiesStream = new FileInputStream(propertiesPath); loadedProperties.load(propertiesStream); } catch (IOException e) { // No properties files means all defaults are loaded  } } What does that comment in the catch block mean? Clearly it meant something to the author, but the meaning does not come through all that well. Apparently, if we get an IOException, it means that there was no properties file; and in that case all the defaults are loaded. But who loads all the defaults? Were they loaded before the call to loadProperties.load? Or did loadProperties.load catch the exception, load the defaults, and then pass the exception on for us to ignore? Or did loadProperties.load load all the defaults before attempting to load the file? Was the author trying to comfort himself about the fact that he was leaving the catch block empty? Or—and this is the scary possibility—was the author trying to tell himself to come back here later and write the code that would load the defaults?\n catch 代码块中的注释是什么意思呢？显然对于作者有其意义，不过并没有好到足够的程度。很明显，如果出现 IOException，就表示没有属性文件；在那种情况下，载入默认设置。但谁来装载默认设置呢？会在对 loadProperties.load 之前装载吗？抑或 loadProperties.load 捕获异常、装载默认设置、再向上传递异常？再或 loadProperties.load 在尝试载入文件前就装载所有默认设置？要么作者只是在安慰自己别在意 catch 代码块的留空？\n Our only recourse is to examine the code in other parts of the system to find out what’s going on. Any comment that forces you to look in another module for the meaning of that comment has failed to communicate to you and is not worth the bits it consumes.\n 或者——这种可能最可怕——作者是想告诉自己，将来再回头写装载默认设置的代码？我们唯有检视系统其他部分的代码，弄清事情原委。任何迫使读者查看其他模块的注释，都没能与读者沟通好，不值所费。\n 4.4.2 Redundant Comments 多余的注释 #  Listing 4-1 shows a simple function with a header comment that is completely redundant. The comment probably takes longer to read than the code itself.\n 代码清单 4-1 展示的简单函数，其头部位置的注释全属多余。读这段注释花的时间没准比读代码花的时间还要长。\n Listing 4-1 waitForClose\n 代码清单 4-1 waitForClose\n // Utility method that returns when this.closed is true. Throws an exception // if the timeout is reached. public synchronized void waitForClose(final long timeoutMillis) throws Exception { if (!closed) { wait(timeoutMillis); if (!closed) throw new Exception(\u0026#34;MockResponseSender could not be closed\u0026#34;); } } What purpose does this comment serve? It’s certainly not more informative than the code. It does not justify the code, or provide intent or rationale. It is not easier to read than the code. Indeed, it is less precise than the code and entices the reader to accept that lack of precision in lieu of true understanding. It is rather like a gladhanding used-car salesman assuring you that you don’t need to look under the hood.\n 这段注释起了什么作用？它并不能比代码本身提供更多的信息。它没有证明代码的意义，也没有给出代码的意图或逻辑。读它并不比读代码更容易。事实上，它不如代码精确，误导读者接受不精确的信息，而不是正确地理解代码。它就像个自来熟的二手车贩子，满口保证你不用打开发动机盖查验。来看看代码清单 4-2 中摘自 Tomcat 项目的无用而多余的 Javadoc 吧。\n Now consider the legion of useless and redundant javadocs in Listing 4-2 taken from Tomcat. These comments serve only to clutter and obscure the code. They serve no documentary purpose at all. To make matters worse, I only showed you the first few. There are many more in this module.\n 这些注释只是一味将代码搞得含糊不明。完全没有文档上的价值。下面只列出了靠前面的一些代码，后续模块中还有许多类似情况。\n Listing 4-2 ContainerBase.java (Tomcat)\n 代码清单 4-2 ContainerBase.java （Tomcat）\n public abstract class ContainerBase implements Container, Lifecycle, Pipeline, MBeanRegistration, Serializable { /** * The processor delay for this component. */ protected int backgroundProcessorDelay = -1; /** * The lifecycle event support for this component. */ protected LifecycleSupport lifecycle = new LifecycleSupport(this); /** * The container event listeners for this Container. */ protected ArrayList listeners = new ArrayList(); /** * The Loader implementation with which this Container is * associated. */ protected Loader loader = null; /** * The Logger implementation with which this Container is * associated. */ protected Log logger = null; /** * Associated logger name. */ protected String logName = null; /** * The Manager implementation with which this Container is * associated. */ protected Manager manager = null; /** * The cluster with which this Container is associated. */ protected Cluster cluster = null; /** * The human-readable name of this Container. */ protected String name = null; /** * The parent Container to which this Container is a child. */ protected Container parent = null; /** * The parent class loader to be configured when we install a * Loader. */ protected ClassLoader parentClassLoader = null; /** * The Pipeline object with which this Container is * associated. */ protected Pipeline pipeline = new StandardPipeline(this); /** * The Realm with which this Container is associated. */ protected Realm realm = null; /** * The resources DirContext object with which this Container * is associated. */ protected DirContext resources = null; } 4.4.3 Misleading Comments 误导性注释 #  Sometimes, with all the best intentions, a programmer makes a statement in his comments that isn’t precise enough to be accurate. Consider for another moment the badly redundant but also subtly misleading comment we saw in Listing 4-1.\n 有时，尽管初衷可嘉，程序员还是会写出不够精确的注释。想想看代码清单 4-1 中那多余而又有误导嫌疑的注释吧。\n Did you discover how the comment was misleading? The method does not return when this.closed becomes true. It returns if this.closed is true; otherwise, it waits for a blind time-out and then throws an exception if this.closed is still not true.\n 你有没有发现那样的注释是如何误导读者的？在 this.closed 变为 true 的时候，方法并没有返回。方法只在判断到 this.closed 为 true 的时候返回，否则，就只是等待遥遥无期的超时，然后如果判断 this.closed 还是非 true，就抛出一个异常。\n This subtle bit of misinformation, couched in a comment that is harder to read than the body of the code, could cause another programmer to blithely call this function in the expectation that it will return as soon as this.closed becomes true. That poor programmer would then find himself in a debugging session trying to figure out why his code executed so slowly.\n 这一细微的误导信息，放在比代码本身更难阅读的注释里面，有可能导致其他程序员快活地调用这个函数，并期望在 this.closed 变为 true 时立即返回。那位可怜的程序员将会发现自己陷于调试困境之中，拼命想找出代码执行得如此之慢的原因。\n 4.4.4 Mandated Comments 循规式注释 #  It is just plain silly to have a rule that says that every function must have a javadoc, or every variable must have a comment. Comments like this just clutter up the code, propagate lies, and lend to general confusion and disorganization.\n 所谓每个函数都要有 Javadoc 或每个变量都要有注释的规矩全然是愚蠢可笑的。这类注释徒然让代码变得散乱，满口胡言，令人迷惑不解。\n For example, required javadocs for every function lead to abominations such as Listing 4-3. This clutter adds nothing and serves only to obfuscate the code and create the potential for lies and misdirection.\n 例如，要求每个函数都要有 Javadoc，就会得到类似代码清单 4-3 那样面目可憎的代码。这类废话只会搞乱代码，有可能误导读者。\n Listing 4-3\n 代码清单 4-3\n /** * @param title The title of the CD * @param author The author of the CD * @param tracks The number of tracks on the CD * @param durationInMinutes The duration of the CD in minutes */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = duration; cdList.add(cd); } 4.4.5 Journal Comments 日志式注释 #  Sometimes people add a comment to the start of a module every time they edit it. These comments accumulate as a kind of journal, or log, of every change that has ever been made. I have seen some modules with dozens of pages of these run-on journal entries.\n 有人会在每次编辑代码时，在模块开始处添加一条注释。这类注释就像是一种记录每次修改的日志。我见过满篇尽是这类日志的代码模块。\n * Changes (from 11-Oct-2001) * -------------------------- * 11-Oct-2001 : Re-organised the class and moved it to new package * com.jrefinery.date (DG); * 05-Nov-2001 : Added a getDescription() method, and eliminated NotableDate * class (DG); * 12-Nov-2001 : IBD requires setDescription() method, now that NotableDate * class is gone (DG); Changed getPreviousDayOfWeek(), * getFollowingDayOfWeek() and getNearestDayOfWeek() to correct * bugs (DG); * 05-Dec-2001 : Fixed bug in SpreadsheetDate class (DG); * 29-May-2002 : Moved the month constants into a separate interface * (MonthConstants) (DG); * 27-Aug-2002 : Fixed bug in addMonths() method, thanks to N???levka Petr (DG); * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG); * 13-Mar-2003 : Implemented Serializable (DG); * 29-May-2003 : Fixed bug in addMonths method (DG); * 04-Sep-2003 : Implemented Comparable. Updated the isInRange javadocs (DG); * 05-Jan-2005 : Fixed bug in addYears() method (1096282) (DG); Long ago there was a good reason to create and maintain these log entries at the start of every module. We didn’t have source code control systems that did it for us. Nowadays, however, these long journals are just more clutter to obfuscate the module. They should be completely removed.\n 很久以前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。\n 4.4.6 Noise Comments 废话注释 #  Sometimes you see comments that are nothing but noise. They restate the obvious and provide no new information.\n 有时，你会看到纯然是废话的注释。它们对于显然之事喋喋不休，毫无新意。\n /** * Default constructor. */ protected AnnualDateRule() { } No, really? Or how about this:\n 对吧？再看看这个：\n /** * The day of the month. */ private int dayOfMonth; And then there’s this paragon of redundancy:\n 这样的废话模范：\n /** * Returns the day of the month. * * @return the day of the month. */ public int getDayOfMonth() { return dayOfMonth; } These comments are so noisy that we learn to ignore them. As we read through code, our eyes simply skip over them. Eventually the comments begin to lie as the code around them changes.\n 这类注释废话连篇，我们都学会了视而不见。读代码时，眼光不会停留在它们上面。最终，当代码修改之后，这类注释就变作了谎言一堆。\n The first comment in Listing 4-4 seems appropriate.2 It explains why the catch block is being ignored. But the second comment is pure noise. Apparently the programmer was just so frustrated with writing try/catch blocks in this function that he needed to vent.\n 代码清单 4-4 中的第一条注释貌似还行。它解释了 catch 代码块为何被忽略。不过第二条注释就纯是废话了。显然，该程序员沮丧于编写函数中那些 try/catch 代码块。\n Listing 4-4 startSending\n 代码清单 4-4 startSending\n private void startSending() { try { doSending(); } catch (SocketException e) { // normal. someone stopped the request.  } catch (Exception e) { try { response.add(ErrorResponder.makeExceptionString(e)); response.closeAll(); } catch (Exception e1) { //Give me a break!  } } } Rather than venting in a worthless and noisy comment, the programmer should have recognized that his frustration could be resolved by improving the structure of his code. He should have redirected his energy to extracting that last try/catch block into a separate function, as shown in Listing 4-5.\n 与其纠缠于毫无价值的废话注释，程序员应该意识到，他的挫败感可以由改进代码结构而消除。他应该把力气花在将最末一个 try/catch 代码块拆解到单独的函数中，如代码清单 4-5 所示。\n Listing 4-5 startSending (refactored)\n 代码清单 4-5 startSending（重构之后）\n private void startSending() { try { doSending(); } catch (SocketException e) { // normal. someone stopped the request.  } catch (Exception e) { addExceptionAndCloseResponse(e); } } private void addExceptionAndCloseResponse(Exception e) { try { response.add(ErrorResponder.makeExceptionString(e)); response.closeAll(); } catch (Exception e1) { } } Replace the temptation to create noise with the determination to clean your code. You’ll find it makes you a better and happier programmer.\n 用整理代码的决心替代创造废话的冲动吧。你会发现自己成为更优秀、更快乐的程序员。\n 4.4.7 Scary Noise 可怕的废话 #  Javadocs can also be noisy. What purpose do the following Javadocs (from a well-known open-source library) serve? Answer: nothing. They are just redundant noisy comments written out of some misplaced desire to provide documentation.\n Javadoc 也可能是废话。下列 Javadoc（来自某知名开源库）的目的是什么？答案：无。它们只是源自某种提供文档的不当愿望的废话注释。\n /** The name. */ private String name; /** The version. */ private String version; /** The licenceName. */ private String licenceName; /** The version. */ private String info; Read these comments again more carefully. Do you see the cut-paste error? If authors aren’t paying attention when comments are written (or pasted), why should readers be expected to profit from them?\n 再仔细读读这些注释。你是否发现了剪切-粘贴错误？如果作者在写（或粘贴）注释时都没花心思，怎么能指望读者从中获益呢？\n 4.4.8 Don’t Use a Comment When You Can Use a Function or a Variable 能用函数或变量时就别用注释 #  Consider the following stretch of code:\n 看看以下代码概要：\n // does the module from the global list \u0026lt;mod\u0026gt; depend on the // subsystem we are part of? if (smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) This could be rephrased without the comment as\n 可以改成以下没有注释的版本：\n ArrayList moduleDependees = smodule.getDependSubsystems(); String ourSubSystem = subSysMod.getSubSystem(); if (moduleDependees.contains(ourSubSystem)) The author of the original code may have written the comment first (unlikely) and then written the code to fulfill the comment. However, the author should then have refactored the code, as I did, so that the comment could be removed.\n 代码原作者可能（不太像）是先写注释再编写代码。不过，作者应该重构代码，如我所做的那样，从而删掉注释。\n 4.4.9 Position Markers 位置标记 #  Sometimes programmers like to mark a particular position in a source file. For example, I recently found this in a program I was looking through:\n 有时，程序员喜欢在源代码中标记某个特别位置。例如，最近我在程序中看到这样一行：\n // Actions ////////////////////////////////// There are rare times when it makes sense to gather certain functions together beneath a banner like this. But in general they are clutter that should be eliminated—especially the noisy train of slashes at the end.\n 把特定函数趸放在这种标记栏下面，多数时候实属无理。鸡零狗碎，理当删除——特别是尾部那一长串无用的斜杠。\n Think of it this way. A banner is startling and obvious if you don’t see banners very often. So use them very sparingly, and only when the benefit is significant. If you overuse banners, they’ll fall into the background noise and be ignored.\n 这么说吧。如果标记栏不多，就会显而易见。所以，尽量少用标记栏，只在特别有价值的时候用。如果滥用标记栏，就会沉没在背景噪音中，被忽略掉。\n 4.4.10 Closing Brace Comments 括号后面的注释 #  Sometimes programmers will put special comments on closing braces, as in Listing 4-6. Although this might make sense for long functions with deeply nested structures, it serves only to clutter the kind of small and encapsulated functions that we prefer. So if you find yourself wanting to mark your closing braces, try to shorten your functions instead.\n 有时，程序员会在括号后面放置特殊的注释，如代码清单 4-6 所示。尽管这对于含有深度嵌套结构的长函数可能有意义，但只会给我们更愿意编写的短小、封装的函数带来混乱。如果你发现自己想标记右括号，其实应该做的是缩短函数。\n Listing 4-6 wc.java\n 代码清单 4-6 wc.java\n public class wc { public static void main(String[] args) { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line; int lineCount = 0; int charCount = 0; int wordCount = 0; try { while ((line = in.readLine()) != null) { lineCount++; charCount += line.length(); String words[] = line.split(\u0026#34;\\\\W\u0026#34;); wordCount += words.length; } //while  System.out.println(\u0026#34;wordCount = \u0026#34; + wordCount); System.out.println(\u0026#34;lineCount = \u0026#34; + lineCount); System.out.println(\u0026#34;charCount = \u0026#34; + charCount); } // try  catch (IOException e) { System.err.println(\u0026#34;Error:\u0026#34; + e.getMessage()); } //catch  } //main } 4.4.11 Attributions and Bylines 归属与署名 #  /* Added by Rick */ Source code control systems are very good at remembering who added what, when. There is no need to pollute the code with little bylines. You might think that such comments would be useful in order to help others know who to talk to about the code. But the reality is that they tend to stay around for years and years, getting less and less accurate and relevant.\n 源代码控制系统非常善于记住是谁在何时添加了什么。没必要用那些小小的签名搞脏代码。你也许会认为，这种注释大概有助于他人了解应该和谁讨论这段代码。不过，事实却是注释在那儿放了一年又一年，越来越不准确，越来越和原作者没关系。\n Again, the source code control system is a better place for this kind of information.\n 重申一下，源代码控制系统是这类信息最好的归属地。\n 4.4.12 Commented-Out Code 注释掉的代码 #  Few practices are as odious as commenting-out code. Don’t do this!\n 直接把代码注释掉是讨厌的做法。别这么干！\n InputStreamResponse response = new InputStreamResponse(); response.setBody(formatter.getResultStream(), formatter.getByteCount()); // InputStream resultsStream = formatter.getResultStream(); // StreamReader reader = new StreamReader(resultsStream); // response.setContent(reader.read(formatter.getByteCount())); Others who see that commented-out code won’t have the courage to delete it. They’ll think it is there for a reason and is too important to delete. So commented-out code gathers like dregs at the bottom of a bad bottle of wine.\n 其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除。注释掉的代码堆积在一起，就像破酒瓶底的渣滓一般。\n Consider this from apache commons:\n 看看以下来自 Apache 公共库的代码：\n this.bytePos = writeBytes(pngIdBytes, 0); //hdrPos = bytePos; writeHeader(); writeResolution(); //dataPos = bytePos; if (writeImageData()) { writeEnd(); this.pngBytes = resizeByteArray(this.pngBytes, this.maxPos); } else { this.pngBytes = null; } return this.pngBytes; Why are those two lines of code commented? Are they important? Were they left as reminders for some imminent change? Or are they just cruft that someone commented-out years ago and has simply not bothered to clean up.\n 这两行代码为什么要注释掉？它们重要吗？它们搁在那儿，是为了给未来的修改做提示吗？或者，只是某人在多年以前注释掉、懒得清理的过时玩意？\n There was a time, back in the sixties, when commenting-out code might have been useful. But we’ve had good source code control systems for a very long time now. Those systems will remember the code for us. We don’t have to comment it out any more. Just delete the code. We won’t lose it. Promise.\n 20 世纪 60 年代，曾经有那么一段时间，注释掉的代码可能有用。但我们已经拥有优良的源代码控制系统如此之久，这些系统可以为我们记住不要的代码。我们无需再用注释来标记，删掉即可，它们丢不了。我担保。\n 4.4.13 HTML Comments HTML 注释 #  HTML in source code comments is an abomination, as you can tell by reading the code below. It makes the comments hard to read in the one place where they should be easy to read—the editor/IDE. If comments are going to be extracted by some tool (like Javadoc) to appear in a Web page, then it should be the responsibility of that tool, and not the programmer, to adorn the comments with appropriate HTML.\n 源代码注释中的 HTML 标记是一种厌物，如你在下面代码中所见。编辑器/IDE 中的代码本来易于阅读，却因为 HTML 注释的存在而变得难以卒读。如果注释将由某种工具（例如 Javadoc）抽取出来，呈现到网页，那么该是工具而非程序员来负责给注释加上合适的 HTML 标签。\n /** * Task to run fit tests. * This task runs fitnesse tests and publishes the results. * \u0026lt;p/\u0026gt; * \u0026lt;pre\u0026gt; * Usage: * \u0026amp;lt;taskdef name=\u0026amp;quot;execute-fitnesse-tests\u0026amp;quot; * classname=\u0026amp;quot;fitnesse.ant.ExecuteFitnesseTestsTask\u0026amp;quot; * classpathref=\u0026amp;quot;classpath\u0026amp;quot; /\u0026amp;gt; * OR * \u0026amp;lt;taskdef classpathref=\u0026amp;quot;classpath\u0026amp;quot; * resource=\u0026amp;quot;tasks.properties\u0026amp;quot; /\u0026amp;gt; * \u0026lt;p/\u0026gt; * \u0026amp;lt;execute-fitnesse-tests * suitepage=\u0026amp;quot;FitNesse.SuiteAcceptanceTests\u0026amp;quot; * fitnesseport=\u0026amp;quot;8082\u0026amp;quot; * resultsdir=\u0026amp;quot;${results.dir}\u0026amp;quot; * resultshtmlpage=\u0026amp;quot;fit-results.html\u0026amp;quot; * classpathref=\u0026amp;quot;classpath\u0026amp;quot; /\u0026amp;gt; * \u0026lt;/pre\u0026gt; */ 4.4.14 Nonlocal Information 非本地信息 #  If you must write a comment, then make sure it describes the code it appears near. Don’t offer systemwide information in the context of a local comment. Consider, for example, the javadoc comment below. Aside from the fact that it is horribly redundant, it also offers information about the default port. And yet the function has absolutely no control over what that default is. The comment is not describing the function, but some other, far distant part of the system. Of course there is no guarantee that this comment will be changed when the code containing the default is changed.\n 假如你一定要写注释，请确保它描述了离它最近的代码。别在本地注释的上下文环境中给出系统级的信息。以下面的 Javadoc 注释为例，除了那可怕的冗余之外，它还给出了有关默认端口的信息。不过该函数完全没控制到那个所谓默认值。这个注释并未描述该函数，而是在描述系统中远在他方的其他函数。当然，也无法担保在包含那个默认值的代码修改之后，这里的注释也会跟着修改。\n /** * Port on which fitnesse would run. Defaults to 8082. * * @param fitnessePort */ public void setFitnessePort(int fitnessePort) { this.fitnessePort = fitnessePort; } 4.4.15 Too Much Information 信息过多 #  Don’t put interesting historical discussions or irrelevant descriptions of details into your comments. The comment below was extracted from a module designed to test that a function could encode and decode base64. Other than the RFC number, someone reading this code has no need for the arcane information contained in the comment.\n 别在注释中添加有趣的历史性话题或者无关的细节描述。下列注释来自某个用来测试 base64 编解码函数的模块。除了 RFC 文档编号之外，注释中的其他细节信息对于读者完全没有必要。\n /* RFC 2045 - Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies section 6.8. Base64 Content-Transfer-Encoding The encoding process represents 24-bit groups of input bits as output strings of 4 encoded characters. Proceeding from left to right, a 24-bit input group is formed by concatenating 3 8-bit input groups. These 24 bits are then treated as 4 concatenated 6-bit groups, each of which is translated into a single digit in the base64 alphabet. When encoding a bit stream via the base64 encoding, the bit stream must be presumed to be ordered with the most-significant-bit first. That is, the first bit in the stream will be the high-order bit in the first 8-bit byte, and the eighth bit will be the low-order bit in the first 8-bit byte, and so on. */ 4.4.16 Inobvious Connection 不明显的联系 #  The connection between a comment and the code it describes should be obvious. If you are going to the trouble to write a comment, then at least you’d like the reader to be able to look at the comment and the code and understand what the comment is talking about.\n 注释及其描述的代码之间的联系应该显而易见。如果你不嫌麻烦要写注释，至少让读者能看着注释和代码，并且理解注释所谈何物。\n Consider, for example, this comment drawn from apache commons:\n 以来自 Apache 公共库的这段注释为例：\n /* * start with an array that is big enough to hold all the pixels * (plus filter bytes), and an extra 200 bytes for header info */ this.pngBytes = new byte[((this.width + 1) * this.height * 3) + 200]; What is a filter byte? Does it relate to the +1? Or to the *3? Both? Is a pixel a byte? Why 200? The purpose of a comment is to explain code that does not explain itself. It is a pity when a comment needs its own explanation.\n 过滤器字节是什么？与那个+1 有关系吗？或与*3 有关？还是与两者皆有关？为什么用 200？注释的作用是解释未能自行解释的代码。如果注释本身还需要解释，就太遗憾了。\n 4.4.17 Function Headers 函数头 #  Short functions don’t need much description. A well-chosen name for a small function that does one thing is usually better than a comment header.\n 短函数不需要太多描述。为只做一件事的短函数选个好名字，通常要比写函数头注释要好。\n 4.4.18 Javadocs in Nonpublic Code 非公共代码中的 Javadoc #  As useful as javadocs are for public APIs, they are anathema to code that is not intended for public consumption. Generating javadoc pages for the classes and functions inside a system is not generally useful, and the extra formality of the javadoc comments amounts to little more than cruft and distraction.\n 虽然 Javadoc 对于公共 API 非常有用，但对于不打算作公共用途的代码就令人厌恶了。为系统中的类和函数生成 Javadoc 页并非总有用，而 Javadoc 注释额外的形式要求几乎等同于八股文章。\n 4.4.19 Example 范例 #  I wrote the module in Listing 4-7 for the first XP Immersion. It was intended to be an example of bad coding and commenting style. Kent Beck then refactored this code into a much more pleasant form in front of several dozen enthusiastic students. Later I adapted the example for my book Agile Software Development, Principles, Patterns, and Practices and the first of my Craftsman articles published in Software Development magazine.\n 我曾为首个 XP Immersion 课程编写了代码清单 4-7 列出的模块。这个模块几乎是糟糕的代码和坏注释风格的典范。后来 Kent Beck 当着几十位满腔热情的学生的面重构了这些代码，将其变得令人愉悦。后来，我在拙著 Agile Software Development，Principles，Patterns，and Practices（中译版《敏捷软件开发：原则、模式与实践》）和 Software Development（软件开发）杂志的“技艺”专栏的第一篇文章中引用了这个例子。\n What I find fascinating about this module is that there was a time when many of us would have considered it “well documented.” Now we see it as a small mess. See how many different comment problems you can find.\n 这个模块最迷人的地方是，有那么一阵，我们中的许多人都认为它“文档做得很好”。如今，我们认为它是一小团乱麻。看看你能发现多少个不同的注释问题吧。\n Listing 4-7 GeneratePrimes.java\n 代码清单 4-7 GeneratePrimes.java\n /** * This class Generates prime numbers up to a user specified * maximum. The algorithm used is the Sieve of Eratosthenes. * \u0026lt;p\u0026gt; * Eratosthenes of Cyrene, b. c. 276 BC, Cyrene, Libya -- * d. c. 194, Alexandria. The first man to calculate the * circumference of the Earth. Also known for working on * calendars with leap years and ran the library at Alexandria. * \u0026lt;p\u0026gt; * The algorithm is quite simple. Given an array of integers * starting at 2. Cross out all multiples of 2. Find the next * uncrossed integer, and cross out all of its multiples. * Repeat untilyou have passed the square root of the maximum * value. * * @author Alphonse * @version 13 Feb 2002 atp */ import java.util.*; public class GeneratePrimes { /** * @param maxValue is the generation limit. */ public static int[] generatePrimes(int maxValue) { if (maxValue \u0026gt;= 2) // the only valid case  { // declarations  int s = maxValue + 1; // size of array  boolean[] f = new boolean[s]; int i; // initialize array to true.  for (i = 0; i \u0026lt; s; i++) f[i] = true; // get rid of known non-primes  f[0] = f[1] = false; // sieve  int j; for (i = 2; i \u0026lt; Math.sqrt(s) + 1; i++) { if (f[i]) // if i is uncrossed, cross its multiples.  { for (j = 2 * i; j \u0026lt; s; j += i) f[j] = false; // multiple is not prime  } } // how many primes are there?  int count = 0; for (i = 0; i \u0026lt; s; i++) { if (f[i]) count++; // bump count.  } int[] primes = new int[count]; // move the primes into the result  for (i = 0, j = 0; i \u0026lt; s; i++) { if (f[i]) // if prime  primes[j++] = i; } return primes; // return the primes  } else // maxValue \u0026lt; 2  return new int[0]; // return null array if bad input.  } } In Listing 4-8 you can see a refactored version of the same module. Note that the use of comments is significantly restrained. There are just two comments in the whole module. Both comments are explanatory in nature.\n 在代码清单 4-8 中，你可以看到该模块重构后的版本。注意，注释的使用被明显地限制了。在整个模块中只有两个注释。每个注释都足具说明意义。\n Listing 4-8 PrimeGenerator.java (refactored)\n 代码清单 4-8 PrimeGenerator.java（重构后）\n /** * This class Generates prime numbers up to a user specified * maximum. The algorithm used is the Sieve of Eratosthenes. * Given an array of integers starting at 2: * Find the first uncrossed integer, and cross out all its * multiples. Repeat until there are no more multiples * in the array. */ public class PrimeGenerator { private static boolean[] crossedOut; private static int[] result; public static int[] generatePrimes(int maxValue) { if (maxValue \u0026lt; 2) return new int[0]; else { uncrossIntegersUpTo(maxValue); crossOutMultiples(); putUncrossedIntegersIntoResult(); return result; } } private static void uncrossIntegersUpTo(int maxValue) { crossedOut = new boolean[maxValue + 1]; for (int i = 2; i \u0026lt; crossedOut.length; i++) crossedOut[i] = false; } private static void crossOutMultiples() { int limit = determineIterationLimit(); for (int i = 2; i \u0026lt;= limit; i++) if (notCrossed(i)) crossOutMultiplesOf(i); } private static int determineIterationLimit() { // Every multiple in the array has a prime factor that  // is less than or equal to the root of the array size,  // so we don’t have to cross out multiples of numbers  // larger than that root.  double iterationLimit = Math.sqrt(crossedOut.length); return (int) iterationLimit; } private static void crossOutMultiplesOf(int i) { for (int multiple = 2 * i; multiple \u0026lt; crossedOut.length; multiple += i) crossedOut[multiple] = true; } private static boolean notCrossed(int i) { return crossedOut[i] == false; } private static void putUncrossedIntegersIntoResult() { result = new int[numberOfUncrossedIntegers()]; for (int j = 0, i = 2; i \u0026lt; crossedOut.length; i++) if (notCrossed(i)) result[j++] = i; } private static int numberOfUncrossedIntegers() { int count = 0; for (int i = 2; i \u0026lt; crossedOut.length; i++) if (notCrossed(i)) count++; return count; } } It is easy to argue that the first comment is redundant because it reads very much like the generatePrimes function itself. Still, I think the comment serves to ease the reader into the algorithm, so I’m inclined to leave it.\n 很容易说明，第一个注释完全是多余的，因为它读起来非常像是 generatePrimes 函数自身。不过，我认为这段注释还是省了读者去读具体算法的精力，所以我倾向于留下它。\n The second argument is almost certainly necessary. It explains the rationale behind the use of the square root as the loop limit. I could find no simple variable name, nor any different coding structure that made this point clear. On the other hand, the use of the square root might be a conceit. Am I really saving that much time by limiting the iteration to the square root? Could the calculation of the square root take more time than I’m saving?\n 第二个注释显然很有必要。它解释了平方根作为循环限制的理由。我找不到能说明白这个问题的简单变量名或者其他编程结构。另外，对平方根的使用可能也有点武断。通过限制平方根循环，我是否真节省了许多时间？平方根计算所花的时间会不会比省下的时间还要多？\n It’s worth thinking about. Using the square root as the iteration limit satisfies the old C and assembly language hacker in me, but I’m not convinced it’s worth the time and effort that everyone else will expend to understand it.\n 这些都值得考虑。使用平方根作为循环限制，满足了我这种旧式 C 语言和汇编语言黑客，不过我可不敢说抵得上其他人为理解它而花的时间和精力。\n "});index.add({'id':208,'href':'/docs/Clean-Code/5.-Formatting/ch5/','title':"Ch5",'section':"Go语言圣经",'content':"第 5 章 Formatting 格式 #   When people look under the hood, we want them to be impressed with the neatness, consistency, and attention to detail that they perceive. We want them to be struck by the orderliness. We want their eyebrows to rise as they scroll through the modules. We want them to perceive that professionals have been at work. If instead they see a scrambled mass of code that looks like it was written by a bevy of drunken sailors, then they are likely to conclude that the same inattention to detail pervades every other aspect of the project.\n 当有人查看底层代码实现时，我们希望他们为其整洁、一致及所感知到的对细节的关注而震惊。我们希望他们高高扬起眉毛，一路看下去。我们希望他们感受到那些为之劳作的专业人士们。但若他们看到的只是一堆像是由酒醉的水手写出的鬼画符，那他们多半会得出结论，认为项目其他任何部分也同样对细节漠不关心。\n You should take care that your code is nicely formatted. You should choose a set of simple rules that govern the format of your code, and then you should consistently apply those rules. If you are working on a team, then the team should agree to a single set of formatting rules and all members should comply. It helps to have an automated tool that can apply those formatting rules for you.\n 你应该保持良好的代码格式。你应该选用一套管理代码格式的简单规则，然后贯彻这些规则。如果你在团队中工作，则团队应该一致同意采用一套简单的格式规则，所有成员都要遵从。使用能帮你应用这些格式规则的自动化工具会很有帮助。\n 5.1 THE PURPOSE OF FORMATTING 格式的目的 #  First of all, let’s be clear. Code formatting is important. It is too important to ignore and it is too important to treat religiously. Code formatting is about communication, and communication is the professional developer’s first order of business.\n 先明确一下，代码格式很重要。代码格式不可忽略，必须严肃对待。代码格式关乎沟通，而沟通是专业开发者的头等大事。\n Perhaps you thought that “getting it working” was the first order of business for a professional developer. I hope by now, however, that this book has disabused you of that idea. The functionality that you create today has a good chance of changing in the next release, but the readability of your code will have a profound effect on all the changes that will ever be made. The coding style and readability set precedents that continue to affect maintainability and extensibility long after the original code has been changed beyond recognition. Your style and discipline survives, even though your code does not.\n 或许你认为“让代码能工作”才是专业开发者的头等大事。然而，我希望本书能让你抛掉那种想法。你今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。原始代码修改之后很久，其代码风格和可读性仍会影响到可维护性和扩展性。即便代码已不复存在，你的风格和律条仍存活下来。\n So what are the formatting issues that help us to communicate best?\n 那么，哪些代码格式相关方面能帮我们最好地沟通呢？\n 5.2 VERTICAL FORMATTING 垂直格式 #  Let’s start with vertical size. How big should a source file be? In Java, file size is closely related to class size. We’ll talk about class size when we talk about classes. For the moment let’s just consider file size.\n 从垂直尺寸开始吧。源代码文件该有多大？在 Java 中，文件尺寸与类尺寸极其相关。讨论类时再说类的尺寸。现在先考虑文件尺寸。\n How big are most Java source files? It turns out that there is a huge range of sizes and some remarkable differences in style. Figure 5-1 shows some of those differences.\n 多数 Java 源代码文件有多大？事实说明，尺寸各各不同，长度殊异，如图 5-1 所示。\n Seven different projects are depicted. Junit, FitNesse, testNG, Time and Money, JDepend, Ant, and Tomcat. The lines through the boxes show the minimum and maximum file lengths in each project. The box shows approximately one-third (one standard deviation1) of the files. The middle of the box is the mean. So the average file size in the FitNesse project is about 65 lines, and about one-third of the files are between 40 and 100+ lines. The largest file in FitNesse is about 400 lines and the smallest is 6 lines. Note that this is a log scale, so the small difference in vertical position implies a very large difference in absolute size.\n 图 5-1 中涉及 7 个不同项目：Junit、FitNesse、testNG、Time and Money、JDepend、Ant 和 Tomcat。贯穿方块的直线两端显示这些项目中最小和最大的文件长度。方块表示在平均值以上或以下的大约三分之一文件（一个标准偏差）的长度。方块中间位置就是平均数。所以 FitNesse 项目的文件平均尺寸是 65 行，而上面三分之一在 40 ～ 100 行及 100 行以上之间。FitNesse 中最大的文件大约 400 行，最小是 6 行。这是个对数标尺，所以较小的垂直位置差异意味着文件绝对尺寸的较大差异。\n Figure 5-1 File length distributions LOG scale (box height = sigma)\n Junit, FitNesse, and Time and Money are composed of relatively small files. None are over 500 lines and most of those files are less than 200 lines. Tomcat and Ant, on the other hand, have some files that are several thousand lines long and close to half are over 200 lines.\n Junit、FitNesse 和 Time and Money 由相对较小的文件组成。没有一个超过 500 行，多数都小于 200 行。Tomcat 和 Ant 则有些文件达到数千行，将近一半文件长于 200 行。\n What does that mean to us? It appears to be possible to build significant systems (FitNesse is close to 50,000 lines) out of files that are typically 200 lines long, with an upper limit of 500. Although this should not be a hard and fast rule, it should be considered very desirable. Small files are usually easier to understand than large files are.\n 对我们来说，这意味着什么？意味着有可能用大多数为 200 行、最长 500 行的单个文件构造出色的系统（FitNesse 总长约 50000 行）。尽管这并非不可违背的原则，也应该乐于接受。短文件通常比长文件易于理解。\n 5.2.1 The Newspaper Metaphor 向报纸学习 #  Think of a well-written newspaper article. You read it vertically. At the top you expect a headline that will tell you what the story is about and allows you to decide whether it is something you want to read. The first paragraph gives you a synopsis of the whole story, hiding all the details while giving you the broad-brush concepts. As you continue downward, the details increase until you have all the dates, names, quotes, claims, and other minutia.\n 想想看写得很好的报纸文章。你从上到下阅读。在顶部，你期望有个头条，告诉你故事主题，好让你决定是否要读下去。第一段是整个故事的大纲，给出粗线条概述，但隐藏了故事细节。接着读下去，细节渐次增加，直至你了解所有的日期、名字、引语、说法及其他细节。\n We would like a source file to be like a newspaper article. The name should be simple but explanatory. The name, by itself, should be sufficient to tell us whether we are in the right module or not. The topmost parts of the source file should provide the high-level concepts and algorithms. Detail should increase as we move downward, until at the end we find the lowest level functions and details in the source file.\n 源文件也要像报纸文章那样。名称应当简单且一目了然。名称本身应该足够告诉我们是否在正确的模块中。源文件最顶部应该给出高层次概念和算法。细节应该往下渐次展开，直至找到源文件中最底层的函数和细节。\n A newspaper is composed of many articles; most are very small. Some are a bit larger. Very few contain as much text as a page can hold. This makes the newspaper usable. If the newspaper were just one long story containing a disorganized agglomeration of facts, dates, and names, then we simply would not read it.\n 报纸由许多篇文章组成；多数短小精悍。有些稍微长点儿。很少有占满一整页的。这样做，报纸才可用。假若一份报纸只登载一篇长故事，其中充斥毫无组织的事实、日期、名字等，没人会去读它。\n 5.2.2 Vertical Openness Between Concepts 概念间垂直方向上的区隔 #  Nearly all code is read left to right and top to bottom. Each line represents an expression or a clause, and each group of lines represents a complete thought. Those thoughts should be separated from each other with blank lines.\n 几乎所有的代码都是从上往下读，从左往右读。每行展现一个表达式或一个子句，每组代码行展示一条完整的思路。这些思路用空白行区隔开来。\n Consider, for example, Listing 5-1. There are blank lines that separate the package declaration, the import(s), and each of the functions. This extremely simple rule has a profound effect on the visual layout of the code. Each blank line is a visual cue that identifies a new and separate concept. As you scan down the listing, your eye is drawn to the first line that follows a blank line.\n 以代码清单 5-1 为例。在封包声明、导入声明和每个函数之间，都有空白行隔开。这条极其简单的规则极大地影响到代码的视觉外观。每个空白行都是一条线索，标识出新的独立概念。往下读代码时，你的目光总会停留于空白行之后那一行。\n Listing 5-1 BoldWidget.java\n 代码清单 5-1 BoldWidget.java\n package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026#34;’’’.+?’’’\u0026#34;; private static final Pattern pattern = Pattern.compile(\u0026#34;’’’(.+?)’’’\u0026#34;, Pattern.MULTILINE + Pattern.DOTALL ); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026#34;\u0026lt;b\u0026gt;\u0026#34;); html.append(childHtml()).append(\u0026#34;\u0026lt;/b\u0026gt;\u0026#34;); return html.toString(); } } Taking those blank lines out, as in Listing 5-2, has a remarkably obscuring effect on the readability of the code.\n 如代码清单 5-2 所示，抽掉这些空白行，代码可读性减弱了不少。\n Listing 5-2 BoldWidget.java\n 代码清单 5-2 BoldWidget.java\n package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026#34;’’’.+?’’’\u0026#34;; private static final Pattern pattern = Pattern.compile(\u0026#34;’’’(.+?)’’’\u0026#34;, Pattern.MULTILINE + Pattern.DOTALL); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026#34;\u0026lt;b\u0026gt;\u0026#34;); html.append(childHtml()).append(\u0026#34;\u0026lt;/b\u0026gt;\u0026#34;); return html.toString(); } } This effect is even more pronounced when you unfocus your eyes. In the first example the different groupings of lines pop out at you, whereas the second example looks like a muddle. The difference between these two listings is a bit of vertical openness.\n 在你不特意注视时，后果就更严重了。在第一个例子中，代码组会跳到你眼中，而第二个例子就像一堆乱麻。两段代码的区别，展示了垂直方向上区隔的作用。\n 5.2.3 Vertical Density 垂直方向上的靠近 #  If openness separates concepts, then vertical density implies close association. So lines of code that are tightly related should appear vertically dense. Notice how the useless comments in Listing 5-3 break the close association of the two instance variables.\n 如果说空白行隔开了概念，靠近的代码行则暗示了它们之间的紧密关系。所以，紧密相关的代码应该互相靠近。注意代码清单 5-3 中的注释是如何割断两个实体变量间的联系的。\n Listing 5-3\n 代码清单 5-3\n public class ReporterConfig { /** * The class name of the reporter listener */ private String m_className; /** * The properties of the reporter listener */ private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); } } Listing 5-4 is much easier to read. It fits in an “eye-full,” or at least it does for me. I can look at it and see that this is a class with two variables and a method, without having to move my head or eyes much. The previous listing forces me to use much more eye and head motion to achieve the same level of comprehension.\n 代码清单 5-4 更易于阅读。它刚好“一览无遗”，至少对我来说是这样。我一眼就能看到，这是个有两个变量和一个方法的类。看上面的代码时，我不得不更多地移动头部和眼球，才能获得相同的理解度。\n Listing 5-4\n 代码清单 5-4\n public class ReporterConfig { private String m_className; private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); } } 5.2.4 Vertical Distance 垂直距离 #  Have you ever chased your tail through a class, hopping from one function to the next, scrolling up and down the source file, trying to divine how the functions relate and operate, only to get lost in a rat’s nest of confusion? Have you ever hunted up the chain of inheritance for the definition of a variable or function? This is frustrating because you are trying to understand what the system does, but you are spending your time and mental energy on trying to locate and remember where the pieces are.\n 你是否曾经在某个类中摸索，从一个函数跳到另一个函数，上下求索，想要弄清楚这些函数如何操作、如何互相相关，最后却被搞糊涂了？你是否曾经苦苦追索某个变量或函数的继承链条？这让人沮丧，因为你想要理解系统做什么，但却花时间和精力在找到和记住那些代码碎片在哪里。\n Concepts that are closely related should be kept vertically close to each other [G10]. Clearly this rule doesn’t work for concepts that belong in separate files. But then closely related concepts should not be separated into different files unless you have a very good reason. Indeed, this is one of the reasons that protected variables should be avoided.\n 关系密切的概念应该互相靠近[G10]。显然，这条规则并不适用于分布在不同文件中的概念。除非有很好的理由，否则就不要把关系密切的概念放到不同的文件中。实际上，这也是避免使用 protected 变量的理由之一。\n For those concepts that are so closely related that they belong in the same source file, their vertical separation should be a measure of how important each is to the understandability of the other. We want to avoid forcing our readers to hop around through our source files and classes.\n 对于那些关系密切、放置于同一源文件中的概念，它们之间的区隔应该成为对相互的易懂度有多重要的衡量标准。应避免迫使读者在源文件和类中跳来跳去。\n Variable Declarations. Variables should be declared as close to their usage as possible. Because our functions are very short, local variables should appear a the top of each function, as in this longish function from Junit4.3.1.\n 变量声明。变量声明应尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现，就像 Junit4.3.1 中这个稍长的函数中那样。\n private static void readPreferences() { InputStream is = null; try { is = new FileInputStream(getPreferencesFile()); setPreferences(new Properties(getPreferences())); getPreferences().load(is); } catch (IOException e) { try { if (is != null) is.close(); } catch (IOException e1) { } } } Control variables for loops should usually be declared within the loop statement, as in this cute little function from the same source.\n 对于那些关系密切、放置于同一源文件中的概念，它们之间的区隔应该成为对相互的易懂度有多重要的衡量标准。应避免迫使读者在源文件和类中跳来跳去。\n public int countTestCases() { int count = 0; for (Test each : tests) count += each.countTestCases(); return count; } In rare cases a variable might be declared at the top of a block or just before a loop in a long-ish function. You can see such a variable in this snippet from the midst of a very long function in TestNG.\n 偶尔，在较长的函数中，变量也可能在某个代码块顶部，或在循环之前声明。你可以在以下摘自 TestNG 中一个长函数的代码片段中找到类似的变量。\n … for (XmlTest test : m_suite.getTests()) { TestRunner tr = m_runnerFactory.newTestRunner(this, test); tr.addListener(m_textReporter); m_testRunners.add(tr); invoker = tr.getInvoker(); for (ITestNGMethod m : tr.getBeforeSuiteMethods()) { beforeSuiteMethods.put(m.getMethod(), m); } for (ITestNGMethod m : tr.getAfterSuiteMethods()) { afterSuiteMethods.put(m.getMethod(), m); } } … Instance variables, on the other hand, should be declared at the top of the class. This should not increase the vertical distance of these variables, because in a well-designed class, they are used by many, if not all, of the methods of the class.\n 实体变量应该在类的顶部声明。这应该不会增加变量的垂直距离，因为在设计良好的类中，它们如果不是被该类的所有方法也是被大多数方法所用。\n There have been many debates over where instance variables should go. In C++ we commonly practiced the so-called scissors rule, which put all the instance variables at the bottom. The common convention in Java, however, is to put them all at the top of the class. I see no reason to follow any other convention. The important thing is for the instance variables to be declared in one well-known place. Everybody should know where to go to see the declarations.\n 关于实体变量应该放在哪里，争论不断。在 C++中，通常会采用所谓“剪刀原则”（scissors rule），所有实体变量都放在底部。而在 Java 中，惯例是放在类的顶部。没理由去遵循其他惯例。重点是在谁都知道的地方声明实体变量。大家都应该知道在哪儿能看到这些声明。\n Consider, for example, the strange case of the TestSuite class in JUnit 4.3.1. I have greatly attenuated this class to make the point. If you look about halfway down the listing, you will see two instance variables declared there. It would be hard to hide them in a better place. Someone reading this code would have to stumble across the declarations by accident (as I did).\n 例如 JUnit 4.3.1 中的这个奇怪情形。我极力删减了这个类，好说明问题。如果你看到代码清单大致一半的位置，会看到在那里声明了两个实体变量。如果放在更好的位置，它们就会更明显。而现在，读代码者只能在无意中看到这些声明（就像我一样）。\n public class TestSuite implements Test { static public Test createTest(Class\u0026lt;? extends TestCase\u0026gt; theClass, String name) { … } public static Constructor\u0026lt;? extends TestCase\u0026gt; getTestConstructor(Class\u0026lt;? extends TestCase\u0026gt; theClass) throws NoSuchMethodException { … } public static Test warning(final String message) { … } private static String exceptionToString(Throwable t) { … } private String fName; private Vector\u0026lt;Test\u0026gt; fTests = new Vector\u0026lt;Test\u0026gt;(10); public TestSuite() { } public TestSuite(final Class\u0026lt;? extends TestCase\u0026gt; theClass) { … } public TestSuite(Class\u0026lt;? extends TestCase\u0026gt; theClass, String name) { … } … … … … … } Dependent Functions. If one function calls another, they should be vertically close, and the caller should be above the callee, if at all possible. This gives the program a natural flow. If the convention is followed reliably, readers will be able to trust that function definitions will follow shortly after their use. Consider, for example, the snippet from FitNesse in Listing 5-5. Notice how the topmost function calls those below it and how they in turn call those below them. This makes it easy to find the called functions and greatly enhances the readability of the whole module.\n 相关函数。若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。这样，程序就有个自然的顺序。若坚定地遵循这条约定，读者将能够确信函数声明总会在其调用后很快出现。以源自 FitNesse 的代码清单 5-5 为例。注意顶部的函数是如何调用其下的函数，而这些被调用的函数又是如何调用更下面的函数的。这样就能轻易找到被调用的函数，极大地增强了整个模块的可读性。\n Listing 5-5 WikiPageResponder.java\n 代码清单 5-5 WikiPageResponder.java\n public class WikiPageResponder implements SecureResponder { protected WikiPage page; protected PageData pageData; protected String pageTitle; protected Request request; protected PageCrawler crawler; public Response makeResponse(FitNesseContext context, Request request) throws Exception { String pageName = getPageNameOrDefault(request, “FrontPage”); loadPage(pageName, context); if (page == null) return notFoundResponse(context, request); else return makePageResponse(context); } private String getPageNameOrDefault(Request request, String defaultPageName) { String pageName = request.getResource(); if (StringUtil.isBlank(pageName)) pageName = defaultPageName; return pageName; } protected void loadPage(String resource, FitNesseContext context) throws Exception { WikiPagePath path = PathParser.parse(resource); crawler = context.root.getPageCrawler(); crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler()); page = crawler.getPage(context.root, path); if (page != null) pageData = page.getData(); } private Response notFoundResponse(FitNesseContext context, Request request) throws Exception { return new NotFoundResponder().makeResponse(context, request); } private SimpleResponse makePageResponse(FitNesseContext context) throws Exception { pageTitle = PathParser.render(crawler.getFullPath(page)); String html = makeHtml(context); SimpleResponse response = new SimpleResponse(); response.setMaxAge(0); response.setContent(html); return response; } } As an aside, this snippet provides a nice example of keeping constants at the appropriate level [G35]. The “FrontPage” constant could have been buried in the getPageNameOrDefault function, but that would have hidden a well-known and expected constant in an inappropriately low-level function. It was better to pass that constant down from the place where it makes sense to know it to the place that actually uses it.\n 说句题外话，以上代码片段也是把常量保持在恰当级别的好例子[G35]。FrontPage 常量可以埋在 getPageNameOrDefault 函数中，但那样就会把一个众人皆知的常量埋藏到位于不太合适的底层函数中。更好的做法是把它放在易于找到的位置，然后再传递到真实使用的位置。\n Conceptual Affinity. Certain bits of code want to be near other bits. They have a certain conceptual affinity. The stronger that affinity, the less vertical distance there should be between them.\n 概念相关。概念相关的代码应该放到一起。相关性越强，彼此之间的距离就该越短。\n As we have seen, this affinity might be based on a direct dependence, such as one function calling another, or a function using a variable. But there are other possible causes of affinity. Affinity might be caused because a group of functions perform a similar operation. Consider this snippet of code from Junit 4.3.1:\n 如上所述，相关性应建立在直接依赖的基础上，如函数间调用，或函数使用某个变量。但也有其他相关性的可能。相关性可能来自于执行相似操作的一组函数。请看以下来自 Junit 4.3.1 的代码片段：\n  public class Assert { static public void assertTrue(String message, boolean condition) { if (!condition) fail(message); } static public void assertTrue(boolean condition) { assertTrue(null, condition); } static public void assertFalse(String message, boolean condition) { assertTrue(message, !condition); } static public void assertFalse(boolean condition) { assertFalse(null, condition); } } These functions have a strong conceptual affinity because they share a common naming scheme and perform variations of the same basic task. The fact that they call each other is secondary. Even if they didn’t, they would still want to be close together.\n这些函数有着极强的概念相关性，因为他们拥有共同的命名模式，执行同一基础任务的不同变种。互相调用是第二位的。即便没有互相调用，也应该放在一起。\n5.2.5 Vertical Ordering 垂直顺序 #  In general we want function call dependencies to point in the downward direction. That is, a function that is called should be below a function that does the calling.2 This creates a nice flow down the source code module from high level to low level.\n 一般而言，我们想自上向下展示函数调用依赖顺序。也就是说，被调用的函数应该放在执行调用的函数下面。这样就建立了一种自顶向下贯穿源代码模块的良好信息流。\n As in newspaper articles, we expect the most important concepts to come first, and we expect them to be expressed with the least amount of polluting detail. We expect the low-level details to come last. This allows us to skim source files, getting the gist from the first few functions, without having to immerse ourselves in the details. Listing 5-5 is organized this way. Perhaps even better examples are Listing 15-5 on page 263, and Listing 3-7 on page 50.\n 像报纸文章一般，我们指望最重要的概念先出来，指望以包括最少细节的方式表述它们。我们指望底层细节最后出来。这样，我们就能扫过源代码文件，自最前面的几个函数获知要旨，而不至于沉溺到细节中。代码清单 5-5 就是如此组织的。或许，更好的例子是代码清单 15-5，及代码清单 3-7。\n 5.3 HORIZONTAL FORMATTING 横向格式 #  How wide should a line be? To answer that, let’s look at how wide lines are in typical programs. Again, we examine the seven different projects. Figure 5-2 shows the distribution of line lengths of all seven projects. The regularity is impressive, especially right around 45 characters. Indeed, every size from 20 to 60 represents about 1 percent of the total number of lines. That’s 40 percent! Perhaps another 30 percent are less than 10 characters wide. Remember this is a log scale, so the linear appearance of the drop-off above 80 characters is really very significant. Programmers clearly prefer short lines.\n 一行代码应该有多宽？要回答这个问题，来看看典型的程序中代码行的宽度。我们再一次检验 7 个不同项目。图 5-2 展示了这 7 个项目的代码行宽度分布情况。其中展现的规律性令人印象深刻，45 个字符左右的宽度分布尤为如此。其实，20 ～ 60 的每个尺寸，都代表全部代码行数的 1%。也就是总共 40%！或许其余 30%的代码行短于 10 个字符。记住，这是个对数标尺，所以图中长于 80 个字符部分的线性下降在实际情况中会极其可观。程序员们显然更喜爱短代码行。\n Figure 5-2 Java line width distribution\n This suggests that we should strive to keep our lines short. The old Hollerith limit of 80 is a bit arbitrary, and I’m not opposed to lines edging out to 100 or even 120. But beyond that is probably just careless.\n 这说明，应该尽力保持代码行短小。死守 80 个字符的上限有点僵化，而且我也并不反对代码行长度达到 100 个字符或 120 个字符。再多的话，大抵就是肆意妄为了。\n I used to follow the rule that you should never have to scroll to the right. But monitors are too wide for that nowadays, and younger programmers can shrink the font so small that they can get 200 characters across the screen. Don’t do that. I personally set my limit at 120.\n 我一向遵循无需拖动滚动条到右边的原则。但近年来显示器越来越宽，而年轻程序员又能将显示字符缩小到如此程度，屏幕上甚至能容纳 200 个字符的宽度。别那么做。我个人的上限是 120 个字符。\n 5.3.1 Horizontal Openness and Density 水平方向上的区隔与靠近 #  We use horizontal white space to associate things that are strongly related and disassociate things that are more weakly related. Consider the following function:\n 我们使用空格字符将彼此紧密相关的事物连接到一起，也用空格字符把相关性较弱的事物分隔开。请看以下函数：\n private void measureLine(String line) { lineCount++; int lineSize = line.length(); totalChars += lineSize; lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); } I surrounded the assignment operators with white space to accentuate them. Assignment statements have two distinct and major elements: the left side and the right side. The spaces make that separation obvious.\n 我在赋值操作符周围加上空格字符，以此达到强调目的。赋值语句有两个确定而重要的要素：左边和右边。空格字符加强了分隔效果。\n On the other hand, I didn’t put spaces between the function names and the opening parenthesis. This is because the function and its arguments are closely related. Separating them makes them appear disjoined instead of conjoined. I separate arguments within the function call parenthesis to accentuate the comma and show that the arguments are separate.\n 另一方面，我不在函数名和左圆括号之间加空格。这是因为函数与其参数密切相关，如果隔开，就会显得互无关系。我把函数调用括号中的参数一一隔开，强调逗号，表示参数是互相分离的。\n Another use for white space is to accentuate the precedence of operators.\n 空格字符的另一种用法是强调其前面的运算符。\n public class Quadratic { public static double root1(double a, double b, double c) { double determinant = determinant(a, b, c); return (-b + Math.sqrt(determinant)) / (2 * a); } public static double root2(int a, int b, int c) { double determinant = determinant(a, b, c); return (-b - Math.sqrt(determinant)) / (2 * a); } private static double determinant(double a, double b, double c) { return b * b - 4 * a * c; } } Notice how nicely the equations read. The factors have no white space between them because they are high precedence. The terms are separated by white space because addition and subtraction are lower precedence.\n 看看这些等式读起来多舒服。乘法因子之间没加空格，因为它们具有较高优先级。加减法运算项之间用空格隔开，因为加法和减法优先级较低。\n Unfortunately, most tools for reformatting code are blind to the precedence of operators and impose the same spacing throughout. So subtle spacings like those shown above tend to get lost after you reformat the code.\n 不幸的是，多数代码格式化工具都会漠视运算符优先级，从头到尾采用同样的空格方式。在重新格式化代码后，以上这些微妙的空格用法就消失殆尽了。\n 5.3.2 Horizontal Alignment 水平对齐 #  When I was an assembly language programmer,3 I used horizontal alignment to accentuate certain structures. When I started coding in C, C++, and eventually Java, I continued to try to line up all the variable names in a set of declarations, or all the rvalues in a set of assignment statements. My code might have looked like this:\n 当我还是个汇编语言程序员时，使用水平对齐来强调某些程序结构。开始用 C、C++编码，最终转向 Java 后，我继续尽力对齐一组声明中的变量名，或一组赋值语句中的右值。我的代码看起来大概是这样：\n public class FitNesseExpediter implements ResponseSender { private Socket socket; private InputStream input; private OutputStream output; private Request request; private Response response; private FitNesseContext context; protected long requestParsingTimeLimit; private long requestProgress; private long requestParsingDeadline; private boolean hasError; public FitNesseExpediter(Socket s, FitNesseContext context) throws Exception { this.context = context; socket = s; input = s.getInputStream(); output = s.getOutputStream(); requestParsingTimeLimit = 10000; } I have found, however, that this kind of alignment is not useful. The alignment seems to emphasize the wrong things and leads my eye away from the true intent. For example, in the list of declarations above you are tempted to read down the list of variable names without looking at their types. Likewise, in the list of assignment statements you are tempted to look down the list of rvalues without ever seeing the assignment operator. To make matters worse, automatic reformatting tools usually eliminate this kind of alignment.\n 我发现这种对齐方式没什么用。对齐，像是在强调不重要的东西，把我的目光从真正的意义上拉开。例如，在上面的声明列表中，你会从上到下阅读变量名，而忽视了它们的类型。同样，在赋值语句代码清单中，你也会从上到下阅读右值，而对赋值运算符视而不见。更麻烦的是，代码自动格式化工具通常会把这类对齐消除掉。\n So, in the end, I don’t do this kind of thing anymore. Nowadays I prefer unaligned declarations and assignments, as shown below, because they point out an important deficiency. If I have long lists that need to be aligned, the problem is the length of the lists, not the lack of alignment. The length of the list of declarations in FitNesseExpediter below suggests that this class should be split up.\n 所以，我最终放弃了这种做法。如今，我更喜欢用不对齐的声明和赋值，如下所示，因为它们指出了重点。如果有较长的列表需要做对齐处理，那问题就是在列表的长度上而不是对齐上。下例 FitNesseExpediter 类中声明列表的长度说明该类应该被拆分了。\n public class FitNesseExpediter implements ResponseSender { private Socket socket; private InputStream input; private OutputStream output; private Request request; private Response response; private FitNesseContext context; protected long requestParsingTimeLimit; private long requestProgress; private long requestParsingDeadline; private boolean hasError; public FitNesseExpediter(Socket s, FitNesseContext context) throws Exception { this.context = context; socket = s; input = s.getInputStream(); output = s.getOutputStream(); requestParsingTimeLimit = 10000; } } 5.3.3 Indentation 缩进 #  A source file is a hierarchy rather like an outline. There is information that pertains to the file as a whole, to the individual classes within the file, to the methods within the classes, to the blocks within the methods, and recursively to the blocks within the blocks. Each level of this hierarchy is a scope into which names can be declared and in which declarations and executable statements are interpreted.\n 源文件是一种继承结构，而不是一种大纲结构。其中的信息涉及整个文件、文件中每个类、类中的方法、方法中的代码块，也涉及代码块中的代码块。这种继承结构中的每一层级都圈出一个范围，名称可以在其中声明，而声明和执行语句也可以在其中解释。\n To make this hierarchy of scopes visible, we indent the lines of source code in proportion to their position in the hiearchy. Statements at the level of the file, such as most class declarations, are not indented at all. Methods within a class are indented one level to the right of the class. Implementations of those methods are implemented one level to the right of the method declaration. Block implementations are implemented one level to the right of their containing block, and so on.\n 要让这种范围式继承结构可见，我们依源代码行在继承结构中的位置对源代码行做缩进处理。在文件顶层的语句，例如大多数的类声明，根本不缩进。类中的方法相对该类缩进一个层级。方法的实现相对方法声明缩进一个层级。代码块的实现相对于其容器代码块缩进一个层级，以此类推。\n Programmers rely heavily on this indentation scheme. They visually line up lines on the left to see what scope they appear in. This allows them to quickly hop over scopes, such as implementations of if or while statements, that are not relevant to their current situation. They scan the left for new method declarations, new variables, and even new classes. Without indentation, programs would be virtually unreadable by humans.\n 程序员相当依赖这种缩进模式。他们从代码行左边查看自己在什么范围中工作。这让他们能快速跳过与当前关注的情形无关的范围，例如 if 或 while 语句的实现之类。他们的眼光扫过左边，查找新的方法声明、新变量，甚至新类。没有缩进的话，程序就会变得无法阅读。\n Consider the following programs that are syntactically and semantically identical:\n 试看以下在语法和语义上等价的两个程序：\n public class FitNesseServer implements SocketServer { private FitNesseContext context; public FitNesseServer(FitNesseContext context) { this.context = context; } public void serve(Socket s) { serve(s, 10000); } public void serve(Socket s, long requestTimeout) { try { FitNesseExpediter sender = new FitNesseExpediter(s, context); sender.setRequestParsingTimeLimit(requestTimeout); sender.start(); } catch(Exception e) { e.printStackTrace(); } } } ----- public class FitNesseServer implements SocketServer { private FitNesseContext context; public FitNesseServer(FitNesseContext context) { this.context = context; } public void serve(Socket s) { serve(s, 10000); } public void serve(Socket s, long requestTimeout) { try { FitNesseExpediter sender = new FitNesseExpediter(s, context); sender.setRequestParsingTimeLimit(requestTimeout); sender.start(); } catch (Exception e) { e.printStackTrace(); } } } Your eye can rapidly discern the structure of the indented file. You can almost instantly spot the variables, constructors, accessors, and methods. It takes just a few seconds to realize that this is some kind of simple front end to a socket, with a time-out. The unindented version, however, is virtually impenetrable without intense study.\n 你能很快地洞悉有缩进的那个文件的结构。你几乎能立即就辨别出那些变量、构造器、存取器和方法。只需要几秒钟就能了解这是一个套接字的简单前端，其中包括了超时设定。而未缩进的版本则不经过一番折腾就无法明白。\n Breaking Indentation. It is sometimes tempting to break the indentation rule for short if statements, short while loops, or short functions. Whenever I have succumbed to this temptation, I have almost always gone back and put the indentation back in. So I avoid collapsing scopes down to one line like this:\n 违反缩进规则。有时，会忍不住想要在短小的 if 语句、while 循环或小函数中违反缩进规则。一旦这么做了，我多数时候还是会回头加上缩进。这样就避免了出现以下这种范围层级坍塌到一行的情况：\n public class CommentWidget extends TextWidget { public static final String REGEXP = \u0026#34;^#[^\\r\\n]*(?:(?:\\r\\n)|\\n|\\r)?\u0026#34;; public CommentWidget(ParentWidget parent, String text) { super(parent, text); } public String render() throws Exception { return \u0026#34;\u0026#34;; } } I prefer to expand and indent the scopes instead, like this:\n 我更喜欢扩展和缩进范围，就像这样：\n public class CommentWidget extends TextWidget { public static final String REGEXP = \u0026#34;^#[^\\r\\n]*(?:(?:\\r\\n)|\\n|\\r)?\u0026#34;; public CommentWidget(ParentWidget parent, String text) { super(parent, text); } public String render() throws Exception { return \u0026#34;\u0026#34;; } } 5.3.4 Dummy Scopes 空范围 #  Sometimes the body of a while or for statement is a dummy, as shown below. I don’t like these kinds of structures and try to avoid them. When I can’t avoid them, I make sure that the dummy body is properly indented and surrounded by braces. I can’t tell you how many times I’ve been fooled by a semicolon silently sitting at the end of a while loop on the same line. Unless you make that semicolon visible by indenting it on it’s own line, it’s just too hard to see.\n 有时，while 或 for 语句的语句体为空，如下所示。我不喜欢这种结构，尽量不使用。如果无法避免，就确保空范围体的缩进，用括号包围起来。我无法告诉你，我曾经多少次被静静安坐在与 while 循环语句同一行末尾的分号所欺骗。除非你把那个分号放到另一行再加以缩进，否则就很难看到它。\n while (dis.read(buf, 0, readBufferSize) != -1) ; 5.4 TEAM RULES 团队规则 #  The title of this section is a play on words. Every programmer has his own favorite formatting rules, but if he works in a team, then the team rules.\n 每个程序员都有自己喜欢的格式规则，但如果在一个团队中工作，就是团队说了算。\n A team of developers should agree upon a single formatting style, and then every member of that team should use that style. We want the software to have a consistent style. We don’t want it to appear to have been written by a bunch of disagreeing individuals.\n 一组开发者应当认同一种格式风格，每个成员都应该采用那种风格。我们想要让软件拥有一以贯之的风格。我们不想让它显得是由一大票意见相左的个人所写成。\n  When I started the FitNesse project back in 2002, I sat down with the team to work out a coding style. This took about 10 minutes. We decided where we’d put our braces, what our indent size would be, how we would name classes, variables, and methods, and so forth. Then we encoded those rules into the code formatter of our IDE and have stuck with them ever since. These were not the rules that I prefer; they were rules decided by the team. As a member of that team I followed them when writing code in the FitNesse project.\n 002 年启动 FitNesse 项目时，我和开发团队一起制订了一套编码风格。这只花了我们 10 分钟时间。我们决定了在什么地方放置括号，缩进几个字符，如何命名类、变量和方法，如此等等。然后，我们把这些规则编写进 IDE 的代码格式功能，接着就一直沿用。这些规则并非全是我喜爱的；但它们是团队决定了的规则。作为团队一员，在为 FitNesse 项目编写代码时，我遵循这些规则。\n Remember, a good software system is composed of a set of documents that read nicely. They need to have a consistent and smooth style. The reader needs to be able to trust that the formatting gestures he or she has seen in one source file will mean the same thing in others. The last thing we want to do is add more complexity to the source code by writing it in a jumble of different individual styles.\n 记住，好的软件系统是由一系列读起来不错的代码文件组成的。它们需要拥有一致和顺畅的风格。读者要能确信，他们在一个源文件中看到的格式风格在其他文件中也是同样的用法。绝对不要用各种不同的风格来编写源代码，这样会增加其复杂度。\n 5.5 UNCLE BOB’S FORMATTING RULES 鲍勃大叔的格式规则 #  The rules I use personally are very simple and are illustrated by the code in Listing 5-6. Consider this an example of how code makes the best coding standard document.\n 我个人使用的规则相当简单，如代码清单 5-6 所示。可以把这段代码看作是展示如何把代码写成最好的编码标准文档的范例。\n Listing 5-6 CodeAnalyzer.java\n 代码清单 5-6 CodeAnalyzer.java\n public int getWidestLineNumber() { return widestLineNumber; } public LineWidthHistogram getLineWidthHistogram() { return lineWidthHistogram; } public double getMeanLineWidth() { return (double) totalChars / lineCount; } public int getMedianLineWidth() { Integer[] sortedWidths = getSortedWidths(); int cumulativeLineCount = 0; for (int width : sortedWidths) { cumulativeLineCount += lineCountForWidth(width); if (cumulativeLineCount \u0026gt; lineCount / 2) return width; } throw new Error(\u0026#34;Cannot get here\u0026#34;); } private int lineCountForWidth(int width) { return lineWidthHistogram.getLinesforWidth(width).size(); } private Integer[] getSortedWidths() { Set\u0026lt;Integer\u0026gt; widths = lineWidthHistogram.getWidths(); Integer[] sortedWidths = (widths.toArray(new Integer[0])); Arrays.sort(sortedWidths); return sortedWidths; } "});index.add({'id':209,'href':'/docs/Clean-Code/6.-Objects-and-Data-Structures/ch6/','title':"Ch6",'section':"Go语言圣经",'content':"第 6 章 Objects and Data Structures 对象和数据结构 #   There is a reason that we keep our variables private. We don’t want anyone else to depend on them. We want to keep the freedom to change their type or implementation on a whim or an impulse. Why, then, do so many programmers automatically add getters and setters to their objects, exposing their private variables as if they were public?\n 将变量设置为私有（private）有一个理由：我们不想其他人依赖这些变量。我们还想在心血来潮时能自由修改其类型或实现。那么，为什么还是有那么多程序员给对象自动添加赋值器和取值器，将私有变量公之于众、如同它们根本就是公共变量一般呢？\n 6.1 DATA ABSTRACTION 数据抽象 #  Consider the difference between Listing 6-1 and Listing 6-2. Both represent the data of a point on the Cartesian plane. And yet one exposes its implementation and the other completely hides it.\n 看看代码清单 6-1 和代码清单 6-2 之间的区别。每段代码都表示笛卡儿平面上的一个点。不过，其中之一曝露了其实现，而另一个则完全隐藏了其实现。\n Listing 6-1 Concrete Point\n 代码清单 6-1 具象点\n public class Point { public double x; public double y; } Listing 6-2 Abstract Point\n 代码清单 6-2 抽象点\n public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); } The beautiful thing about Listing 6-2 is that there is no way you can tell whether the implementation is in rectangular or polar coordinates. It might be neither! And yet the interface still unmistakably represents a data structure.\n 代码清单 6-2 的漂亮之处在于，你不知道该实现会是在矩形坐标系中还是在极坐标系中。可能两个都不是！然而，该接口还是明白无误地呈现了一种数据结构。\n But it represents more than just a data structure. The methods enforce an access policy. You can read the individual coordinates independently, but you must set the coordinates together as an atomic operation.\n 不过它呈现的还不止是一个数据结构。那些方法固定了一套存取策略。你可以单独读取某个坐标，但必须通过一次原子操作设定所有坐标。\n Listing 6-1, on the other hand, is very clearly implemented in rectangular coordinates, and it forces us to manipulate those coordinates independently. This exposes implementation. Indeed, it would expose implementation even if the variables were private and we were using single variable getters and setters.\n 而代码清单 6-1 则非常清楚地是在矩形坐标系中实现，并要求我们单个操作那些坐标。这就曝露了实现。实际上，即便变量都是私有，而且我们也通过变量取值器和赋值器使用变量，其实现仍然曝露了。\n Hiding implementation is not just a matter of putting a layer of functions between the variables. Hiding implementation is about abstractions! A class does not simply push its variables out through getters and setters. Rather it exposes abstract interfaces that allow its users to manipulate the essence of the data, without having to know its implementation.\n 隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！类并不简单地用取值器和赋值器将其变量推向外间，而是曝露抽象接口，以便用户无需了解数据的实现就能操作数据本体。\n Consider Listing 6-3 and Listing 6-4. The first uses concrete terms to communicate the fuel level of a vehicle, whereas the second does so with the abstraction of percentage. In the concrete case you can be pretty sure that these are just accessors of variables. In the abstract case you have no clue at all about the form of the data.\n 看看代码清单 6-3 和代码清单 6-4。前者使用具象手段与机动车的燃料层通信，而后者则采用百分比抽象。你能确定前者里面都是些变量存取器，而却无法得知后者中的数据形态。\n Listing 6-3 Concrete Vehicle\n 代码清单 6-3 具象机动车\n public interface Vehicle { double getFuelTankCapacityInGallons(); double getGallonsOfGasoline(); } Listing 6-4 Abstract Vehicle\n 代码清单 6-4 抽象机动车\n public interface Vehicle { double getPercentFuelRemaining(); } In both of the above cases the second option is preferable. We do not want to expose the details of our data. Rather we want to express our data in abstract terms. This is not merely accomplished by using interfaces and/or getters and setters. Serious thought needs to be put into the best way to represent the data that an object contains. The worst option is to blithely add getters and setters.\n 以上两段代码以后者为佳。我们不愿曝露数据细节，更愿意以抽象形态表述数据。这并不只是用接口和/或赋值器、取值器就万事大吉。要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。傻乐着乱加取值器和赋值器，是最坏的选择。\n 6.2 DATA/OBJECT ANTI-SYMMETRY 数据、对象的反对称性 #  These two examples show the difference between objects and data structures. Objects hide their data behind abstractions and expose functions that operate on that data. Data structure expose their data and have no meaningful functions. Go back and read that again. Notice the complimentary nature of the two definitions. They are virtual opposites. This difference may seem trivial, but it has far-reaching implications.\n 这两个例子展示了对象与数据结构之间的差异。对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数。回过头再读一遍。留意这两种定义的本质。它们是对立的。这种差异貌似微小，但却有深远的含义。\n Consider, for example, the procedural shape example in Listing 6-5. The Geometry class operates on the three shape classes. The shape classes are simple data structures without any behavior. All the behavior is in the Geometry class.\n 例如，代码清单 6-5 中的过程式代码形状范例。Geometry 类操作三个形状类。形状类都是简单的数据结构，没有任何行为。所有行为都在 Geometry 类中。\n Listing 6-5 Procedural Shape\n 代码清单 6-5 过程式形状代码\n public class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square) shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle) shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle) shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } } Object-oriented programmers might wrinkle their noses at this and complain that it is procedural—and they’d be right. But the sneer may not be warranted. Consider what would happen if a perimeter() function were added to Geometry. The shape classes would be unaffected! Any other classes that depended upon the shapes would also be unaffected! On the other hand, if I add a new shape, I must change all the functions in Geometry to deal with it. Again, read that over. Notice that the two conditions are diametrically opposed.\n 面向对象程序员可能会对此嗤之以鼻，抱怨说这是过程式代码——他们大概是对的，不过这种嘲笑并不完全正确。想想看，如果给 Geometry 类添加一个 primeter() 函数会怎样。那些形状类根本不会因此而受影响！另一方面，如果添加一个新形状，就得修改 Geometry 中的所有函数来处理它。再读一遍代码。注意，这两种情形也是直接对立的。\n Now consider the object-oriented solution in Listing 6-6. Here the area() method is polymorphic. No Geometry class is necessary. So if I add a new shape, none of the existing functions are affected, but if I add a new function all of the shapes must be changed!1\n 现在来看看代码清单 6-6 中的面向对象方案。这里，area() 方法是多态的。不需要有 Geometry 类。所以，如果添加一个新形状，现有的函数一个也不会受到影响，而当添加新函数时所有的形状都得做修改！\n Listing 6-6 Polymorphic Shapes\n 代码清单 6-6 多态式形状\n public class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } } Again, we see the complimentary nature of these two definitions; they are virtual opposites! This exposes the fundamental dichotomy between objects and data structures:\n 我们再次看到这两种定义的本质；它们是截然对立的。这说明了对象与数据结构之间的二分原理：\n Procedural code (code using data structures) makes it easy to add new functions without changing the existing data structures. OO code, on the other hand, makes it easy to add new classes without changing existing functions.\n 过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。\n The complement is also true:\n 反过来讲也说得通：\n Procedural code makes it hard to add new data structures because all the functions must change. OO code makes it hard to add new functions because all the classes must change.\n 过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。\n So, the things that are hard for OO are easy for procedures, and the things that are hard for procedures are easy for OO!\n 所以，对于面向对象较难的事，对于过程式代码却较容易，反之亦然！\n In any complex system there are going to be times when we want to add new data types rather than new functions. For these cases objects and OO are most appropriate. On the other hand, there will also be times when we’ll want to add new functions as opposed to data types. In that case procedural code and data structures will be more appropriate.\n 在任何一个复杂系统中，都会有需要添加新数据类型而不是新函数的时候。这时，对象和面向对象就比较适合。另一方面，也会有想要添加新函数而不是数据类型的时候。在这种情况下，过程式代码和数据结构更合适。\n Mature programmers know that the idea that everything is an object is a myth. Sometimes you really do want simple data structures with procedures operating on them.\n6.3 THE LAW OF DEMETER 得墨忒耳律 #  There is a well-known heuristic called the Law of Demeter2 that says a module should not know about the innards of the objects it manipulates. As we saw in the last section, objects hide their data and expose operations. This means that an object should not expose its internal structure through accessors because to do so is to expose, rather than to hide, its internal structure.\n 著名的得墨忒耳律（The Law of Demeter）认为，模块不应了解它所操作对象的内部情形。如上节所见，对象隐藏数据，曝露操作。这意味着对象不应通过存取器曝露其内部结构，因为这样更像是曝露而非隐藏其内部结构。\n More precisely, the Law of Demeter says that a method f of a class C should only call the methods of these:\n 更准确地说，得墨忒耳律认为，类 C 的方法 f 只应该调用以下对象的方法：\n  C An object created by f An object passed as an argument to f An object held in an instance variable of C     C 由 f 创建的对象； 作为参数传递给 f 的对象； 由 C 的实体变量持有的对象。   The method should not invoke methods on objects that are returned by any of the allowed functions. In other words, talk to friends, not to strangers.\n 方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话。\n The following code3 appears to violate the Law of Demeter (among other things) because it calls the getScratchDir() function on the return value of getOptions() and then calls getAbsolutePath() on the return value of getScratchDir().\n 下列代码违反了得墨忒耳律（除了违反其他规则之外），因为它调用了 getOptions( )返回值的 getScratchDir( )函数，又调用了 getScratchDir( )返回值的 getAbsolutePath( )方法。\n final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 6.3.1 Train Wrecks 火车失事 #  This kind of code is often called a train wreck because it look like a bunch of coupled train cars. Chains of calls like this are generally considered to be sloppy style and should be avoided [G36]. It is usually best to split them up as follows:\n 这类代码常被称作火车失事，因为它看起来就像是一列火车。这类连串的调用通常被认为是肮脏的风格，应该避免[G36]。最好做类似如下的切分：\n Options opts = ctxt.getOptions(); File scratchDir = opts.getScratchDir(); final String outputDir = scratchDir.getAbsolutePath(); Are these two snippets of code violations of the Law of Demeter? Certainly the containing module knows that the ctxt object contains options, which contain a scratch directory, which has an absolute path. That’s a lot of knowledge for one function to know. The calling function knows how to navigate through a lot of different objects.\n 上列代码是否违反了得墨忒耳律呢？当然，模块知道 ctxt 对象包含有多个选项，每个选项中都有一个临时目录，而每个临时目录都有一个绝对路径。对于一个函数，这些知识真够丰富的。调用函数懂得如何在一大堆不同对象间浏览。\n  Whether this is a violation of Demeter depends on whether or not ctxt, Options, and ScratchDir are objects or data structures. If they are objects, then their internal structure should be hidden rather than exposed, and so knowledge of their innards is a clear violation of the Law of Demeter. On the other hand, if ctxt, Options, and ScratchDir are just data structures with no behavior, then they naturally expose their internal structure, and so Demeter does not apply.\n 这些代码是否违反得墨忒耳律，取决于 ctxt、Options 和 ScratchDir 是对象还是数据结构。如果是对象，则它们的内部结构应当隐藏而不曝露，而有关其内部细节的知识就明显违反了得墨忒耳律。如果 ctxt、Options 和 ScratchDir 只是数据结构，没有任何行为，则它们自然会曝露其内部结构，得墨忒耳律也就不适用了。\n The use of accessor functions confuses the issue. If the code had been written as follows, then we probably wouldn’t be asking about Demeter violations.\n 属性访问器函数的使用把问题搞复杂了。如果像下面这样写代码，我们大概就不会提及对得墨忒耳律的违反。\n final String outputDir = ctxt.options.scratchDir.absolutePath; This issue would be a lot less confusing if data structures simply had public variables and no functions, whereas objects had private variables and public functions. However, there are frameworks and standards (e.g., “beans”) that demand that even simple data structures have accessors and mutators.\n 如果数据结构只简单地拥有公共变量，没有函数，而对象则拥有私有变量和公共函数，这个问题就不那么混淆。然而，有些框架和标准甚至要求最简单的数据结构都要有访问器和改值器。\n 6.3.2 Hybrids 混杂 #  This confusion sometimes leads to unfortunate hybrid structures that are half object and half data structure. They have functions that do significant things, and they also have either public variables or public accessors and mutators that, for all intents and purposes, make the private variables public, tempting other external functions to use those variables the way a procedural program would use a data structure.4\n 这种混淆有时会不幸导致混合结构，一半是对象，一半是数据结构。这种结构拥有执行操作的函数，也有公共变量或公共访问器及改值器。无论出于怎样的初衷，公共访问器及改值器都把私有变量公开化，诱导外部函数以过程式程序使用数据结构的方式使用这些变量。\n Such hybrids make it hard to add new functions but also make it hard to add new data structures. They are the worst of both worlds. Avoid creating them. They are indicative of a muddled design whose authors are unsure of—or worse, ignorant of—whether they need protection from functions or types.\n 此类混杂增加了添加新函数的难度，也增加了添加新数据结构的难度，两面不讨好。应避免创造这种结构。它们的出现，展示了一种乱七八糟的设计，其作者不确定——或者更糟糕，完全无视——他们是否需要函数或类型的保护。\n 6.3.3 Hiding Structure 隐藏结构 #  What if ctxt, options, and scratchDir are objects with real behavior? Then, because objects are supposed to hide their internal structure, we should not be able to navigate through them. How then would we get the absolute path of the scratch directory?\n 假使 ctxt、Options 和 ScratchDir 是拥有真实行为的对象又怎样呢？由于对象应隐藏其内部结构，我们就不该能够看到内部结构。这样一来，如何才能取得临时目录的绝对路径呢？\n ctxt.getAbsolutePathOfScratchDirectoryOption(); or\n 或者\n ctx.getScratchDirectoryOption().getAbsolutePath() The first option could lead to an explosion of methods in the ctxt object. The second presumes that getScratchDirectoryOption() returns a data structure, not an object. Neither option feels good.\n 第一种方案可能导致 ctxt 对象中方法的曝露。第二种方案是在假设 getScratchDirectoryOption()返回一个数据结构而非对象。两种方案感觉都不好。\n If ctxt is an object, we should be telling it to do something; we should not be asking it about its internals. So why did we want the absolute path of the scratch directory? What were we going to do with it? Consider this code from (many lines farther down in) the same module:\n 如果 ctxt 是个对象，就应该要求它做点什么，不该要求它给出内部情形。那我们为何还要得到临时目录的绝对路径呢？我们要它做什么？来看看同一模块（许多行之后）的这段代码：\n String outFile = outputDir + \u0026#34;/\u0026#34; + className.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) + \u0026#34;.class\u0026#34;; FileOutputStream fout = new FileOutputStream(outFile); BufferedOutputStream bos = new BufferedOutputStream(fout); The admixture of different levels of detail [G34][g6] is a bit troubling. Dots, slashes, file extensions, and File objects should not be so carelessly mixed together, and mixed with the enclosing code. Ignoring that, however, we see that the intent of getting the absolute path of the scratch directory was to create a scratch file of a given name.\n 这种不同层级细节的混杂（[G34][g36]）有点麻烦。句点、斜杠、文件扩展名和 File 对象不该如此随便地混杂到一起。不过，撇开这些毛病，我们发现，取得临时目录绝对路径的初衷是为了创建指定名称的临时文件。\n So, what if we told the ctxt object to do this?\n 所以，直接让 ctxt 对象来做这事如何？\n BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName); That seems like a reasonable thing for an object to do! This allows ctxt to hide its internals and prevents the current function from having to violate the Law of Demeter by navigating through objects it shouldn’t know about.\n 这下看起来像是个对象做的事了！ctxt 隐藏了其内部结构，防止当前函数因浏览它不该知道的对象而违反得墨忒耳律。\n 6.4 DATA TRANSFER OBJECTS 数据传送对象 #  The quintessential form of a data structure is a class with public variables and no functions. This is sometimes called a data transfer object, or DTO. DTOs are very useful structures, especially when communicating with databases or parsing messages from sockets, and so on. They often become the first in a series of translation stages that convert raw data in a database into objects in the application code.\n 最为精练的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，或 DTO（Data Transfer Objects）。 DTO 是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类场景中。在应用程序代码里一系列将原始数据转换为数据库的翻译过程中，它们往往是排头兵。\n Somewhat more common is the “bean” form shown in Listing 6-7. Beans have private variables manipulated by getters and setters. The quasi-encapsulation of beans seems to make some OO purists feel better but usually provides no other benefit.\n 更常见的是如代码清单 6-7 所示的“豆”（bean）结构。豆结构拥有由赋值器和取值器操作的私有变量。对豆结构的半封装会让某些 OO 纯化论者感觉舒服些，不过通常没有其他好处。\n Listing 6-7 address.java\n 代码清单 6-7 address.java\n public class Address { private String street; private String streetExtra; private String city; private String state; private String zip; public Address(String street, String streetExtra, String city, String state, String zip) { this.street = street; this.streetExtra = streetExtra; this.city = city; this.state = state; this.zip = zip; } public String getStreet() { return street; } public String getStreetExtra() { return streetExtra; } public String getCity() { return city; } public String getState() { return state; } public String getZip() { return zip; } } Active Record #  Active Records are special forms of DTOs. They are data structures with public (or bean-accessed) variables; but they typically have navigational methods like save and find. Typically these Active Records are direct translations from database tables, or other data sources.\n Active Record 是一种特殊的 DTO 形式。它们是拥有公共（或可豆式访问的）变量的数据结构，但通常也会拥有类似 save 和 find 这样的可浏览方法。Active Record 一般是对数据库表或其他数据源的直接翻译。\n Unfortunately we often find that developers try to treat these data structures as though they were objects by putting business rule methods in them. This is awkward because it creates a hybrid between a data structure and an object.\n 我们不幸经常发现开发者往这类数据结构中塞进业务规则方法，把这类数据结构当成对象来用。这是不智的行为，因为它导致了数据结构和对象的混杂体。\n The solution, of course, is to treat the Active Record as a data structure and to create separate objects that contain the business rules and that hide their internal data (which are probably just instances of the Active Record).\n 当然，解决方案就是把 Active Record 当做数据结构，并创建包含业务规则、隐藏内部数据（可能就是 Active Record 的实体）的独立对象。\n 6.5 CONCLUSION 小结 #  Objects expose behavior and hide data. This makes it easy to add new kinds of objects without changing existing behaviors. It also makes it hard to add new behaviors to existing objects. Data structures expose data and have no significant behavior. This makes it easy to add new behaviors to existing data structures but makes it hard to add new data structures to existing functions.\n 对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。\n In any given system we will sometimes want the flexibility to add new data types, and so we prefer objects for that part of the system. Other times we will want the flexibility to add new behaviors, and so in that part of the system we prefer data types and procedures. Good software developers understand these issues without prejudice and choose the approach that is best for the job at hand.\n 在任何系统中，我们有时会希望能够灵活地添加新数据类型，所以更喜欢在这部分使用对象。另外一些时候，我们希望能灵活地添加新行为，这时我们更喜欢使用数据类型和过程。优秀的软件开发者不带成见地了解这种情形，并依据手边工作的性质选择其中一种手段。\n "});index.add({'id':210,'href':'/docs/Clean-Code/7.-Error-Handling/ch7/','title':"Ch7",'section':"Go语言圣经",'content':"第 7 章 Error Handling 错误处理 #  by Michael Feathers\n It might seem odd to have a section about error handling in a book about clean code. Error handling is just one of those things that we all have to do when we program. Input can be abnormal and devices can fail. In short, things can go wrong, and when they do, we as programmers are responsible for making sure that our code does what it needs to do.\n 在一本有关整洁代码的书中，居然有讨论错误处理的章节，看起来有些突兀。错误处理只不过是编程时必须要做的事之一。输入可能出现异常，设备可能失效。简言之，可能会出错，当错误发生时，程序员就有责任确保代码照常工作。\n The connection to clean code, however, should be clear. Many code bases are completely dominated by error handling. When I say dominated, I don’t mean that error handling is all that they do. I mean that it is nearly impossible to see what the code does because of all of the scattered error handling. Error handling is important, but if it obscures logic, it’s wrong.\n 然而，应该弄清楚错误处理与整洁代码的关系。许多程序完全由错误处理所占据。所谓占据，并不是说错误处理就是全部。我的意思是几乎无法看明白代码所做的事，因为到处都是凌乱的错误处理代码。错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。\n In this chapter I’ll outline a number of techniques and considerations that you can use to write code that is both clean and robust—code that handles errors with grace and style.\n 在本章中，我将概要列出编写既整洁又强固的代码——雅致地处理错误代码的一些技巧和思路。\n 7.1 USE EXCEPTIONS RATHER THAN RETURN CODES 使用异常而非返回码 #  Back in the distant past there were many languages that didn’t have exceptions. In those languages the techniques for handling and reporting errors were limited. You either set an error flag or returned an error code that the caller could check. The code in Listing 7-1 illustrates these approaches.\n 在很久以前，许多语言都不支持异常。这些语言处理和汇报错误的手段都有限。你要么设置一个错误标识，要么返回给调用者检查的错误码。代码清单 7-1 中的代码展示了这些手段。\n Listing 7-1 DeviceController.java\n 代码清单 7-1 DeviceController.java\n public class DeviceController { … public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device  if (handle != DeviceHandle.INVALID) { // Save the device status to the record field  retrieveDeviceRecord(handle); // If not suspended, shut down  if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { logger.log(\u0026#34;Device suspended. Unable to shut down\u0026#34;); } } else { logger.log(\u0026#34;Invalid handle for: \u0026#34; + DEV1.toString()); } } … } The problem with these approaches is that they clutter the caller. The caller must check for errors immediately after the call. Unfortunately, it’s easy to forget. For this reason it is better to throw an exception when you encounter an error. The calling code is cleaner. Its logic is not obscured by error handling.\n 这类手段的问题在于，它们搞乱了调用者代码。调用者必须在调用之后即刻检查错误。不幸的是，这个步骤很容易被遗忘。所以，遇到错误时，最好抛出一个异常。调用代码很整洁，其逻辑不会被错误处理搞乱。\n Listing 7-2 shows the code after we’ve chosen to throw exceptions in methods that can detect errors.\n 代码清单 7-2 展示了在方法中遇到错误时抛出异常的情形。\n Listing 7-2 DeviceController.java (with exceptions)\n 代码清单 7-2 展示了在方法中遇到错误时抛出异常的情形。\n public class DeviceController { … public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { … throw new DeviceShutDownError(\u0026#34;Invalid handle for: \u0026#34; + id.toString()); … } … } Notice how much cleaner it is. This isn’t just a matter of aesthetics. The code is better because two concerns that were tangled, the algorithm for device shutdown and error handling, are now separated. You can look at each of those concerns and understand them independently.\n 注意这段代码整洁了很多。这不仅关乎美观。这段代码更好，因为之前纠结的两个元素设备关闭算法和错误处理现在被隔离了。你可以查看其中任一元素，分别理解它。\n 7.2 WRITE YOUR TRY-CATCH-FINALLY STATEMENT FIRST 先写 Try-Catch-Finally 语句 #  One of the most interesting things about exceptions is that they define a scope within your program. When you execute code in the try portion of a try-catch-finally statement, you are stating that execution can abort at any point and then resume at the catch.\n 异常的妙处之一是，它们在程序中定义了一个范围。执行 try-catchfinally 语句中 try 部分的代码时，你是在表明可随时取消执行，并在 catch 语句中接续。\n In a way, try blocks are like transactions. Your catch has to leave your program in a consistent state, no matter what happens in the try. For this reason it is good practice to start with a try-catch-finally statement when you are writing code that could throw exceptions. This helps you define what the user of that code should expect, no matter what goes wrong with the code that is executed in the try.\n 在某种意义上，try 代码块就像是事务。catch 代码块将程序维持在一种持续状态，无论 try 代码块中发生了什么均如此。所以，在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。这能帮你定义代码的用户应该期待什么，无论 try 代码块中执行的代码出什么错都一样。\n Let’s look at an example. We need to write some code that accesses a file and reads some serialized objects.\n 来看个例子。我们要编写访问某个文件并读出一些序列化对象的代码。\n We start with a unit test that shows that we’ll get an exception when the file doesn’t exist:\n 先写一个单元测试，其中显示当文件不存在时将得到一个异常：\n @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(\u0026#34;invalid - file\u0026#34;); } The test drives us to create this stub:\n 该测试驱动我们创建以下占位代码：\n public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { // dummy return until we have a real implementation  return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } Our test fails because it doesn’t throw an exception. Next, we change our implementation so that it attempts to access an invalid file. This operation throws an exception:\n 测试失败了，因为以上代码并未抛出异常。下一步，修改实现代码，尝试访问非法文件。该操作抛出一个异常：\n public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); } catch (Exception e) { throw new StorageException(\u0026#34;retrieval error\u0026#34;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } Our test passes now because we’ve caught the exception. At this point, we can refactor. We can narrow the type of the exception we catch to match the type that is actually thrown from the FileInputStream constructor: FileNotFoundException:\n 这次测试通过了，因为我们捕获了异常。此时，我们可以重构了。我们可以缩小异常类型的范围，使之符合 FileInputStream 构造器真正抛出的异常，即 FileNotFoundException：\n public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(\u0026#34;retrieval error\u0026#34;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } Now that we’ve defined the scope with a try-catch structure, we can use TDD to build up the rest of the logic that we need. That logic will be added between the creation of the FileInputStream and the close, and can pretend that nothing goes wrong.\n 如此一来，我们就用 try-catch 结构定义了一个范围，可以继续用测试驱动（TDD）方法构建剩余的代码逻辑。这些代码逻辑将在 FileInputStream 和 close 之间添加，装作一切正常的样子。\n Try to write tests that force exceptions, and then add behavior to your handler to satisfy your tests. This will cause you to build the transaction scope of the try block first and will help you maintain the transaction nature of that scope.\n 尝试编写强行抛出异常的测试，再往处理器中添加行为，使之满足测试要求。结果就是你要先构造 try 代码块的事务范围，而且也会帮助你维护好该范围的事务特征。\n 7.3 USE UNCHECKED EXCEPTIONS 使用不可控异常 #  The debate is over. For years Java programmers have debated over the benefits and liabilities of checked exceptions. When checked exceptions were introduced in the first version of Java, they seemed like a great idea. The signature of every method would list all of the exceptions that it could pass to its caller. Moreover, these exceptions were part of the type of the method. Your code literally wouldn’t compile if the signature didn’t match what your code could do.\n 辩论业已结束。多年来，Java 程序员们一直在争论可控异常（checked exception）的利与弊。Java 的第一个版本中引入可控异常时，看似一个极好的点子。每个方法的签名都列出它可能传递给调用者的异常。而且，这些异常就是方法类型的一部分。如果签名与代码实际所做之事不符，代码在字面上就无法编译。\n At the time, we thought that checked exceptions were a great idea; and yes, they can yield some benefit. However, it is clear now that they aren’t necessary for the production of robust software. C# doesn’t have checked exceptions, and despite valiant attempts, C++ doesn’t either. Neither do Python or Ruby. Yet it is possible to write robust software in all of these languages. Because that is the case, we have to decide—really—whether checked exceptions are worth their price.\n 那时，我们认为可控异常是个绝妙的主意；而且，它也有所裨益。然而，现在已经很清楚，对于强固软件的生产，它并非必需。C#不支持可控异常。尽管做过勇敢的尝试，C++最后也不支持可控异常。Python 和 Ruby 同样如此。不过，用这些语言也有可能写出强固的软件。我们得决定——的确如此——可控异常是否值回票价。\n What price? The price of checked exceptions is an Open/Closed Principle1 violation. If you throw a checked exception from a method in your code and the catch is three levels above, you must declare that exception in the signature of each method between you and the catch. This means that a change at a low level of the software can force signature changes on many higher levels. The changed modules must be rebuilt and redeployed, even though nothing they care about changed.\n 代价是什么？可控异常的代价就是违反开放/闭合原则。如果你在方法中抛出可控异常，而 catch 语句在三个层级之上，你就得在 catch 语句和抛出异常处之间的每个方法签名中声明该异常。这意味着对软件中较低层级的修改，都将波及较高层级的签名。修改好的模块必须重新构建、发布，即便它们自身所关注的任何东西都没改动过。\n Consider the calling hierarchy of a large system. Functions at the top call functions below them, which call more functions below them, ad infinitum. Now let’s say one of the lowest level functions is modified in such a way that it must throw an exception. If that exception is checked, then the function signature must add a throws clause. But this means that every function that calls our modified function must also be modified either to catch the new exception or to append the appropriate throws clause to its signature. Ad infinitum. The net result is a cascade of changes that work their way from the lowest levels of the software to the highest! Encapsulation is broken because all functions in the path of a throw must know about details of that low-level exception. Given that the purpose of exceptions is to allow you to handle errors at a distance, it is a shame that checked exceptions break encapsulation in this way.\n 以某个大型系统的调用层级为例。顶端函数调用它们之下的函数，逐级向下。假设某个位于最底层级的函数被修改为抛出一个异常。如果该异常是可控的，则函数签名就要添加 throw 子句。这意味着每个调用该函数的函数都要修改，捕获新异常，或在其签名中添加合适的 throw 子句。以此类推。最终得到的就是一个从软件最底端贯穿到最高端的修改链！封装被打破了，因为在抛出路径中的每个函数都要去了解下一层级的异常细节。既然异常旨在让你能在较远处处理错误，可控异常以这种方式破坏封装简直就是一种耻辱。\n Checked exceptions can sometimes be useful if you are writing a critical library: You must catch them. But in general application development the dependency costs outweigh the benefits.\n 如果你在编写一套关键代码库，则可控异常有时也会有用：你必须捕获异常。但对于一般的应用开发，其依赖成本要高于收益。\n 7.4 PROVIDE CONTEXT WITH EXCEPTIONS 给出异常发生的环境说明 #  Each exception that you throw should provide enough context to determine the source and location of an error. In Java, you can get a stack trace from any exception; however, a stack trace can’t tell you the intent of the operation that failed.\n 你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。在 Java 中，你可以从任何异常里得到堆栈踪迹（stack trace）；然而，堆栈踪迹却无法告诉你该失败操作的初衷。\n Create informative error messages and pass them along with your exceptions. Mention the operation that failed and the type of failure. If you are logging in your application, pass along enough information to be able to log the error in your catch.\n 应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。如果你的应用程序有日志系统，传递足够的信息给 catch 块，并记录下来。\n 7.5 DEFINE EXCEPTION CLASSES IN TERMS OF A CALLER’S NEEDS 依调用者需要定义异常类 #  There are many ways to classify errors. We can classify them by their source: Did they come from one component or another? Or their type: Are they device failures, network failures, or programming errors? However, when we define exception classes in an application, our most important concern should be how they are caught.\n 对错误分类有很多方式。可以依其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是它们如何被捕获。\n Let’s look at an example of poor exception classification. Here is a try-catch-finally statement for a third-party library call. It covers all of the exceptions that the calls can throw:\n 来看一个不太好的异常分类例子。下面的 try-catch-finally 语句是对某个第三方代码库的调用。它覆盖了该调用可能抛出的所有异常：\n ACMEPort port = new ACMEPort(12); try { port.open(); } catch (DeviceResponseException e) { reportPortError(e); logger.log(\u0026#34;Device response exception\u0026#34;, e); } catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(\u0026#34;Unlock exception\u0026#34;, e); } catch (GMXError e) { reportPortError(e); logger.log(\u0026#34;Device response exception\u0026#34;); } finally { … } That statement contains a lot of duplication, and we shouldn’t be surprised. In most exception handling situations, the work that we do is relatively standard regardless of the actual cause. We have to record an error and make sure that we can proceed.\n 语句包含了一大堆重复代码，这并不出奇。在大多数异常处理中，不管真实原因如何，我们总是做相对标准的处理。我们得记录错误，确保能继续工作。\n In this case, because we know that the work that we are doing is roughly the same regardless of the exception, we can simplify our code considerably by wrapping the API that we are calling and making sure that it returns a common exception type:\n 在本例中，既然知道我们所做的事不外如此，就可以通过打包调用 API、确保它返回通用异常类型，从而简化代码。\n LocalPort port = new LocalPort(12); try { port.open(); } catch (PortDeviceFailure e) { reportError(e); logger.log(e.getMessage(), e); } finally { … } Our LocalPort class is just a simple wrapper that catches and translates exceptions thrown by the ACMEPort class:\n 在本例中，既然知道我们所做的事不外如此，就可以通过打包调用 API、确保它返回通用异常类型，从而简化代码。\n public class LocalPort { private ACMEPort innerPort; public LocalPort(int portNumber) { innerPort = new ACMEPort(portNumber); } public void open() { try { innerPort.open(); } catch (DeviceResponseException e) { throw new PortDeviceFailure(e); } catch (ATM1212UnlockedException e) { throw new PortDeviceFailure(e); } catch (GMXError e) { throw new PortDeviceFailure(e); } } … } Wrappers like the one we defined for ACMEPort can be very useful. In fact, wrapping third-party APIs is a best practice. When you wrap a third-party API, you minimize your dependencies upon it: You can choose to move to a different library in the future without much penalty. Wrapping also makes it easier to mock out third-party calls when you are testing your own code.\n 类似我们为 ACMEPort 定义的这种打包类非常有用。实际上，将第三方 API 打包是个良好的实践手段。当你打包一个第三方 API，你就降低了对它的依赖：未来你可以不太痛苦地改用其他代码库。在你测试自己的代码时，打包也有助于模拟第三方调用。\n One final advantage of wrapping is that you aren’t tied to a particular vendor’s API design choices. You can define an API that you feel comfortable with. In the preceding example, we defined a single exception type for port device failure and found that we could write much cleaner code.\n 打包的好处还在于你不必绑死在某个特定厂商的 API 设计上。你可以定义自己感觉舒服的 API。在上例中，我们为 port 设备错误定义了一个异常类型，然后发现这样能写出更整洁的代码。\n Often a single exception class is fine for a particular area of code. The information sent with the exception can distinguish the errors. Use different classes only if there are times when you want to catch one exception and allow the other one to pass through.\n 对于代码的某个特定区域，单一异常类通常可行。伴随异常发送出来的信息能够区分不同错误。如果你想要捕获某个异常，并且放过其他异常，就使用不同的异常类。\n 7.6 DEFINE THE NORMAL FLOW 定义常规流程 #  If you follow the advice in the preceding sections, you’ll end up with a good amount of separation between your business logic and your error handling. The bulk of your code will start to look like a clean unadorned algorithm. However, the process of doing this pushes error detection to the edges of your program. You wrap external APIs so that you can throw your own exceptions, and you define a handler above your code so that you can deal with any aborted computation. Most of the time this is a great approach, but there are some times when you may not want to abort.\n 如果你遵循前文提及的建议，在业务逻辑和错误处理代码之间就会有良好的区隔。大量代码会开始变得像是整洁而简朴的算法。然而，这样做却把错误检测推到了程序的边缘地带。你打包了外部 API 以抛出自己的异常，你在代码的顶端定义了一个处理器来应付任何失败了的运算。在大多数时候，这种手段很棒，不过有时你也许不愿这么做。\n  Let’s take a look at an example. Here is some awkward code that sums expenses in a billing application:\n 来看一个例子。下面的笨代码来自某个记账应用的开支总计模块：\n try { MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); } catch (MealExpensesNotFound e) { m_total += getMealPerDiem(); } In this business, if meals are expensed, they become part of the total. If they aren’t, the employee gets a meal per diem amount for that day. The exception clutters the logic. Wouldn’t it be better if we didn’t have to deal with the special case? If we didn’t, our code would look much simpler. It would look like this:\n 业务逻辑是，如果消耗了餐食，则计入总额中。如果没有消耗，则员工得到当日餐食补贴。异常打断了业务逻辑。如果不去处理特殊情况会不会好一些？那样的话代码看起来会更简洁。就像这样：\n MealExpenses expenses = expenseReportDAO.getMeals(employee.getID()); m_total += expenses.getTotal(); Can we make the code that simple? It turns out that we can. We can change the ExpenseReportDAO so that it always returns a MealExpense object. If there are no meal expenses, it returns a MealExpense object that returns the per diem as its total:\n 其总是返回 MealExpense 对象。如果没有餐食消耗，就返回一个返回餐食补贴的 MealExpense 对象。\n public class PerDiemMealExpenses implements MealExpenses { public int getTotal() { // return the per diem default  } } This is called the SPECIAL CASE PATTERN [Fowler]. You create a class or configure an object so that it handles a special case for you. When you do, the client code doesn’t have to deal with exceptional behavior. That behavior is encapsulated in the special case object.\n 这种手法叫做特例模式（SPECIAL CASE PATTERN，[Fowler]）。创建一个类或配置一个对象，用来处理特例。你来处理特例，客户代码就不用应付异常行为了。异常行为被封装到特例对象中。\n 7.7 DON’T RETURN NULL 别返回 null 值 #  I think that any discussion about error handling should include mention of the things we do that invite errors. The first on the list is returning null. I can’t begin to count the number of applications I’ve seen in which nearly every other line was a check for null. Here is some example code:\n 我认为，要讨论错误处理，就一定要提及那些容易引发错误的做法。第一项就是返回 null 值。我不想去计算曾经见过多少几乎每行代码都在检查 null 值的应用程序。下面就是个例子：\n public void registerItem(Item item) { if (item != null) { ItemRegistry registry = peristentStore.getItemRegistry(); if (registry != null) { Item existing = registry.getItem(item.getID()); if (existing.getBillingPeriod().hasRetailOwner()) { existing.register(item); } } } } If you work in a code base with code like this, it might not look all that bad to you, but it is bad! When we return null, we are essentially creating work for ourselves and foisting problems upon our callers. All it takes is one missing null check to send an application spinning out of control.\n 这种代码看似不坏，其实糟透了！返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控。\n Did you notice the fact that there wasn’t a null check in the second line of that nested if statement? What would have happened at runtime if persistentStore were null? We would have had a NullPointerException at runtime, and either someone is catching NullPointerException at the top level or they are not. Either way it’s bad. What exactly should you do in response to a NullPointerException thrown from the depths of your application?\n 你有没有注意到，嵌套 if 语句的第二行没有检查 null 值？如果在运行时 persistentStore 为 null 会发生什么事？我们会在运行时得到一个 NullPointerException 异常，也许有人在代码顶端捕获这个异常，也可能没有捕获。两种情况都很糟糕。对于从应用程序深处抛出的 NullPointerException 异常，你到底该作何反应呢？\n It’s easy to say that the problem with the code above is that it is missing a null check, but in actuality, the problem is that it has too many. If you are tempted to return null from a method, consider throwing an exception or returning a SPECIAL CASE object instead. If you are calling a null-returning method from a third-party API, consider wrapping that method with a method that either throws an exception or returns a special case object.\n 可以敷衍说上列代码的问题是少做了一次 null 值检查，其实问题多多。如果你打算在方法中返回 null 值，不如抛出异常，或是返回特例对象。如果你在调用某个第三方 API 中可能返回 null 值的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或返回特例对象。\n In many cases, special case objects are an easy remedy. Imagine that you have code like this:\n 在许多情况下，特例对象都是爽口良药。设想有这么一段代码：\n List\u0026lt;Employee\u0026gt; employees = getEmployees(); if (employees != null) { for (Employee e : employees) { totalPay += e.getPay(); } } Right now, getEmployees can return null, but does it have to? If we change getEmployee so that it returns an empty list, we can clean up the code:\n 现在，getExployees 可能返回 null，但是否一定要这么做呢？如果修改 getEmployee，返回空列表，就能使代码整洁起来：\n List\u0026lt;Employee\u0026gt; employees = getEmployees(); for (Employee e : employees) { totalPay += e.getPay(); } Fortunately, Java has Collections.emptyList(), and it returns a predefined immutable list that we can use for this purpose:\n 所幸 Java 有 Collections.emptyList( )方法，该方法返回一个预定义不可变列表，可用于这种目的：\n public List\u0026lt;Employee\u0026gt; getEmployees() { if ( .. there are no employees .. ) return Collections.emptyList(); } If you code this way, you will minimize the chance of NullPointerExceptions and your code will be cleaner.\n 这样编码，就能尽量避免 NullPointerException 的出现，代码也就更整洁了。\n 7.8 DON’T PASS NULL 别传递 null 值 #  Returning null from methods is bad, but passing null into methods is worse. Unless you are working with an API which expects you to pass null, you should avoid passing null in your code whenever possible.\n 在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。除非 API 要求你向它传递 null 值，否则就要尽可能避免传递 null 值。\n Let’s look at an example to see why. Here is a simple method which calculates a metric for two points:\n 举例说明原因。用下面这个简单的方法计算两点的投射：\n public class MetricsCalculator { public double xProjection(Point p1, Point p2) { return (p2.x –p1.x) *1.5; } … } What happens when someone passes null as an argument?\n 如果有人传入 null 值会怎样？\n calculator.xProjection(null, new Point(12, 13)); We’ll get a NullPointerException, of course.\n 当然，我们会得到一个 NullPointerException 异常。\n How can we fix it? We could create a new exception type and throw it:\n 如何修正？可以创建一个新异常类型并抛出：\n public class MetricsCalculator { public double xProjection(Point p1, Point p2) { if (p1 == null || p2 == null) { throw InvalidArgumentException( \u0026#34;Invalid argument for MetricsCalculator.xProjection\u0026#34;); } return (p2.x –p1.x) *1.5; } } Is this better? It might be a little better than a null pointer exception, but remember, we have to define a handler for InvalidArgumentException. What should the handler do? Is there any good course of action?\n 这样做好些吗？可能比 null 指针异常好一些，但要记住，我们还得为 InvalidArgumentException 异常定义处理器。这个处理器该做什么？还有更好的做法吗？\n There is another alternative. We could use a set of assertions:\n 还有替代方案。可以使用一组断言\n public class MetricsCalculator { public double xProjection(Point p1, Point p2) { assert p1 != null : \u0026#34;p1 should not be null\u0026#34;; assert p2 != null : \u0026#34;p2 should not be null\u0026#34;; return (p2.x –p1.x) *1.5; } } It’s good documentation, but it doesn’t solve the problem. If someone passes null, we’ll still have a runtime error.\n 看上去很美，但仍未解决问题。如果有人传入 null 值，还是会得到运行时错误。\n In most programming languages there is no good way to deal with a null that is passed by a caller accidentally. Because this is the case, the rational approach is to forbid passing null by default. When you do, you can code with the knowledge that a null in an argument list is an indication of a problem, and end up with far fewer careless mistakes.\n 在大多数编程语言中，没有良好的方法能对付由调用者意外传入的 null 值。事已如此，恰当的做法就是禁止传入 null 值。这样，你在编码的时候，就会时时记住参数列表中的 null 值意味着出问题了，从而大量避免这种无心之失。\n 7.9 CONCLUSION 小结 #  Clean code is readable, but it must also be robust. These are not conflicting goals. We can write robust clean code if we see error handling as a separate concern, something that is viewable independently of our main logic. To the degree that we are able to do that, we can reason about it independently, and we can make great strides in the maintainability of our code.\n 整洁代码是可读的，但也要强固。可读与强固并不冲突。如果将错误处理隔离看待，独立于主要逻辑之外，就能写出强固而整洁的代码。做到这一步，我们就能单独处理它，也极大地提升了代码的可维护性。\n "});index.add({'id':211,'href':'/docs/Clean-Code/8.-Boundaries/ch8/','title':"Ch8",'section':"Go语言圣经",'content':"第 8 章 Boundaries 边界 #  by James Grenning\n We seldom control all the software in our systems. Sometimes we buy third-party packages or use open source. Other times we depend on teams in our own company to produce components or subsystems for us. Somehow we must cleanly integrate this foreign code with our own. In this chapter we look at practices and techniques to keep the boundaries of our software clean.\n 我们很少控制系统中的全部软件。有时我们购买第三方程序包或使用开放源代码，有时我们依靠公司中其他团队打造组件或子系统。不管是哪种情况，我们都得将外来代码干净利落地整合进自己的代码中。本章将介绍一些保持软件边界整洁的实践手段和技巧。\n 8.1 USING THIRD-PARTY CODE 使用第三方代码 #  There is a natural tension between the provider of an interface and the user of an interface. Providers of third-party packages and frameworks strive for broad applicability so they can work in many environments and appeal to a wide audience. Users, on the other hand, want an interface that is focused on their particular needs. This tension can cause problems at the boundaries of our systems.\n 在接口提供者和使用者之间，存在与生俱来的张力。第三方程序包和框架提供者追求普适性，这样就能在多个环境中工作，吸引广泛的用户。而使用者则想要集中满足特定需求的接口。这种张力会导致系统边界上出现问题。\n Let’s look at java.util.Map as an example. As you can see by examining Figure 8-1, Maps have a very broad interface with plenty of capabilities. Certainly this power and flexibility is useful, but it can also be a liability. For instance, our application might build up a Map and pass it around. Our intention might be that none of the recipients of our Map delete anything in the map. But right there at the top of the list is the clear() method. Any user of the Map has the power to clear it. Or maybe our design convention is that only particular types of objects can be stored in the Map, but Maps do not reliably constrain the types of objects placed within them. Any determined user can add items of any type to any Map.\n 以 java.util.Map 为例。如你在表 8-1 中所见，Map 有着广阔的接口和丰富的功能。当然，这种力量和灵活性很有用，但也要付出代价。比如，应用程序可能构造一个 Map 对象并传递它。我们的初衷可能是 Map 对象的所有接收者都不要删除映射图中的任何东西。但表 8-1 的顶端却正好有一个 clear( )方法。Map 的任何使用者都能清除映射图。或许设计惯例是 Map 中只能保存特定的类型，但 Map 并不会可靠地约束存于其中的对象的类型。使用者可随意往 Map 中塞入任何类型的条目。\n Figure 8-1 The methods of Map\n If our application needs a Map of Sensors, you might find the sensors set up like this:\n 如果你的应用程序需要一个包容 Sensor 类对象的 Map 映射图，大概会是这样：\n Map sensors = new HashMap(); Then, when some other part of the code needs to access the sensor, you see this code:\n 当代码的其他部分需要访问这些 sensor，就会有这行代码：\n Sensor s = (Sensor)sensors.get(sensorId); We don’t just see it once, but over and over again throughout the code. The client of this code carries the responsibility of getting an Object from the Map and casting it to the right type. This works, but it’s not clean code. Also, this code does not tell its story as well as it could. The readability of this code can be greatly improved by using generics, as shown below:\n 这行代码一再出现。代码的调用端承担了从 Map 中取得对象并将其转换为正确类型的职责。行倒是行，却并非整洁的代码。而且，这行代码并未说明自己的用途。通过对泛型的使用，这段代码可读性可以大大提高，如下所示：\n Map\u0026lt;Sensor\u0026gt; sensors = new HashMap\u0026lt;Sensor\u0026gt;(); … Sensor s = sensors.get(sensorId); However, this doesn’t solve the problem that Map\u0026lt;Sensor\u0026gt; provides more capability than we need or want.\n 不过，Map\u0026lt;Sensor\u0026gt; 提供了超出所需/所愿的功能的问题，仍未得到解决。\n Passing an instance of Map\u0026lt;Sensor\u0026gt; liberally around the system means that there will be a lot of places to fix if the interface to Map ever changes. You might think such a change to be unlikely, but remember that it changed when generics support was added in Java 5. Indeed, we’ve seen systems that are inhibited from using generics because of the sheer magnitude of changes needed to make up for the liberal use of Maps.\n 在系统中不受限制地传递Map\u0026lt;Sensor\u0026gt;的实体，意味着当到 Map 的接口被修改时，有许多地方都要跟着改。你或许会认为这样的改动不太可能发生，不过，当 Java 5 加入对泛型的支持时，的确发生了改动。我们也的确见到一些系统因为要做大量改动才能自由使用 Map 类，而无法使用泛型。\n A cleaner way to use Map might look like the following. No user of Sensors would care one bit if generics were used or not. That choice has become (and always should be) an implementation detail.\n 使用 Map 的更整洁的方式大致如下。Sensors 的用户不必关心是否用了泛型，那将是（也该是）实现细节才关心的。\n public class Sensors { private Map sensors = new HashMap(); public Sensor getById(String id) { return (Sensor) sensors.get(id); } //snip } The interface at the boundary (Map) is hidden. It is able to evolve with very little impact on the rest of the application. The use of generics is no longer a big issue because the casting and type management is handled inside the Sensors class.\n 边界上的接口（Map）是隐藏的。它能随来自应用程序其他部分的极小的影响而变动。对泛型的使用不再是个大问题，因为转换和类型管理是在 Sensors 类内部处理的。\n This interface is also tailored and constrained to meet the needs of the application. It results in code that is easier to understand and harder to misuse. The Sensors class can enforce design and business rules.\n 该接口也经过仔细修整和归置以适应应用程序的需要。结果就是得到易于理解、难以被误用的代码。Sensors 类推动了设计和业务的规则。我们并不建议总是以这种方式封装 Map 的使用。\n We are not suggesting that every use of Map be encapsulated in this form. Rather, we are advising you not to pass Maps (or any other interface at a boundary) around your system. If you use a boundary interface like Map, keep it inside the class, or close family of classes, where it is used. Avoid returning it from, or accepting it as an argument to, public APIs.\n 我们建议不要将 Map（或在边界上的其他接口）在系统中传递。如果你使用类似 Map 这样的边界接口，就把它保留在类或近亲类中。避免从公共 API 中返回边界接口，或将边界接口作为参数传递给公共 API。\n 8.2 EXPLORING AND LEARNING BOUNDARIES 浏览和学习边界 #  Third-party code helps us get more functionality delivered in less time. Where do we start when we want to utilize some third-party package? It’s not our job to test the third-party code, but it may be in our best interest to write tests for the third-party code we use.\n 第三方代码帮助我们在更少时间内发布更丰富的功能。在利用第三方程序包时，该从何处入手呢？我们没有测试第三方代码的职责，但为要使用的第三方代码编写测试，可能最符合我们的利益。\n Suppose it is not clear how to use our third-party library. We might spend a day or two (or more) reading the documentation and deciding how we are going to use it. Then we might write our code to use the third-party code and see whether it does what we think. We would not be surprised to find ourselves bogged down in long debugging sessions trying to figure out whether the bugs we are experiencing are in our code or theirs.\n 设想第三方代码库的使用方法并不清楚。我们可能会花上一两天（或者更多）时间阅读文档，决定如何使用。然后，我们会编写使用第三方代码的代码，看看是否如我们所愿地工作。陷入长时间的调试、找出在我们或他们代码中的缺陷，这可不是什么稀罕事。\n Learning the third-party code is hard. Integrating the third-party code is hard too. Doing both at the same time is doubly hard. What if we took a different approach? Instead of experimenting and trying out the new stuff in our production code, we could write some tests to explore our understanding of the third-party code. Jim Newkirk calls such tests learning tests.1\n 学习第三方代码很难。整合第三方代码也很难。同时做这两件事难上加难。如果我们采用不同的做法呢？不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码。Jim Newkirk 把这叫做学习性测试（learning tests）。\n In learning tests we call the third-party API, as we expect to use it in our application. We’re essentially doing controlled experiments that check our understanding of that API. The tests focus on what we want out of the API.\n 在学习性测试中，我们如在应用中那样调用第三方代码。我们基本上是在通过核对试验来检测自己对那个 API 的理解程度。测试聚焦于我们想从 API 得到的东西。\n 8.3 LEARNING LOG4J 学习 log4j #  Let’s say we want to use the apache log4j package rather than our own custom-built logger. We download it and open the introductory documentation page. Without too much reading we write our first test case, expecting it to write “hello” to the console.\n 比如，我们想使用 apache log4j 包来代替自定义的日志代码。我们下载了 log4j，打开介绍文档页。无需看太久，就编写了第一个测试用例，希望它能向控制台输出 hello 字样。\n @Test public void testLogCreate() { Logger logger = Logger.getLogger(\u0026#34;MyLogger\u0026#34;); logger.info(\u0026#34;hello\u0026#34;); } When we run it, the logger produces an error that tells us we need something called an Appender. After a little more reading we find that there is a ConsoleAppender. So we create a ConsoleAppender and see whether we have unlocked the secrets of logging to the console.\n 运行，logger 发生了一个错误，告诉我们需要用 Appender。再多读一点文档，我们发现有个 ConsoleAppender。于是我们创建了一个 ConsoleAppender，再看是否能解开向控制台输出日志的秘诀。\n @Test public void testLogAddAppender() { Logger logger = Logger.getLogger(\u0026#34;MyLogger\u0026#34;); ConsoleAppender appender = new ConsoleAppender(); logger.addAppender(appender); logger.info(\u0026#34;hello\u0026#34;); } This time we find that the Appender has no output stream. Odd—it seems logical that it’d have one. After a little help from Google, we try the following:\n 比如，我们想使用 apache log4j 包来代替自定义的日志代码。我们下载了 log4j，打开介绍文档页。无需看太久，就编写了第一个测试用例，希望它能向控制台输出 hello 字样。\n @Test public void testLogAddAppender() { Logger logger = Logger.getLogger(\u0026#34;MyLogger\u0026#34;); logger.removeAllAppenders(); logger.addAppender(new ConsoleAppender( new PatternLayout(\u0026#34;%p %t %m%n\u0026#34;), ConsoleAppender.SYSTEM_OUT)); logger.info(\u0026#34;hello\u0026#34;); } That worked; a log message that includes “hello” came out on the console! It seems odd that we have to tell the ConsoleAppender that it writes to the console.\n 这回行了；hello 字样的日志信息出现在控制台上！必须告知 ConsoleAppender，让它往控制台写字，看起来有点奇怪。\n Interestingly enough, when we remove the ConsoleAppender.SystemOut argument, we see that “hello” is still printed. But when we take out the PatternLayout, it once again complains about the lack of an output stream. This is very strange behavior.\n 很有趣，当我们移除 ConsoleAppender.SystemOut 参数时，那个 hello 字样仍然输出到屏幕上。但如果取走 PatternLayout，就会出现关于没有输出流的错误信息。这实在太古怪了。\n Looking a little more carefully at the documentation, we see that the default ConsoleAppender constructor is “unconfigured,” which does not seem too obvious or useful. This feels like a bug, or at least an inconsistency, in log4j.\n 再仔细看看文档，我们看到默认的 ConsoleAppender 构造器是“未配置”的，这看起来并不明显或没什么用，反而像是 log4j 的一个缺陷，或者至少是前后不太一致。\n A bit more googling, reading, and testing, and we eventually wind up with Listing 8-1. We’ve discovered a great deal about the way that log4j works, and we’ve encoded that knowledge into a set of simple unit tests.\n 再搜索、阅读、测试，最终我们得到代码清单 8-1。我们极大地发掘了 log4j 的工作方式，也将得到的知识融入了一系列简单的单元测试中。\n Listing 8-1 LogTest.java\n 代码清单 8-1 LogTest.java\n public class LogTest { private Logger logger; @Before public void initialize() { logger = Logger.getLogger(\u0026#34;logger\u0026#34;); logger.removeAllAppenders(); Logger.getRootLogger().removeAllAppenders(); } @Test public void basicLogger() { BasicConfigurator.configure(); logger.info(\u0026#34;basicLogger\u0026#34;); } @Test public void addAppenderWithStream() { logger.addAppender(new ConsoleAppender( new PatternLayout(\u0026#34;%p %t %m%n\u0026#34;), ConsoleAppender.SYSTEM_OUT)); logger.info(\u0026#34;addAppenderWithStream\u0026#34;); } @Test public void addAppenderWithoutStream() { logger.addAppender(new ConsoleAppender( new PatternLayout(\u0026#34;%p %t %m%n\u0026#34;))); logger.info(\u0026#34;addAppenderWithoutStream\u0026#34;); } } Now we know how to get a simple console logger initialized, and we can encapsulate that knowledge into our own logger class so that the rest of our application is isolated from the log4j boundary interface.\n 现在我们知道如何初始化一个简单的控制台日志器，也能把这些知识封装到自己的日志类中，好将应用程序的其他部分与 log4j 的边界接口隔离开来。\n 8.4 LEARNING TESTS ARE BETTER THAN FREE 学习性测试的好处不只是免费 #  The learning tests end up costing nothing. We had to learn the API anyway, and writing those tests was an easy and isolated way to get that knowledge. The learning tests were precise experiments that helped increase our understanding.\n 学习性测试毫无成本。无论如何我们都得学习要使用的 API，而编写测试则是获得这些知识的容易而不会影响其他工作的途径。学习性测试是一种精确试验，帮助我们增进对 API 的理解。\n Not only are learning tests free, they have a positive return on investment. When there are new releases of the third-party package, we run the learning tests to see whether there are behavioral differences.\n 学习性测试不光免费，还在投资上有正面的回报。当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。\n Learning tests verify that the third-party packages we are using work the way we expect them to. Once integrated, there are no guarantees that the third-party code will stay compatible with our needs. The original authors will have pressures to change their code to meet new needs of their own. They will fix bugs and add new capabilities. With each release comes new risk. If the third-party package changes in some way incompatible with our tests, we will find out right away.\n 学习性测试确保第三方程序包按照我们想要的方式工作。一旦整合进来，就不能保证第三方代码总与我们的需要兼容。原作者不得不修改代码来满足他们自己的新需要。他们会修正缺陷、添加新功能。风险伴随新版本而来。如果第三方程序包的修改与测试不兼容，我们也能马上发现。\n Whether you need the learning provided by the learning tests or not, a clean boundary should be supported by a set of outbound tests that exercise the interface the same way the production code does. Without these boundary tests to ease the migration, we might be tempted to stay with the old version longer than we should.\n 无论你是否需要通过学习性测试来学习，总要有一系列与生产代码中调用方式一致的输出测试来支持整洁的边界。不使用这些边界测试来减轻迁移的劳力，我们可能会超出应有时限，长久地绑在旧版本上面。\n 8.5 USING CODE THAT DOES NOT YET EXIST 使用尚不存在的代码 #  There is another kind of boundary, one that separates the known from the unknown. There are often places in the code where our knowledge seems to drop off the edge. Sometimes what is on the other side of the boundary is unknowable (at least right now). Sometimes we choose to look no farther than the boundary.\n 还有另一种边界，那种将已知和未知分隔开的边界。在代码中总有许多地方是我们的知识未及之处。有时，边界那边就是未知的（至少目前未知）。有时，我们并不往边界那边看过去。\n A number of years back I was part of a team developing software for a radio communications system. There was a subsystem, the “Transmitter,” that we knew little about, and the people responsible for the subsystem had not gotten to the point of defining their interface. We did not want to be blocked, so we started our work far away from the unknown part of the code.\n 好多年以前，我曾在一个开发无线通信系统软件的团队中工作。该系统有个子系统 Transmitter（发送机）。我们对 Transmitter 知之甚少，而该子系统的开发者还没有对接口进行定义。我们不想受这种事阻碍，就从距未知那部分代码很远处开始工作。\n We had a pretty good idea of where our world ended and the new world began. As we worked, we sometimes bumped up against this boundary. Though mists and clouds of ignorance obscured our view beyond the boundary, our work made us aware of what we wanted the boundary interface to be. We wanted to tell the transmitter something like this:\n 对于我们的世界如何结束、新世界如何开始，我们有许多好主意。工作时，我们偶尔会跨越那道边界。尽管云雾遮挡了我们看向边界那边的视线，我们还是从工作中了解到我们想要的边界接口是什么样的。我们想要告知发送机一些事：\n Key the transmitter on the provided frequency and emit an analog representation of the data coming from this stream.\n 对于我们的世界如何结束、新世界如何开始，我们有许多好主意。工作时，我们偶尔会跨越那道边界。\n We had no idea how that would be done because the API had not been designed yet. So we decided to work out the details later.\n 尽管云雾遮挡了我们看向边界那边的视线，我们还是从工作中了解到我们想要的边界接口是什么样的。我们想要告知发送机一些事：\n To keep from being blocked, we defined our own interface. We called it something catchy, like Transmitter. We gave it a method called transmit that took a frequency and a data stream. This was the interface we wished we had.\n 为了不受阻碍，我们定义了自己使用的接口。我们给它取了个好记的名字，比如 Transmitter。我们给它写了个名为 transmit 的方法，获取频率参数和数据流。这就是我们希望得到的接口。\n One good thing about writing the interface we wish we had is that it’s under our control. This helps keep client code more readable and focused on what it is trying to accomplish.\n 编写我们想得到的接口，好处之一是它在我们控制之下。这有助于保持客户代码更可读，且集中于它该完成的工作。\n In Figure 8-2, you can see that we insulated the CommunicationsController classes from the transmitter API (which was out of our control and undefined). By using our own application specific interface, we kept our CommunicationsController code clean and expressive. Once the transmitter API was defined, we wrote the TransmitterAdapter to bridge the gap. The ADAPTER2 encapsulated the interaction with the API and provides a single place to change when the API evolves.\n 在图 8-2 中可以看到，我们将 CommunicationsController 类从发送器 API（该 API 不受我们控制，而且还没定义）中隔离出来。通过使用符合应用程序的接口，CommunicationsController 代码整洁且足以表达其意图。一旦发送器 API 被定义出来，我们就编写 TransmitterAdapter 来跨接。ADAPTER 封装了与 API 的互动，也提供了一个当 API 发生变动时唯一需要改动的地方。\n Figure 8-2 Predicting the transmitter\n This design also gives us a very convenient seam3 in the code for testing. Using a suitable FakeTransmitter, we can test the CommunicationsController classes. We can also create boundary tests once we have the TransmitterAPI that make sure we are using the API correctly.\n 这套设计方案为测试提供了一种极为方便的接缝。使用适当的 FakeTransmitter，我们就能测试 CommunicationsController 类。在拿到 TransmitterAPI 时，我们也能创建确保正确使用 API 的边界测试。\n 8.6 CLEAN BOUNDARIES 整洁的边界 #  Interesting things happen at boundaries. Change is one of those things. Good software designs accommodate change without huge investments and rework. When we use code that is out of our control, special care must be taken to protect our investment and make sure future change is not too costly.\n 边界上会发生有趣的事。改动是其中之一。有良好的软件设计，无需巨大投入和重写即可进行修改。在使用我们控制不了的代码时，必须加倍小心保护投资，确保未来的修改不至于代价太大。\n Code at the boundaries needs clear separation and tests that define expectations. We should avoid letting too much of our code know about the third-party particulars. It’s better to depend on something you control than on something you don’t control, lest it end up controlling you.\n 边界上的代码需要清晰的分割和定义了期望的测试。应该避免我们的代码过多地了解第三方代码中的特定信息。依靠你能控制的东西，好过依靠你控制不了的东西，免得日后受它控制。\n We manage third-party boundaries by having very few places in the code that refer to them. We may wrap them as we did with Map, or we may use an ADAPTER to convert from our perfect interface to the provided interface. Either way our code speaks to us better, promotes internally consistent usage across the boundary, and has fewer maintenance points when the third-party code changes.\n 我们通过代码中少数几处引用第三方边界接口的位置来管理第三方边界。可以像我们对待 Map 那样包装它们，也可以使用 ADAPTER 模式将我们的接口转换为第三方提供的接口。采用这两种方式，代码都能更好地与我们沟通，在边界两边推动内部一致的用法，当第三方代码有改动时修改点也会更少。\n "});index.add({'id':212,'href':'/docs/Clean-Code/9.-Unit-Tests/ch9/','title':"Ch9",'section':"Go语言圣经",'content':"第 9 章 Unit Tests 单元测试 #   Our profession has come a long way in the last ten years. In 1997 no one had heard of Test Driven Development. For the vast majority of us, unit tests were short bits of throw-away code that we wrote to make sure our programs “worked.” We would painstakingly write our classes and methods, and then we would concoct some ad hoc code to test them. Typically this would involve some kind of simple driver program that would allow us to manually interact with the program we had written.\n 过去十年以来，编程专业领域进步很大。1997 年时，没人听说过测试驱动开发。对于我们之中的大多数人来说，单元测试是那种用来确保程序“可运行”的用过即扔的短代码。我们辛勤地编写类和方法，再弄出一些特殊代码来测试它们。通常这会是种简单的驱动式程序，让我们能够手工与自己编写的程序交互。\n I remember writing a C++ program for an embedded real-time system back in the mid-90s. The program was a simple timer with the following signature:\n 我记得在 20 世纪 90 年代曾为一套嵌入式实时系统编写过 C++程序。该程序是个简单的计时器，有如下签名：\n void Timer::ScheduleCommand(Command* theCommand, int milliseconds) The idea was simple; the execute method of the Command would be executed in a new thread after the specified number of milliseconds. The problem was, how to test it.\n 想法很简单；到达指定毫秒数时，在一个新线程中执行 Command 的 excute 方法。问题在于如何测试它。\n I cobbled together a simple driver program that listened to the keyboard. Every time a character was typed, it would schedule a command that would type the same character five seconds later. Then I tapped out a rhythmic melody on the keyboard and waited for that melody to replay on the screen five seconds later.\n 我随便写了个简单的驱动式程序，聆听来自键盘的动作。键盘输入一个字符时，它就安排 5 秒钟之后输出同样的字符。我输入了一句带节奏的歌词，然后等着 5 秒钟之后它在屏幕上重现出来。\n “I … want-a-girl … just … like-the-girl-who-marr … ied … dear … old … dad.”\nI actually sang that melody while typing the “.” key, and then I sang it again as the dots appeared on the screen.\n 在按下那些“.”键时，我真的在哼着那段旋律，当那些句点出现在屏幕上时，我又再哼了一次。\n That was my test! Once I saw it work and demonstrated it to my colleagues, I threw the test code away.\n 那就是我的测试！我看到这法子可行，演示给同事们看，然后就把代码扔掉了。\n As I said, our profession has come a long way. Nowadays I would write a test that made sure that every nook and cranny of that code worked as I expected it to. I would isolate my code from the operating system rather than just calling the standard timing functions. I would mock out those timing functions so that I had absolute control over the time. I would schedule commands that set boolean flags, and then I would step the time forward, watching those flags and ensuring that they went from false to true just as I changed the time to the right value.\n 如前文所述，我们的专业领域进步甚多。如今，我会编写测试，确保代码中每个犄角旮旯都如我所愿地工作。我会将代码和操作系统隔离开，而不是直接调用标准计时功能。我会伪造一套计时函数，这样就能全面控制时间。我会安排一些设置布尔值标识的命令，往前步进时间，查看这些标识，确保它们在我将时间调到正确值时由 false 变为 true。\n Once I got a suite of tests to pass, I would make sure that those tests were convenient to run for anyone else who needed to work with the code. I would ensure that the tests and the code were checked in together into the same source package.\n 有了一套运行通过的测试，我会确保任何需要用到代码的人都能方便地使用这些测试。我会确保测试和代码一起签入同一个代码包。\n Yes, we’ve come a long way; but we have farther to go. The Agile and TDD movements have encouraged many programmers to write automated unit tests, and more are joining their ranks every day. But in the mad rush to add testing to our discipline, many programmers have missed some of the more subtle, and important, points of writing good tests.\n 对，我们进步甚多；但还有很长的路要走。敏捷和 TDD 运动鼓舞了许多程序员编写自动化单元测试，每天还有更多人加入这个行列。但是，在争先恐后将测试加入规程中时，许多程序员遗漏了一些关于编写好测试的更细微但却重要的要点。\n 9.1 THE THREE LAWS OF TDD TDD 三定律 #  By now everyone knows that TDD asks us to write unit tests first, before we write production code. But that rule is just the tip of the iceberg. Consider the following three laws:\n 谁都知道 TDD 要求我们在编写生产代码前先编写单元测试。但这条规则只是冰山之巅。看看下列三定律：\n http://doi.ieeecomputersociety.org/10.1109/MS.2007.85\nFirst Law You may not write production code until you have written a failing unit test.\n 定律一 在编写不能通过的单元测试前，不可编写生产代码。\n Second Law You may not write more of a unit test than is sufficient to fail, and not compiling is failing.\n 定律二 只可编写刚好无法通过的单元测试，不能编译也算不通过。\n Third Law You may not write more production code than is sufficient to pass the currently failing test.\n 定律三 只可编写刚好足以通过当前失败测试的生产代码。\n These three laws lock you into a cycle that is perhaps thirty seconds long. The tests and the production code are written together, with the tests just a few seconds ahead of the production code.\n 这三条定律将你限制在大概 30 秒一个的循环中。测试与生产代码一起编写，测试只比生产代码早写几秒钟。\n If we work this way, we will write dozens of tests every day, hundreds of tests every month, and thousands of tests every year. If we work this way, those tests will cover virtually all of our production code. The sheer bulk of those tests, which can rival the size of the production code itself, can present a daunting management problem.\n 这样写程序，我们每天就会编写数十个测试，每个月编写数百个测试，每年编写数千个测试。这样写程序，测试将覆盖所有生产代码。测试代码量足以匹敌生产代码量，导致令人生畏的管理问题。\n 9.2 KEEPING TESTS CLEAN 保持测试整洁 #  Some years back I was asked to coach a team who had explicitly decided that their test code should not be maintained to the same standards of quality as their production code. They gave each other license to break the rules in their unit tests. “Quick and dirty” was the watchword. Their variables did not have to be well named, their test functions did not need to be short and descriptive. Their test code did not need to be well designed and thoughtfully partitioned. So long as the test code worked, and so long as it covered the production code, it was good enough.\n 几年前，有人请我去指导一个开发团队。那个团队认定，测试代码的维护不应遵循生产代码的质量标准。他们彼此默许在单元测试中破坏规矩。“速而不周”成了团队格言。变量命名不用好，测试函数不必短小和具有描述性。测试代码不必做良好设计和仔细划分。只要测试代码还能工作，只要还覆盖着生产代码，就足够好。\n Some of you reading this might sympathize with that decision. Perhaps, long in the past, you wrote tests of the kind that I wrote for that Timer class. It’s a huge step from writing that kind of throw-away test, to writing a suite of automated unit tests. So, like the team I was coaching, you might decide that having dirty tests is better than having no tests.\n 有些读者可能会同意这种做法。或许，在很久以前，你也用过我为那个 Timer 类写测试的方法。从编写那种用后即扔的测试到编写全套自动化单元测试是一大进步。所以，就像那个我指导过的团队一样，你或许也会认为脏测试好过没测试。\n What this team did not realize was that having dirty tests is equivalent to, if not worse than, having no tests. The problem is that tests must change as the production code evolves. The dirtier the tests, the harder they are to change. The more tangled the test code, the more likely it is that you will spend more time cramming new tests into the suite than it takes to write the new production code. As you modify the production code, old tests start to fail, and the mess in the test code makes it hard to get those tests to pass again. So the tests become viewed as an ever-increasing liability.\n 这个团队没有意识到的是，脏测试等同于——如果不是坏于的话 ——没测试。问题在于，测试必须随生产代码的演进而修改。测试越脏，就越难修改。测试代码越缠结，你就越有可能花更多时间塞进新测试，而不是编写新生产代码。修改生产代码后，旧测试就会开始失败，而测试代码中乱七八糟的东西将阻碍代码再次通过。于是，测试变得就像是不断翻番的债务。\n From release to release the cost of maintaining my team’s test suite rose. Eventually it became the single biggest complaint among the developers. When managers asked why their estimates were getting so large, the developers blamed the tests. In the end they were forced to discard the test suite entirely.\n随着版本递进，团队维护测试代码组的代价也在上升。最终，它变成了开发者最大的抱怨对象。当经理们问及为何超支如此巨大，开发者们就归咎于测试。最后，他们只能扔掉了整个测试代码组。\nBut, without a test suite they lost the ability to make sure that changes to their code base worked as expected. Without a test suite they could not ensure that changes to one part of their system did not break other parts of their system. So their defect rate began to rise. As the number of unintended defects rose, they started to fear making changes. They stopped cleaning their production code because they feared the changes would do more harm than good. Their production code began to rot. In the end they were left with no tests, tangled and bug-riddled production code, frustrated customers, and the feeling that their testing effort had failed them.\n 但是，没有了测试代码组，他们就失去了确保对代码的改动能如愿工作的能力。没有了测试代码组，他们就无法确保对系统某个部分的修改不会影响到系统的其他部分。故障率开始增加。随着并非出自有意的故障越来越多，他们开始害怕做改动。他们不再清理生产代码，因为他们害怕修改带来的损害多于收益。生产代码开始腐坏。最后，他们只剩下没有测试、纷乱而缺陷缠身的生产代码，沮丧的客户，还有对测试的失望。\n In a way they were right. Their testing effort had failed them. But it was their decision to allow the tests to be messy that was the seed of that failure. Had they kept their tests clean, their testing effort would not have failed. I can say this with some certainty because I have participated in, and coached, many teams who have been successful with clean unit tests.\n 在某种意义上，他们说对了。测试的确让他们失望。不过是他们自己决定让测试变得乱七八糟的，而那正是失败的根源。如果他们保持测试整洁，测试就不会令他们失望。我可以拍着胸脯这么说，因为我曾经参与并指导了多个凭借整洁单元测试获得成功的团队。\n The moral of the story is simple: Test code is just as important as production code. It is not a second-class citizen. It requires thought, design, and care. It must be kept as clean as production code.\n 故事的寓意很简单：测试代码和生产代码一样重要。它可不是二等公民。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。\n Tests Enable the -ilities 测试带来一切好处 #  If you don’t keep your tests clean, you will lose them. And without them, you lose the very thing that keeps your production code flexible. Yes, you read that correctly. It is unit tests that keep our code flexible, maintainable, and reusable. The reason is simple. If you have tests, you do not fear making changes to the code! Without tests every change is a possible bug. No matter how flexible your architecture is, no matter how nicely partitioned your design, without tests you will be reluctant to make changes because of the fear that you will introduce undetected bugs.\n 如果测试不能保持整洁，你就会失去它们。没有了测试，你就会失去保证生产代码可扩展的一切要素。你没看错。正是单元测试让你的代码可扩展、可维护、可复用。原因很简单。有了测试，你就不担心对代码的修改！没有测试，每次修改都可能带来缺陷。无论架构多有扩展性，无论设计划分得有多好，没有了测试，你就很难做改动，因为你担忧改动会引入不可预知的缺陷。\n But with tests that fear virtually disappears. The higher your test coverage, the less your fear. You can make changes with near impunity to code that has a less than stellar architecture and a tangled and opaque design. Indeed, you can improve that architecture and design without fear!\n 有了测试，愁云一扫而空。测试覆盖率越高，你就越不担心。哪怕是对于那种架构并不优秀、设计晦涩纠缠的代码，你也能近乎没有后患地做修改。实际上，你能毫无顾虑地改进架构和设计！\n So having an automated suite of unit tests that cover the production code is the key to keeping your design and architecture as clean as possible. Tests enable all the -ilities, because tests enable change.\n 所以，覆盖了生产代码的自动化单元测试程序组能尽可能地保持设计和架构的整洁。测试带来了一切好处，因为测试使改动变得可能。\n So if your tests are dirty, then your ability to change your code is hampered, and you begin to lose the ability to improve the structure of that code. The dirtier your tests, the dirtier your code becomes. Eventually you lose the tests, and your code rots.\n 如果测试不干净，你改动自己代码的能力就有所牵制，而你也会开始失去改进代码结构的能力。测试越脏，代码就会变得越脏。最终，你丢失了测试，代码开始腐坏。\n 9.3 CLEAN TESTS 整洁的测试 #  What makes a clean test? Three things. Readability, readability, and readability. Readability is perhaps even more important in unit tests than it is in production code. What makes tests readable? The same thing that makes all code readable: clarity, simplicity, and density of expression. In a test you want to say a lot with as few expressions as possible.\n 整洁的测试有什么要素？有三个要素：可读性，可读性和可读性。在单元测试中，可读性甚至比在生产代码中还重要。测试如何才能做到可读？和其他代码中一样：明确，简洁，还有足够的表达力。在测试中，你要以尽可能少的文字表达大量内容。\n Consider the code from FitNesse in Listing 9-1. These three tests are difficult to understand and can certainly be improved. First, there is a terrible amount of duplicate code [G5] in the repeated calls to addPage and assertSubString. More importantly, this code is just loaded with details that interfere with the expressiveness of the test.\n 来看看代码清单 9-1 中来自 FitNesse 的代码。这三个测试很难读懂，显然有改善空间。首先，其中有数量恐怖的重复代码[G5]调用 addPage 和 assertSubString。更重要的是，代码中充满了干扰测试表达力的细节。\n Listing 9-1 SerializedPageResponderTest.java\n 代码清单 9-1 SerializedPageResponderTest.java\n public void testGetPageHieratchyAsXml() throws Exception { crawler.addPage(root, PathParser.parse(\u0026#34;PageOne\u0026#34;)); crawler.addPage(root, PathParser.parse(\u0026#34;PageOne.ChildOne\u0026#34;)); crawler.addPage(root, PathParser.parse(\u0026#34;PageTwo\u0026#34;)); request.setResource(\u0026#34;root\u0026#34;); request.addInput(\u0026#34;type\u0026#34;, \u0026#34;pages\u0026#34;); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse( new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(\u0026#34;text / xml\u0026#34;, response.getContentType()); assertSubString(\u0026#34; \u0026lt; name \u0026gt; PageOne \u0026lt;/name \u0026gt;\u0026#34;, xml); assertSubString(\u0026#34; \u0026lt; name \u0026gt; PageTwo \u0026lt;/name \u0026gt;\u0026#34;, xml); assertSubString(\u0026#34; \u0026lt; name \u0026gt; ChildOne \u0026lt;/name \u0026gt;\u0026#34;, xml); } public void testGetPageHieratchyAsXmlDoesntContainSymbolicLinks() throws Exception { WikiPage pageOne = crawler.addPage(root, PathParser.parse(\u0026#34;PageOne\u0026#34;)); crawler.addPage(root, PathParser.parse(\u0026#34;PageOne.ChildOne\u0026#34;)); crawler.addPage(root, PathParser.parse(\u0026#34;PageTwo\u0026#34;)); PageData data = pageOne.getData(); WikiPageProperties properties = data.getProperties(); WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME); symLinks.set(\u0026#34;SymPage\u0026#34;, \u0026#34;PageTwo\u0026#34;); pageOne.commit(data); request.setResource(\u0026#34;root\u0026#34;); request.addInput(\u0026#34;type\u0026#34;, \u0026#34;pages\u0026#34;); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse( new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(\u0026#34;text/xml\u0026#34;, response.getContentType()); assertSubString(\u0026#34;\u0026lt;name\u0026gt;PageOne\u0026lt;/name\u0026gt;\u0026#34;, xml); assertSubString(\u0026#34;\u0026lt;name\u0026gt;PageTwo\u0026lt;/name\u0026gt;\u0026#34;, xml); assertSubString(\u0026#34;\u0026lt;name\u0026gt;ChildOne\u0026lt;/name\u0026gt;\u0026#34;, xml); assertNotSubString(\u0026#34;SymPage\u0026#34;, xml); } public void testGetDataAsHtml() throws Exception { crawler.addPage(root, PathParser.parse(\u0026#34;TestPageOne\u0026#34;), \u0026#34;test page\u0026#34;); request.setResource(\u0026#34;TestPageOne\u0026#34;); request.addInput(\u0026#34;type\u0026#34;, \u0026#34;data\u0026#34;); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse( new FitNesseContext(root), request); String xml = response.getContent(); assertEquals(\u0026#34;text/xml\u0026#34;, response.getContentType()); assertSubString(\u0026#34;test page\u0026#34;, xml); assertSubString(\u0026#34;\u0026lt;Test\u0026#34;, xml); } For example, look at the PathParser calls. They transform strings into PagePath instances used by the crawlers. This transformation is completely irrelevant to the test at hand and serves only to obfuscate the intent. The details surrounding the creation of the responder and the gathering and casting of the response are also just noise. Then there’s the ham-handed way that the request URL is built from a resource and an argument. (I helped write this code, so I feel free to roundly criticize it.)\n 请看对 PathParser 的那些调用。它们将字符串转换为供爬虫使用的 PagePath 实体。转换与测试毫无关系，徒然混淆了代码的意图。与创建 responder 相关的细节，还有 response 的收集与转换也尽是噪声。此外还有从 resource 和参数构造请求 URL 的笨手段。（这些代码我有幸参与编写，所以可以敞开来批评。）\n In the end, this code was not designed to be read. The poor reader is inundated with a swarm of details that must be understood before the tests make any real sense.\n 最终，这段代码不是设计来给人看的。可怜的读者淹没在细节的汪洋大海中，在真正用到测试之前，还得理解这些细节。\n Now consider the improved tests in Listing 9-2. These tests do the exact same thing, but they have been refactored into a much cleaner and more explanatory form.\n 现在看看代码清单 9-2 中改进了的测试。这些测试还是做一样的事，不过已经被重构为更整洁和有表达力的形式。\n Listing 9-2 SerializedPageResponderTest.java (refactored)\n 代码清单 9-2 SerializedPageResponderTest.java（重构后）\n public void testGetPageHierarchyAsXml() throws Exception { makePages(\u0026#34;PageOne\u0026#34;, \u0026#34;PageOne.ChildOne\u0026#34;, \u0026#34;PageTwo\u0026#34;); submitRequest(\u0026#34;root\u0026#34;, \u0026#34;type:pages\u0026#34;); assertResponseIsXML(); assertResponseContains( \u0026#34;\u0026lt;name\u0026gt;PageOne\u0026lt;/name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;PageTwo\u0026lt;/name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;ChildOne\u0026lt;/name\u0026gt;\u0026#34; ); } public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception { WikiPage page = makePage(\u0026#34;PageOne\u0026#34;); makePages(\u0026#34;PageOne.ChildOne\u0026#34;, \u0026#34;PageTwo\u0026#34;); addLinkTo(page, \u0026#34;PageTwo\u0026#34;, \u0026#34;SymPage\u0026#34;); submitRequest(\u0026#34;root\u0026#34;, \u0026#34;type:pages\u0026#34;); assertResponseIsXML(); assertResponseContains( \u0026#34;\u0026lt;name\u0026gt;PageOne\u0026lt;/name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;PageTwo\u0026lt;/name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;ChildOne\u0026lt;/name\u0026gt;\u0026#34; ); assertResponseDoesNotContain(\u0026#34;SymPage\u0026#34;); } public void testGetDataAsXml() throws Exception { makePageWithContent(\u0026#34;TestPageOne\u0026#34;, \u0026#34;test page\u0026#34;); submitRequest(\u0026#34;TestPageOne\u0026#34;, \u0026#34;type:data\u0026#34;); assertResponseIsXML(); assertResponseContains(\u0026#34;test page\u0026#34;, \u0026#34;\u0026lt;Test\u0026#34;); } The BUILD-OPERATE-CHECK2 pattern is made obvious by the structure of these tests. Each of the tests is clearly split into three parts. The first part builds up the test data, the second part operates on that test data, and the third part checks that the operation yielded the expected results.\n 这些测试显然呈现了构造-操作-检验（BUILD-OPERATE-CHECK）模式。每个测试都清晰地拆分为三个环节。第一个环节构造测试数据，第二个环节操作测试数据，第三个部分检验操作是否得到期望的结果。\n Notice that the vast majority of annoying detail has been eliminated. The tests get right to the point and use only the data types and functions that they truly need. Anyone who reads these tests should be able to work out what they do very quickly, without being misled or overwhelmed by details.\n 注意，那些恼人的细节大部分消失了。测试直达目的，只用到那些真正需要的数据类型和函数。读测试的人应该都能够很快搞清楚状况，不至于被细节误导或吓倒。\n 9.3.1 Domain-Specific Testing Language 面向特定领域的测试语言 #  The tests in Listing 9-2 demonstrate the technique of building a domain-specific language for your tests. Rather than using the APIs that programmers use to manipulate the system, we build up a set of functions and utilities that make use of those APIs and that make the tests more convenient to write and easier to read. These functions and utilities become a specialized API used by the tests. They are a testing language that programmers use to help themselves to write their tests and to help those who must read those tests later on.\n 代码清单 9-2 中的测试展示了为测试构造一种面向特定领域的语言的技巧。我们没有直接使用程序员用来对系统进行操作的 API，而是打造了一套包装这些 API 的函数和工具代码，这样就能更方便地编写测试，写出来的测试也更便于阅读。那正是一种测试语言，可以帮助程序员编写自己的测试，也可以帮助后来者阅读测试。\n This testing API is not designed up front; rather it evolves from the continued refactoring of test code that has gotten too tainted by obfuscating detail. Just as you saw me refactor Listing 9-1 into Listing 9-2, so too will disciplined developers refactor their test code into more succinct and expressive forms.\n 这种测试 API 并非起初就设计出来，而是在对那些充满令人迷惑细节的测试代码进行后续重构时逐渐演进。如同你看见我将代码清单 9-1 重构为代码清单 9-2 一般，守规矩的开发者也将他们的测试代码重构为更简洁和具有表达力的形式。\n 9.3.2 A Dual Standard 双重标准 #  In one sense the team I mentioned at the beginning of this chapter had things right. The code within the testing API does have a different set of engineering standards than production code. It must still be simple, succinct, and expressive, but it need not be as efficient as production code. After all, it runs in a test environment, not a production environment, and those two environment have very different needs.\n 在某种意义上，本章开始处提到的那个团队的做法是正确的。测试 API 中的代码与生产代码相比，的确有一套不同的工程标准。测试代码应当简单、精悍、足具表达力，但它该和生产代码一般有效。毕竟它是在测试环境而非生产环境中运行，这两种环境有着截然不同的需求。\n Consider the test in Listing 9-3. I wrote this test as part of an environment control system I was prototyping. Without going into the details you can tell that this test checks that the low temperature alarm, the heater, and the blower are all turned on when the temperature is “way too cold.”\n 请看代码清单 9-3 中的测试。在为某个环境控制系统设计原型时，我写了这个测试。无需深入细节，你就能说出该测试在“温度太低”时检验温度警报器、加热器和送风机是否全部打开。\n Listing 9-3 EnvironmentControllerTest.java\n 代码清单 9-3 EnvironmentControllerTest.java\n @Test public void turnOnLoTempAlarmAtThreashold() throws Exception { hw.setTemp(WAY_TOO_COLD); controller.tic(); assertTrue(hw.heaterState()); assertTrue(hw.blowerState()); assertFalse(hw.coolerState()); assertFalse(hw.hiTempAlarm()); assertTrue(hw.loTempAlarm()); } There are, of course, lots of details here. For example, what is that tic function all about? In fact, I’d rather you not worry about that while reading this test. I’d rather you just worry about whether you agree that the end state of the system is consistent with the temperature being “way too cold.”\n 当然，这里头也有许多细节。例如，tic 函数是做什么的？实际上，在读测试时你可以不用担心这些问题。你只需考虑是否同意系统最终状态是否与“温度太低”的情况相符。\n Notice, as you read the test, that your eye needs to bounce back and forth between the name of the state being checked, and the sense of the state being checked. You see heaterState, and then your eyes glissade left to assertTrue. You see coolerState and your eyes must track left to assertFalse. This is tedious and unreliable. It makes the test hard to read.\n 当你阅读这个测试时，可以留意到自己的眼光得在被检验的状态的名称与状态的“意义”之间来回跳转。你看到 heaterState，眼光向左滑到 assertTrue。你看到 coolerState，眼光向左看 assertFalse。这个过程既乏味又不可靠。它让测试变得难以阅读。\n I improved the reading of this test greatly by transforming it into Listing 9-4.\n 我大幅改进了测试的可读性，得到代码清单 9-4。\n Listing 9-4 EnvironmentControllerTest.java (refactored)\n 代码清单 9-4 EnvironmentControllerTest.java（重构后）\n @Test public void turnOnLoTempAlarmAtThreshold() throws Exception { wayTooCold(); assertEquals(\u0026#34;HBchL\u0026#34;, hw.getState()); } Of course I hid the detail of the tic function by creating a wayTooCold function. But the thing to note is the strange string in the assertEquals. Upper case means “on,” lower case means “off,” and the letters are always in the following order: {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm}.\n 当然，我创建了一个 wayTooCold 函数，隐藏了 tic 函数的细节。不过要注意的是 assertEquals 中的那个奇怪的字符串。大写表示“打开”，小写表示“关闭”，那些字符遵循以下次序：{heater, blower, cooler, hitemp-alarm, lo-temp-alarm}。\n Even though this is close to a violation of the rule about mental mapping,3 it seems appropriate in this case. Notice, once you know the meaning, your eyes glide across that string and you can quickly interpret the results. Reading the test becomes almost a pleasure. Just take a look at Listing 9-5 and see how easy it is to understand these tests.\n 尽管这破坏了思维映射的规则，看来它在这种情况下还是适用的。只要你明白其含义，你就能一眼看到那个字符串，迅速译解出结果。\n Listing 9-5 EnvironmentControllerTest.java (bigger selection)\n 代码清单 9-5 EnvironmentControllerTest.java（扩展到更大范围）\n @Test public void turnOnCoolerAndBlowerIfTooHot() throws Exception { tooHot(); assertEquals(\u0026#34;hBChl\u0026#34;, hw.getState()); } @Test public void turnOnHeaterAndBlowerIfTooCold() throws Exception { tooCold(); assertEquals(\u0026#34;HBchl\u0026#34;, hw.getState()); } @Test public void turnOnHiTempAlarmAtThreshold() throws Exception { wayTooHot(); assertEquals(\u0026#34;hBCHl\u0026#34;, hw.getState()); } @Test public void turnOnLoTempAlarmAtThreshold() throws Exception { wayTooCold(); assertEquals(\u0026#34;HBchL\u0026#34;, hw.getState()); } The getState function is shown in Listing 9-6. Notice that this is not very efficient code. To make it efficient, I probably should have used a StringBuffer.\n 代码清单 9-6 中给出了 getState 函数。注意，代码效率不是非常高。要提升效率，可能应该使用 StringBuffer。\n Listing 9-6 MockControlHardware.java\n 代码清单 9-6 MockControlHardware.java\n public String getState() { String state = \u0026#34;\u0026#34;; state += heater ? \u0026#34;H\u0026#34; : \u0026#34;h\u0026#34;; state += blower ? \u0026#34;B\u0026#34; : \u0026#34;b\u0026#34;; state += cooler ? \u0026#34;C\u0026#34; : \u0026#34;c\u0026#34;; state += hiTempAlarm ? \u0026#34;H\u0026#34; : \u0026#34;h\u0026#34;; state += loTempAlarm ? \u0026#34;L\u0026#34; : \u0026#34;l\u0026#34;; return state; } StringBuffers are a bit ugly. Even in production code I will avoid them if the cost is small; and you could argue that the cost of the code in Listing 9-6 is very small. However, this application is clearly an embedded real-time system, and it is likely that computer and memory resources are very constrained. The test environment, however, is not likely to be constrained at all.\n StringBuffer 有点丑陋。即便在生产代码中，假使代价较小，我都会避免使用 StringBuffer；而且你可以看到，清单 9-6 中代码的代价的确很小。这套应用显然是嵌入式实时系统，计算机和内存资源都很有限。不过，测试环境大概完全不必做限制。\n That is the nature of the dual standard. There are things that you might never do in a production environment that are perfectly fine in a test environment. Usually they involve issues of memory or CPU efficiency. But they never involve issues of cleanliness.\n 这就是双重标准。有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题。通常这关乎内存或 CPU 效率的问题，不过却永远不会与整洁有关。\n 9.4 ONE ASSERT PER TEST 每个测试一个断言 #  There is a school of thought4 that says that every test function in a JUnit test should have one and only one assert statement. This rule may seem draconian, but the advantage can be seen in Listing 9-5. Those tests come to a single conclusion that is quick and easy to understand.\n 有个流派认为，JUnit 中每个测试函数都应该有且只有一个断言语句。这条规则看似过于苛求，但其好处却可以在代码清单 9-5 中看到。这些测试都归结为一个可快速方便地理解的结论。\n But what about Listing 9-2? It seems unreasonable that we could somehow easily merge the assertion that the output is XML and that it contains certain substrings. However, we can break the test into two separate tests, each with its own particular assertion, as shown in Listing 9-7.\n 代码清单 9-2 又如何？我们能将关于输出是 XML 的断言与输出包含某些子字符串的断言轻易地组合到一起，不过这样做看来毫无道理。然而，我们可以将测试分解为两个单独的测试，每个都有自己的断言，如代码清单 9-7 所示。\n Listing 9-7 SerializedPageResponderTest.java (Single Assert)\n 代码清单 9-7 SerializedPageResponderTest.java（单个断言的版本）\n public void testGetPageHierarchyAsXml() throws Exception { givenPages(\u0026#34;PageOne\u0026#34;, \u0026#34;PageOne.ChildOne\u0026#34;, \u0026#34;PageTwo\u0026#34;); whenRequestIsIssued(\u0026#34;root\u0026#34;, \u0026#34;type:pages\u0026#34;); thenResponseShouldBeXML(); } public void testGetPageHierarchyHasRightTags() throws Exception { givenPages(\u0026#34;PageOne\u0026#34;, \u0026#34;PageOne.ChildOne\u0026#34;, \u0026#34;PageTwo\u0026#34;); whenRequestIsIssued(\u0026#34;root\u0026#34;, \u0026#34;type:pages\u0026#34;); thenResponseShouldContain(\u0026#34;\u0026lt;name\u0026gt;PageOne\u0026lt;/name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;PageTwo\u0026lt;/name\u0026gt;\u0026#34;, \u0026#34;\u0026lt;name\u0026gt;ChildOne\u0026lt;/name\u0026gt;\u0026#34;); } Notice that I have changed the names of the functions to use the common given-when-then5 convention. This makes the tests even easier to read. Unfortunately, splitting the tests as shown results in a lot of duplicate code.\n 注意，我修改了那些函数的名称，以符合 given-when-then 约定。这让测试更易阅读。不幸的是，如此分解测试，导致了许多重复代码的出现。\n We can eliminate the duplication by using the TEMPLATE METHOD6 pattern and putting the given/when parts in the base class, and the then parts in different derivatives. Or we could create a completely separate test class and put the given and when parts in the @Before function, and the when parts in each @Test function. But this seems like too much mechanism for such a minor issue. In the end, I prefer the multiple asserts in Listing 9-2.\n 可以利用模板方法（TEMPLATE METHOD）模式，将 given/when 部分放到基类中，将 then 部分放到派生类中，消除代码重复问题。或者，我们也可以创建一个完整的单独测试类，把 given 和 when 部分放到@Before 函数中，把 when 部分放到每个@Test 函数中。但对于这个小问题，这看来有点太机械。最后，我还是保留了代码清单 9-2 那种多个断言的形式。\n I think the single assert rule is a good guideline.7 I usually try to create a domain-specific testing language that supports it, as in Listing 9-5. But I am not afraid to put more than one assert in a test. I think the best thing we can say is that the number of asserts in a test ought to be minimized.\n 我认为，单个断言是个好准则。我通常都会创建支持这条准则的特定领域测试语言，如代码清单 9-5 所示。不过，我也不害怕在单个测试中放入一个以上断言。我认为，最好的说法是单个测试中的断言数量应该最小化。\n Single Concept per Test 每个测试一个概念 #  Perhaps a better rule is that we want to test a single concept in each test function. We don’t want long test functions that go testing one miscellaneous thing after another. Listing 9-8 is an example of such a test. This test should be split up into three independent tests because it tests three independent things. Merging them all together into the same function forces the reader to figure out why each section is there and what is being tested by that section.\n 更好一些的规则或许是每个测试函数中只测试一个概念。我们不想要超长的测试函数，测试完这个又测试那个。代码清单 9-8 就是那样一种测试的例子。这个测试应当拆解为 3 个单独测试，因为它测试了 3 件不同的事。把三者混到一起，读者就不得不猜想每段代码出现的理由，以及那段代码到底要测试什么。\n Listing 9-8\n 代码清单 9-8\n /** * Miscellaneous tests for the addMonths() method. */ public void testAddMonths() { SerialDate d1 = SerialDate.createInstance(31, 5, 2004); SerialDate d2 = SerialDate.addMonths(1, d1); assertEquals(30, d2.getDayOfMonth()); assertEquals(6, d2.getMonth()); assertEquals(2004, d2.getYYYY()); SerialDate d3 = SerialDate.addMonths(2, d1); assertEquals(31, d3.getDayOfMonth()); assertEquals(7, d3.getMonth()); assertEquals(2004, d3.getYYYY()); SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)); assertEquals(30, d4.getDayOfMonth()); assertEquals(7, d4.getMonth()); assertEquals(2004, d4.getYYYY()); } The three test functions probably ought to be like this:\n 这三个测试函数大概应该像这个样子：\n  Given the last day of a month with 31 days (like May):   对于某个有 31 天的月份的最后一天（如五月）：\n  When you add one month, such that the last day of that month is the 30th (like June), then the date should be the 30th of that month, not the 31st.   （1） 增加一个该月份最末一天为 30 日（如六月）的月份时，日期应该是该月的 30 日而非 31 日。\n When you add two months to that date, such that the final month has 31 days, then the date should be the 31st.   （2） 增加最末月有 31 天的两个月时，日期应该是 31 日。\n  Given the last day of a month with 30 days in it (like June):   对于某个有 30 天的月份的最后一天（如六月）：\n When you add one month such that the last day of that month has 31 days, then the date should be the 30th, not the 31st.   增加一个有 31 天的月份时，日期应该是 30 日而非 31 日。\n Stated like this, you can see that there is a general rule hiding amidst the miscellaneous tests. When you increment the month, the date can be no greater than the last day of the month. This implies that incrementing the month on February 28th should yield March 28th. That test is missing and would be a useful test to write.\n 这样一来，你可以看到，在这些混杂的测试当中，隐藏有一条普遍规则。增加月份数时，日期不能大于该月份的最末一天。这意味着在 2 月 28 日增加月份数，就会得到 3 月 28 日。而这个测试应该有用，但被遗漏了。\n So it’s not the multiple asserts in each section of Listing 9-8 that causes the problem. Rather it is the fact that there is more than one concept being tested. So probably the best rule is that you should minimize the number of asserts per concept and test just one concept per test function.\n 并非是代码清单 9-8 中每个段落的多重断言导致问题。问题在于，有多个概念被测试，所以，最佳规则也许是应该尽可能减少每个概念的断言数量，每个测试函数只测试一个概念。\n 9.5 F.I.R.S.T. #  Clean tests follow five other rules that form the above acronym:\n 整洁的测试还遵循以下 5 条规则，这 5 条规则的首字母构成了本节标题：\n Fast Tests should be fast. They should run quickly. When tests run slow, you won’t want to run them frequently. If you don’t run them frequently, you won’t find problems early enough to fix them easily. You won’t feel as free to clean up the code. Eventually the code will begin to rot.\n 快速（Fast）测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。\n Independent Tests should not depend on each other. One test should not set up the conditions for the next test. You should be able to run each test independently and run the tests in any order you like. When tests depend on each other, then the first one to fail causes a cascade of downstream failures, making diagnosis difficult and hiding downstream defects.\n 独立（Independent）测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。\n Repeatable Tests should be repeatable in any environment. You should be able to run the tests in the production environment, in the QA environment, and on your laptop while riding home on the train without a network. If your tests aren’t repeatable in any environment, then you’ll always have an excuse for why they fail. You’ll also find yourself unable to run the tests when the environment isn’t available.\n 可重复（Repeatable）测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的接口。当环境条件不具备时，你也会无法运行测试。\n Self-Validating The tests should have a boolean output. Either they pass or fail. You should not have to read through a log file to tell whether the tests pass. You should not have to manually compare two different text files to see whether the tests pass. If the tests aren’t self-validating, then failure can become subjective and running the tests can require a long manual evaluation.\n 自足验证（Self-Validating）测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。\n Timely The tests need to be written in a timely fashion. Unit tests should be written just before the production code that makes them pass. If you write tests after the production code, then you may find the production code to be hard to test. You may decide that some production code is too hard to test. You may not design the production code to be testable.\n 及时（Timely）测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。\n 9.6 CONCLUSION 小结 #  We have barely scratched the surface of this topic. Indeed, I think an entire book could be written about clean tests. Tests are as important to the health of a project as the production code is. Perhaps they are even more important, because tests preserve and enhance the flexibility, maintainability, and reusability of the production code. So keep your tests constantly clean. Work to make them expressive and succinct. Invent testing APIs that act as domain-specific language that helps you write the tests.\n 我们只是触及了这个话题的表面。实际上，我认为应该为整洁的测试写上一整本书。对于项目的健康度，测试盒生产代码同等重要。或许测试更为重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。所以，保持测试整洁吧。让测试具有表达力并短小精悍。发明作为面向特定领域语言的测试 API，帮助自己编写测试。\n If you let the tests rot, then your code will rot too. Keep your tests clean.\n 如果你坐视测试腐坏，那么代码也会跟着腐坏。保持测试整洁吧。\n "});index.add({'id':213,'href':'/docs/Clean-Code/Appendix-A-Concurrency-II/apA/','title':"Ap A",'section':"Go语言圣经",'content':"附录 A 并发编程 II #  by Brett L. Schuchert\nThis appendix supports and amplifies the Concurrency chapter on page 177. It is written as a series of independent topics and you can generally read them in any order. There is some duplication between sections to allow for such reading.\n 本附录扩充了“并发编程”一章的内容，由一组相互独立的主题组成，你可以按随意顺序阅读。为了实现这样的阅读方式，节与节之间存在一些重复内容。\n A.1 CLIENT/SERVER EXAMPLE 客户端/服务器的例子 #  Imagine a simple client/server application. A server sits and waits listening on a socket for a client to connect. A client connects and sends a request.\n 想象一个简单的客户端/服务器应用程序。服务器在一个套接字上等待接受来自客户端的连接请求。客户端连接到服务器并发送请求。\n A.1.1 The Server 服务器 #  Here is a simplified version of a server application. Full source for this example is available starting on page 343, Client/Server Nonthreaded.\n 下面是服务器应用程序的简化版本代码。在后文“客户端/服务器非多线程版本”一节中有完整的代码。\n ServerSocket serverSocket = new ServerSocket(8009); while (keepProcessing) { try { Socket socket = serverSocket.accept(); process(socket); } catch (Exception e) { handle(e); } } This simple application waits for a connection, processes an incoming message, and then again waits for the next client request to come in. Here’s client code that connects to this server:\n 这个简单的应用等待连接请求，处理接收到的新消息，再等待下一个客户端请求。下面是连接到服务器的客户端代码：\n private void connectSendReceive(int i) { try { Socket socket = new Socket(“localhost”, PORT); MessageUtils.sendMessage(socket, Integer.toString(i)); MessageUtils.getMessage(socket); socket.close(); } catch (Exception e) { e.printStackTrace(); } } How well does this client/server pair perform? How can we formally describe that performance? Here’s a test that asserts that the performance is “acceptable”:\n 这对客户端/服务器程序运行得如何呢？怎样才能正式地描述其性能？下面是断言其性能“可接受”的测试：\n @Test(timeout = 10000) public void shouldRunInUnder10Seconds() throws Exception { Thread[] threads = createThreads(); startAllThreadsw(threads); waitForAllThreadsToFinish(threads); } The setup is left out to keep the example simple (see “ClientTest.java” on page 344). This test asserts that it should complete within 10,000 milliseconds.\n 为了让例子够简单，设置过程被忽略了（见后文 ClientText.java 部分）。测试断言程序应该在 10000 毫秒内完成。\n This is a classic example of validating the throughput of a system. This system should complete a series of client requests in ten seconds. So long as the server can process each individual client request in time, the test will pass.\n 这是个验证系统吞吐量的典型例子。系统应该在 10 秒钟以内完成一组客户端请求。只要服务器能在时限内处理每个客户端请求，测试就通过了。\n What happens if the test fails? Short of developing some kind of event polling loop, there is not much to do within a single thread that will make this code any faster. Will using multiple threads solve the problem? It might, but we need to know where the time is being spent. There are two possibilities:\n 如果测试失败会怎样？缺少了某些事件轮询机制，在单个线程上也没什么可让代码更快的手段。使用多线程能解决问题吗？可能会，我们先得了解什么地方耗费时间。下面是两种可能：\n  I/O—using a socket, connecting to a database, waiting for virtual memory swapping, and so on. Processor—numerical calculations, regular expression processing, garbage collection, and so on.     I/O——使用套接字、连接到数据库、等待虚拟内存交换等； 处理器——数值计算、正则表达式处理、垃圾回收等。   Systems typically have some of each, but for a given operation one tends to dominate. If the code is processor bound, more processing hardware can improve throughput, making our test pass. But there are only so many CPU cycles available, so adding threads to a processor-bound problem will not make it go faster.\n 以上在系统中都会部分存在，但对于特定的操作，其中之一会起主导作用。如果代码运行速度主要与处理器有关，增加处理器硬件就能提升吞吐量，从而通过测试。但 CPU 运算周期是有上限的，因此，只是增加线程的话并不会提升受处理器限制的代码的速度。\n On the other hand, if the process is I/O bound, then concurrency can increase efficiency. When one part of the system is waiting for I/O, another part can use that wait time to process something else, making more effective use of the available CPU.\n 另一方面，如果吞吐量与 I/O 有关，则并发编程能提升运行效率。当系统的某个部分在等待 I/O，另一部分就可以利用等待的时间处理其他事务，从而更有效地利用了 CPU 能力。\n A.1.2 Adding Threading 添加线程代码 #  Assume for the moment that the performance test fails. How can we improve the throughput so that the performance test passes? If the process method of the server is I/O bound, then here is one way to make the server use threads (just change the processMessage):\n 假定性能测试失败了。如何才能提高吞吐量、通过性能测试呢？如果服务器的 process 方法与 I/O 有关，就有个办法让服务器利用线程（只需要修改 processMessage）：\n void process(final Socket socket) { if (socket == null) return; Runnable clientHandler = new Runnable() { public void run() { try { String message = MessageUtils.getMessage(socket); MessageUtils.sendMessage(socket, “Processed: ” + message); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); } } }; Thread clientConnection = new Thread(clientHandler); clientConnection.start(); } Assume that this change causes the test to pass;1 the code is complete, correct?\n 假设修改后测试通过了。代码是否完整、正确了呢？\n A.1.3 Server Observations 观察服务器端 #  The updated server completes the test successfully in just over one second. Unfortunately, this solution is a bit naive and introduces some new problems.\n 修改了的服务器成功通过测试，只花费了一秒多钟时间。不幸的是，这种解决手段有点一厢情愿，而且导致了新问题产生。\n How many threads might our server create? The code sets no limit, so the we could feasibly hit the limit imposed by the Java Virtual Machine (JVM). For many simple systems this may suffice. But what if the system is meant to support many users on the public net? If too many users connect at the same time, the system might grind to a halt.\n 服务器应该创建多少个线程？代码没有设置上限，所以我们很有可能达到 Java 虚拟机（JVM）的限制。对于许多简单系统来说这无所谓。但如果系统要支持公众网络上的众多用户呢？如果有太多用户同时连接，系统就有可能挂掉。\n But set the behavioral problem aside for the moment. The solution shown has problems of cleanliness and structure. How many responsibilities does the server code have?\n 不过先把性能问题放到一边吧。这种手段还有整洁性和结构上的问题。服务器代码有多少种权责呢？\n  Socket connection management Client processing Threading policy Server shutdown policy     套接字连接管理； 客户端处理； 线程策略； 服务器关闭策略。   Unfortunately, all these responsibilities live in the process function. In addition, the code crosses many different levels of abstraction. So, small as the process function is, it needs to be repartitioned.\n 这些权责不幸全在 process 函数中。而且，代码跨越多个抽象层级。所以，即便 process 函数这么短小，还是需要再加以切分。\n The server has several reasons to change; therefore it violates the Single Responsibility Principle. To keep concurrent systems clean, thread management should be kept to a few, well-controlled places. What’s more, any code that manages threads should do nothing other than thread management. Why? If for no other reason than that tracking down concurrency issues is hard enough without having to unwind other nonconcurrency issues at the same time.\n 服务器有几个修改的原因，所以它违反了单一权责原则。要保持并发系统整洁，应该将线程管理代码约束于少数几处控制良好的地方。而且，管理线程的代码只应该做管理线程的事。为什么？即便无需同时考虑其他非多线程代码，跟踪并发问题都已经足够困难了。\n If we create a separate class for each of the responsibilities listed above, including the thread management responsibility, then when we change the thread management strategy, the change will impact less overall code and will not pollute the other responsibilities. This also makes it much easier to test all the other responsibilities without having to worry about threading. Here is an updated version that does just that:\n 如果为上述每个权责（包括线程管理权责在内）创建单独的类，当改动线程管理策略时，就会对整个代码产生较小影响，不至于污染其他权责。这样一来，也能在不担心线程问题的前提下测试所有其他权责。下面是修改过的版本：\n public void run() { while (keepProcessing) { try { ClientConnection clientConnection = connectionManager.awaitClient(); ClientRequestProcessor requestProcessor = new ClientRequestProcessor(clientConnection); clientScheduler.schedule(requestProcessor); } catch (Exception e) { e.printStackTrace(); } } connectionManager.shutdown(); } This now focuses all things thread-related into one place, clientScheduler. If there are concurrency problems, there is just one place to look:\n 所有与线程相关的东西都放到了 clientScheduler 里面。如果出现并发问题，只要看这个地方就好了：\n public interface ClientScheduler { void schedule(ClientRequestProcessor requestProcessor); } The current policy is easy to implement:\n 并发策略易于实现：\n public class ThreadPerRequestScheduler implements ClientScheduler { public void schedule(final ClientRequestProcessor requestProcessor) { Runnable runnable = new Runnable() { public void run() { requestProcessor.process(); } }; Thread thread = new Thread(runnable); thread.start(); } } Having isolated all the thread management into a single place, it is much easier to change the way we control threads. For example, moving to the Java 5 Executor framework involves writing a new class and plugging it in (Listing A-1).\n 把所有线程管理隔离到一个位置，修改控制线程的方式就容易多了。例如，移植到 Java 5 Executor 框架就只需要编写一个新类并插进来即可（如代码清单 A-1 所示）。\n Listing A-1 ExecutorClientScheduler.java\n 代码清单 A-1 ExecutorClientScheduler.java\n import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ExecutorClientScheduler implements ClientScheduler { Executor executor; public ExecutorClientScheduler(int availableThreads) { executor = Executors.newFixedThreadPool(availableThreads); } public void schedule(final ClientRequestProcessor requestProcessor) { Runnable runnable = new Runnable() { public void run() { requestProcessor.process(); } }; executor.execute(runnable); } } A.1.4 Conclusion 小结 #  Introducing concurrency in this particular example demonstrates a way to improve the throughput of a system and one way of validating that throughput through a testing framework. Focusing all concurrency code into a small number of classes is an example of applying the Single Responsibility Principle. In the case of concurrent programming, this becomes especially important because of its complexity.\n 本例介绍的并发编程，演示了一种提高系统吞吐量的方法，以及一种通过测试框架验证吞吐量的方法。将全部并发代码放到少数类中，是应用单一权责原则的范例。对于并发编程，因其复杂性，这一点尤其重要。\n A.2 POSSIBLE PATHS OF EXECUTION 执行的可能路径 #  Review the method incrementValue, a one-line Java method with no looping or branching:\n 复查没有循环或条件分支的单行 Java 方法 incrementValue：\n public class IdGenerator { int lastIdUsed; public int incrementValue() { return ++lastIdUsed; } } Ignore integer overflow and assume that only one thread has access to a single instance of IdGenerator. In this case there is a single path of execution and a single guaranteed result:\n 忽略整数溢出的情形，假定只有单个线程能访问 IdGenerator 的单个实体。这种情况下，只有一种执行路径和一个确定的结果：\n  The value returned is equal to the value of lastIdUsed, both of which are one greater than just before calling the method.    返回值等于 lastIdUsed 的值，两者都比调用方法前大 1。   What happens if we use two threads and leave the method unchanged? What are the possible outcomes if each thread calls incrementValue once? How many possible paths of execution are there? First, the outcomes (assume lastIdUsed starts with a value of 93):\n 如果使用两个线程、不修改方法的话会发生什么？如果每个线程都调用一次 incrementValue，可能得到什么结果呢？有多少种可能执行路径？首先来看结果（假定 lastIdUsed 初始值为 93）：\n  Thread 1 gets the value of 94, thread 2 gets the value of 95, and lastIdUsed is now 95. Thread 1 gets the value of 95, thread 2 gets the value of 94, and lastIdUsed is now 95. Thread 1 gets the value of 94, thread 2 gets the value of 94, and lastIdUsed is now 94.     线程 1 得到 94，线程 2 得到 95，lastIdUsed 为 95； 线程 1 得到 95，线程 2 得到 94，lastIdUsed 为 95； 线程 1 得到 94，线程 2 得到 94，lastIdUsed 为 94。   The final result, while surprising, is possible. To see how these different results are possible, we need to understand the number of possible paths of execution and how the Java Virtual Machine executes them.\n 最后一个结果尽管令人吃惊，也是有可能出现的。要想明白为何可能出现这些结果，就需要理解可能执行路径的数量以及 Java 虚拟机是如何执行这些路径的。\n A.2.1 Number of Paths 路径数量 #  To calculate the number of possible execution paths, we’ll start with the generated byte-code. The one line of java (return ++lastIdUsed;) becomes eight byte-code instructions. It is possible for the two threads to interleave the execution of these eight instructions the way a card dealer interleaves cards as he shuffles a deck.2 Even with only eight cards in each hand, there are a remarkable number of shuffled outcomes.\n 为了算出可能执行路径的数量，我们从生成的字节码开始研究。那行 Java 代码（return++lastIdUsed;）变成了 8 个字节码指令。两个线程有可能交错执行这 8 个指令，就像庄家在洗牌时交错牌张一样。即便每只手上只有 8 张牌，洗牌得到的结果数量也很可观。\n For this simple case of N instructions in a sequence, no looping or conditionals, and T threads, the total number of possible execution paths is equal to\n 对于指令系列中有 N 个指令和 T 个线程、没有循环或条件分支的简单情况，总的可能执行路径数量等于\n  Calculating the Possible Orderings\n 计算可能执行次序\n This comes from an email from Uncle Bob to Brett:\n 以下摘自鲍勃大叔给 Brett 的一封电子邮件：\n With N steps and T threads there are T * N total steps. Prior to each step there is a context switch that chooses between the T threads. Each path can thus be represented as a string of digits denoting the context switches. Given steps A and B and threads 1 and 2, the six possible paths are 1122, 1212, 1221, 2112, 2121, and 2211. Or, in terms of steps it is A1B1A2B2, A1A2B1B2, A1A2B2B1, A2A1B1B2, A2A1B2B1, and A2B2A1B1. For three threads the sequence is 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123, ….\n 对于 N 步指令和 T 个线程，总共有T*N个步骤。在执行每步指令之前，会有在 T 个线程中选择其一的环境开关。因而每条路径都能以一个数字字符串的形式来表示该环境开关。对于步骤 A、B 及线程 1 和 2，可能有 6 条可能路径：1122、1212、1221、2112、2121 和 2211。或者以指令步骤表示为 A1B1A2B2、A1A2B1B2、A1A2B2B1、A2A1B1B2、A2A1B2B1 及 A2B2A1B1。对于三个线程，执行序列就是 112233、112323、113223、113232、112233、121233、121323、121332、123132、123123……\n One characteristic of these strings is that there must always be N instances of each T. So the string 111111 is invalid because it has six instances of 1 and zero instances of 2 and 3.\n 这些字符串的特征之一是每个 T 总会出现 N 次。所以字符串 111111 是无效的，因为里面有 6 个 1，而 2 和 3 则未出现过。\n So we want the permutations of N 1’s, N 2’s, … and N T’s. This is really just the permutations of N * T things taken N * T at a time, which is (N * T)!, but with all the duplicates removed. So the trick is to count the duplicates and subtract that from (N * T)!.\n 所以要排列组合 N1、N2……直至 NT。这其实就是N * T对应N * T的排列，即(N * T)!，但要剔除重复的情形。所以，巧妙之处就在于计算重复次数并从(N * T)!中剔除掉。\n Given two steps and two threads, how many duplicates are there? Each four-digit string has two 1s and two 2s. Each of those pairs could be swapped without changing the sense of the string. You could swap the 1s or the 2s both, or neither. So there are four isomorphs for each string, which means that there are three duplicates. So three out of four of the options are duplicates; alternatively one of four of the permutations are NOT duplicates. 4! * .25 = 6. So this reasoning seems to work.\n 对于两步指令和两个线程，有多少重复呢？每个四位数字符串中都有两个 1 和两个 2。每个这种配对都可以在不影响字符串意义的前提下调换。可以同时调换全部 1 和 2，也可以都不调换。所以每个字符串就有四种同构形态，即存在 3 次重复。所以四分之三的路径是重复的；而四分之一的排列则不重复。4!*.25=6。这样计算看来可行。\n How many duplicates are there? In the case where N = 2 and T = 2, I could swap the 1s, the 2s, or both. In the case where N = 2 and T = 3, I could swap the 1s, the 2s, the 3s, 1s and 2s, 1s and 3s, or 2s and 3s. Swapping is just the permutations of N. Let’s say there are P permutations of N. The number of different ways to arrange those permutations are P**T.\n 有多少重复呢？对于 N=1 且 T=2 的情形，我可以调换 1，调换 2，或两者都调换。对于 N=2 且 T=3 的情形，我可以调换 1、2、3，1 和 2，1 和 3，或 2 和 3。调换只是 N 的排列组合罢了。设有 N 的 P 种排列组合。排列组合的方式总共有P**T种。\n So the number of possible isomorphs is N!**T. And so the number of paths is (T*N)!/(N!**T). Again, in our T = 2, N = 2 case we get 6 (24/4).\n 所以可能的同构形态数量为N!**T。路径的数量就是(T*N)!/(N!**T)。对于 T=2 且 N=2 的情况，结果就是 6（即 24/4）。\n For N = 2 and T = 3 we get 720/8 = 90.\n 对于 N=2 且 T=3，结果是 720/8=90。\n For N = 3 and T = 3 we get 9!/6^3 = 1680.\n 对于 N=3 且 T=3，结果是 9!/6^3=1680。\n For our simple case of one line of Java code, which equates to eight lines of byte-code and two threads, the total number of possible paths of execution is 12,870. If the type of lastIdUsed is a long, then every read/write becomes two operations instead of one, and the number of possible orderings becomes 2,704,156.\n 对于一行 Java 代码（等同于 8 行字节码）和两个线程的简单情况，可能执行路径的总数量就是 12870。如果 lastIdUsed 的类型为 long，每次读/写操作都变成了两次操作，而可能的次序高达 2704156 种。\n What happens if we make one change to this method?\n 如果改动一下该方法会怎样？\n public synchronized void incrementValue() { ++lastIdUsed; } The number of possible execution pathways becomes two for two threads and N! in the general case.\n 这样一来，对于两个线程的情况，可能执行路径的数量就是 2，即 N!。\n A.2.2 Digging Deeper 深入挖掘 #  What about the surprising result that two threads could both call the method once (before we added synchronized) and get the same numeric result? How is that possible? First things first.\n 两个线程都调用方法一次（在添加 synchronize 之前）、得到同一结果数字的惊异结果又怎样呢？怎么可能出现这种情况？一样一样来。\n What is an atomic operation? We can define an atomic operation as any operation that is uninterruptable. For example, in the following code, line 5, where 0 is assigned to lastid, is atomic because according to the Java Memory model, assignment to a 32-bit value is uninterruptable.\n 什么是原子操作？可以把原子操作定义为不可中断的操作。例如，在下列代码的第 5 行，0 被赋值给 lastid，就是一个原子操作。因为依据 Java 内存模型，32 位值的赋值操作是不可中断的。\n 01: public class Example { 02: int lastId; 03: 04: public void resetId() { 05: value = 0; 06: } 07: 08: public int getNextId() { 09: ++value; 10: } 11:} What happens if we change type of lastId from int to long? Is line 5 still atomic? Not according to the JVM specification. It could be atomic on a particular processor, but according to the JVM specification, assignment to any 64-bit value requires two 32-bit assignments. This means that between the first 32-bit assignment and the second 32-bit assignment, some other thread could sneak in and change one of the values.\n 如果把 lastId 的类型从 int 改为 long 会怎样？第 5 行还是原子操作吗？如果不考虑 JVM 规约，则有可能根据处理器不同而不同。不过，根据 JVM 规约，64 位值的赋值需要两次 32 位赋值。这意味着在第一次和第二次 32 位赋值之间，其他线程可能插进来，修改其中一个值。\n What about the pre-increment operator, ++, on line 9? The pre-increment operator can be interrupted, so it is not atomic. To understand, let’s review the byte-code of both of these methods in detail.\n 第 9 行的前递增操作符++又怎样呢？前递增操作符可以被中断，所 以它不是原子的。为了理解这点，仔细复查一下这些方法的字节码吧。\n Before we go any further, here are three definitions that will be important:\n 在更进一步之前，有三个重要的定义：\n  Frame—Every method invocation requires a frame. The frame includes the return address, any parameters passed into the method and the local variables defined in the method. This is a standard technique used to define a call stack, which is used by modern languages to allow for basic function/method invocation and to allow for recursive invocation. Local variable—Any variables defined in the scope of the method. All nonstatic methods have at least one variable, this, which represents the current object, the object that received the most recent message (in the current thread), which caused the method invocation. Operand stack—Many of the instructions in the Java Virtual Machine take parameters. The operand stack is where those parameters are put. The stack is a standard last-in, first-out (LIFO) data structure.     框架——每个方法调用都需要一个框架。该框架包括返回地址、传入方法的参数，以及方法中定义的本地变量。这是定义一个调用堆栈的标准技术，现代编程语言用来实现基本函数/方法调用和递归调用； 本地变量——方法作用范围内定义的每个变量。所有非静态方法至少有一个变量 this，代表当前对象，即接收导致方法调用的（当前线程内）大多数最新消息的对象； 运算对象栈——Java 虚拟机中的许多指令都有参数。运算对象栈是放置参数的地方。堆栈是个标准的后入先出（LIFO）数据结构。   Here is the byte-code generated for resetId():\n 下面是 restId() 的字节码，如表 A-1 所示。\n   These three instructions are guaranteed to be atomic because, although the thread executing them could be interrupted after any one of them, the information for the PUTFIELD instruction (the constant value 0 on the top of the stack and the reference to this one below the top, along with the field value) cannot be touched by another thread. So when the assignment occurs, we are guaranteed that the value 0 will be stored in the field value. The operation is atomic. The operands all deal with information local to the method, so there is no interference between multiple threads.\n 这三个指令确保是原子的，因为尽管执行它们的线程可能在其中任何一个指令后被打断，但 PUTFIELD 指令（堆栈顶部的常量值 0 和顶端之下的 this 引用及其字段值）的信息并不能为其他线程所触及。所以，当赋值操作发生时，值 0 一定将存储到字段值中。该操作是原子的。操作对象都处理对于方法而言是本地的信息，故在多个线程之间并无冲突。\n So if these three instructions are executed by ten threads, there are 4.38679733629e+24 possible orderings. However, there is only one possible outcome, so the different orderings are irrelevant. It just so happens that the same outcome is guaranteed for longs in this case as well. Why? All ten threads are assigning a constant value. Even if they interleave with each other, the end result is the same.\n 所以，如果这三个指令由 10 个线程执行，就会有 4.38679733629e+24 种可能的执行次序。不过，只会有一种可能的结果，所以执行次序不同无关紧要。对于本例中的 long 常量，总是有同一种运算结果。为什么？因为 10 个线程的赋值操作都是针对一个常量的。即便它们互相干涉，结果也是一样。\n With the ++ operation in the getNextId method, there are going to be problems. Assume that lastId holds 42 at the beginning of this method. Here is the byte-code for this new method:\n 方法 getNextId 中的++操作就会有问题了。假定 lastId 在方法开始时的值为 42.下面是新方法的字节码，如表 A-2 所示。\n  Imagine the case where the first thread completes the first three instructions, up to and including GETFIELD, and then it is interrupted. A second thread takes over and performs the entire method, incrementing lastId by one; it gets 43 back. Then the first thread picks up where it left off; 42 is still on the operand stack because that was the value of lastId when it executed GETFIELD. It adds one to get 43 again and stores the result. The value 43 is returned to the first thread as well. The result is that one of the increments is lost because the first thread stepped on the second thread after the second thread interrupted the first thread.\n 设想第一个线程完成了前三个操作，直到执行完 GETFIELD，然后被打断。第二个线程接手并完成整个方法调用，lastId 的值递增 1；得到的值为 43。第一个线程再从中断处继续执行；操作对象栈中的值还是 42，因为那就是该线程执行 GETFIELD 时的 lastId 值。线程给 lastId 加 1，得到 43，存储这个结果。第一个线程也得到了值 43。结果就是其中一个递增操作丢失了，因为第一个线程在被第二个线程打断后又踏入了第二个线程中。\n Making the getNexId() method synchronized fixes this problem.\n 将 getNextId( )方法修改为同步方法就能修正这个问题。\n A.2.3 Conclusion 小结 #  An intimate understanding of byte-code is not necessary to understand how threads can step on each other. If you can understand this one example, it should demonstrate the possibility of multiple threads stepping on each other, which is enough knowledge.\n 理解线程之间如何互相干涉，并不一定要精通字节码。如果你能看明白这个例子，它应该已经展示了多个线程之间互相干涉的可能性，这已经足够了。\n That being said, what this trivial example demonstrates is a need to understand the memory model enough to know what is and is not safe. It is a common misconception that the ++ (pre- or post-increment) operator is atomic, and it clearly is not. This means you need to know:\n 这个小例子说明，有必要尽量理解内存模型，明白什么是安全的，什么是不安全的。有一种普遍的误解，认为++（前递增或后递增）操作符是原子的，其实并非如此。你必须知道：\n  Where there are shared objects/values The code that can cause concurrent read/update issues How to guard such concurrent issues from happening     什么地方有共享对象/值； 哪些代码会导致并发读/写问题； 如何防止这种并发问题发生。   A.3 KNOWING YOUR LIBRARY 了解类库 #  A.3.1 Executor Framework Executor 框架 #  As demonstrated in the ExecutorClientScheduler.java on page 321, the Executor framework introduced in Java 5 allows for sophisticated execution using thread pools. This is a class in the java.util.concurrent package.\n 如前文 ExecutorClientScheduler.java 所演示的那样，Java 5 中引入的 Executor 框架支持利用线程池进行复杂的执行。那就是 java.util.concurrent 包中的一个类。\n If you are creating threads and are not using a thread pool or are using a hand-written one, you should consider using the Executor. It will make your code cleaner, easier to follow, and smaller.\n 如果在创建线程时没有使用线程池或自行编写线程池，可以考虑使用 Executor。它能让代码更整洁，易于理解，且更加短小。\n The Executor framework will pool threads, resize automatically, and recreate threads if necessary. It also supports futures, a common concurrent programming construct. The Executor framework works with classes that implement Runnable and also works with classes that implement the Callable interface. A Callable looks like a Runnable, but it can return a result, which is a common need in multithreaded solutions.\n Executor 框架将把线程放到池中，自动调整其大小，并在必要时重建线程。它还支持 future，一种通用的并发编程构造。Executor 能与实现了 Runnable 的类协同工作，也能与实现了 Callable 接口的类协同工作。Callback 看来就像是 Runnable，但它能返回一个结果，那在多线程解决方案中是普遍的需求。\n A future is handy when code needs to execute multiple, independent operations and wait for both to finish:\n 当代码需要执行多个相互独立的操作并等待这些操作结束时，future 刚好就手：\n public String processRequest(String message) throws Exception { Callable\u0026lt;String\u0026gt; makeExternalCall = new Callable\u0026lt;String\u0026gt;() { public String call() throws Exception { String result = “”; // make external request  return result; } }; Future\u0026lt;String\u0026gt; result = executorService.submit(makeExternalCall); String partialResult = doSomeLocalProcessing(); return result.get() + partialResult; } In this example, the method starts executing the makeExternalCall object. The method continues other processing. The final line calls result.get(), which blocks until the future completes.\n 在本例中，方法开始执行 makeExternalCall 对象。然后该方法继续其他操作。最后一行代码调用 result.get()，在 future 代码执行完成前，这个操作是锁定的。\n A.3.2 Nonblocking Solutions 非锁定的解决方案 #  The Java 5 VM takes advantage of modern processor design, which supports reliable, nonblocking updates. Consider, for example, a class that uses synchronization (and therefore blocking) to provide a thread-safe update of a value:\n Java5 虚拟机利用了现代处理器支持可靠、非锁定更新的设计优点。例如，考虑某个使用同步（从而也是锁定的）来提供线程安全地更新一个值的类：\n public class ObjectWithValue { private int value; public void synchronized incrementValue() { ++value; } public int getValue() { return value; } } Java 5 has a series of new classes for situations like this: AtomicBoolean, AtomicInteger, and AtomicReference are three examples; there are several more. We can rewrite the above code to use a nonblocking approach as follows:\n Java5 有一系列用于此类情况的新类，例如 AtomicBoolean、 AtomicInteger 和 AtomicReference 等；还有另外一些。我们可以重写上面的代码，使用非锁定的手段，如下所示：\n public class ObjectWithValue { private AtomicInteger value = new AtomicInteger(0); public void incrementValue() { value.incrementAndGet(); } public int getValue() { return value.get(); } } Even though this uses an object instead of a primitive and sends messages like incrementAndGet() instead of ++, the performance of this class will nearly always beat the previous version. In some cases it will only be slightly faster, but the cases where it will be slower are virtually nonexistent.\n 即便使用了对象而非直接操作，使用了 incrementAndGet() 这样的信息发送方式而非++操作，这个类的性能还是几乎总能胜过上一版本。在某些情况下只会快一点点，但较慢的情形却几乎不存在。\n How is this possible? Modern processors have an operation typically called Compare and Swap (CAS). This operation is analogous to optimistic locking in databases, whereas the synchronized version is analogous to pessimistic locking.\n 怎么会这样？现代处理器拥有一种通常称为比较交换（Compare and Swap，CAS）的操作。这种操作类似于数据库中的乐观锁定，而其同步版本则类似于保守锁定。\n The synchronized keyword always acquires a lock, even when a second thread is not trying to update the same value. Even though the performance of intrinsic locks has improved from version to version, they are still costly.\n 关键字 synchronized 总是要求上锁，即便第二个线程并不更新同一值时也如此。尽管这种固有锁的性能一直在提升，但仍然代价昂贵。\n The nonblocking version starts with the assumption that multiple threads generally do not modify the same value often enough that a problem will arise. Instead, it efficiently detects whether such a situation has occurred and retries until the update happens successfully. This detection is almost always less costly than acquiring a lock, even in moderate to high contention situations.\n 非上锁的版本假定多个线程通常并不频繁修改同一个值，导致问题产生。它高效地侦测这种情形是否发生，并不断尝试，直至更新成功。这种侦测行为几乎总是比上锁来得划算，在争用激烈的情况下也是如此。\n How does the Virtual Machine accomplish this? The CAS operation is atomic. Logically, the CAS operation looks something like the following:\n 虚拟机如何实现这种机制？CAS 的操作是原子的。逻辑上，CAS 操作看起来像这样：\n int variableBeingSet; void simulateNonBlockingSet(int newValue) { int currentValue; do { currentValue = variableBeingSet } while(currentValue != compareAndSwap(currentValue, newValue)); } int synchronized compareAndSwap(int currentValue, int newValue) { if(variableBeingSet == currentValue) { variableBeingSet = newValue; return currentValue; } return variableBeingSet; } When a method attempts to update a shared variable, the CAS operation verifies that the variable getting set still has the last known value. If so, then the variable is changed. If not, then the variable is not set because another thread managed to get in the way. The method making the attempt (using the CAS operation) sees that the change was not made and retries.\n 当某个方法试图更新一个共享变量，CAS 操作就会验证要赋值的变量是否保有上一次的已知值。如果是，就修改变量值。如果不是，则不会碰变量，因为另一个线程正在试图更新变量值。要更新数据的方法（通过 CAS 操作）查看是否修改并持续尝试。\n A.3.3 Nonthread-Safe Classes 非线程安全类 #  There are some classes that are inherently not thread safe. Here are a few examples:\n 有些类天生不是线程安全的。下面是几个例子：\n  SimpleDateFormat Database Connections Containers in java.util Servlets     SimpleDateFormat 数据库连接 java.util 中的容器 Servlet   Note that some collection classes have individual methods that are thread-safe. However, any operation that involves calling more than one method is not. For example, if you do not want to replace something in a HashTable because it is already there, you might write the following code:\n 注意，有些群集类拥有一些线程安全的方法。不过，涉及调用多个方法的操作都不是线程安全的。例如，如果因为 HashTable 中已经有某物而不打算替换它，可能会写出以下代码：\n if(!hashTable.containsKey(someKey)) { hashTable.put(someKey, new SomeValue()); } Each individual method is thread-safe. However, another thread might add a value in between the containsKey and put calls. There are several options to fix this problem.\n 单个方法是线程安全的。不过，另一个线程却可能在 containsKey 和 put 调用之间塞进一个值。有几种修正这个问题的手段。\n  Lock the HashTable first, and make sure all other users of the HashTable do the same—client-based locking:    先锁定 HashTable，确定其他使用者都做了基于客户端的锁定：   synchronized(map) { if(!map.conainsKey(key)) map.put(key, value); }  Wrap the HashTable in its own object and use a different API—server-based locking using an ADAPTER:    用其对象包装 HashTable，并使用不同的 API——利用 ADAPTER 模式做基于服务端的锁定：   public class WrappedHashtable\u0026lt;K, V\u0026gt; { private Map\u0026lt;K, V\u0026gt; map = new Hashtable\u0026lt;K, V\u0026gt;(); public synchronized void putIfAbsent(K key, V value) { if (map.containsKey(key)) map.put(key, value); } }  Use the thread-safe collections:    采用线程安全的群集：   ConcurrentHashMap\u0026lt;Integer, String\u0026gt; map = new ConcurrentHashMap\u0026lt;Integer, String\u0026gt;(); map.putIfAbsent(key, value); The collections in java.util.concurrent have operations like putIfAbsent() to accommodate such operations.\n 在 java.util.concurrent 中的群集都有 putIfAbsent() 之类提供这种操作的方法。\n A.4 DEPENDENCIES BETWEEN METHODS CAN BREAK CONCURRENT CODE 方法之间的依赖可能破坏并发代码 #  Here is a trivial example of a way to introduce dependencies between methods:\n 以下是一个有关在方法间引入依赖的小例子：\n public class IntegerIterator implements Iterator\u0026lt;Integer\u0026gt; { private Integer nextValue = 0; public synchronized boolean hasNext() { return nextValue \u0026lt; 100000; } public synchronized Integer next() { if (nextValue == 100000) throw new IteratorPastEndException(); return nextValue++; } public synchronized Integer getNextValue() { return nextValue; } } Here is some code to use this IntegerIterator:\n 下面是使用 IntegerIterator 的代码：\n IntegerIterator iterator = new IntegerIterator(); while(iterator.hasNext()) { int nextValue = iterator.next(); // do something with nextValue } If one thread executes this code, there will be no problem. But what happens if two threads attempt to share a single instance of IngeterIterator with the intent that each thread will process the values it gets, but that each element of the list is processed only once? Most of the time, nothing bad happens; the threads happily share the list, processing the elements they are given by the iterator and stopping when the iterator is complete. However, there is a small chance that, at the end of the iteration, the two threads will interfere with each other and cause one thread to go beyond the end of the iterator and throw an exception.\n 如果只有一个线程执行这段代码，不会有什么问题。但如果有两个线程抱着每个线程都处理它获得的值、但列表中的每个元素都只被处理一次的意图，尝试共享 IntegerIterator 的单个实体，会发生什么事？多数时候什么也不会发生；线程开心地共享着列表，处理从迭代器获取的元素，在迭代器完成执行时停下。然而，在迭代的末尾，两个线程也有少量可能互相干涉，导致其中一个超出迭代器末尾，抛出异常。\n Here’s the problem: Thread 1 asks the question hasNext(), which returns true. Thread 1 gets preempted and then Thread 2 asks the same question, which is still true. Thread 2 then calls next(), which returns a value as expected but has a side effect of making hasNext() return false. Thread 1 starts up again, thinking hasNext() is still true, and then calls next(). Even though the individual methods are synchronized, the client uses two methods.\n 问题在这里。线程 1 调用 hasNext( )方法，该方法返回 true。线程 1 占先，然后线程 2 也调用这个方法，同样返回 true。线程 2 接着调用 next( )，该方法如期返回一个值，但副作用是之后再调用 hasNext( )就会返回 false。线程 1 继续执行，以为 hasNext( )还是 true，然后调用 next( )。即便单个方法是同步的，客户端还是使用了两个方法。\n This is a real problem and an example of the kinds of problems that crop up in concurrent code. In this particular situation this problem is especially subtle because the only time where this causes a fault is when it happens during the final iteration of the iterator. If the threads happen to break just right, then one of the threads could go beyond the end of the iterator. This is the kind of bug that happens long after a system has been in production, and it is hard to track down.\n 这的确是个问题，也是并发代码中此类问题的典型例子。在这个特殊例子中，问题尤其隐蔽，因为只有在迭代器最后一次迭代时发生才会导致错误。如果线程刚好在那个点中断，其中一个线程就可能超出迭代器末尾。这类错误往往在系统部署之后很久才发生，而且很难追踪。\n You have three options:\n 出现错误时，你有 3 种做法。\n  Tolerate the failure. Solve the problem by changing the client: client-based locking Solve the problem by changing the server, which additionally changes the client: server-based locking     容忍错误； 修改客户代码解决问题：基于客户代码的锁定； 修改服务端代码解决问题，同时也修改了客户代码：基于服务端的锁定。   A.4.1 Tolerate the Failure 容忍错误 #  Sometimes you can set things up such that the failure causes no harm. For example, the above client could catch the exception and clean up. Frankly, this is a bit sloppy. It’s rather like cleaning up memory leaks by rebooting at midnight.\n 有时，可以通过一些设置让错误不会导致损害。例如，上述客户代码可以捕捉并清理异常。坦白地说，这有点草草从事，就像是半夜重启解决内存泄露问题一样。\n A.4.2 Client-Based Locking 基于客户代码的锁定 #  To make IntegerIterator work correctly with multiple threads, change this client (and every other client) as follows:\n 要让 IntegerIterator 在多线程情况下正确运行，对客户代码做如下修改：\n IntegerIterator iterator = new IntegerIterator(); while (true) { int nextValue; synchronized (iterator) { if (!iterator.hasNext()) break; nextValue = iterator.next(); } doSometingWith(nextValue); } Each client introduces a lock via the synchronized keyword. This duplication violates the DRY principle, but it might be necessary if the code uses non-thread-safe third-party tools.\n 每个客户端都通过 synchronized 关键字引入一个锁。这种重复违反了 DRY 原则，但如果代码使用非线程安全的第三方工具，可能必须这样做。\n This strategy is risky because all programmers who use the server must remember to lock it before using it and unlock it when done. Many (many!) years ago I worked on a system that employed client-based locking on a shared resource. The resource was used in hundreds of different places throughout the code. One poor programmer forgot to lock the resource in one of those places.\n 这种策略有风险，因为使用服务端的程序员都得记住在使用前上锁、用过后解锁。许多（许多！）年前，我遇到过一个在共享资源上应用基于客户代码锁定的系统。代码中有几百处用到这个资源的地方。有位可怜的程序员忘记在其中一处做资源锁定。\n The system was a multi-terminal time-sharing system running accounting software for Local 705 of the trucker’s union. The computer was in a raised-floor, environment-controlled room 50 miles north of the Local 705 headquarters. At the headquarters they had dozens of data entry clerks typing union dues postings into the terminals. The terminals were connected to the computer using dedicated phone lines and 600bps half-duplex modems. (This was a very, very long time ago.)\n 该系统是个多终端分时系统，为 Local 705 卡车司机联盟运行会计软件。计算机放在距 Local 705 总部 50 英里（约 84.65km）以北的一间镶有高于地面的地板、环境可控的机房中。总部有几十位数据录入员，往终端输入记录。终端使用电话专线和 600bit/s 的半双工调制解调器连接到计算机。（这可是很久很久以前的事了。）\n About once per day, one of the terminals would “lock up.” There was no rhyme or reason to it. The lock up showed no preference for particular terminals or particular times. It was as though there were someone rolling dice choosing the time and terminal to lock up. Sometimes more than one terminal would lock up. Sometimes days would go by without any lock-ups.\n 每天大概都会有一台终端毫无理由地“死锁”。死锁也不限定在某些终端或特定时间。就像是有人掷骰子选择死锁的时机和终端一般。有时，会有几台终端死锁。有时，好几天都不出现死锁情况。\n At first the only solution was a reboot. But reboots were tough to coordinate. We had to call the headquarters and get everyone to finish what they were doing on all the terminals. Then we could shut down and restart. If someone was doing something important that took an hour or two, the locked up terminal simply had to stay locked up.\n 刚开始，唯一的解决手段就是重启。但协同起来很不便。我们得打电话给总部，让大家都完成在终端上的工作。然后我们才能关机、重启。如果有人在做要花上一两个小时才能做完的事，被锁定的终端就只能一直等着。\n After a few weeks of debugging we found that the cause was a ring-buffer counter that had gotten out of sync with its pointer. This buffer controlled output to the terminal. The pointer value indicated that the buffer was empty, but the counter said it was full. Because it was empty, there was nothing to display; but because it was also full, nothing could be added to the buffer to be displayed on the screen.\n 经过几个星期的调试，我们发现，原因在于一个指针不同步的环形缓冲区计数器。该缓冲区控制向终端的输出。指针值说明缓冲区是空的，但计数器却指出缓冲区是满的。因为缓冲区是空的，就没什么可显示；但因为缓冲区也是满的，也就无法向其中加入可在屏幕上显示的内容。\n So we knew why the terminals were locking, but we didn’t know why the ring buffer was getting out of sync. So we added a hack to work around the problem. It was possible to read the front panel switches on the computer. (This was a very, very, very long time ago.) We wrote a little trap function that detected when one of these switches was thrown and then looked for a ring buffer that was both empty and full. If one was found, it reset that buffer to empty. Voila! The locked-up terminal(s) started displaying again.\n 我们知道了终端为何会死锁，但却不知道为什么环形缓冲区会不同步。我们用了点手段发现问题所在。当时程序能够读取计算机的前面板开关状态（这可是很久很久以前的事了）。我们写了个陷阱程序，侦测这些开关何时被拨动，然后查找既空又满的环形缓冲区。如果找到，就重置该缓冲区为空。乌拉！锁定的终端又重新开始显示了。\n So now we didn’t have to reboot the system when a terminal locked up. The Local would simply call us and tell us we had a lock-up, and then we just walked into the computer room and flicked a switch.\n 这样，在终端锁定时就不必重启系统了。客户只需要打电话告诉我们出现死锁，我们就径直走到机房，拨动一下开关即可。\n Of course sometimes they worked on the weekends, and we didn’t. So we added a function to the scheduler that checked all the ring buffers once per minute and reset any that were both empty and full. This caused the displays to unclog before the Local could even get on the phone.\n 当然，有时他们会在周末加班，但是我们可不加班。所以我们又在计划列表中添加了一个函数，每分钟检查一次全部环形缓冲区，重置既空又满的缓冲区。在客户打电话之前，显示就已经恢复正常了。\n It was several more weeks of poring over page after page of monolithic assembly language code before we found the culprit. We had done the math and calculated that the frequency of the lock-ups was consistent with a single unprotected use of the ring buffer. So all we had to do was find that one faulty usage. Unfortunately, this was so very long ago that we didn’t have search tools or cross references or any other kind of automated help. We simply had to pore over listings.\n 在发现问题原因之前，我们花了好几个星期查看一页又一页的单片机汇编语言代码。我们已经完成计算，算出死锁的频率是周期性的，而且其中有一处未受保护的环形缓冲区使用。所以，剩下的任务就是找出那个错误的用法。不幸这是多年以前的事，那时既没有搜索工具，也没有交叉引用或任何其他自动化帮助手段。我们只能细查代码清单。\n I learned an important lesson that cold Chicago winter of 1971. Client-based locking really blows.\n 在芝加哥 1971 年的寒冬，我学到了重要的一课。基于客户代码的锁定实在不可靠。\n A.4.3 Server-Based Locking 基于服务端的锁定 #  The duplication can be removed by making the following changes to IntegerIterator:\n 按照以下方式修改 IntegerIterator 也能消除重复：\n public class IntegerIteratorServerLocked { private Integer nextValue = 0; public synchronized Integer getNextOrNull() { if (nextValue \u0026lt; 100000) return nextValue++; else return null; } } And the client code changes as well:\n 客户代码也要修改：\n while (true) { Integer nextValue = iterator.getNextOrNull(); if (next == null) break; // do something with nextValue } In this case we actually change the API of our class to be multithread aware.3 The client needs to perform a null check instead of checking hasNext().\n 在这种情形下，我们实际上是修改了类的 API，使其能适应多线程。客户端需要做 null 检查，而不是检查 hasNext()。\n In general you should prefer server-based locking for these reasons:\n 通常你应该选用基于服务端的锁定，因为：\n  It reduces repeated code—Client-based locking forces each client to lock the server properly. By putting the locking code into the server, clients are free to use the object and not worry about writing additional locking code. It allows for better performance—You can swap out a thread-safe server for a non-thread safe one in the case of single-threaded deployment, thereby avoiding all overhead. It reduces the possibility of error—All it takes is for one programmer to forget to lock properly. It enforces a single policy—The policy is in one place, the server, rather than many places, each client. It reduces the scope of the shared variables—The client is not aware of them or how they are locked. All of that is hidden in the server. When things break, the number of places to look is smaller.     它减少了重复代码——采用基于客户代码的锁定，每个客户端都要正确锁定服务端。把锁定代码放到服务端，客户端就能自由使用对象，不必费心编写额外的锁定代码； 它提升了性能——在单线程部署中，可以用非多线程安全服务端代码替代线程安全客户端，从而省去花销； 它减少了出错的可能性——只会有一个程序员忘记上锁； 它执行了单一策略——该策略只在服务端这一处地方实施，而不是在许多地方（每个客户端）实施； 它缩减了共享变量的作用范围——客户端不必关心它们或它们是如何锁定的。一切都隐藏在服务端。如果出错，要侦查的范围就小多了。   What if you do not own the server code?\n 如果你无法修改服务端代码又该如何？\n  Use an ADAPTER to change the API and add locking    使用 ADAPTER 模式修改 API，添加锁定；   public class ThreadSafeIntegerIterator { private IntegerIterator iterator = new IntegerIterator(); public synchronized Integer getNextOrNull() { if(iterator.hasNext()) return iterator.next(); return null; } }  OR better yet, use the thread-safe collections with extended interfaces    更好的方法是使用线程安全的群集和扩展接口。   A.5 INCREASING THROUGHPUT 提升吞吐量 #  Let’s assume that we want to go out on the net and read the contents of a set of pages from a list of URLs. As each page is read, we will parse it to accumulate some statistics. Once all the pages are read, we will print a summary report.\n 假设我们打算连接上网，从一个 URL 列表中读取一组页面的内容。读到一个页面时，解析该页面并得到一些统计结果。读完所有页面后，打印出一份提要报表。\n The following class returns the contents of one page, given a URL.\n 下面的类返回给定 URL 的页面内容：\n public class PageReader { //…  public String getPageFor(String url) { HttpMethod method = new GetMethod(url); try { httpClient.executeMethod(method); String response = method.getResponseBodyAsString(); return response; } catch (Exception e) { handle(e); } finally { method.releaseConnection(); } } } The next class is the iterator that provides the contents of the pages based on an iterator of URLs:\n 下一个类是给出 URL 迭代器中每个页面的内容的迭代器：\n public class PageIterator { private PageReader reader; private URLIterator urls; public PageIterator(PageReader reader, URLIterator urls) { this.urls = urls; this.reader = reader; } public synchronized String getNextPageOrNull() { if (urls.hasNext()) getPageFor(urls.next()); else return null; } public String getPageFor(String url) { return reader.getPageFor(url); } } An instance of the PageIterator can be shared between many different threads, each one using it’s own instance of the PageReader to read and parse the pages it gets from the iterator.\n PageIterator 的一个实体可为多个不同线程共享，每个线程使用自己的 PageReader 实体读取并解析从迭代器中得到的页面。\n Notice that we’ve kept the synchronized block very small. It contains just the critical section deep inside the PageIterator. It is always better to synchronize as little as possible as opposed to synchronizing as much as possible.\n 注意，我们把 synchronized 代码块的数量限制在小范围之内。它只包括深处于 PageIterator 内部的临界区。最好是尽可能少地使用同步。\n A.5.1 Single-Thread Calculation of Throughput 单线程条件下的吞吐量 #  Now lets do some simple calculations. For the purpose of argument, assume the following:\n 来做个简单计算。鉴于讨论的目的，假定：\n  I/O time to retrieve a page (average): 1 second Processing time to parse page (average): .5 seconds I/O requires 0 percent of the CPU while processing requires 100 percent.     获取一个页面的 I/O 时间（平均）是 1s； 解析一个页面的处理时间（平均）是 0.5s； I/O 操作不耗费处理器能力，而解析页面耗费 100%处理器能力。   For N pages being processed by a single thread, the total execution time is 1.5 seconds * N. Figure A-1 shows a snapshot of 13 pages or about 19.5 seconds.\n 对于单个线程要处理的 N 个页面，总的执行时间为 1.5s*N。图 A-1 显示了 13 个页面或大概 19.5s 的快照。\n Figure A-1 Single thread\n A.5.2 Multithread Calculation of Throughput 多线程条件下的吞吐量 #  If it is possible to retrieve pages in any order and process the pages independently, then it is possible to use multiple threads to increase throughput. What happens if we use three threads? How many pages can we acquire in the same time?\n 如果能够以任意次序获得页面并独立处理页面，就有可能利用多线程提升吞吐量。如果我们使用三个线程会如何？在同一时间内能获取多少个页面呢？\n As you can see in Figure A-2, the multithreaded solution allows the process-bound parsing of the pages to overlap with the I/O-bound reading of the pages. In an idealized world this means that the processor is fully utilized. Each one-second page read is overlapped with two parses. Thus, we can process two pages per second, which is three times the throughput of the single-threaded solution.\n 如你在图 A-2 中所见，多线程方案中与处理器能力有关的页面解析操作可以和与 I/O 有关的页面读取操作叠加进行。在理想状态下，这意味着处理器力尽其用。每个耗时一秒钟的页面读取操作都与两次解析操作叠加进行。这样，我们就能在每秒钟内处理两个页面，即三倍于单线程方案的吞吐量。\n Figure A-2 Three concurrent threads\n A.6 DEADLOCK 死锁 #  Imagine a Web application with two shared resource pools of some finite size:\n 想象一个拥有两个有限共享资源池的 Web 应用程序。\n  A pool of database connections for local work in process storage A pool of MQ connections to a master repository     一个用于本地临时工作存储的数据库连接池； 一个用于连接到主存储库的 MQ 池。   Assume there are two operations in this application, create and update:\n 假定该应用中有两个操作：创建和更新。\n  Create—Acquire connection to master repository and database. Talk to service master repository and then store work in local work in process database. Update—Acquire connection to database and then master repository. Read from work in process database and then send to the master repository     创建——获取到主存储库和数据库的连接。与主存储库协调，并把工作保存到本地临时工作数据库； 更新——先获取到数据库的连接，再获取到主存储库的连接。从临时工作数据库中读取数据，再发送给主存储库。   What happens when there are more users than the pool sizes? Consider each pool has a size of ten.\n 如果用户数量多于池的大小会怎样？假设每个池中能容纳 10 个资源。\n  Ten users attempt to use create, so all ten database connections are acquired, and each thread is interrupted after acquiring a database connection but before acquiring a connection to the master repository. Ten users attempt to use update, so all ten master repository connections are acquired, and each thread is interrupted after acquiring the master repository but before acquiring a database connection. Now the ten “create” threads must wait to acquire a master repository connection, but the ten “update” threads must wait to acquire a database connection. Deadlock. The system never recovers.     有 10 个用户尝试创建，获取了 10 个数据库连接，每个线程在获取到数据库连接之后、获取到主存储库连接之前都被打断； 有 10 个用户尝试更新，获取了 10 个主存储库连接，每个线程在获取到主存储库连接之后、获取到数据库连接之前都会被打断； 现在那 10 个“创建”线程必须等待获取主存储库连接，但那 10 个“更新”线程必须等待获取数据库连接； 死锁。系统永远无法恢复。   This might sound like an unlikely situation, but who wants a system that freezes solid every other week? Who wants to debug a system with symptoms that are so difficult to reproduce? This is the kind of problem that happens in the field, then takes weeks to solve.\n 这听起来不太会出现，但谁会想要一个每隔一周就僵在那里不动的系统呢？谁想要调试出现了难以复现的症状的系统呢？这种问题突然发生，然后得花上好几个星期才能解决。\n A typical “solution” is to introduce debugging statements to find out what is happening. Of course, the debug statements change the code enough so that the deadlock happens in a different situation and takes months to again occur.4\n 典型的“解决方案”是加入调试语句，发现问题。当然，调试语句对代码的修改足以令死锁在不同情况下发生，而且要几个月后才会再出现。\n To really solve the problem of deadlock, we need to understand what causes it. There are four conditions required for deadlock to occur:\n 要真正地解决死锁问题，我们需要理解死锁的原因。死锁的发生需要 4 个条件：\n  Mutual exclusion Lock \u0026amp; wait No preemption Circular wait     互斥； 上锁及等待； 无抢先机制； 循环等待。   A.6.1 Mutual Exclusion 互斥 #  Mutual exclusion occurs when multiple threads need to use the same resources and those resources\n 当多个线程需要使用同一资源，且这些资源满足下列条件时，互斥就会发生。\n  Cannot be used by multiple threads at the same time. Are limited in number.     无法在同一时间为多个线程所用； 数量上有限制。   A common example of such a resource is a database connection, a file open for write, a record lock, or a semaphore.\n 这种资源的常见例子是数据库连接、打开后用于写入的文件、记录锁或是信号量。\n A.6.2 Lock \u0026amp; Wait 上锁及等待 #  Once a thread acquires a resource, it will not release the resource until it has acquired all of the other resources it requires and has completed its work.\n 当某个线程获取一个资源，在获取到其他全部所需资源并完成其工作之前，不会释放这个资源。\n A.6.3 No Preemption 无抢先机制 #  One thread cannot take resources away from another thread. Once a thread holds a resource, the only way for another thread to get it is for the holding thread to release it.\n 线程无法从其他线程处夺取资源。一个线程持有资源时，其他线程获得这个资源的唯一手段就是等待该线程释放资源。\n A.6.4 Circular Wait 循环等待 #  This is also referred to as the deadly embrace. Imagine two threads, T1 and T2, and two resources, R1 and R2. T1 has R1, T2 has R2. T1 also requires R2, and T2 also requires R1. This gives something like Figure A-3:\n 这也被称为“死命拥抱”。想象两个线程，T1 和 T2，还有两个资源，R1 和 R2。T1 拥有 R1，T2 拥有 R2。T1 需要 R2，T2 需要 R1。如此就出现了如图 A-3 所示的情形。\n Figure A-3\n All four of these conditions must hold for deadlock to be possible. Break any one of these conditions and deadlock is not possible.\n 这 4 种条件都是死锁所必需的。只要其中一个不满足，死锁就不会发生。\n A.6.5 Breaking Mutual Exclusion 不互斥 #  One strategy for avoiding deadlock is to sidestep the mutual exclusion condition. You might be able to do this by\n 避免死锁的一种策略是规避互斥条件。你可以：\n  Using resources that allow simultaneous use, for example, AtomicInteger. Increasing the number of resources such that it equals or exceeds the number of competing threads. Checking that all your resources are free before seizing any.     使用允许同时使用的资源，如 AtomicInteger； 增加资源数量，使其等于或大于竞争线程的数量； 在获取资源之前，检查是否可用。   Unfortunately, most resources are limited in number and don’t allow simultaneous use. And it’s not uncommon for the identity of the second resource to be predicated on the results of operating on the first. But don’t be discouraged; there are three conditions left.\n 不幸的是，多数资源都有上限，且不能同时使用。而且第二个资源的标识也常常要依据对第一个资源的操作结果来判断。不过别丧气，还有 3 个其他条件呢。\n A.6.6 Breaking Lock \u0026amp; Wait 不上锁及等待 #  You can also eliminate deadlock if you refuse to wait. Check each resource before you seize it, and release all resources and start over if you run into one that’s busy.\n 如果拒绝等待，就能消除死锁。在获得资源之前检查资源，如果遇到某个繁忙资源，就释放所有资源，重新来过。\n This approach introduces several potential problems:\n 这种手段带来几个潜在问题：\n  Starvation—One thread keeps being unable to acquire the resources it needs (maybe it has a unique combination of resources that seldom all become available). Livelock—Several threads might get into lockstep and all acquire one resource and then release one resource, over and over again. This is especially likely with simplistic CPU scheduling algorithms (think embedded devices or simplistic hand-written thread balancing algorithms).     线程饥饿——某个线程一直无法获得它所需的资源（它可能需要某种很少能同时获得的资源组合）； 活锁——几个线程可能会前后相连地要求获得某个资源，然后再释放一个资源，如此循环。这在单纯的 CPU 任务排列算法中尤其有可能出现（想想嵌入式设备或单纯的手写线程平衡算法）。   Both of these can cause poor throughput. The first results in low CPU utilization, whereas the second results in high and useless CPU utilization.\n 二者都能导致较差的吞吐量。第一个的结果是 CPU 利用率低，第二个的结果是较高但无用的 CPU 利用率。\n As inefficient as this strategy sounds, it’s better than nothing. It has the benefit that it can almost always be implemented if all else fails.\n 尽管这种策略听起来没效率，但也好过没有。至少，如果其他方案不奏效，这种手段几乎总可以用上。\n A.6.7 Breaking Preemption 满足抢先机制 #  Another strategy for avoiding deadlock is to allow threads to take resources away from other threads. This is usually done through a simple request mechanism. When a thread discovers that a resource is busy, it asks the owner to release it. If the owner is also waiting for some other resource, it releases them all and starts over.\n 避免死锁的另一策略是允许线程从其他线程上夺取资源。这通常利用一种简单的请求机制来实现。当线程发现资源繁忙，就要求其拥有者释放之。如果拥有者还在等待其他资源，就释放全部资源并重新来过。\n This is similar to the previous approach but has the benefit that a thread is allowed to wait for a resource. This decreases the number of startovers. Be warned, however, that managing all those requests can be tricky.\n 这和上一种手段相似，但好处是允许线程等待资源。这减少了线程重新启动的次数。不过，管理所有请求可要花点心思。\n A.6.8 Breaking Circular Wait 不做循环等待 #  This is the most common approach to preventing deadlock. For most systems it requires no more than a simple convention agreed to by all parties.\n 这是避免死锁的最常用手段。对于多数系统，它只要求一个为各方认同的约定。\n In the example above with Thread 1 wanting both Resource 1 and Resource 2 and Thread 2 wanting both Resource 2 and then Resource 1, simply forcing both Thread 1 and Thread 2 to allocate resources in the same order makes circular wait impossible.\n 在上面的例子中线程 1 同时需要资源 1 和资源 2、线程 2 同时需要资源 2 和资源 1，只要强制线程 1 和线程 2 以同样次序分配资源，循环等待就不会发生。\n More generally, if all threads can agree on a global ordering of resources and if they all allocate resources in that order, then deadlock is impossible. Like all the other strategies, this can cause problems:\n 更普遍地，如果所有线程都认同一种资源获取次序，并按照这种次序获取资源，死锁就不会发生。就像其他策略一样，这也会有问题：\n  The order of acquisition might not correspond to the order of use; thus a resource acquired at the start might not be used until the end. This can cause resources to be locked longer than strictly necessary. Sometimes you cannot impose an order on the acquisition of resources. If the ID of the second resource comes from an operation performed on the first, then ordering is not feasible.     获取资源的次序可能与使用资源的次序不匹配；一开始获取的资源可能在最后才会用到。这可能导致资源不必要地被长时间锁定； 有时无法强求资源获取顺序。如果第二个资源的 ID 来自对第一个资源操作的结果，获取次序也无从谈起。   So there are many ways to avoid deadlock. Some lead to starvation, whereas others make heavy use of the CPU and reduce responsiveness. TANSTAAFL!5\n 有许多避免死锁的方法。有些会导致饥饿，另外一些会导致对 CPU 能力的大量耗费和降低响应率。TANSTAAFL！\n Isolating the thread-related part of your solution to allow for tuning and experimentation is a powerful way to gain the insights needed to determine the best strategies.\n 将解决方案中与线程相关的部分分隔出来，再加以调整和试验，是获得判断最佳策略所需的洞见的正道。\n A.7 TESTING MULTITHREADED CODE 测试多线程代码 #  How can we write a test to demonstrate the following code is broken?\n 怎么才能编写显示以下代码有错的测试呢？\n 01: public class ClassWithThreadingProblem { 02: int nextId; 03: 04: public int takeNextId() { 05: return nextId++; 06: } 07:} Here’s a description of a test that will prove the code is broken:\n 下面是对能证明上列代码有错的测试的描述：\n  Remember the current value of nextId. Create two threads, both of which call takeNextId() once. Verify that nextId is two more than what we started with. Run this until we demonstrate that nextId was only incremented by one instead of two.    记住 nextId 的当前值； 创建两个线程，每个都调用 takeNextId( )一次； 验证 nextId 比开始时大 2； 持续运行，直至发现 nextId 只比开始时大 1 为止。   Listing A-2 shows such a test:\n 代码清单 A-2 展示了这样一个测试：\n Listing A-2 ClassWithThreadingProblemTest.java\n 代码清单 A-2 ClassWithThreadingProblemTest.java\n 01: package example; 02: 03: import static org.junit.Assert.fail; 04: 05: import org.junit.Test; 06: 07: public class ClassWithThreadingProblemTest { 08: @Test 09: public void twoThreadsShouldFailEventually() throws Exception { 10: final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(); 11: 12: Runnable runnable = new Runnable() { 13: public void run() { 14: classWithThreadingProblem.takeNextId(); 15: } 16: }; 17: 18: for (int i = 0; i \u0026lt; 50000; ++i) { 19: int startingId = classWithThreadingProblem.lastId; 20: int expectedResult = 2 + startingId; 21: 22: Thread t1 = new Thread(runnable); 23: Thread t2 = new Thread(runnable); 24: t1.start(); 25: t2.start(); 26: t1.join(); 27: t2.join(); 28: 29: int endingId = classWithThreadingProblem.lastId; 30: 31: if (endingId != expectedResult) 32: return; 33: } 34: 35: fail(“Should have exposed a threading issue but it did not.”); 36: } 37: }   This test certainly sets up the conditions for a concurrent update problem. However, the problem occurs so infrequently that the vast majority of times this test won’t detect it.\n 这个测试当然设置了满足并发更新问题发生的条件。不过，问题发生得如此频繁，测试也就极有可能侦测不到。\n Indeed, to truly detect the problem we need to set the number of iterations to over one million. Even then, in ten executions with a loop count of 1,000,000, the problem occurred only once. That means we probably ought to set the iteration count to well over one hundred million to get reliable failures. How long are we prepared to wait?\n 实际上，要真正侦测到问题，需要将循环数量设置到 100 万次以上。即便是这样，在 10 个 100 万次循环的执行中，错误也只发生了一次。这意味着我们可能要把循环次数设置为超过亿次才能获得可靠的失败证明。要等多久呢？\n Even if we tuned the test to get reliable failures on one machine, we’ll probably have to retune the test with different values to demonstrate the failure on another machine, operating system, or version of the JVM.\n 即便我们调优测试，在单台机器上得到可靠的失败证明，我们可能还需要用不同的值来重新设置测试，得到在其他机器、操作系统或不同版本的 JVM 上的失败证明。\n And this is a simple problem. If we cannot demonstrate broken code easily with this problem, how will we ever detect truly complex problems?\n 而且这只是个简单问题。如果连这个简单问题都无法轻易获得出错证明，我们怎么能真正侦测复杂问题呢？\n So what approaches can we take to demonstrate this simple failure? And, more importantly, how can we write tests that will demonstrate failures in more complex code? How will we be able to discover if our code has failures when we do not know where to look?\n 我们能用什么手段来证明这个简单错误呢？而且，更重要的是，我们如何能写出证明更复杂代码中的错误的测试呢？我们怎样才能在不知道从何处着手时知道代码是否出错了呢？\n Here are a few ideas:\n 下面是一些想法：\n  Monte Carlo Testing. Make tests flexible, so they can be tuned. Then run the test over and over—say on a test server—randomly changing the tuning values. If the tests ever fail, the code is broken. Make sure to start writing those tests early so a continuous integration server starts running them soon. By the way, make sure you carefully log the conditions under which the test failed. Run the test on every one of the target deployment platforms. Repeatedly. Continuously. The longer the tests run without failure, the more likely that The production code is correct or The tests aren’t adequate to expose problems. Run the tests on a machine with varying loads. If you can simulate loads close to a production environment, do so.     蒙特卡洛测试。测试要灵活，便于调整。多次运行测试——在一台测试服务器上——随机改变调整值。如果测试失败，代码就有错。确保及早编写这些测试，好让持续集成服务器尽快开始运行测试。另外，确认小心记录了在何种条件下测试失败。 在每种目标部署平台上运行测试。重复运行。持续运行。测试在不失败的前提下运行得越久，就越能说明： 生产代码正确或； 测试不足以暴露问题。 在另一台有不同负载的机器上运行测试。能模拟生产环境的负载，就模拟之。   Yet, even if you do all of these things, you still don’t stand a very good chance of finding threading problems with your code. The most insidious problems are the ones that have such a small cross section that they only occur once in a billion opportunities. Such problems are the terror of complex systems.\n 即便你做了所有这些，还是不见得有很好的机会发现代码中的线程问题。最阴险的问题拥有很小的截面，在十亿次执行中只会发生一次。这类错误是复杂系统的噩梦。\n A.8 TOOL SUPPORT FOR TESTING THREAD-BASED CODE 测试线程代码的工具支持 #  IBM has created a tool called ConTest.6 It instruments classes to make it more likely that non-thread-safe code fails.\n IBM 提供了一个名为 ConTest 的工具。它能对类进行装置，令非线程安全代码更有可能失败。\n We do not have any direct relationship with IBM or the team that developed ConTest. A colleague of ours pointed us to it. We noticed vast improvement in our ability to find threading issues after a few minutes of using it.\n 我们与 IBM 或开发 ConTest 的团队没有直接关系。有位同事发现了这个工具。在用了几分钟后，我们发现自己发现线程问题的能力得到了很大提升。\n Here’s an outline of how to use ConTest:\n 下面是使用 ConTest 的简要步骤：\n  Write tests and production code, making sure there are tests specifically designed to simulate multiple users under varying loads, as mentioned above. Instrument test and production code with ConTest. Run the tests.     编写测试和生产代码，确保有专门模拟多用户在多种负载情况下操作的测试，如上文所述； 用 ConTest 装置测试和生产代码； 运行测试。   When we instrumented code with ConTest, our success rate went from roughly one failure in ten million iterations to roughly one failure in thirty iterations. Here are the loop values for several runs of the test after instrumentation: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. So clearly the instrumented classes failed much earlier and with much greater reliability.\n 用 ConTest 装置代码后，原本千万次循环才能暴露一个错误的比率提升到 30 次循环就能找到错误。以下是装置代码后的几次测试运行结果值：13、23、0、54、16、14、6、69、107、49 和 2。显然装置后的类更加容易和可靠地被证明失败。\n A.9 CONCLUSION 小结 #  This chapter has been a very brief sojourn through the large and treacherous territory of concurrent programming. We barely scratched the surface. Our emphasis here was on disciplines to help keep concurrent code clean, but there is much more you should learn if you are going to be writing concurrent systems. We recommend you start with Doug Lea’s wonderful book Concurrent Programming in Java: Design Principles and Patterns.7\n 本章只是在并发编程广阔而可怕的领地上的短暂逗留罢了。我们只触及了地表。我们在这里强调的，只是保持并发代码整洁的一些规程，如果要编写并发系统，还有许多东西要学。建议从 Doug Lea 的大作 Concurrent Programming in Java:Design Principles and Patterns 开始。\n In this chapter we talked about concurrent update, and the disciplines of clean synchronization and locking that can prevent it. We talked about how threads can enhance the throughput of an I/O-bound system and showed the clean techniques for achieving such improvements. We talked about deadlock and the disciplines for preventing it in a clean way. Finally, we talked about strategies for exposing concurrent problems by instrumenting your code.\n 在本章中，我们谈到并发更新，还有清理及避免同步的规程。我们谈到线程如何提升与 I/O 有关的系统的吞吐量，展示了获得这种提升的整洁技术。我们谈到死锁及干净地避免死锁的规程。最后，我们谈到通过装置代码暴露并发问题的策略。\n A.10 TUTORIAL: FULL CODE EXAMPLES 教程：完整代码范例 #  A.10.1 Client/Server Nonthreaded 客户端/服务器非线程代码 #  Listing A-3 Server.java\n 代码清单 A-3 Server.java\n package com.objectmentor.clientserver.nonthreaded; import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import common.MessageUtils; public class Server implements Runnable { ServerSocket serverSocket; volatile boolean keepProcessing = true; public Server(int port, int millisecondsTimeout) throws IOException { serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(millisecondsTimeout); } public void run() { System.out.printf(\u0026#34;Server Starting\\n\u0026#34;); while (keepProcessing) { try { System.out.printf(\u0026#34;accepting client\\n\u0026#34;); Socket socket = serverSocket.accept(); System.out.printf(\u0026#34;got client\\n\u0026#34;); process(socket); } catch (Exception e) { handle(e); } } } private void handle(Exception e) { if (!(e instanceof SocketException)) { e.printStackTrace(); } } public void stopProcessing() { keepProcessing = false; closeIgnoringException(serverSocket); } void process(Socket socket) { if (socket == null) return; try { System.out.printf(\u0026#34;Server: getting message\\n\u0026#34;); String message = MessageUtils.getMessage(socket); System.out.printf(\u0026#34;Server: got message: %s\\n\u0026#34;, message); Thread.sleep(1000); System.out.printf(\u0026#34;Server: sending reply: %s\\n\u0026#34;, message); MessageUtils.sendMessage(socket, \u0026#34;Processed: \u0026#34; + message); System.out.printf(\u0026#34;Server: sent\\n\u0026#34;); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); } } private void closeIgnoringException(Socket socket) { if (socket != null) try { socket.close(); } catch (IOException ignore) { } } private void closeIgnoringException(ServerSocket serverSocket) { if (serverSocket != null) try { serverSocket.close(); } catch (IOException ignore) { } } } Listing A-4 ClientTest.java\n 代码清单 A-4 ClientTest.java\n package com.objectmentor.clientserver.nonthreaded; import java.io.IOException; import java.net.Socket; import org.junit.After; import org.junit.Before; import org.junit.Test; import common.MessageUtils; public class ClientTest { private static final int PORT = 8009; private static final int TIMEOUT = 2000; Server server; Thread serverThread; @Before public void createServer() throws Exception { try { server = new Server(PORT, TIMEOUT); serverThread = new Thread(server); serverThread.start(); } catch (Exception e) { e.printStackTrace(System.err); throw e; } } @After public void shutdownServer() throws InterruptedException { if (server != null) { server.stopProcessing(); serverThread.join(); } } class TrivialClient implements Runnable { int clientNumber; TrivialClient(int clientNumber) { this.clientNumber = clientNumber; } public void run() { try { connectSendReceive(clientNumber); } catch (IOException e) { e.printStackTrace(); } } } @Test(timeout = 10000) public void shouldRunInUnder10Seconds() throws Exception { Thread[] threads = new Thread[10]; for (int i = 0; i \u0026lt; threads.length; ++i) { threads[i] = new Thread(new TrivialClient(i)); threads[i].start(); } for (int i = 0; i \u0026lt; threads.length; ++i) { threads[i].join(); } } private void connectSendReceive(int i) throws IOException { System.out.printf(\u0026#34;Client %2d: connecting\\n\u0026#34;, i); Socket socket = new Socket(\u0026#34;localhost\u0026#34;, PORT); System.out.printf(\u0026#34;Client %2d: sending message\\n\u0026#34;, i); MessageUtils.sendMessage(socket, Integer.toString(i)); System.out.printf(\u0026#34;Client %2d: getting reply\\n\u0026#34;, i); MessageUtils.getMessage(socket); System.out.printf(\u0026#34;Client %2d: finished\\n\u0026#34;, i); socket.close(); } } Listing A-5 MessageUtils.java\n 代码清单 A-5 MessageUtils.java\n package common; import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket; public class MessageUtils { public static void sendMessage(Socket socket, String message) throws IOException { OutputStream stream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(stream); oos.writeUTF(message); oos.flush(); } public static String getMessage(Socket socket) throws IOException { InputStream stream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(stream); return ois.readUTF(); } } A.10.2 Client/Server Using Threads 使用线程的客户端/服务器代码 #  Changing the server to use threads simply requires a change to the process message (new lines are emphasized to stand out):\n 把服务器修改为使用多线程，只需要对处理消息进行修改即可（新的代码行用粗体标出）：\n void process(final Socket socket) { if (socket == null) return; Runnable clientHandler = new Runnable() { public void run() { try { System.out.printf(\u0026#34;Server: getting message\\n\u0026#34;); String message = MessageUtils.getMessage(socket); System.out.printf(\u0026#34;Server: got message: %s\\n\u0026#34;, message); Thread.sleep(1000); System.out.printf(\u0026#34;Server: sending reply: %s\\n\u0026#34;, message); MessageUtils.sendMessage(socket, \u0026#34;Processed: \u0026#34; + message); System.out.printf(\u0026#34;Server: sent\\n\u0026#34;); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); } } }; Thread clientConnection = new Thread(clientHandler); clientConnection.start(); } "});})();